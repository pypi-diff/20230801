# Comparing `tmp/sylk-0.2.0-py3-none-any.whl.zip` & `tmp/sylk-0.3.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,187 +1,245 @@
-Zip file size: 351486 bytes, number of entries: 216
+Zip file size: 422345 bytes, number of entries: 275
 -rw-r--r--  2.0 unx     8617 b- defN 23-Mar-20 19:45 docs/_downloads/29a3c68eabc4dfce3cc2b8f28cbf7499/test.py
 -rw-r--r--  2.0 unx    42938 b- defN 23-Mar-20 19:45 docs/_downloads/9a3170560eff0e8080a7006943761820/PubSubTs.template.py
 -rw-r--r--  2.0 unx    13027 b- defN 23-Mar-20 19:45 docs/_downloads/a8af61e20b3888c79a5cc6ff79c43632/HelloWorldPy.template.py
 -rw-r--r--  2.0 unx    13715 b- defN 23-Mar-20 19:45 docs/_downloads/cb75f7c5c4638fa0c1e352dc3e3ce4c7/HelloWorldTs.template.py
 -rw-r--r--  2.0 unx     8617 b- defN 23-Mar-20 19:45 docs/build/_downloads/29a3c68eabc4dfce3cc2b8f28cbf7499/test.py
 -rw-r--r--  2.0 unx    42938 b- defN 23-Mar-20 19:45 docs/build/_downloads/9a3170560eff0e8080a7006943761820/PubSubTs.template.py
 -rw-r--r--  2.0 unx    13027 b- defN 23-Mar-20 19:45 docs/build/_downloads/a8af61e20b3888c79a5cc6ff79c43632/HelloWorldPy.template.py
 -rw-r--r--  2.0 unx    13715 b- defN 23-Mar-20 19:45 docs/build/_downloads/cb75f7c5c4638fa0c1e352dc3e3ce4c7/HelloWorldTs.template.py
 -rw-r--r--  2.0 unx     8617 b- defN 23-Mar-20 19:45 docs/build/html/_downloads/29a3c68eabc4dfce3cc2b8f28cbf7499/test.py
 -rw-r--r--  2.0 unx    42938 b- defN 23-Mar-20 19:45 docs/build/html/_downloads/9a3170560eff0e8080a7006943761820/PubSubTs.template.py
 -rw-r--r--  2.0 unx    13027 b- defN 23-Mar-20 19:45 docs/build/html/_downloads/a8af61e20b3888c79a5cc6ff79c43632/HelloWorldPy.template.py
 -rw-r--r--  2.0 unx    13711 b- defN 23-Mar-22 23:18 docs/build/html/_downloads/cb75f7c5c4638fa0c1e352dc3e3ce4c7/HelloWorldTs.template.py
--rw-r--r--  2.0 unx     1274 b- defN 23-Jun-07 13:22 docs/source/conf.py
+-rw-r--r--  2.0 unx     1274 b- defN 23-Aug-01 10:45 docs/source/conf.py
 -rw-r--r--  2.0 unx      339 b- defN 23-Jun-06 21:25 sylk/__init__.py
--rw-r--r--  2.0 unx       21 b- defN 23-Jun-07 13:22 sylk/__version__.py
--rw-r--r--  2.0 unx      708 b- defN 23-Jun-07 13:21 sylk/config.py
--rw-r--r--  2.0 unx    10921 b- defN 23-Jun-07 10:30 sylk/architect/__init__.py
--rw-r--r--  2.0 unx     3059 b- defN 23-Mar-22 20:33 sylk/architect/commands.py
+-rw-r--r--  2.0 unx       21 b- defN 23-Aug-01 10:45 sylk/__version__.py
+-rw-r--r--  2.0 unx      758 b- defN 23-Aug-01 16:12 sylk/config.py
+-rw-r--r--  2.0 unx    14295 b- defN 23-Jul-31 22:06 sylk/architect/__init__.py
+-rw-r--r--  2.0 unx     3059 b- defN 23-Jul-22 20:00 sylk/architect/commands.py
 -rw-r--r--  2.0 unx     1226 b- defN 23-Mar-22 19:43 sylk/architect/hooks.py
--rw-r--r--  2.0 unx    13049 b- defN 23-May-25 08:51 sylk/architect/invoker.py
+-rw-r--r--  2.0 unx    13525 b- defN 23-Jul-22 20:00 sylk/architect/invoker.py
 -rw-r--r--  2.0 unx     1677 b- defN 23-Mar-22 19:48 sylk/architect/interfaces/__init__.py
--rw-r--r--  2.0 unx    12201 b- defN 23-Jun-07 08:27 sylk/architect/recievers/__init__.py
+-rw-r--r--  2.0 unx    13656 b- defN 23-Jul-27 15:42 sylk/architect/recievers/__init__.py
 -rw-r--r--  2.0 unx      186 b- defN 23-Mar-22 20:12 sylk/builder/__init__.py
--rw-r--r--  2.0 unx     4843 b- defN 23-Jun-07 08:33 sylk/builder/plugins/SylkBase.py
--rw-r--r--  2.0 unx     8117 b- defN 23-Jun-07 12:04 sylk/builder/plugins/SylkGoClient.py
--rw-r--r--  2.0 unx     9117 b- defN 23-Jun-07 13:04 sylk/builder/plugins/SylkGoServer.py
--rw-r--r--  2.0 unx     8512 b- defN 23-May-26 21:05 sylk/builder/plugins/SylkJsClient.py
--rw-r--r--  2.0 unx     6605 b- defN 23-Jun-07 11:40 sylk/builder/plugins/SylkJsServer.py
--rw-r--r--  2.0 unx    20000 b- defN 23-Jun-07 10:32 sylk/builder/plugins/SylkMigrate.py
--rw-r--r--  2.0 unx     2042 b- defN 23-May-24 22:52 sylk/builder/plugins/SylkPlugins.py
--rw-r--r--  2.0 unx     6962 b- defN 23-Jun-07 12:44 sylk/builder/plugins/SylkProto.py
--rw-r--r--  2.0 unx    18111 b- defN 23-Jun-07 12:43 sylk/builder/plugins/SylkPyClient.py
--rw-r--r--  2.0 unx    22473 b- defN 23-Jun-07 12:55 sylk/builder/plugins/SylkPyServer.py
--rw-r--r--  2.0 unx     8729 b- defN 23-May-26 21:05 sylk/builder/plugins/SylkReadme.py
--rw-r--r--  2.0 unx    10496 b- defN 23-Jun-07 11:37 sylk/builder/plugins/SylkTsClient.py
--rw-r--r--  2.0 unx    17277 b- defN 23-Jun-07 11:41 sylk/builder/plugins/SylkTsServer.py
+-rw-r--r--  2.0 unx     4870 b- defN 23-Jul-14 12:08 sylk/builder/plugins/SylkBase.py
+-rw-r--r--  2.0 unx     8509 b- defN 23-Jul-28 18:58 sylk/builder/plugins/SylkGoClient.py
+-rw-r--r--  2.0 unx    10833 b- defN 23-Jul-28 17:40 sylk/builder/plugins/SylkGoServer.py
+-rw-r--r--  2.0 unx     9940 b- defN 23-Jul-12 21:24 sylk/builder/plugins/SylkJsClient.py
+-rw-r--r--  2.0 unx     7071 b- defN 23-Jul-12 21:24 sylk/builder/plugins/SylkJsServer.py
+-rw-r--r--  2.0 unx    25917 b- defN 23-Jul-12 21:24 sylk/builder/plugins/SylkMigrate.py
+-rw-r--r--  2.0 unx     2039 b- defN 23-Jul-12 21:24 sylk/builder/plugins/SylkPlugins.py
+-rw-r--r--  2.0 unx    15394 b- defN 23-Jul-28 17:41 sylk/builder/plugins/SylkProto.py
+-rw-r--r--  2.0 unx    23411 b- defN 23-Jul-31 14:32 sylk/builder/plugins/SylkPyClient.py
+-rw-r--r--  2.0 unx    24221 b- defN 23-Jul-27 12:52 sylk/builder/plugins/SylkPyServer.py
+-rw-r--r--  2.0 unx     9288 b- defN 23-Jul-28 18:42 sylk/builder/plugins/SylkReadme.py
+-rw-r--r--  2.0 unx    12058 b- defN 23-Jul-31 21:19 sylk/builder/plugins/SylkTsClient.py
+-rw-r--r--  2.0 unx    18541 b- defN 23-Jul-31 12:56 sylk/builder/plugins/SylkTsServer.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-22 19:48 sylk/builder/plugins/__init__.py
--rw-r--r--  2.0 unx    25419 b- defN 23-Jun-07 13:04 sylk/builder/plugins/static.py
+-rw-r--r--  2.0 unx    26758 b- defN 23-Jul-31 12:56 sylk/builder/plugins/static.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-22 20:12 sylk/builder/src/__init__.py
 -rw-r--r--  2.0 unx     4747 b- defN 23-Jun-03 09:35 sylk/builder/src/hookspecs.py
 -rw-r--r--  2.0 unx      967 b- defN 23-Mar-22 19:48 sylk/builder/src/lru.py
 -rw-r--r--  2.0 unx    19326 b- defN 23-Jun-07 08:29 sylk/builder/src/main.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-22 19:00 sylk/cli/__init__.py
 -rw-r--r--  2.0 unx     1140 b- defN 23-Mar-22 20:13 sylk/cli/__main__.py
--rw-r--r--  2.0 unx    48204 b- defN 23-Jun-07 10:32 sylk/cli/main.py
+-rw-r--r--  2.0 unx    60277 b- defN 23-Aug-01 10:48 sylk/cli/main.py
 -rw-r--r--  2.0 unx    13242 b- defN 23-May-24 20:50 sylk/cli/prompter.py
 -rw-r--r--  2.0 unx     2226 b- defN 23-May-25 08:32 sylk/cli/theme.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-22 19:00 sylk/cli/commands/__init__.py
 -rw-r--r--  2.0 unx     1935 b- defN 23-May-26 21:11 sylk/cli/commands/build.py
--rw-r--r--  2.0 unx     9482 b- defN 23-May-27 07:58 sylk/cli/commands/call.py
--rw-r--r--  2.0 unx    10048 b- defN 23-Jun-07 13:21 sylk/cli/commands/cloud.py
+-rw-r--r--  2.0 unx    10142 b- defN 23-Jun-09 13:19 sylk/cli/commands/call.py
+-rw-r--r--  2.0 unx    11930 b- defN 23-Jul-28 14:26 sylk/cli/commands/cloud.py
 -rw-r--r--  2.0 unx     1983 b- defN 23-Apr-27 18:30 sylk/cli/commands/config.py
--rw-r--r--  2.0 unx    52542 b- defN 23-Apr-19 19:21 sylk/cli/commands/edit.py
+-rw-r--r--  2.0 unx    55267 b- defN 23-Jul-27 13:33 sylk/cli/commands/edit.py
 -rw-r--r--  2.0 unx    21960 b- defN 23-Mar-22 19:08 sylk/cli/commands/extend.py
--rw-r--r--  2.0 unx    28166 b- defN 23-Jun-07 10:34 sylk/cli/commands/generate.py
--rw-r--r--  2.0 unx    20355 b- defN 23-Jun-07 10:35 sylk/cli/commands/ls.py
+-rw-r--r--  2.0 unx    41708 b- defN 23-Aug-01 10:38 sylk/cli/commands/generate.py
+-rw-r--r--  2.0 unx    20520 b- defN 23-Jul-16 20:50 sylk/cli/commands/ls.py
 -rw-r--r--  2.0 unx     2257 b- defN 23-Jun-07 10:35 sylk/cli/commands/migrate.py
--rw-r--r--  2.0 unx    12496 b- defN 23-Jun-07 10:37 sylk/cli/commands/new.py
--rw-r--r--  2.0 unx     5718 b- defN 23-May-24 22:54 sylk/cli/commands/package.py
--rw-r--r--  2.0 unx     2946 b- defN 23-Jun-07 08:31 sylk/cli/commands/plugin.py
--rw-r--r--  2.0 unx     1506 b- defN 23-May-14 06:22 sylk/cli/commands/run.py
+-rw-r--r--  2.0 unx    15923 b- defN 23-Jul-27 16:13 sylk/cli/commands/new.py
+-rw-r--r--  2.0 unx     6923 b- defN 23-Jul-16 18:54 sylk/cli/commands/package.py
+-rw-r--r--  2.0 unx     3689 b- defN 23-Jul-25 10:43 sylk/cli/commands/plugin.py
+-rw-r--r--  2.0 unx     1498 b- defN 23-Jul-16 10:30 sylk/cli/commands/run.py
 -rw-r--r--  2.0 unx    28044 b- defN 23-Jun-07 10:39 sylk/cli/commands/template.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-22 18:02 sylk/commons/__init__.py
 -rw-r--r--  2.0 unx     2158 b- defN 23-Mar-22 20:09 sylk/commons/client_wrapper.py
--rw-r--r--  2.0 unx    10568 b- defN 23-Jun-07 10:39 sylk/commons/config.py
--rw-r--r--  2.0 unx     2312 b- defN 23-Mar-22 18:50 sylk/commons/errors.py
--rw-r--r--  2.0 unx     4370 b- defN 23-Jun-05 13:13 sylk/commons/file_system.py
--rw-r--r--  2.0 unx   124286 b- defN 23-Jun-07 13:17 sylk/commons/helpers.py
--rw-r--r--  2.0 unx     8125 b- defN 23-May-25 12:01 sylk/commons/interceptors.py
+-rw-r--r--  2.0 unx    10725 b- defN 23-Jul-24 19:47 sylk/commons/config.py
+-rw-r--r--  2.0 unx     2315 b- defN 23-Jun-11 09:39 sylk/commons/errors.py
+-rw-r--r--  2.0 unx     4882 b- defN 23-Jul-19 20:28 sylk/commons/file_system.py
+-rw-r--r--  2.0 unx   207688 b- defN 23-Jul-31 22:10 sylk/commons/helpers.py
+-rw-r--r--  2.0 unx     9426 b- defN 23-Jun-11 09:39 sylk/commons/interceptors.py
 -rw-r--r--  2.0 unx     2711 b- defN 23-Mar-22 18:25 sylk/commons/parser.py
 -rw-r--r--  2.0 unx     2665 b- defN 23-Mar-22 18:51 sylk/commons/pretty.py
--rw-r--r--  2.0 unx    38542 b- defN 23-Jun-07 10:42 sylk/commons/resources.py
--rw-r--r--  2.0 unx      543 b- defN 23-Mar-22 18:51 sylk/commons/sylk.py
--rw-r--r--  2.0 unx    31998 b- defN 23-Jun-07 10:26 sylk/commons/protos/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 09:59 sylk/commons/protos/sylk/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/EnumValues/__init__.py
--rw-r--r--  2.0 unx     1800 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/EnumValues/v1/EnumValues_pb2.py
--rw-r--r--  2.0 unx     7744 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/EnumValues/v1/EnumValues_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/EnumValues/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Enums/__init__.py
--rw-r--r--  2.0 unx     1672 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Enums/v1/Enums_pb2.py
--rw-r--r--  2.0 unx     7419 b- defN 23-Jun-07 10:01 sylk/commons/protos/sylk/Enums/v1/Enums_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Enums/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Fields/__init__.py
--rw-r--r--  2.0 unx     1704 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Fields/v1/Fields_pb2.py
--rw-r--r--  2.0 unx     7484 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Fields/v1/Fields_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Fields/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Messages/__init__.py
--rw-r--r--  2.0 unx     1731 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Messages/v1/Messages_pb2.py
--rw-r--r--  2.0 unx     7614 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Messages/v1/Messages_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Messages/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Methods/__init__.py
--rw-r--r--  2.0 unx     1723 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Methods/v1/Methods_pb2.py
--rw-r--r--  2.0 unx     7549 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Methods/v1/Methods_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Methods/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Organizations/__init__.py
--rw-r--r--  2.0 unx     2294 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Organizations/v1/Organizations_pb2.py
--rw-r--r--  2.0 unx    14552 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Organizations/v1/Organizations_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Organizations/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Packages/__init__.py
--rw-r--r--  2.0 unx     1846 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Packages/v1/Packages_pb2.py
--rw-r--r--  2.0 unx     9268 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Packages/v1/Packages_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Packages/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Projects/__init__.py
--rw-r--r--  2.0 unx     2304 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Projects/v1/Projects_pb2.py
--rw-r--r--  2.0 unx    16079 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Projects/v1/Projects_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Projects/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Services/__init__.py
--rw-r--r--  2.0 unx     1840 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Services/v1/Services_pb2.py
--rw-r--r--  2.0 unx     9268 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Services/v1/Services_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Services/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Sylk/__init__.py
--rw-r--r--  2.0 unx     3170 b- defN 23-Jun-07 10:44 sylk/commons/protos/sylk/Sylk/v1/Sylk_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/Sylk/v1/Sylk_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/Sylk/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkApi/__init__.py
--rw-r--r--  2.0 unx    26682 b- defN 23-Jun-07 10:05 sylk/commons/protos/sylk/SylkApi/v1/SylkApi_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkApi/v1/SylkApi_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkApi/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkClient/__init__.py
--rw-r--r--  2.0 unx     1641 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkClient/v1/SylkClient_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkClient/v1/SylkClient_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkClient/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkCommons/__init__.py
--rw-r--r--  2.0 unx     2198 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkCommons/v1/SylkCommons_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkCommons/v1/SylkCommons_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkCommons/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkConfigs/__init__.py
--rw-r--r--  2.0 unx     2447 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkConfigs/v1/SylkConfigs_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkConfigs/v1/SylkConfigs_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkConfigs/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkEnum/__init__.py
--rw-r--r--  2.0 unx     2138 b- defN 23-Jun-07 10:05 sylk/commons/protos/sylk/SylkEnum/v1/SylkEnum_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkEnum/v1/SylkEnum_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkEnum/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkEnumValue/__init__.py
--rw-r--r--  2.0 unx     2039 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkEnumValue/v1/SylkEnumValue_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkEnumValue/v1/SylkEnumValue_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkEnumValue/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkField/__init__.py
--rw-r--r--  2.0 unx     4599 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkField/v1/SylkField_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkField/v1/SylkField_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkField/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkMessage/__init__.py
--rw-r--r--  2.0 unx     2996 b- defN 23-Jun-07 10:44 sylk/commons/protos/sylk/SylkMessage/v1/SylkMessage_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkMessage/v1/SylkMessage_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkMessage/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkMethod/__init__.py
--rw-r--r--  2.0 unx     2671 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkMethod/v1/SylkMethod_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkMethod/v1/SylkMethod_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkMethod/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkOrganization/__init__.py
--rw-r--r--  2.0 unx     2137 b- defN 23-Jun-07 10:03 sylk/commons/protos/sylk/SylkOrganization/v1/SylkOrganization_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkOrganization/v1/SylkOrganization_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkOrganization/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkPackage/__init__.py
--rw-r--r--  2.0 unx     2995 b- defN 23-Jun-07 10:04 sylk/commons/protos/sylk/SylkPackage/v1/SylkPackage_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkPackage/v1/SylkPackage_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 10:00 sylk/commons/protos/sylk/SylkPackage/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 09:59 sylk/commons/protos/sylk/SylkProject/__init__.py
--rw-r--r--  2.0 unx     3421 b- defN 23-Jun-07 10:44 sylk/commons/protos/sylk/SylkProject/v1/SylkProject_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkProject/v1/SylkProject_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 09:59 sylk/commons/protos/sylk/SylkProject/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 09:59 sylk/commons/protos/sylk/SylkServer/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkServer/v1/SylkServer_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkServer/v1/SylkServer_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 09:59 sylk/commons/protos/sylk/SylkServer/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 09:59 sylk/commons/protos/sylk/SylkService/__init__.py
--rw-r--r--  2.0 unx     2770 b- defN 23-Jun-07 10:04 sylk/commons/protos/sylk/SylkService/v1/SylkService_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkService/v1/SylkService_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 09:59 sylk/commons/protos/sylk/SylkService/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 09:59 sylk/commons/protos/sylk/SylkUser/__init__.py
--rw-r--r--  2.0 unx     3640 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkUser/v1/SylkUser_pb2.py
--rw-r--r--  2.0 unx      159 b- defN 23-Jun-07 09:58 sylk/commons/protos/sylk/SylkUser/v1/SylkUser_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 09:59 sylk/commons/protos/sylk/SylkUser/v1/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 09:59 sylk/commons/protos/sylk/Users/__init__.py
--rw-r--r--  2.0 unx     2053 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Users/v1/Users_pb2.py
--rw-r--r--  2.0 unx    12603 b- defN 23-Jun-07 10:02 sylk/commons/protos/sylk/Users/v1/Users_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 09:59 sylk/commons/protos/sylk/Users/v1/__init__.py
+-rw-r--r--  2.0 unx    46086 b- defN 23-Jul-16 18:10 sylk/commons/resources.py
+-rw-r--r--  2.0 unx    33801 b- defN 23-Jul-31 21:59 sylk/commons/sylk.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-22 20:26 sylk/commons/modules/__init__.py
+-rw-r--r--  2.0 unx     1812 b- defN 23-Jul-20 10:25 sylk/commons/modules/google/__init__.py
+-rw-r--r--  2.0 unx    73411 b- defN 23-Jul-20 12:42 sylk/commons/protos/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Activities/__init__.py
+-rw-r--r--  2.0 unx     1443 b- defN 23-Jul-20 11:18 sylk/commons/protos/sylk/Activities/v1/Activities_pb2.py
+-rw-r--r--  2.0 unx     4570 b- defN 23-Jul-18 14:01 sylk/commons/protos/sylk/Activities/v1/Activities_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Activities/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/ActivityLog/__init__.py
+-rw-r--r--  2.0 unx     4837 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/ActivityLog/v1/ActivityLog_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/ActivityLog/v1/ActivityLog_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/ActivityLog/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/EnumValues/__init__.py
+-rw-r--r--  2.0 unx     1649 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/EnumValues/v1/EnumValues_pb2.py
+-rw-r--r--  2.0 unx     7915 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/EnumValues/v1/EnumValues_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/EnumValues/v1/__init__.py
+-rw-r--r--  2.0 unx     3749 b- defN 23-Jul-11 13:43 sylk/commons/protos/sylk/EnumValues/v2/EnumValues_pb2.py
+-rw-r--r--  2.0 unx     8057 b- defN 23-Jul-18 14:06 sylk/commons/protos/sylk/EnumValues/v2/EnumValues_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/EnumValues/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Enums/__init__.py
+-rw-r--r--  2.0 unx     1524 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Enums/v1/Enums_pb2.py
+-rw-r--r--  2.0 unx     7545 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Enums/v1/Enums_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Enums/v1/__init__.py
+-rw-r--r--  2.0 unx     3409 b- defN 23-Jul-11 13:45 sylk/commons/protos/sylk/Enums/v2/Enums_pb2.py
+-rw-r--r--  2.0 unx     7472 b- defN 23-Jul-18 14:06 sylk/commons/protos/sylk/Enums/v2/Enums_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Enums/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Fields/__init__.py
+-rw-r--r--  2.0 unx     1557 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Fields/v1/Fields_pb2.py
+-rw-r--r--  2.0 unx     7619 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Fields/v1/Fields_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Fields/v1/__init__.py
+-rw-r--r--  2.0 unx     3542 b- defN 23-Jul-11 13:43 sylk/commons/protos/sylk/Fields/v2/Fields_pb2.py
+-rw-r--r--  2.0 unx     7589 b- defN 23-Jul-18 14:05 sylk/commons/protos/sylk/Fields/v2/Fields_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Fields/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Folders/__init__.py
+-rw-r--r--  2.0 unx     3548 b- defN 23-Jul-11 13:44 sylk/commons/protos/sylk/Folders/v2/Folders_pb2.py
+-rw-r--r--  2.0 unx     9227 b- defN 23-Jul-18 14:02 sylk/commons/protos/sylk/Folders/v2/Folders_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Folders/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Integrations/__init__.py
+-rw-r--r--  2.0 unx     1991 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Integrations/v2/Integrations_pb2.py
+-rw-r--r--  2.0 unx     2827 b- defN 23-Jul-18 14:07 sylk/commons/protos/sylk/Integrations/v2/Integrations_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Integrations/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Messages/__init__.py
+-rw-r--r--  2.0 unx     1582 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Messages/v1/Messages_pb2.py
+-rw-r--r--  2.0 unx     7767 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Messages/v1/Messages_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Messages/v1/__init__.py
+-rw-r--r--  2.0 unx     3726 b- defN 23-Jul-11 13:44 sylk/commons/protos/sylk/Messages/v2/Messages_pb2.py
+-rw-r--r--  2.0 unx     7823 b- defN 23-Jul-18 14:04 sylk/commons/protos/sylk/Messages/v2/Messages_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Messages/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Methods/__init__.py
+-rw-r--r--  2.0 unx     1575 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Methods/v1/Methods_pb2.py
+-rw-r--r--  2.0 unx     7693 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Methods/v1/Methods_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Methods/v1/__init__.py
+-rw-r--r--  2.0 unx     3394 b- defN 23-Jul-11 13:43 sylk/commons/protos/sylk/Methods/v2/Methods_pb2.py
+-rw-r--r--  2.0 unx     7706 b- defN 23-Jul-18 14:06 sylk/commons/protos/sylk/Methods/v2/Methods_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Methods/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Organizations/__init__.py
+-rw-r--r--  2.0 unx     2141 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Organizations/v1/Organizations_pb2.py
+-rw-r--r--  2.0 unx    14926 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Organizations/v1/Organizations_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Organizations/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Packages/__init__.py
+-rw-r--r--  2.0 unx     1694 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Packages/v1/Packages_pb2.py
+-rw-r--r--  2.0 unx     9455 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Packages/v1/Packages_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Packages/v1/__init__.py
+-rw-r--r--  2.0 unx     3526 b- defN 23-Jul-11 13:44 sylk/commons/protos/sylk/Packages/v2/Packages_pb2.py
+-rw-r--r--  2.0 unx     7823 b- defN 23-Jul-18 14:05 sylk/commons/protos/sylk/Packages/v2/Packages_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Packages/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Projects/__init__.py
+-rw-r--r--  2.0 unx     2155 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Projects/v1/Projects_pb2.py
+-rw-r--r--  2.0 unx    16402 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Projects/v1/Projects_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Projects/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Services/__init__.py
+-rw-r--r--  2.0 unx     1691 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Services/v1/Services_pb2.py
+-rw-r--r--  2.0 unx     9455 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Services/v1/Services_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Services/v1/__init__.py
+-rw-r--r--  2.0 unx     3454 b- defN 23-Jul-11 13:44 sylk/commons/protos/sylk/Services/v2/Services_pb2.py
+-rw-r--r--  2.0 unx     7823 b- defN 23-Jul-18 14:06 sylk/commons/protos/sylk/Services/v2/Services_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Services/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Sylk/__init__.py
+-rw-r--r--  2.0 unx     3005 b- defN 23-Jul-11 13:44 sylk/commons/protos/sylk/Sylk/v1/Sylk_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Sylk/v1/Sylk_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Sylk/v1/__init__.py
+-rw-r--r--  2.0 unx     2730 b- defN 23-Jul-11 13:44 sylk/commons/protos/sylk/Sylk/v2/Sylk_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Sylk/v2/Sylk_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Sylk/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkApi/__init__.py
+-rw-r--r--  2.0 unx    26511 b- defN 23-Jul-11 13:44 sylk/commons/protos/sylk/SylkApi/v1/SylkApi_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkApi/v1/SylkApi_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkApi/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkClient/__init__.py
+-rw-r--r--  2.0 unx     1461 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkClient/v1/SylkClient_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkClient/v1/SylkClient_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkClient/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkCommons/__init__.py
+-rw-r--r--  2.0 unx     2016 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkCommons/v1/SylkCommons_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkCommons/v1/SylkCommons_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkCommons/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkConfigs/__init__.py
+-rw-r--r--  2.0 unx     2440 b- defN 23-Jul-12 21:13 sylk/commons/protos/sylk/SylkConfigs/v1/SylkConfigs_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-12 21:13 sylk/commons/protos/sylk/SylkConfigs/v1/SylkConfigs_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkConfigs/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkEnum/__init__.py
+-rw-r--r--  2.0 unx     1965 b- defN 23-Jul-11 13:43 sylk/commons/protos/sylk/SylkEnum/v1/SylkEnum_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkEnum/v1/SylkEnum_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkEnum/v1/__init__.py
+-rw-r--r--  2.0 unx     2028 b- defN 23-Jul-11 13:43 sylk/commons/protos/sylk/SylkEnum/v2/SylkEnum_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkEnum/v2/SylkEnum_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkEnum/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkEnumValue/__init__.py
+-rw-r--r--  2.0 unx     1856 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkEnumValue/v1/SylkEnumValue_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkEnumValue/v1/SylkEnumValue_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkEnumValue/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkField/__init__.py
+-rw-r--r--  2.0 unx     4516 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkField/v1/SylkField_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkField/v1/SylkField_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkField/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkMessage/__init__.py
+-rw-r--r--  2.0 unx     2811 b- defN 23-Jul-11 13:43 sylk/commons/protos/sylk/SylkMessage/v1/SylkMessage_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkMessage/v1/SylkMessage_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkMessage/v1/__init__.py
+-rw-r--r--  2.0 unx     3041 b- defN 23-Jul-11 13:43 sylk/commons/protos/sylk/SylkMessage/v2/SylkMessage_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkMessage/v2/SylkMessage_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkMessage/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkMethod/__init__.py
+-rw-r--r--  2.0 unx     2518 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkMethod/v1/SylkMethod_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkMethod/v1/SylkMethod_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkMethod/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkOrganization/__init__.py
+-rw-r--r--  2.0 unx     1948 b- defN 23-Jul-11 13:42 sylk/commons/protos/sylk/SylkOrganization/v1/SylkOrganization_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkOrganization/v1/SylkOrganization_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkOrganization/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkPackage/__init__.py
+-rw-r--r--  2.0 unx     2810 b- defN 23-Jul-11 13:43 sylk/commons/protos/sylk/SylkPackage/v1/SylkPackage_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkPackage/v1/SylkPackage_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkPackage/v1/__init__.py
+-rw-r--r--  2.0 unx     3047 b- defN 23-Jul-11 13:45 sylk/commons/protos/sylk/SylkPackage/v2/SylkPackage_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkPackage/v2/SylkPackage_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkPackage/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkProject/__init__.py
+-rw-r--r--  2.0 unx     3245 b- defN 23-Jul-11 13:42 sylk/commons/protos/sylk/SylkProject/v1/SylkProject_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkProject/v1/SylkProject_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkProject/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkServer/__init__.py
+-rw-r--r--  2.0 unx     1424 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkServer/v1/SylkServer_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkServer/v1/SylkServer_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkServer/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkService/__init__.py
+-rw-r--r--  2.0 unx     2585 b- defN 23-Jul-11 13:43 sylk/commons/protos/sylk/SylkService/v1/SylkService_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkService/v1/SylkService_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkService/v1/__init__.py
+-rw-r--r--  2.0 unx     2616 b- defN 23-Jul-11 13:43 sylk/commons/protos/sylk/SylkService/v2/SylkService_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkService/v2/SylkService_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkService/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkUser/__init__.py
+-rw-r--r--  2.0 unx     3464 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkUser/v1/SylkUser_pb2.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkUser/v1/SylkUser_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/SylkUser/v1/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Tags/__init__.py
+-rw-r--r--  2.0 unx     3636 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Tags/v2/Tags_pb2.py
+-rw-r--r--  2.0 unx    11977 b- defN 23-Jul-18 14:06 sylk/commons/protos/sylk/Tags/v2/Tags_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Tags/v2/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Users/__init__.py
+-rw-r--r--  2.0 unx     1905 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Users/v1/Users_pb2.py
+-rw-r--r--  2.0 unx    12813 b- defN 23-Jul-11 13:41 sylk/commons/protos/sylk/Users/v1/Users_pb2_grpc.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-11 07:53 sylk/commons/protos/sylk/Users/v1/__init__.py
 -rw-r--r--  2.0 unx    28738 b- defN 23-Jun-07 10:46 sylk/commons/templates/sylk/TodoAppPy.template.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-20 19:56 sylk/helpers/__init__.py
 -rw-r--r--  2.0 unx     2665 b- defN 23-Mar-22 20:34 sylk/helpers/pretty.py
 -rw-r--r--  2.0 unx    11392 b- defN 23-Mar-22 20:34 sylk/helpers/prompter.py
 -rw-r--r--  2.0 unx     2561 b- defN 23-Mar-22 20:09 sylk/helpers/theme.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-05 13:09 sylk/tools/__init__.py
 -rw-r--r--  2.0 unx     2378 b- defN 23-Jun-05 13:09 sylk/tools/sylkprotoc/__init__.py
@@ -194,25 +252,26 @@
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-05 13:09 sylk/tools/sylkprotoc/protos/sylk/Protoc/__init__.py
 -rw-r--r--  2.0 unx     1404 b- defN 23-Jun-05 13:24 sylk/tools/sylkprotoc/protos/sylk/Protoc/v1/Protoc_pb2.py
 -rw-r--r--  2.0 unx     4141 b- defN 23-Jun-05 13:24 sylk/tools/sylkprotoc/protos/sylk/Protoc/v1/Protoc_pb2_grpc.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-05 13:09 sylk/tools/sylkprotoc/protos/sylk/Protoc/v1/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-06 21:26 sylk/types/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-06 21:27 sylk/types/google/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-06 21:27 sylk/types/google/longrunning/__init__.py
--rw-r--r--  2.0 unx     4782 b- defN 23-Jun-06 21:34 sylk/types/google/longrunning/operations_pb2.py
--rw-r--r--  2.0 unx    13653 b- defN 23-Jun-06 21:34 sylk/types/google/longrunning/operations_pb2_grpc.py
+-rw-r--r--  2.0 unx     4780 b- defN 23-Jun-11 09:58 sylk/types/google/longrunning/operations_pb2.py
+-rw-r--r--  2.0 unx    13642 b- defN 23-Jun-11 09:56 sylk/types/google/longrunning/operations_pb2_grpc.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-06 21:27 sylk/types/google/rpc/__init__.py
--rw-r--r--  2.0 unx     1815 b- defN 23-Jun-06 21:03 sylk/types/google/rpc/code_pb2.py
--rw-r--r--  2.0 unx     4675 b- defN 23-Jun-06 21:03 sylk/types/google/rpc/error_details_pb2.py
--rw-r--r--  2.0 unx     1891 b- defN 23-Jun-06 21:03 sylk/types/google/rpc/http_pb2.py
--rw-r--r--  2.0 unx     1522 b- defN 23-Jun-06 21:03 sylk/types/google/rpc/status_pb2.py
+-rw-r--r--  2.0 unx     1811 b- defN 23-Jun-11 09:56 sylk/types/google/rpc/code_pb2.py
+-rw-r--r--  2.0 unx     4671 b- defN 23-Jun-11 09:56 sylk/types/google/rpc/error_details_pb2.py
+-rw-r--r--  2.0 unx     1887 b- defN 23-Jun-11 09:56 sylk/types/google/rpc/http_pb2.py
+-rw-r--r--  2.0 unx     1518 b- defN 23-Jun-11 09:56 sylk/types/google/rpc/status_pb2.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-06 21:27 sylk/types/sylk/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-06 21:27 sylk/types/sylk/io/__init__.py
--rw-r--r--  2.0 unx     1428 b- defN 23-Jun-06 21:03 sylk/types/sylk/io/pagination_pb2.py
--rw-r--r--  2.0 unx     2843 b- defN 23-Jun-06 21:34 sylk/types/sylk/io/service_config_pb2.py
--rw-r--r--  2.0 unx     1053 b- defN 23-Jun-07 13:22 sylk-0.2.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     9750 b- defN 23-Jun-07 13:22 sylk-0.2.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-07 13:22 sylk-0.2.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       48 b- defN 23-Jun-07 13:22 sylk-0.2.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       10 b- defN 23-Jun-07 13:22 sylk-0.2.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    21476 b- defN 23-Jun-07 13:22 sylk-0.2.0.dist-info/RECORD
-216 files, 1274263 bytes uncompressed, 316200 bytes compressed:  75.2%
+-rw-r--r--  2.0 unx     1428 b- defN 23-Jun-11 09:56 sylk/types/sylk/io/pagination_pb2.py
+-rw-r--r--  2.0 unx     2843 b- defN 23-Jun-11 09:58 sylk/types/sylk/io/service_config_pb2.py
+-rw-r--r--  2.0 unx     1678 b- defN 23-Jul-18 14:12 tests/test.py
+-rw-r--r--  2.0 unx     1053 b- defN 23-Aug-01 16:15 sylk-0.3.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx    10238 b- defN 23-Aug-01 16:15 sylk-0.3.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Aug-01 16:15 sylk-0.3.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       48 b- defN 23-Aug-01 16:15 sylk-0.3.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       16 b- defN 23-Aug-01 16:15 sylk-0.3.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    27778 b- defN 23-Aug-01 16:15 sylk-0.3.0.dist-info/RECORD
+275 files, 1659534 bytes uncompressed, 376561 bytes compressed:  77.3%
```

## zipnote {}

```diff
@@ -213,80 +213,179 @@
 
 Filename: sylk/commons/resources.py
 Comment: 
 
 Filename: sylk/commons/sylk.py
 Comment: 
 
+Filename: sylk/commons/modules/__init__.py
+Comment: 
+
+Filename: sylk/commons/modules/google/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/Activities/__init__.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Activities/v1/Activities_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Activities/v1/Activities_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Activities/v1/__init__.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/ActivityLog/__init__.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/ActivityLog/v1/ActivityLog_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/ActivityLog/v1/ActivityLog_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/ActivityLog/v1/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/EnumValues/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/EnumValues/v1/EnumValues_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/EnumValues/v1/EnumValues_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/EnumValues/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/EnumValues/v2/EnumValues_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/EnumValues/v2/EnumValues_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/EnumValues/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/Enums/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Enums/v1/Enums_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Enums/v1/Enums_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Enums/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/Enums/v2/Enums_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Enums/v2/Enums_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Enums/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/Fields/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Fields/v1/Fields_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Fields/v1/Fields_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Fields/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/Fields/v2/Fields_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Fields/v2/Fields_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Fields/v2/__init__.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Folders/__init__.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Folders/v2/Folders_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Folders/v2/Folders_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Folders/v2/__init__.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Integrations/__init__.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Integrations/v2/Integrations_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Integrations/v2/Integrations_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Integrations/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/Messages/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Messages/v1/Messages_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Messages/v1/Messages_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Messages/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/Messages/v2/Messages_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Messages/v2/Messages_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Messages/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/Methods/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Methods/v1/Methods_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Methods/v1/Methods_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Methods/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/Methods/v2/Methods_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Methods/v2/Methods_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Methods/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/Organizations/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Organizations/v1/Organizations_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Organizations/v1/Organizations_pb2_grpc.py
@@ -303,14 +402,23 @@
 
 Filename: sylk/commons/protos/sylk/Packages/v1/Packages_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Packages/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/Packages/v2/Packages_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Packages/v2/Packages_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Packages/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/Projects/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Projects/v1/Projects_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Projects/v1/Projects_pb2_grpc.py
@@ -327,26 +435,44 @@
 
 Filename: sylk/commons/protos/sylk/Services/v1/Services_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Services/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/Services/v2/Services_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Services/v2/Services_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Services/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/Sylk/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Sylk/v1/Sylk_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Sylk/v1/Sylk_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Sylk/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/Sylk/v2/Sylk_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Sylk/v2/Sylk_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Sylk/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/SylkApi/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkApi/v1/SylkApi_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkApi/v1/SylkApi_pb2_grpc.py
@@ -399,14 +525,23 @@
 
 Filename: sylk/commons/protos/sylk/SylkEnum/v1/SylkEnum_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkEnum/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/SylkEnum/v2/SylkEnum_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/SylkEnum/v2/SylkEnum_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/SylkEnum/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/SylkEnumValue/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkEnumValue/v1/SylkEnumValue_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkEnumValue/v1/SylkEnumValue_pb2_grpc.py
@@ -435,14 +570,23 @@
 
 Filename: sylk/commons/protos/sylk/SylkMessage/v1/SylkMessage_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkMessage/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/SylkMessage/v2/SylkMessage_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/SylkMessage/v2/SylkMessage_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/SylkMessage/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/SylkMethod/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkMethod/v1/SylkMethod_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkMethod/v1/SylkMethod_pb2_grpc.py
@@ -471,14 +615,23 @@
 
 Filename: sylk/commons/protos/sylk/SylkPackage/v1/SylkPackage_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkPackage/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/SylkPackage/v2/SylkPackage_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/SylkPackage/v2/SylkPackage_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/SylkPackage/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/SylkProject/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkProject/v1/SylkProject_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkProject/v1/SylkProject_pb2_grpc.py
@@ -507,26 +660,47 @@
 
 Filename: sylk/commons/protos/sylk/SylkService/v1/SylkService_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkService/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/SylkService/v2/SylkService_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/SylkService/v2/SylkService_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/SylkService/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/SylkUser/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkUser/v1/SylkUser_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkUser/v1/SylkUser_pb2_grpc.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/SylkUser/v1/__init__.py
 Comment: 
 
+Filename: sylk/commons/protos/sylk/Tags/__init__.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Tags/v2/Tags_pb2.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Tags/v2/Tags_pb2_grpc.py
+Comment: 
+
+Filename: sylk/commons/protos/sylk/Tags/v2/__init__.py
+Comment: 
+
 Filename: sylk/commons/protos/sylk/Users/__init__.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Users/v1/Users_pb2.py
 Comment: 
 
 Filename: sylk/commons/protos/sylk/Users/v1/Users_pb2_grpc.py
@@ -624,26 +798,29 @@
 
 Filename: sylk/types/sylk/io/pagination_pb2.py
 Comment: 
 
 Filename: sylk/types/sylk/io/service_config_pb2.py
 Comment: 
 
-Filename: sylk-0.2.0.dist-info/LICENSE
+Filename: tests/test.py
+Comment: 
+
+Filename: sylk-0.3.0.dist-info/LICENSE
 Comment: 
 
-Filename: sylk-0.2.0.dist-info/METADATA
+Filename: sylk-0.3.0.dist-info/METADATA
 Comment: 
 
-Filename: sylk-0.2.0.dist-info/WHEEL
+Filename: sylk-0.3.0.dist-info/WHEEL
 Comment: 
 
-Filename: sylk-0.2.0.dist-info/entry_points.txt
+Filename: sylk-0.3.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: sylk-0.2.0.dist-info/top_level.txt
+Filename: sylk-0.3.0.dist-info/top_level.txt
 Comment: 
 
-Filename: sylk-0.2.0.dist-info/RECORD
+Filename: sylk-0.3.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## docs/source/conf.py

```diff
@@ -8,15 +8,15 @@
 
 import sys
 
 
 project = 'sylk'
 copyright = 'sylk 2022, Amit Shmulevitch'
 author = 'Amit Shmulevitch'
-release = '0.2.0'
+release = '0.3.0'
 
 sys.path.append('/Users/amitshmulevitch/Projects/sylk/sylk')
 # -- General configuration ---------------------------------------------------
 # https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration
 extensions = [
     'sphinx.ext.duration',
     'sphinx.ext.doctest',
```

## sylk/__version__.py

```diff
@@ -1 +1 @@
-__version__ = '0.2.0'
+__version__ = '0.3.0'
```

## sylk/config.py

```diff
@@ -24,7 +24,10 @@
         # "@sylk/SamplePy",
         # "@sylk/SampleTs",
         # "@sylk/PubSubTs",
         # "@sylk/HelloWorldPy",
         # "@sylk/HelloWorldTs"
     ]
 )
+
+sylk_api_host='api.sylk.build'
+sylk_api_port=9000
```

## sylk/architect/__init__.py

```diff
@@ -27,177 +27,436 @@
 from sylk.commons.pretty import print_error, print_info, print_note
 
 from sylk.commons.protos.sylk.SylkClient.v1 import SylkClient_pb2
 from sylk.commons.protos.sylk.SylkServer.v1 import SylkServer_pb2
 from sylk.commons.protos.sylk.SylkProject.v1 import SylkProject_pb2
 
 from google.protobuf.json_format import MessageToDict
-from sylk.commons.resources import generate_enum, generate_message, generate_package, generate_project,\
-                                     generate_rpc, generate_service
+from sylk.commons.resources import (
+    generate_enum,
+    generate_message,
+    generate_package,
+    generate_project,
+    generate_rpc,
+    generate_service,
+)
 
 from sylk.architect.recievers import Builder
-from sylk.architect.commands import AddResource, EditResource, InitProject,\
-                                    Logger,RemoveResource, SetDomain
+from sylk.architect.commands import (
+    AddResource,
+    EditResource,
+    InitProject,
+    Logger,
+    RemoveResource,
+    SetDomain,
+)
 from sylk.architect.invoker import Sylk
 
 logging.basicConfig(
-    level='INFO',
-    format='%(asctime)s - [%(filename)10s] - %(funcName)10s() - %(name)s - %(levelname)s - %(message)s',
-    datefmt='%Y%m%d-%H:%M%p',
+    level="INFO",
+    format="%(asctime)s - [%(filename)10s] - %(funcName)10s() - %(name)s - %(levelname)s - %(message)s",
+    datefmt="%Y%m%d-%H:%M%p",
 )
 
+def replace_object_element(array, target_object, new_object):
+    for i, element in enumerate(array):
+        if element == target_object:  # Using the '==' operator for object comparison
+            array[i] = new_object
+            break
+
 class CommandMap(Enum):
     _REMOVE_RESOURCE = "RemoveResource"
     _EDIT_RESOURCE = "EditResource"
     _ADD_RESOURCE = "AddResource"
     _SET_DOMAIN = "SetDomain"
     _SET_CONFIG = "SetConfig"
 
-
-class SylkArchitect():
-
-    def __init__(self,path,domain='domain',project_name='project',save=None) -> None:
+class SylkArchitect:
+    def __init__(
+        self, path, domain="domain", project_name="project", save=None, base_protos="protos", format="json"
+    ) -> None:
         logging.debug("Starting sylk build architect process")
-        if 'sylk.json' not in path:
-            raise SylkProtoError('sylk.json file path is not valid','Make sure you pass in your architect class the right path to your sylk.json file')
+        if "sylk.json" not in path:
+            raise SylkProtoError(
+                "sylk.json file path is not valid",
+                "Make sure you pass in your architect class the right path to your sylk.json file",
+            )
         self._path = path
         self._org_id = None
         self._project = None
         self._domain = domain
         self._project_name = project_name
+        self._base_protos = base_protos
         self._builder = Builder()
         self._remove_resource = RemoveResource(self._builder)
         self._edit_resource = EditResource(self._builder)
         self._add_resource = AddResource(self._builder)
         self._logger = Logger(self._builder)
         self._set_domain = SetDomain(self._builder)
-        self._sylk = Sylk(self._path,save)
-        self._sylk.registerCommand(CommandMap._REMOVE_RESOURCE,self._remove_resource)
-        self._sylk.registerCommand(CommandMap._EDIT_RESOURCE,self._edit_resource)
-        self._sylk.registerCommand(CommandMap._ADD_RESOURCE,self._add_resource)
-        self._sylk.registerHook(CommandMap._ADD_RESOURCE,'log',self._logger)
+        self._format = format
+        self._sylk = Sylk(self._path, save, self._format)
+        self._sylk.registerCommand(CommandMap._REMOVE_RESOURCE, self._remove_resource)
+        self._sylk.registerCommand(CommandMap._EDIT_RESOURCE, self._edit_resource)
+        self._sylk.registerCommand(CommandMap._ADD_RESOURCE, self._add_resource)
+        self._sylk.registerHook(CommandMap._ADD_RESOURCE, "log", self._logger)
 
-    def SetDomain(self,domain):
+    def SetDomain(self, domain):
         self._domain = domain
-        self._sylk.execute(CommandMap._ADD_RESOURCE, {'organization': { 'domain' : domain }})
-    
-    def SetOrgId(self,orgId):
+        self._sylk.execute(
+            CommandMap._ADD_RESOURCE, {"organization": {"domain": domain}}, []
+        )
+
+    def SetOrgId(self, orgId):
         self._org_id = orgId
-        self._sylk.execute(CommandMap._ADD_RESOURCE, {'organization': { 'orgId' : orgId }})
-    
-    def SetConfig(self,config):
-        self._sylk.execute(CommandMap._ADD_RESOURCE, { 'configs' : config })
+        self._sylk.execute(CommandMap._ADD_RESOURCE, {"organization": {"orgId": orgId}}, [])
 
-    def SetSylkVersion(self):
-        self._sylk.execute(CommandMap._ADD_RESOURCE, { 'sylkVersion' : __version__.__version__ })
+    def SetConfig(self, config):
+        self._sylk.execute(CommandMap._ADD_RESOURCE, {"configs": config}, [])
 
-    def AddProject(self,name=None,server_language=SylkServer_pb2.SylkServerLanguages.Name(SylkServer_pb2.python),clients=[]) -> SylkProject_pb2.SylkProject:
+    def SetSylkVersion(self):
+        self._sylk.execute(
+            CommandMap._ADD_RESOURCE, {"sylkVersion": __version__.__version__}, []
+        )
+
+    def AddProject(
+        self,
+        name=None,
+        server_language=SylkServer_pb2.SylkServerLanguages.Name(SylkServer_pb2.python),
+        clients=[],
+    ) -> SylkProject_pb2.SylkProject:
         name = name if name is not None else self._project_name
-        dict = generate_project(self._path,name,server_language,clients,json=True)
-        project = generate_project(self._path,name,server_language,clients)
-        self._sylk.execute(CommandMap._ADD_RESOURCE,{'project':dict})
+        dict = generate_project(self._path, name, server_language, clients, json=True)
+        project = generate_project(self._path, name, server_language, clients)
+        self._sylk.execute(CommandMap._ADD_RESOURCE, {"project": dict}, [])
         self._project = project
         return project
-    
+
     def AddClient(self):
         pass
 
-    def AddService(self,name,dependencies,description,methods,extensions=None,version:str='v1'):
-        dict = generate_service(self._path,self._domain,name,self._sylk.sylkJson.get('project')['server']['language'],dependencies=dependencies,description=description,extensions=extensions,json=True,methods=methods,sylk_json=self._sylk.sylkJson) 
-        service = generate_service(self._path,self._domain,name,self._sylk.sylkJson.get('project')['server']['language'],dependencies=dependencies,description=description,extensions=extensions,methods=methods,sylk_json=self._sylk.sylkJson)
-        services = self._sylk.sylkJson.get('services') if self._sylk.sylkJson.get('services') is not None else {} 
-        services[f'protos/{self._domain}/{name}/{version}/{name}.proto'] = dict
-        self._sylk.execute(CommandMap._ADD_RESOURCE,{'services': services })
+    def AddService(
+        self,
+        name,
+        dependencies,
+        description,
+        methods,
+        package,
+        extensions=None,
+        tag=None,
+        order_pkg=[]
+    ):
+
+        path_with_domain = package.package + '.' + name
+        service = generate_service(
+            self._path,
+            path_with_domain,
+            self._sylk.sylkJson.get("project")["server"]["language"],
+            dependencies=dependencies,
+            description=description,
+            extensions=extensions,
+            methods=methods,
+            sylk_json=self._sylk.sylkJson,
+            tag=tag
+        )
+        if next((s for s in package.services if s.name == service.name), None) is None:
+            package.services.append(service)
+            self._sylk.execute(
+                CommandMap._ADD_RESOURCE,
+                {
+                    "packages": {
+                        f"{package.package.replace('.','/')}": MessageToDict(
+                            package
+                        )
+                    }
+                },
+                order_pkg
+            )
+            return service
+        else:
+            logging.error(
+                f"Cannot create service '{service.name}' already exists under '{package.name}' package"
+            )
         return service
 
-    def AddRPC(self,service,name,*args):
-        service_name = service.name
-        service_ver = service.full_name.split('.')[2]
-        service_path = f'protos/{self._domain}/{service_name}/{service_ver}/{service_name}.proto'
+    def AddRPC(self, package, service, name, order_pkg=[], *args):
+        # service_name = service.name
+        # service_ver = service.full_name.split(".")[2]
+        package_path = (
+            f"{package.package.replace('.','/')}"
+        )
         _IN = args[0][0]
         _OUT = args[0][1]
-        RPC = generate_rpc(self._path,name,_IN[0],_OUT[0],_IN[1],_OUT[1],args[1])
+        print(args)
+        RPC = generate_rpc(self._path, name, _IN[0], _OUT[0], _IN[1], _OUT[1], args[1])
         service.methods.append(RPC)
         
-        in_package = '.'.join(_IN[1].split('.')[:-1])
-        out_package = '.'.join(_OUT[1].split('.')[:-1])
-
-        if in_package not in service.dependencies:
-            service.dependencies.append(in_package)
-        if out_package not in service.dependencies:
-            service.dependencies.append(out_package)
-        self._sylk.execute(CommandMap._ADD_RESOURCE,{'services': { service_path : MessageToDict(service) } })
-
-    def AddPackage(self,name,dependencies=[],messages=[],description=None,domain=None,extensions=None,version:str='v1'):
-        dict = generate_package(self._path,self._domain if domain is None else domain,name,dependencies=dependencies,messages=messages,description=description,extensions=extensions,json=True,sylk_json=self._sylk.sylkJson)
-        package = generate_package(self._path,self._domain if domain is None else domain,name,dependencies=dependencies,messages=messages,description=description,extensions=extensions,sylk_json=self._sylk.sylkJson)
-        self._sylk.execute(CommandMap._ADD_RESOURCE,{'packages': { f'protos/{self._domain}/{name}/{version}/{name}.proto' : dict } })
+        for i, svc in enumerate(package.services):
+            if svc.name == service.name:
+                package.services[i].methods.append(RPC)
+                break
+        
+        self._sylk.execute(
+            CommandMap._ADD_RESOURCE,
+            {
+                "packages": {
+                    package_path: MessageToDict(package)
+                }
+            },
+            order_pkg
+        )
+
+    def AddPackage(
+        self,
+        name,
+        dependencies=[],
+        messages=[],
+        description=None,
+        extensions=None,
+        version_component=None,
+        order_pkg=[]
+    ):
+        if name == self._domain:
+            path_with_domain = self._domain
+        else:
+            path_with_domain = self._domain + '.' + name
+        dict = generate_package(
+            self._path,
+            path_with_domain,
+            dependencies=dependencies,
+            messages=messages,
+            description=description,
+            extensions=extensions,
+            json=True,
+            sylk_json=self._sylk.sylkJson,
+            version=version_component
+        )
+        package = generate_package(
+            self._path,
+            path_with_domain,
+            dependencies=dependencies,
+            messages=messages,
+            description=description,
+            extensions=extensions,
+            sylk_json=self._sylk.sylkJson,
+            version=version_component
+        )
+        self._sylk.execute(
+            CommandMap._ADD_RESOURCE,
+            {
+                "packages": {
+                    f"{path_with_domain.replace('.','/')}": dict
+                }
+            },
+            order_pkg
+        )
         return package
 
-    def AddMessage(self,package,name,fields,description=None,options=None,extensions=None,domain=None,version:str='v1'):
-        message = generate_message(self._path,self._domain if domain is None else domain,package,name,fields,option=options,description=description,extensions=extensions,sylk_json=self._sylk.sylkJson)
+    def AddMessage(
+        self,
+        package,
+        name,
+        fields,
+        description=None,
+        options=None,
+        extensions=None,
+        domain=None,
+        tag=None,
+        order_pkg=[]
+    ):
+        path_with_domain = self._domain + '.' + name
+        message = generate_message(
+            self._path,
+            self._domain if domain is None else domain,
+            package,
+            name,
+            fields,
+            option=options,
+            description=description,
+            extensions=extensions,
+            sylk_json=self._sylk.sylkJson,
+            tag=tag,
+        )
         if next((m for m in package.messages if m.name == message.name), None) is None:
             package.messages.append(message)
-            self._sylk.execute(CommandMap._ADD_RESOURCE,{'packages':{f'protos/{self._domain}/{package.name}/{version}/{package.name}.proto': MessageToDict(package)}})
+            self._sylk.execute(
+                CommandMap._ADD_RESOURCE,
+                {
+                    "packages": {
+                        f"{package.package.replace('.','/')}": MessageToDict(
+                            package
+                        )
+                    }
+                },
+                order_pkg
+            )
             return message
         else:
-            logging.error(f"Cannot create message '{message.name}' already exists under '{package.name}' package")
+            logging.error(
+                f"Cannot create message '{message.name}' already exists under '{package.name}' package"
+            )
         return message
+
+    def AddEnum(
+        self,
+        package,
+        name,
+        enum_values,
+        description=None,
+        domain=None,
+        tag=None,
+        order_pkg=[]
+    ):
+        enum = generate_enum(
+            self._path,
+            self._domain if domain is None else domain,
+            package,
+            name,
+            enum_values,
+            description=description,
+            tag=tag
+        )
         
-    def AddEnum(self,package,name,enum_values,description=None,domain=None,version:str='v1'):
-        enum = generate_enum(self._path,self._domain if domain is None else domain,package.name,name,enum_values,description=description)
         package.enums.append(enum)
-        self._sylk.execute(CommandMap._ADD_RESOURCE,{'packages':{f'protos/{self._domain}/{package.name}/{version}/{package.name}.proto': MessageToDict(package)}})
+        self._sylk.execute(
+            CommandMap._ADD_RESOURCE,
+            {
+                "packages": {
+                    f"{package.package.replace('.','/')}": MessageToDict(
+                        package
+                    )
+                }
+            },
+            order_pkg
+        )
         return enum
 
-    def EditService(self,name,dependencies,description,methods,extensions=None):
-        service = generate_service(self._path,self._domain,name,self._sylk.sylkJson.get('project')['server']['language'],dependencies=dependencies,description=description,methods=methods,extensions=extensions,sylk_json=self._sylk.sylkJson)
-        self._sylk.execute(CommandMap._EDIT_RESOURCE,MessageToDict(service))
+    def EditService(
+        self, name, dependencies, description, methods, extensions=None, version="v1"
+    ):
+        service = generate_service(
+            self._path,
+            self._domain,
+            name,
+            self._sylk.sylkJson.get("project")["server"]["language"],
+            dependencies=dependencies,
+            description=description,
+            methods=methods,
+            extensions=extensions,
+            sylk_json=self._sylk.sylkJson,
+            version=version,
+        )
+        self._sylk.execute(CommandMap._EDIT_RESOURCE, MessageToDict(service))
         return service
 
-    def EditPackage(self,name,dependencies=[],messages=[],enums=[],description=None,extensions=None):
-        package = generate_package(self._path,self._domain,name,dependencies=dependencies,messages=messages,description=description,enums=enums,extensions=extensions,sylk_json=self._sylk.sylkJson)
-        self._sylk.execute(CommandMap._EDIT_RESOURCE,MessageToDict(package))
+    def EditPackage(
+        self,
+        name,
+        dependencies=[],
+        messages=[],
+        enums=[],
+        description=None,
+        extensions=None,
+        version="v1",
+    ):
+        package = generate_package(
+            self._path,
+            name,
+            dependencies=dependencies,
+            messages=messages,
+            description=description,
+            enums=enums,
+            extensions=extensions,
+            sylk_json=self._sylk.sylkJson,
+            version=version,
+        )
+        self._sylk.execute(CommandMap._EDIT_RESOURCE, MessageToDict(package))
         return package
 
-    def EditMessage(self,package,name,fields,description=None,options=None,old_name=None,extensions=None):
-        message = generate_message(self._path,self._domain,package,name,fields,option=options,description=description,extensions=extensions,sylk_json=self._sylk.sylkJson)
-        self._sylk.execute(CommandMap._EDIT_RESOURCE,MessageToDict(message),old_name=old_name)
+    def EditMessage(
+        self,
+        package,
+        name,
+        fields,
+        description=None,
+        options=None,
+        old_name=None,
+        extensions=None,
+        tag=None
+    ):
+        message = generate_message(
+            self._path,
+            self._domain,
+            package,
+            name,
+            fields,
+            option=options,
+            description=description,
+            extensions=extensions,
+            sylk_json=self._sylk.sylkJson,
+            tag=tag
+        )
+        self._sylk.execute(
+            CommandMap._EDIT_RESOURCE, MessageToDict(message), old_name=old_name, package=package.package
+        )
         return message
 
-    def EditEnum(self,package,name,enum_values):
-        enum = generate_enum(self._path,self._domain,package.name,name,enum_values)
-        self._sylk.execute(CommandMap._EDIT_RESOURCE,MessageToDict(enum))
-    
-    def EditRPC(self,service,name,input_type,output_type,client_stream,server_stream,description,extensions=None):
-        RPC = generate_rpc(self._path,name,client_stream,server_stream,input_type,output_type,description)
-        self._sylk.execute(CommandMap._EDIT_RESOURCE,MessageToDict(RPC))
-
-    def RemoveEnum(self,full_name):
-        self._sylk.execute(CommandMap._REMOVE_RESOURCE,full_name)
-    
-    def RemoveMessage(self,full_name):
-        self._sylk.execute(CommandMap._REMOVE_RESOURCE,full_name)
+    def EditEnum(
+        self,
+        package,
+        name,
+        enum_values,
+        description=None,
+        tag=None,
+    ):
+        enum = generate_enum(self._path, self._domain, package, name, enum_values,tag=tag,description=description)
+        self._sylk.execute(CommandMap._EDIT_RESOURCE, MessageToDict(enum))
+
+    def EditRPC(
+        self,
+        service,
+        name,
+        input_type,
+        output_type,
+        client_stream,
+        server_stream,
+        description,
+        extensions=None,
+    ):
+        RPC = generate_rpc(
+            self._path,
+            name,
+            client_stream,
+            server_stream,
+            input_type,
+            output_type,
+            description,
+        )
+        self._sylk.execute(CommandMap._EDIT_RESOURCE, MessageToDict(RPC))
+
+    def RemoveEnum(self, full_name):
+        self._sylk.execute(CommandMap._REMOVE_RESOURCE, full_name)
+
+    def RemoveMessage(self, full_name):
+        self._sylk.execute(CommandMap._REMOVE_RESOURCE, full_name)
 
     def RemoveRpc(self, full_name):
-        self._sylk.execute(CommandMap._REMOVE_RESOURCE,full_name)
+        self._sylk.execute(CommandMap._REMOVE_RESOURCE, full_name)
 
     def RemoveField(self, full_name):
-        self._sylk.execute(CommandMap._REMOVE_RESOURCE,full_name)
+        self._sylk.execute(CommandMap._REMOVE_RESOURCE, full_name)
 
     def RemoveOneofField(self, full_name):
-        self._sylk.execute(CommandMap._REMOVE_RESOURCE,full_name)
-        
-    def RemoveEnumValue(self, full_name):
-        self._sylk.execute(CommandMap._REMOVE_RESOURCE,full_name)
+        self._sylk.execute(CommandMap._REMOVE_RESOURCE, full_name)
 
+    def RemoveEnumValue(self, full_name):
+        self._sylk.execute(CommandMap._REMOVE_RESOURCE, full_name)
 
     def Save(self):
         logging.debug("Saving sylk.build architect process")
 
         self._sylk.save()
 
     def undo(self):
         self._sylk.undo()
 
     def redo(self):
-        self._sylk.redo()
+        self._sylk.redo()
```

## sylk/architect/invoker.py

```diff
@@ -25,20 +25,22 @@
 from sylk.commons import pretty
 from sylk.commons import helpers
 from sylk.commons.file_system import rFile, wFile, join_path, walkFiles, mkdir
 from sylk.commons.helpers import SylkJsonToMessage, MessageToDict
 from sylk.architect.commands import GetSylkJson, SaveSylkJson
 from sylk.architect.recievers import Core
 from sylk.architect.interfaces import IUndoRedo
-log = logging.getLogger('sylk.cli.main')
+
+log = logging.getLogger("sylk.cli.main")
 
 try:
-   import cPickle as pickle
+    import cPickle as pickle
 except:
-   import pickle
+    import pickle
+
 
 class CoreInvoker:
     """The Invoker Class"""
 
     def __init__(self, path):
         log.debug("Invoker class __init__")
         self._commands = {}
@@ -61,18 +63,18 @@
             response = self._commands[command_name].execute(self._path, args)
             self._history.append((time.time(), command_name, args, response))
         else:
             log.error(f"Command [{command_name}] not recognised")
 
 
 class Sylk(IUndoRedo):
-    def __init__(self, path=None, load=None):
-        log.debug(
-            "Architect class __init__ | path to project -> {0}".format(path))
+    def __init__(self, path=None, load=None, format="json"):
+        log.debug("Architect class __init__ | path to project -> {0}".format(path))
         self._saves = 0
+        self._format = format
         self._load = load
         self._core = Core()
         self._core_invoker = CoreInvoker(path)
         self.init_core()
         # self._cache = lru.LruCache(100)
         self._commands = {}
         self._hooks = {}
@@ -81,171 +83,186 @@
         self._get_sylk_json()
         self._get_saves()
         temp_sylk = self._sylk_json.copy()
         self._history = [(temp_sylk, "INIT", (path,))]
         self._unsaved_changes = False
 
     def init_core(self):
-        self._core_invoker.register('GetSylkJson', GetSylkJson(self._core))
-        self._core_invoker.register(
-            'SaveSylkJson', SaveSylkJson(self._core))
+        self._core_invoker.register("GetSylkJson", GetSylkJson(self._core))
+        self._core_invoker.register("SaveSylkJson", SaveSylkJson(self._core))
 
     def _get_sylk_json(self):
-        self._core_invoker.execute('GetSylkJson')
+        self._core_invoker.execute("GetSylkJson",{'format': self.sylkJson.get('configs',{"format":self._format}).get('format','json')})
         self._sylk_json = self._core_invoker.history[-1][-1]
 
     def _get_saves(self):
-        if self._sylk_json.get('project').get('uri') is not None:
+        if self._sylk_json.get("project").get("uri") is not None:
+            cache = walkFiles(
+                join_path(self._sylk_json.get("project").get("uri"), ".sylk", "cache")
+            )
 
-            cache = walkFiles(join_path(self._sylk_json.get(
-                'project').get('uri'), '.sylk', 'cache'))
-            
             if cache is not None:
                 self._saves = len(cache)
                 if self._load is not None:
-                    loaded_save = next(
-                        (f for f in cache if f == self._load), None)
+                    loaded_save = next((f for f in cache if f == self._load), None)
                     if loaded_save is None:
-                        log.error(
-                            f"Couldnt load cached save [{self._load}]")
+                        log.error(f"Couldnt load cached save [{self._load}]")
                     else:
-                        path = join_path(self._sylk_json.get('project').get(
-                            'uri'), '.sylk', 'cache', f'{loaded_save}')
+                        path = join_path(
+                            self._sylk_json.get("project").get("uri"),
+                            ".sylk",
+                            "cache",
+                            f"{loaded_save}",
+                        )
                         sylkJson = SylkJsonToMessage(rFile(path, json=True))
                         # log.error(sylkJson)
-                        self._sylk_json = MessageToDict(sylkJson) 
+                        self._sylk_json = MessageToDict(sylkJson)
 
     def registerCommand(self, command_name, command):
         """All commands are registered in the Invoker Class"""
         self._commands[command_name] = command
 
-    def registerHook(self, command_name, hook_name, hook, type='before'):
+    def registerHook(self, command_name, hook_name, hook, type="before"):
         """All hooks are registered in the Invoker Class"""
         if self._hooks.get(command_name) is None:
-            self._hooks[command_name] = {'before': {}, 'after': {}}
+            self._hooks[command_name] = {"before": {}, "after": {}}
 
         self._hooks[command_name][type][hook_name] = hook
 
     def before_execute(self, command_name, *args):
         hook_map = self._hooks.get(command_name)
         if hook_map is not None:
-            for hook in hook_map.get('before'):
+            for hook in hook_map.get("before"):
                 log.debug("Running before hook")
-                hook_map['before'][hook].execute('before', command_name, args)
+                hook_map["before"][hook].execute("before", command_name, args)
 
     def after_execute(self, command_name, *args):
         hook_map = self._hooks.get(command_name)
         if hook_map is not None:
-            for hook in hook_map.get('after'):
+            for hook in hook_map.get("after"):
                 log.debug("Running after hook")
-                hook_map['after'][hook].execute('after', command_name, args)
+                hook_map["after"][hook].execute("after", command_name, args)
 
     def execute(self, command_name, *args, **kwargs):
         if command_name in self._commands.keys():
             log.debug(f"[EXCUTE] {command_name}")
             if self._history_position != 0 and self._unsaved_changes == False:
                 self._get_sylk_json()
             # else:
-                # self._sylk_json = self._history[self._history_position][0]
+            # self._sylk_json = self._history[self._history_position][0]
             self._history_position += 1
             self.before_execute(command_name, args)
-            self._commands[command_name].execute(
-                self._sylk_json, args, kwargs)
+            self._commands[command_name].execute(self._sylk_json, args, kwargs)
             self.after_execute(command_name, args)
             self._unsaved_changes = True
             if len(self._history) == self._history_position:
                 # This is a new event in hisory
                 temp = self._sylk_json.copy()
                 self._history.append((temp, command_name, args, kwargs))
             else:
                 # This occurs if there was one of more UNDOs and then a new
                 # execute command happened. In case of UNDO, the history_position
                 # changes, and executing new commands purges any history after
                 # the current position"""
-                self._history = self._history[:self._history_position+1]
+                self._history = self._history[: self._history_position + 1]
                 self._history[self._history_position] = {
                     time.time(): [command_name, args]
                 }
         else:
             log.error(f"Command [{command_name}] not recognised")
 
     def undo(self):
         """Undo a command if there is a command that can be undone.
         Update the history psoition so that further UNDOs or REDOs
         point to the correct index"""
         if self._history_position > 0:
             self._history_position -= 1
-            log.debug(
-                f"[UNDO] {self._history_position} / {len(self.history)}")
+            log.debug(f"[UNDO] {self._history_position} / {len(self.history)}")
             self._sylk_json = self.history[self._history_position][0]
             # self._commands[
             #     self._history[self._history_position][1]
             # ].execute(self._history[self._history_position][0],self._history[self._history_position][2])
         else:
             log.warning("nothing to undo")
 
     def redo(self):
         """Perform a REDO if the history_position is less than the end of the history list"""
         if self._history_position + 1 < len(self._history):
             self._history_position += 1
-            log.debug(
-                f"[REDO] {self._history_position} / {len(self.history)}")
-            self._commands[
-                self._history[self._history_position][1]
-            ].execute(self._history[self._history_position][0], self._history[self._history_position][2])
+            log.debug(f"[REDO] {self._history_position} / {len(self.history)}")
+            self._commands[self._history[self._history_position][1]].execute(
+                self._history[self._history_position][0],
+                self._history[self._history_position][2],
+            )
         else:
             log.warning("nothing to REDO")
 
     def save(self, sylkJson=True):
         """Saving current state"""
         current_state = self._sylk_json
         log.debug(f"[SAVE] {current_state}")
         self._unsaved_changes = False
-        self._core_invoker.execute('SaveSylkJson', current_state)
+        self._core_invoker.execute(
+            "SaveSylkJson",
+            current_state,
+            {"format": self.sylkJson.get("configs").get("format", "json")},
+        )
         self._saves += 1
         message = SylkJsonToMessage(self._sylk_json)
-        path = join_path(self._sylk_json.get('project').get(
-            'uri'), '.sylk', 'cache', f'save_{self._saves}.json')
-        if self._saves > 1 :
-            old_save = SylkJsonToMessage(rFile(join_path(self._sylk_json.get('project').get(
-                'uri'), '.sylk', 'cache', f'save_{self._saves-1}.json'), True))
-            if old_save != message :
-                log.info(old_save)
-                message = SylkJsonToMessage(self._sylk_json,validate=True)
+        path = join_path(
+            self._sylk_json.get("project").get("uri"),
+            ".sylk",
+            "cache",
+            f"save_{self._saves}.json",
+        )
+        if self._saves > 1:
+            old_save = SylkJsonToMessage(
+                rFile(
+                    join_path(
+                        self._sylk_json.get("project").get("uri"),
+                        ".sylk",
+                        "cache",
+                        f"save_{self._saves-1}.json",
+                    ),
+                    True,
+                )
+            )
+            if old_save != message:
+                message = SylkJsonToMessage(self._sylk_json, validate=True)
                 try:
-                    wFile(path, MessageToDict(message),
-                        overwrite=True, json=True)
+                    wFile(path, MessageToDict(message), overwrite=True, json=True)
                 except Exception:
-                    temp_path = '/'.join(path.split('/')[:-1])
+                    temp_path = "/".join(path.split("/")[:-1])
                     mkdir(temp_path)
-                    wFile(path, MessageToDict(message),
-                        overwrite=True, json=True)
+                    wFile(path, MessageToDict(message), overwrite=True, json=True)
                 log.info(
-                    f"Saving cache to [{join_path('.sylk','cache',f'save_{self._saves}.json')}]")
+                    f"Saving cache to [{join_path('.sylk','cache',f'save_{self._saves}.json')}]"
+                )
         else:
             try:
-                temp_p = path.replace('/cache/save_1.json', '')
-                log.info(temp_p)
+                temp_p = path.replace("/cache/save_1.json", "")
                 mkdir(temp_p)
                 wFile(path, MessageToDict(message), overwrite=True, json=True)
             except Exception:
-                temp_path = '/'.join(path.split('/')[:-1])
+                temp_path = "/".join(path.split("/")[:-1])
                 mkdir(temp_path)
                 wFile(path, MessageToDict(message), overwrite=True, json=True)
             log.info(
-                f"Saving cache to [{join_path('.sylk','cache',f'save_{self._saves}.json')}]")
-      
+                f"Saving cache to [{join_path('.sylk','cache',f'save_{self._saves}.json')}]"
+            )
+
         # self._cache.insert(f'save_{self._saves}.json',MessageToDict(message))
         # out_s = open(join_path(self._sylk_json.get('project').get(
         #     'uri'), '.sylk', 'cache','dump'), 'wb')
         # try:
         #     log.debug('WRITING: %s' % (message.domain))
         #     pickle.dump(message, out_s)
         # finally:
         #     out_s.close()
+
     @property
     def history(self):
         return self._history
 
     @property
     def commands(self):
         return self._commands
@@ -254,56 +271,59 @@
     def hooks(self):
         return self._hooks
 
     @property
     def sylkJson(self):
         return self._sylk_json
 
-
-    def validate_sylk_json(self,sylkJson):
-        if  sylkJson.packages is not None:
+    def validate_sylk_json(self, sylkJson):
+        if sylkJson.packages is not None:
             for p in sylkJson.packages:
                 pkg = sylkJson.packages[p]
                 reorder = []
                 index = 0
                 for m in pkg.messages:
-                    dependency_in_pkg = next((f for f in m.fields if f.message_type is not None),None)
-                    
+                    dependency_in_pkg = next(
+                        (f for f in m.fields if f.message_type is not None), None
+                    )
+
                     reorder.append(index)
                     if dependency_in_pkg is not None:
                         if pkg.package in dependency_in_pkg.message_type:
                             # pretty.print_error(dependency_in_pkg)
-                            pretty.print_info(reorder,True,"{0} / {1}".format(index,max(reorder)))
+                            pretty.print_info(
+                                reorder, True, "{0} / {1}".format(index, max(reorder))
+                            )
                             if index > max(reorder):
-                                reorder = [x+1 for x in reorder]
-                                reorder[index] = max(reorder) -1
-                            else: 
-                                reorder[index] = index +1
+                                reorder = [x + 1 for x in reorder]
+                                reorder[index] = max(reorder) - 1
+                            else:
+                                reorder[index] = index + 1
                         else:
                             if index >= reorder[index]:
-                                reorder = [x+1 for x in reorder]
+                                reorder = [x + 1 for x in reorder]
 
                             reorder[index] = index
                     else:
-                        reorder[index] = max(reorder) +1
-                    pretty.print_info(dependency_in_pkg,True)
-                    pretty.print_info(reorder,True,"After changes")
-                
+                        reorder[index] = max(reorder) + 1
+                    pretty.print_info(dependency_in_pkg, True)
+                    pretty.print_info(reorder, True, "After changes")
+
                     index += 1
-                reorder = [x-1 for x in reorder]
+                reorder = [x - 1 for x in reorder]
                 mylist = [pkg.messages[i] for i in reorder]
                 pkg_temp = MessageToDict(pkg)
-                pkg_temp['messages'] = mylist
+                pkg_temp["messages"] = mylist
 
-                pretty.print_info(mylist,True,"Last step")
+                pretty.print_info(mylist, True, "Last step")
                 sylkJson_temp = MessageToDict(sylkJson)
                 index = 0
-                for i in pkg_temp['messages']:
-                    pretty.print_info(i,True)
+                for i in pkg_temp["messages"]:
+                    pretty.print_info(i, True)
 
                     pkg_temp[index] = MessageToDict(i)
                     index += 1
 
-                sylkJson_temp.get('packages')[p] = pkg_temp
-                pretty.print_info(sylkJson_temp,True)
+                sylkJson_temp.get("packages")[p] = pkg_temp
+                pretty.print_info(sylkJson_temp, True)
                 return helpers.SylkJsonToMessage(sylkJson_temp)
-                # pretty.print_info(sylkJson.packages[p],True,"Package After Change step")
+                # pretty.print_info(sylkJson.packages[p],True,"Package After Change step")
```

## sylk/architect/recievers/__init__.py

```diff
@@ -16,81 +16,103 @@
 # MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import logging
+
+from google.protobuf.json_format import ParseDict
+
 from sylk.commons import resources
 from sylk.commons.helpers import Graph
 from sylk.commons.pretty import print_error, print_info, print_warning
+from sylk.commons.protos.sylk.Sylk.v2 import Sylk_pb2
 
 from sylk.commons.resources import get_blank_sylk_json
 from sylk.commons.file_system import mkdir, rFile, wFile, get_current_location, join_path, check_if_file_exists
 log = logging.getLogger('sylk.cli.main')
 
 class Core:
 
     def get_sylk_json(self,*args,**kwargs):
         # log.debug(args)
         if args[0][0] is None:
             current_path = get_current_location()
-            destination_path = join_path(current_path,'sylk.json')
-            log.debug("Writing new sylk json {1}".format(args[0][0],destination_path))
+            opts = args[0][0]
+            format = opts.get('format')
+            destination_path = join_path(current_path,f'sylk.{format}')
+            log.debug("Writing new sylk {2} {1}".format(args[0][0],destination_path,format))
             sylkJson = get_blank_sylk_json(True)
-            wFile(destination_path,sylkJson,json=True)
+            if format == 'textpb':
+                sylk_json = ParseDict(sylkJson,Sylk_pb2.SylkJson())
+                wFile(destination_path,sylk_json,flags='wb')
+            else:
+                wFile(destination_path,sylkJson,json=True)
             # destination_path = destination_path.replace('sylk.json','.sylk')
             # mkdir(destination_path)
         else:
             log.debug("Getting sylk json {0}".format(args[0][0]))
             try:
                 sylkJson = rFile(args[0][0],json=True)
             except Exception:
                 sylkJson = get_blank_sylk_json(True)
                 wFile(args[0][0],sylkJson,json=True)
 
         return sylkJson
 
     def save_sylk_json(self,*args,**kwargs):
-        log.debug("Saving sylk json")
-        wFile(args[0][0],args[0][1][0],json=True,overwrite=True)
+        opts = args[0][1][1]
+        log.debug(f"Saving sylk {opts.get('format')}")
+        if opts.get('format') == 'textpb':
+            sylk_json = ParseDict(args[0][1][0],Sylk_pb2.SylkJson())
+            wFile(args[0][0].replace('sylk.json','sylk.textpb'), sylk_json.SerializeToString(), overwrite=True,flags='wb')
+        else:
+            wFile(args[0][0],args[0][1][0],json=True,overwrite=True)
 
 
 class Builder:
 
     def log(self,hook,command_name,*args,**kwargs):
         log.debug(f"[EXCUTE-HOOK-{hook.upper()}] {command_name} : {args}")
    
     def add_resource(self,sylkJson,*args,**kwargs):
         request = args[0][0][0]
+        order_dict = args[0][0][1]
         for k in request:
             # log.debug(f"Adding resource : {k}")
             if sylkJson.get(k) is None:
                 sylkJson[k] = request[k]
 
             else:
                 # Primitives
                 if k in ['domain','sylkVersion']:
                     sylkJson[k] = request[k]
                 # Composites
                 else:
                     for j in request[k]:
+
                         sylkJson[k][j] = request[k][j]
+                    if k == 'packages':
+                        def reorder_dict(dictionary, key_order):
+                            return {key: dictionary[key] for key in key_order if key in dictionary}
+                        sylkJson[k] = reorder_dict(sylkJson[k],[c.replace('.','/') for c in order_dict])
 
     def edit_resource(self,sylkJson,resource,args):
 
         resource = resource[0]
         type = resource.get('type')
         kind = resource.get('kind')
-
+        base_protos = sylkJson.get('configs').get('protoBasePath')+'/' if sylkJson.get('configs').get('protoBasePath') is not None else ''
+        
         if type is not None:
-            if type == 'descriptors':
+            if type == 'descriptor':
                 if kind == resources.ResourceKinds.message.value:
                     fullname = resource.get('fullName')
-                    pkgname = 'protos/{0}/{1}/{2}/{1}.proto'.format(fullname.split('.')[0],fullname.split('.')[1],fullname.split('.')[2])
+                    pkgname = args[0].get('package').replace('.','/')
                     package = sylkJson.get('packages').get(pkgname)
                     if package is not None:
 
                         index = 0
                         for m in package['messages']:
 
                             if args[0] is not None and args[0].get('old_name') is not None:
@@ -114,35 +136,48 @@
                                 # sylkJson['packages'][pkgname]['messages'].insert(len(sylkJson['packages'][pkgname]['messages']), removed_message)
                                 break
                             index += 1
                 elif kind == resources.ResourceKinds.method.value:
                     pass
                 elif kind == resources.ResourceKinds.enum.value:
                     fullname = resource.get('fullName')
-                    pkgname = 'protos/{0}/{1}/{2}/{1}.proto'.format(fullname.split('.')[0],fullname.split('.')[1],fullname.split('.')[1])
+                    pkgname = args[0].get('package').replace('.','/')
                     package = sylkJson.get('packages').get(pkgname)
                     if package is not None:
                         index = 0
                         for e in package['enums']:
                             if e.get('fullName') == resource.get('fullName'):
                                 sylkJson['packages'][pkgname]['enums'][index] = resource
                                 break
                             index += 1
                 elif kind == resources.ResourceKinds.enum_value.value:
                     pass
                 elif kind == resources.ResourceKinds.field.value:
                     pass
-            elif type == 'packages':
+            elif type == 'package':
                 fullname = resource.get('package')
-                pkgname = 'protos/{0}/{1}/{2}/{1}.proto'.format(fullname.split('.')[0],fullname.split('.')[1],fullname.split('.')[2])
+                pkgname = fullname.replace('.','/')
                 package = sylkJson.get('packages').get(pkgname)
                 if package is not None:
                     sylkJson['packages'][pkgname] = resource
-            elif type == 'services':
-                sylkJson['services'][resource.get('name')] = resource
+            elif type == 'service':
+                svc_path = args[0].get('package').replace('.','/')
+                index = 0
+                for s in sylkJson['packages'][svc_path]['services']:
+                    if args[0] is not None and args[0].get('old_name') is not None:
+
+                        if s.get('name') == args[0].get('old_name'):
+                            sylkJson['packages'][svc_path]['services'][index] = resource
+                            break
+
+                    if s.get('fullName') == resource.get('fullName'):
+                        sylkJson['packages'][svc_path]['services'][index] = resource
+                        break
+                    
+                    index += 1
 
     def remove_resource(self,sylkJson,full_name,*args,**kwargs):
         """Removing sylk.build resource by full name identifier"""
 
         removed = False
         full_name = full_name[0]
 
@@ -185,15 +220,14 @@
                         for m in sylkJson['packages'][pkg_name].get('messages'):
                             field_name = '.'.join(full_name.split('.')[:-1])
                             field = next((f for f in m.get('fields') if f.get('fullName') == field_name),None)
                             if field is not None:
                                 field_index = m.get('fields').index(field)
                                 oneof_field = next((one_f for one_f in field.get('oneofFields') if one_f.get('fullName') == full_name),None)
                                 if oneof_field is not None:
-                                    print_info(f'{pkg_name=} | {index_msgs=} | {field_index=}')
                                     sylkJson['packages'][pkg_name]['messages'][index_msgs]['fields'][field_index]['oneofFields'].remove(oneof_field)
                                     removed = True
                                     break
                             index_msgs += 1
 
         else:
             # Removing fields or enum values
```

## sylk/builder/plugins/SylkBase.py

```diff
@@ -17,105 +17,105 @@
 # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import logging
 import sylk.builder as builder
-from sylk.commons import helpers,file_system,pretty
+from sylk.commons import helpers, file_system, pretty
 from sylk.commons.errors import SylkValidationError
 
 
 @builder.hookimpl
-def pre_build(sylk_json:helpers.SylkJson, sylk_context: helpers.SylkContext):
+def pre_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     pretty.print_info("🔌 Starting sylk build process %s plugin" % (__name__))
 
     directories = [
         # Clients
-        file_system.join_path(sylk_json.path,'clients'),
-        file_system.join_path(sylk_json.path,'services','protos', sylk_json.domain),
-        file_system.join_path(sylk_json.path,'protos'),
-        file_system.join_path(sylk_json.path,'protos', sylk_json.domain),
-        file_system.join_path(sylk_json.path,'bin'),
-        file_system.join_path(sylk_json.path,'.sylk'),
-        file_system.join_path(sylk_json.path,'server'),
+        file_system.join_path(sylk_json.path, "clients"),
+        file_system.join_path(sylk_json.path, "services", "protos", sylk_json.domain),
+        file_system.join_path(sylk_json.path, "protos"),
+        file_system.join_path(sylk_json.path, "protos", sylk_json.domain),
+        file_system.join_path(sylk_json.path, "bin"),
+        file_system.join_path(sylk_json.path, ".sylk"),
+        file_system.join_path(sylk_json.path, "server"),
     ]
     for d in directories:
         file_system.mkdir(d)
 
 
 @builder.hookimpl(hookwrapper=True)
-def post_build(sylk_json:helpers.SylkJson, sylk_context: helpers.SylkContext):
+def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # pretty.print_success("Finished sylk.build build process %s plugin" % (__name__))
     # all corresponding hookimpls are invoked here
     outcome = yield
     results = outcome.get_result()
     if results != []:
-        pretty.print_info('Sylk finished build for:')
+        pretty.print_info("Sylk finished build for:")
         for p in results:
-            pretty.print_note(f'\t- {p[0]}')
+            pretty.print_note(f"\t- {p[0]}")
+
 
 @builder.hookimpl(hookwrapper=True)
-def pre_build_server(sylk_json:helpers.SylkJson, sylk_context: helpers.SylkContext):
+def pre_build_server(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # all corresponding hookimpls are invoked here
     outcome = yield
     # outcome.force_result([{'test':'test'}])
     results = outcome.get_result()
 
     inject_base_dependencies = None
-    for s in sylk_json.services:
-        svc = sylk_json.services[s]
-        if svc.get('dependencies') is not None and len(svc.get('dependencies')) > 0:
-            for d in svc.get('dependencies') :
-                dependentSvc = sylk_json.get_service(d.split('.')[1])
+    for svc in sylk_json.services:
+        if svc.get("dependencies") is not None and len(svc.get("dependencies")) > 0:
+            for d in svc.get("dependencies"):
+                dependentSvc = sylk_json.get_service(d.split(".")[1])
                 if dependentSvc is not None:
                     if inject_base_dependencies is None:
                         inject_base_dependencies = {}
-                    inject_base_dependencies[s] = d.split('.')[1]+'Impl'
+                    inject_base_dependencies[svc.get('name')] = d.split(".")[1] + "Impl"
     if inject_base_dependencies is not None:
-        results.append({
-            'sylk.build.builder.plugins.SylkTsServer:write_server():inject_service': inject_base_dependencies
-        })
+        results.append(
+            {
+                "sylk.build.builder.plugins.SylkTsServer:write_server():inject_service": inject_base_dependencies
+            }
+        )
     if results != []:
         for impl in results:
             for mini_hook in impl:
-                pretty.print_info(f'[pre_build_server] Found MiniHook: {mini_hook}')
+                pretty.print_info(f"[pre_build_server] Found MiniHook: {mini_hook}")
+
 
 @builder.hookimpl(hookwrapper=True)
-def post_build_server(sylk_json:helpers.SylkJson, sylk_context: helpers.SylkContext):
+def post_build_server(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # all corresponding hookimpls are invoked here
     outcome = yield
     results = outcome.get_result()
     if results != []:
         for impl in results:
             for mini_hook in impl:
-                pretty.print_info(f'[post_build_server] Found MiniHook: {mini_hook}')
+                pretty.print_info(f"[post_build_server] Found MiniHook: {mini_hook}")
 
 
 @builder.hookimpl(hookwrapper=True)
-def pre_build_clients(sylk_json:helpers.SylkJson, sylk_context: helpers.SylkContext):
+def pre_build_clients(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # all corresponding hookimpls are invoked here
     outcome = yield
     results = outcome.get_result()
     if results != []:
         for impl in results:
             for mini_hook in impl:
-                pretty.print_info(f'[pre_build_clients] Found MiniHook: {mini_hook}')
+                pretty.print_info(f"[pre_build_clients] Found MiniHook: {mini_hook}")
 
 
 @builder.hookimpl(hookwrapper=True)
-def post_build_clients(sylk_json:helpers.SylkJson, sylk_context: helpers.SylkContext):
+def post_build_clients(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # all corresponding hookimpls are invoked here
     outcome = yield
     results = outcome.get_result()
     if results != []:
         for impl in results:
             for mini_hook in impl:
-                pretty.print_info(f'[post_build_clients] Found MiniHook: {mini_hook}')
-
-
-
+                pretty.print_info(f"[post_build_clients] Found MiniHook: {mini_hook}")
 
 
 @builder.hookimpl
 def get_sylk_json():
-    pass
+    pass
```

## sylk/builder/plugins/SylkGoClient.py

```diff
@@ -19,139 +19,176 @@
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import logging
 import subprocess
 import sylk.builder as builder
 from sylk.commons import helpers, file_system, resources, pretty
-from sylk.builder.plugins.static import gitignore_go,package_json,bash_init_script_go,sylk_go_utils_channel
+from sylk.builder.plugins.static import (
+    gitignore_go,
+    package_json,
+    bash_init_script_go,
+    sylk_go_utils_channel,
+)
 
 
 @builder.hookimpl
 def pre_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    pretty.print_info("🔌 Starting sylk build build process %s plugin" % (__name__))
+    pretty.print_info("🔌 Starting sylk build process %s plugin" % (__name__))
 
 
 @builder.hookimpl
 def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    if file_system.check_if_file_exists(file_system.join_path(sylk_json.path,'go.mod')):
-        pretty.print_info('Run the following commands :\n\t-> $ go test\n\t-> $ go mod tidy')
+    if file_system.check_if_file_exists(
+        file_system.join_path(sylk_json.path, "go.mod")
+    ):
+        pretty.print_info(
+            "Run the following commands :\n\t-> $ go test\n\t-> $ go mod tidy"
+        )
 
     else:
-        pretty.print_info('Run the following command :\n\t-> $ go mod init {}'.format(_format_go_package_name(sylk_json.project.get('goPackage'))))
+        pretty.print_info(
+            "Run the following command :\n\t-> $ go mod init {}".format(
+                _format_go_package_name(sylk_json.project.get("goPackage"))
+            )
+        )
     # pretty.print_success("Finished sylk.build build process %s plugin" % (__name__))
-    return (__name__,'OK')
+    return (__name__, "OK")
 
 
 @builder.hookimpl
-def init_project_structure(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+def init_project_structure(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext
+):
     directories = [
         # Clients
-        file_system.join_path(sylk_json.path, 'clients', 'go'),
-        file_system.join_path(sylk_json.path, 'clients', 'go','protos'),
-        file_system.join_path(sylk_json.path, 'clients', 'go','utils'),
-
+        file_system.join_path(sylk_json.path, "clients", "go"),
+        file_system.join_path(sylk_json.path, "clients", "go", "protos"),
+        file_system.join_path(sylk_json.path, "clients", "go", "utils"),
         # Protos
-        file_system.join_path(sylk_json.path, 'services', 'protos')]
+        file_system.join_path(sylk_json.path, "services", "protos"),
+    ]
 
     for dir in directories:
         file_system.mkdir(dir)
-    
+
     # Bin files
     services_protoc = []
     packages_protoc = []
     # if sylk_json.services is not None:
     #     for s in sylk_json.services:
     #         services_protoc.append(s)
     #         if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'services', 'protos', s)) == False:
     #             file_system.mkdir(file_system.join_path(sylk_json.path, 'services', 'protos',s))
     # if sylk_json.packages is not None:
     #     for p in sylk_json.packages:
     #         packages_protoc.append(sylk_json.packages[p].get('name'))
     #         if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'services', 'protos', sylk_json.packages[p].get('name'))) == False:
     #             file_system.mkdir(file_system.join_path(sylk_json.path, 'services', 'protos', sylk_json.packages[p].get('name')))
 
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'clients','go','utils', 'channel.go'), sylk_go_utils_channel)
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "clients", "go", "utils", "channel.go"),
+        sylk_go_utils_channel,
+    )
     # file_system.wFile(file_system.join_path(
-        # sylk_json.path, 'bin', 'proto.js'), protos_compile_script_ts)
+    # sylk_json.path, 'bin', 'proto.js'), protos_compile_script_ts)
 
     # tsconfig.json
     # if sylk_json.get_server_language() != 'typescript':
-        # file_system.wFile(file_system.join_path(sylk_json.path, 'tsconfig.json'),main_ts_config_client_only)
-        # file_system.wFile(file_system.join_path(sylk_json.path, 'services', 'protos', 'tsconfig.json'),protos_ts_config_client_only)
-    
+    # file_system.wFile(file_system.join_path(sylk_json.path, 'tsconfig.json'),main_ts_config_client_only)
+    # file_system.wFile(file_system.join_path(sylk_json.path, 'services', 'protos', 'tsconfig.json'),protos_ts_config_client_only)
+
     # file_system.wFile(file_system.join_path(sylk_json.path,'.sylk','contxt.json'),'{"files":[]}')
-    
+
     # .gitignore
     # gitignore_path = file_system.join_path(sylk_json.path,'.gitignore')
     # if file_system.check_if_file_exists(gitignore_path):
     #     gitignore_file = ''.join(file_system.rFile(gitignore_path))
     #     gitignore_file += gitignore_go
     #     file_system.wFile(file_system.join_path(sylk_json.path,'.gitignore'),gitignore_file,True)
-    file_system.wFile(file_system.join_path(sylk_json.path,'.gitignore'),gitignore_go)
+    file_system.wFile(file_system.join_path(sylk_json.path, ".gitignore"), gitignore_go)
 
     return [directories]
 
+
 @builder.hookimpl
 def pre_compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    if sylk_json.get_server_language() != 'go':
-        pretty.print_info("Running pre compile protos")
+    if sylk_json.get_server_language() != "go":
+        pretty.print_info("Running pre compile protos - go client")
         return {
-            'sylk.builder.plugins.SylkProto:compile_protos():commands':[
-                '--proto-path=protos/',
-                '--go_out=./services/protos',
-                '--go_opt=paths=source_relative',
-                '--go-grpc_out=./services/protos',
-                '--go-grpc_opt=paths=source_relative',
-                '--go_out=./clients/go/protos',
-                '--go-grpc_out=./clients/go/protos',
-                '-I./protos/'
+            "sylk.builder.plugins.SylkProto:compile_protos():commands": [
+                f"--proto_path={sylk_json._root_protos}/",
+                f"--go_out=./services/{sylk_json._root_protos}",
+                f"--go_opt=paths=source_relative",
+                f"--go-grpc_out=./services/{sylk_json._root_protos}",
+                f"--go-grpc_opt=paths=source_relative",
+                f"-I./{sylk_json._root_protos}/",
             ],
-            'sylk.builder.plugins.SylkProto:compile_protos():include_dirs':[],
+            "sylk.builder.plugins.SylkProto:compile_protos():include_dirs": [],
         }
 
-@builder.hookimpl
-def compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    services_protoc = []
-    packages_protoc = []
-    if sylk_json.services is not None:
-        for s in sylk_json.services:
-            services_protoc.append(s)
-    if sylk_json.packages is not None:
-        for p in sylk_json.packages:
-            packages_protoc.append(sylk_json.packages[p].get('name'))
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'bin', 'init-go.sh'), bash_init_script_go(sylk_json.project.get('goPackage'),services_protoc,packages_protoc),True)
-    # Running ./bin/init-go.sh script for compiling protos
-    # if sylk_json.get_server_language() != 'go':
-    #     logging.info("Running ./bin/init-go.sh script for 'protoc' compiler")
-    #     subprocess.run(['bash', file_system.join_path(
-    #         sylk_json.path, 'bin', 'init-go.sh')])
+
+# @builder.hookimpl
+# def compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+#     services_protoc = []
+#     packages_protoc = []
+#     if sylk_json.services is not None:
+#         for s in sylk_json.services:
+#             services_protoc.append(s)
+#     if sylk_json.packages is not None:
+#         for p in sylk_json.packages:
+#             packages_protoc.append(sylk_json.packages[p].get("name"))
+#     file_system.wFile(
+#         file_system.join_path(sylk_json.path, "bin", "init-go.sh"),
+#         bash_init_script_go(
+#             sylk_json.project.get("goPackage"), services_protoc, packages_protoc
+#         ),
+#         True,
+#     )
+#     # Running ./bin/init-go.sh script for compiling protos
+#     # if sylk_json.get_server_language() != 'go':
+#     #     logging.info("Running ./bin/init-go.sh script for 'protoc' compiler")
+#     #     subprocess.run(['bash', file_system.join_path(
+#     #         sylk_json.path, 'bin', 'init-go.sh')])
+
 
 @builder.hookimpl
 def write_clients(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path,'clients','go')):
-        file_system.mkdir(file_system.join_path(sylk_json.path,'clients','go','protos'))
+    if file_system.check_if_dir_exists(
+        file_system.join_path(sylk_json.path, "clients", "go")
+    ):
+        file_system.mkdir(
+            file_system.join_path(sylk_json.path, "clients", "go", "protos")
+        )
     else:
-        file_system.mkdir(file_system.join_path(sylk_json.path,'clients','go'))
-        file_system.mkdir(file_system.join_path(sylk_json.path,'clients','go','protos'))
-    
+        file_system.mkdir(file_system.join_path(sylk_json.path, "clients", "go"))
+        file_system.mkdir(
+            file_system.join_path(sylk_json.path, "clients", "go", "protos")
+        )
+
     # if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'services','protos')):
     #     for f in file_system.walkFiles(file_system.join_path(sylk_json.path, 'services','protos')):
     #         if '.go' in f:
     #             file_name = f.split('.')[0] if '_grpc' not in f else f.split('_grpc.')[0]
     #             go_proto_package_dir = file_system.join_path(sylk_json.path,'services', 'protos', file_name)
     #             if file_system.check_if_dir_exists(go_proto_package_dir) == False:
     #                 file_system.mkdir(go_proto_package_dir)
     #             file_system.mv(file_system.join_path(sylk_json.path,'services', 'protos', f), file_system.join_path(go_proto_package_dir,f))
-        
-        # if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'services','protos','google')):
-            # file_system.cpDir(file_system.join_path(sylk_json.path, 'services','protos','google'),file_system.join_path(sylk_json.path, 'clients','go','protos','google'))
-
-    client = helpers.SylkClientGo(sylk_json.project.get(
-        'packageName'), sylk_json.services, sylk_json.packages, sylk_context, sylk_json=sylk_json)
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'clients','go', 'main.go'), client.__str__(), overwrite=True)
+
+    # if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'services','protos','google')):
+    # file_system.cpDir(file_system.join_path(sylk_json.path, 'services','protos','google'),file_system.join_path(sylk_json.path, 'clients','go','protos','google'))
+    imports = []
+    client_options = []
+    helpers.SylkClientGo(
+        sylk_json.project.get("packageName"),
+        sylk_json.services,
+        sylk_json.packages,
+        sylk_context,
+        sylk_json=sylk_json,
+        pre_data={"imports": imports, "client_options": client_options}
+    )
+    # file_system.wFile(file_system.join_path(
+    #     sylk_json.path, 'clients','go', 'main.go'), client.__str__(), overwrite=True)
+
 
 def _format_go_package_name(go_package):
-    return '{}'.format(go_package)
+    return "{}".format(go_package)
```

## sylk/builder/plugins/SylkGoServer.py

```diff
@@ -18,45 +18,55 @@
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import logging
 import subprocess
 import sylk.builder as builder
-from sylk.commons import helpers, file_system, resources,pretty, protos
-from sylk.builder.plugins.static import gitignore_go,bash_init_script_go,bash_run_server_script_go,utils_go
+from sylk.commons import helpers, file_system, resources, pretty, protos
+from sylk.builder.plugins.static import (
+    gitignore_go,
+    bash_init_script_go,
+    bash_run_server_script_go,
+    utils_go,
+)
 
 
 @builder.hookimpl
 def pre_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     pretty.print_info("🔌 Starting sylk build process %s plugin" % (__name__))
 
 
 @builder.hookimpl
 def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # TODO add postbuild validation of generated code
     # pretty.print_success("Finished sylk build process %s plugin" % (__name__))
-    return (__name__,'OK')
+    return (__name__, "OK")
+
 
 @builder.hookimpl
-def init_project_structure(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+def init_project_structure(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext
+):
     directories = [
         # Utils
-        file_system.join_path(sylk_json.path, 'services', 'utils'),
+        file_system.join_path(sylk_json.path, "services", "utils"),
         # Protos
-        file_system.join_path(sylk_json.path, 'services', 'protos')]
+        file_system.join_path(sylk_json.path, "services", "protos"),
+    ]
 
     for dir in directories:
         file_system.mkdir(dir)
     # Utils
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'services','utils', 'utils.go'), utils_go)
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "services", "utils", "utils.go"), utils_go
+    )
     # Utils Interfaces
     # file_system.wFile(file_system.join_path(
-        # sylk_json.path, 'services','utils', 'interfaces.ts'), utils_interfaces)
+    # sylk_json.path, 'services','utils', 'interfaces.ts'), utils_interfaces)
     # package.json
     # file_system.wFile(file_system.join_path(sylk_json.path,'package.json'),package_json.replace('REPLACEME',sylk_json.project.get('packageName')))
     # Bin files
     services_protoc = []
     packages_protoc = []
     # if sylk_json.services is not None:
     #     for s in sylk_json.services:
@@ -69,124 +79,189 @@
     #     for p in sylk_json.packages:
     #         packages_protoc.append(sylk_json.packages[p].get('name'))
     #         if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'services', 'protos', sylk_json.packages[p].get('name'))) == False:
     #             file_system.mkdir(file_system.join_path(sylk_json.path, 'services', 'protos', sylk_json.packages[p].get('name')))
 
     # Bin files
     # file_system.wFile(file_system.join_path(
-        # sylk_json.path, 'bin', 'init-go.sh'), bash_init_script_ts)
+    # sylk_json.path, 'bin', 'init-go.sh'), bash_init_script_ts)
     # file_system.wFile(file_system.join_path(
-        # sylk_json.path, 'bin', 'proto.js'), protos_compile_script_ts)
+    # sylk_json.path, 'bin', 'proto.js'), protos_compile_script_ts)
 
     # tsconfig.json
     # file_system.wFile(file_system.join_path(sylk_json.path, 'tsconfig.json'),main_ts_config)
     # file_system.wFile(file_system.join_path(sylk_json.path, 'services', 'protos', 'tsconfig.json'),protos_ts_config)
-    
-    if sylk_json.get_server_language() == 'go':
-        file_system.wFile(file_system.join_path(
-            sylk_json.path, 'bin', 'run-server.sh'), bash_run_server_script_go)
-    
+
+    if sylk_json.get_server_language() == "go":
+        file_system.wFile(
+            file_system.join_path(sylk_json.path, "bin", "run-server.sh"),
+            bash_run_server_script_go,
+        )
+
     # file_system.wFile(file_system.join_path(sylk_json.path,'.webezy','contxt.json'),'{"files":[]}')
-    
+
     # .gitignore
-    file_system.wFile(file_system.join_path(sylk_json.path,'.gitignore'),gitignore_go)
+    file_system.wFile(file_system.join_path(sylk_json.path, ".gitignore"), gitignore_go)
 
     return [directories]
 
 
 @builder.hookimpl
 def write_services(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     for svc in sylk_json.services:
-        svc_name = svc.split('/')[-1].split('.')[0]
-        if file_system.check_if_file_exists(file_system.join_path(
-            sylk_json.path, 'services',svc_name, f'{svc_name}.go')) == False:
-            service_code = helpers.SylkServiceGo(sylk_json.project.get('packageName'), svc, sylk_json.services[svc].get(
-                'dependencies'), sylk_json.services[svc], context=sylk_context,sylk_json=sylk_json).to_str()
-            file_system.wFile(file_system.join_path(
-                sylk_json.path, 'services',svc_name, f'{svc_name}.go'), service_code, overwrite=True,force=True)
+        service_name = svc.get('name')
+        ver = helpers.parse_version_component(svc.get("fullName"))
+        if ver:
+            service_version = svc.get("fullName").split(".")[-2]
+            svc_path = file_system.join_path(
+                    sylk_json.path,
+                    "services",
+                    service_name,
+                    service_version,
+                    f"{service_name}.go",
+                )
+        else:
+            svc_path = file_system.join_path(
+                    sylk_json.path,
+                    "services",
+                    service_name,
+                    f"{service_name}.go",
+                )
+        if (
+            file_system.check_if_file_exists(
+                svc_path
+            )
+            == False
+        ):
+            service_code = helpers.SylkServiceGo(
+                sylk_json.project.get("packageName"),
+                service_name,
+                svc.get("dependencies"),
+                svc,
+                context=sylk_context,
+                sylk_json=sylk_json,
+            ).to_str()
+            file_system.wFile(
+                svc_path,
+                service_code,
+                overwrite=True,
+                force=True,
+            )
         # else:
         #     pretty.print_info("Make sure you are editing the {0} file\n - See how to edit service written in Go".format(file_system.join_path(
         #         sylk_json.path, 'services',svc, f'{svc}.go')))
+
+
 # mkdir $DST_DIR"/{0}"\nprotoc -I=$SRC_DIR --go_out=$DST_DIR --go_opt=paths=source_relative --go-grpc_out=$DST_DIR"/{0}"  --go-grpc_opt=paths=source_relative protos/{0}.proto
 
+
 @builder.hookimpl
 def pre_compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    pretty.print_info("Running pre compile protos")
+    pretty.print_info("Running pre compile protos - go server")
     return {
-        'sylk.builder.plugins.SylkProto:compile_protos():commands':[
-            '--go_out=./services/protos',
-            '--go_opt=paths=source_relative',
-            '--go-grpc_out=./services/protos',
-            '--go-grpc_opt=paths=source_relative',
-            '--go_out=./clients/go/protos',
-            '--go-grpc_out=./clients/go/protos',
-
-            '-I./protos/'
+        "sylk.builder.plugins.SylkProto:compile_protos():commands": [
+            f"--proto_path={sylk_json._root_protos}/",
+            f"--go_out=./services/{sylk_json._root_protos}",
+            f"--go_opt=paths=source_relative",
+            f"--go-grpc_out=./services/{sylk_json._root_protos}",
+            f"--go-grpc_opt=paths=source_relative",
+            f"-I./{sylk_json._root_protos}/",
         ],
-        'sylk.builder.plugins.SylkProto:compile_protos():include_dirs':[],
+        "sylk.builder.plugins.SylkProto:compile_protos():include_dirs": [],
     }
 
 
-@builder.hookimpl
-def compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    services_protoc = []
-    packages_protoc = []
-    if sylk_json.services is not None:
-        for s in sylk_json.services:
-            services_protoc.append(s)
-    if sylk_json.packages is not None:
-        for p in sylk_json.packages:
-            packages_protoc.append(sylk_json.packages[p].get('name'))
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'bin', 'init-go.sh'), bash_init_script_go(sylk_json.project.get('goPackage'),services_protoc,packages_protoc),True)
-    # Running ./bin/init-go.sh script for compiling protos
-    # logging.info("Running ./bin/init-go.sh script for 'protoc' compiler")
-    subprocess.run(['bash', file_system.join_path(
-        sylk_json.path, 'bin', 'init-go.sh')])
-
-
-_OPEN_BRCK = '{'
-_CLOSING_BRCK = '}'
-
-
-@builder.hookimpl
-def write_server(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext,pre_data):
-    # pretty.print_error(pre_data,True,'pre_data')
-    go_package_name = sylk_json.project.get('goPackage')
-    imports = ['"log"','"fmt"','"flag"','"net"','"google.golang.org/grpc"']
-    services_bindings = []
-    for svc in sylk_json.services:
-        svc_name = svc.split('/')[-1].split('.')[0]
-        svc_path = '/'.join(svc.split('/')[:-1])
-        imports.append(f'{svc_name}Servicer "{go_package_name}/services/{svc_path}"')
-        imports.append(f'{svc_name} "{go_package_name}/services/{svc_name}"')
-        temp_svc_name = svc_name[0].capitalize() + svc_name[1:]
-        services_bindings.append(
-            f'{svc_name}Servicer.Register{temp_svc_name}Server(grpcServer, new({svc_name}.{temp_svc_name}));')
-    services_bindings = '\n\t'.join(services_bindings)
-    imports = '\n\t'.join(imports)
-    port = sylk_json._config.get('port')
-    server_code = f'// sylk.build Generated Server Code\n\
-package main\n\n\
-import (\n\t{imports}\n)\n\
-var (\n\
-	port = flag.Int("port", {port}, "The server port")\n\
-)\n\n\
-func main() {_OPEN_BRCK}\n\
-\tflag.Parse()\n\
-\tlis, err := net.Listen("tcp", fmt.Sprintf("localhost:%d", *port))\n\
-\tif err != nil {_OPEN_BRCK}\n\
-\t\tlog.Fatalf("Failed to listen: %v", err)\n\
-\t{_CLOSING_BRCK}\n\
-\tvar opts []grpc.ServerOption\n\
-\tgrpcServer := grpc.NewServer(opts...)\n\
-\t{services_bindings}\n\
-\tlog.Printf("[sylk.build] Starting server (Go) at -> %d",*port)\n\
-\tgrpcServer.Serve(lis)\n\
-{_CLOSING_BRCK}'
-   
-    if file_system.check_if_file_exists(file_system.join_path(
-            sylk_json.path,'server', 'server.go')) == False:
-        file_system.wFile(file_system.join_path(
-            sylk_json.path, 'server', 'server.go'), server_code, overwrite=True)
-    else:
-        pretty.print_warning("Make sure you make desired changes on server/server.go file !")
+# @builder.hookimpl
+# def compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+#     services_protoc = []
+#     packages_protoc = []
+#     if sylk_json.services is not None:
+#         for s in sylk_json.services:
+#             services_protoc.append(s)
+#     if sylk_json.packages is not None:
+#         for p in sylk_json.packages:
+#             packages_protoc.append(sylk_json.packages[p].get("name"))
+#     file_system.wFile(
+#         file_system.join_path(sylk_json.path, "bin", "init-go.sh"),
+#         bash_init_script_go(
+#             sylk_json.project.get("goPackage"), services_protoc, packages_protoc
+#         ),
+#         True,
+#     )
+#     # Running ./bin/init-go.sh script for compiling protos
+#     # logging.info("Running ./bin/init-go.sh script for 'protoc' compiler")
+#     subprocess.run(["bash", file_system.join_path(sylk_json.path, "bin", "init-go.sh")])
+
+
+_OPEN_BRCK = "{"
+_CLOSING_BRCK = "}"
+
+
+@builder.hookimpl
+def write_server(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext, pre_data
+):
+    if (
+        file_system.check_if_file_exists(
+            file_system.join_path(sylk_json.path, "server", "server.go")
+        )
+        == False
+    ):
+        go_package_name = sylk_json.project.get("goPackage")
+        imports = ['"log"', '"fmt"', '"flag"', '"net"', '"google.golang.org/grpc"']
+        services_bindings = []
+        for svc in sylk_json.services:
+            svc_name = svc.get('name')
+            svc_path = "/".join(svc.get('fullName').split(".")[:-1])
+            svc_ver = helpers.parse_version_component(svc.get('fullName'))
+            if svc_ver is not None:
+                svc_ver =f"v{svc_ver.get('version')}{svc_ver.get('channel') if svc_ver.get('channel') is not None else ''}{svc_ver.get('release') if svc_ver.get('release') is not None else ''}"
+            else:
+                svc_ver = ""
+            # svc_ver = svc.split("/")[-2]
+            imports.append(
+                f'{svc_name}{svc_ver}Servicer "{go_package_name}/services/{svc_path}"'
+            )
+            imports.append(
+                f'{svc_name}{svc_ver} "{go_package_name}/services/{svc_name}/{svc_ver}"'
+            )
+            temp_svc_name = svc_name[0].capitalize() + svc_name[1:]
+            services_bindings.append(
+                f"{svc_name}{svc_ver}Servicer.Register{temp_svc_name}Server(grpcServer, new({svc_name}{svc_ver}.{temp_svc_name}));"
+            )
+        services_bindings = "\n\t".join(services_bindings)
+        imports = "\n\t".join(imports)
+        port = sylk_json._config.get("port")
+        server_code = f'// sylk.build Generated Server Code\n\
+    package main\n\n\
+    import (\n\t{imports}\n)\n\
+    var (\n\
+        port = flag.Int("port", {port}, "The server port")\n\
+    )\n\n\
+    func main() {_OPEN_BRCK}\n\
+    \tflag.Parse()\n\
+    \tlis, err := net.Listen("tcp", fmt.Sprintf("localhost:%d", *port))\n\
+    \tif err != nil {_OPEN_BRCK}\n\
+    \t\tlog.Fatalf("Failed to listen: %v", err)\n\
+    \t{_CLOSING_BRCK}\n\
+    \tvar opts []grpc.ServerOption\n\
+    \tgrpcServer := grpc.NewServer(opts...)\n\
+    \t{services_bindings}\n\
+    \tlog.Printf("[sylk.build] Starting server (Go) at -> %d",*port)\n\
+    \tgrpcServer.Serve(lis)\n\
+    {_CLOSING_BRCK}'
+
+        if (
+            file_system.check_if_file_exists(
+                file_system.join_path(sylk_json.path, "server", "server.go")
+            )
+            == False
+        ):
+            file_system.wFile(
+                file_system.join_path(sylk_json.path, "server", "server.go"),
+                server_code,
+                overwrite=True,
+            )
+        else:
+            pretty.print_warning(
+                "Make sure you make desired changes on server/server.go file !"
+            )
```

## sylk/builder/plugins/SylkJsClient.py

```diff
@@ -20,147 +20,245 @@
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import logging
 import subprocess
 import sylk.builder as builder
 from sylk import __version__
 from sylk.commons import helpers, file_system, resources, pretty
-from sylk.builder.plugins.static import gitignore_ts,js_package_json,interceptors_js
+from sylk.builder.plugins.static import gitignore_ts, js_package_json, interceptors_js
 import inspect
 
+
 @builder.hookimpl
 def pre_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     pretty.print_info("🔌 Starting sylk build process %s plugin" % (__name__))
 
 
 @builder.hookimpl
 def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path,'node_modules')) == False:
+    if (
+        file_system.check_if_dir_exists(
+            file_system.join_path(sylk_json.path, "node_modules")
+        )
+        == False
+    ):
         # proc = subprocess.run('npm i')
-        subprocess.check_call('npm i', shell=True)
+        subprocess.check_call("npm i", shell=True)
 
         # if proc.returncode != 0:
-            # pretty.print_error("ERROR occured during installation of node modules. some more info on specific error can be found above")
-            # exit(proc.returncode)
-    if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path,'clients', 'javascript','utils')) == False:
-        file_system.mkdir(file_system.join_path(sylk_json.path,'clients', 'javascript','utils'))
-
-    file_system.cpDir(file_system.join_path(sylk_json.path,'server','services','utils'),file_system.join_path(sylk_json.path,'clients','javascript','utils'))
-    for f in file_system.walkFiles(file_system.join_path(sylk_json.path,'protos')):
-        if file_system.check_if_file_exists(file_system.join_path(sylk_json.path,'clients','javascript','protos',f.split('.')[0],'v1',f)):
-            file_system.copyFile(file_system.join_path(sylk_json.path,'protos',f),file_system.join_path(sylk_json.path,'clients','javascript','protos',f.split('.')[0],'v1',f))
+        # pretty.print_error("ERROR occured during installation of node modules. some more info on specific error can be found above")
+        # exit(proc.returncode)
+    if (
+        file_system.check_if_dir_exists(
+            file_system.join_path(sylk_json.path, "clients", "javascript", "utils")
+        )
+        == False
+    ):
+        file_system.mkdir(
+            file_system.join_path(sylk_json.path, "clients", "javascript", "utils")
+        )
+
+    file_system.cpDir(
+        file_system.join_path(sylk_json.path, "server", "services", "utils"),
+        file_system.join_path(sylk_json.path, "clients", "javascript", "utils"),
+    )
+    for f in file_system.walkFiles(file_system.join_path(sylk_json.path, "protos")):
+        if file_system.check_if_file_exists(
+            file_system.join_path(
+                sylk_json.path,
+                "clients",
+                "javascript",
+                "protos",
+                f.split(".")[0],
+                "v1",
+                f,
+            )
+        ):
+            file_system.copyFile(
+                file_system.join_path(sylk_json.path, "protos", f),
+                file_system.join_path(
+                    sylk_json.path,
+                    "clients",
+                    "javascript",
+                    "protos",
+                    f.split(".")[0],
+                    "v1",
+                    f,
+                ),
+            )
         else:
-            file_system.wFile(file_system.join_path(sylk_json.path,'clients','javascript','protos',f.split('.')[0],'v1',f),'',True,False,True)
-            file_system.copyFile(file_system.join_path(sylk_json.path,'protos',f),file_system.join_path(sylk_json.path,'clients','javascript','protos',f.split('.')[0],'v1',f))
+            file_system.wFile(
+                file_system.join_path(
+                    sylk_json.path,
+                    "clients",
+                    "javascript",
+                    "protos",
+                    f.split(".")[0],
+                    "v1",
+                    f,
+                ),
+                "",
+                True,
+                False,
+                True,
+            )
+            file_system.copyFile(
+                file_system.join_path(sylk_json.path, "protos", f),
+                file_system.join_path(
+                    sylk_json.path,
+                    "clients",
+                    "javascript",
+                    "protos",
+                    f.split(".")[0],
+                    "v1",
+                    f,
+                ),
+            )
 
     # file_system.cpDir(file_system.join_path(sylk_json.path,'protos'),file_system.join_path(sylk_json.path,'clients','javascript','protos'))
-    
+
     # pretty.print_success("Finished sylk build process %s plugin" % (__name__))
-    return (__name__,'OK')
+    return (__name__, "OK")
 
 
 @builder.hookimpl
-def init_project_structure(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+def init_project_structure(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext
+):
     directories = [
         # Clients
-        file_system.join_path(sylk_json.path, 'clients', 'javascript'),
-        file_system.join_path(sylk_json.path, 'clients', 'javascript','protos'),
+        file_system.join_path(sylk_json.path, "clients", "javascript"),
+        file_system.join_path(sylk_json.path, "clients", "javascript", "protos"),
         # Utils
-        file_system.join_path(sylk_json.path, 'services', 'utils'),
+        file_system.join_path(sylk_json.path, "services", "utils"),
         # Protos
-        file_system.join_path(sylk_json.path, 'services', 'protos')]
+        file_system.join_path(sylk_json.path, "services", "protos"),
+    ]
 
     for dir in directories:
         file_system.mkdir(dir)
     # package.json
-    file_system.wFile(file_system.join_path(sylk_json.path,'package.json'),js_package_json(sylk_json.project.get('packageName')))
-    
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "package.json"),
+        js_package_json(sylk_json.project.get("packageName")),
+    )
+
     # Bin files
     # file_system.wFile(file_system.join_path(
-        # sylk_json.path, 'bin', 'init-ts.sh'), bash_init_script_ts)
+    # sylk_json.path, 'bin', 'init-ts.sh'), bash_init_script_ts)
     # file_system.wFile(file_system.join_path(
-        # sylk_json.path, 'bin', 'proto.js'), protos_compile_script_ts)
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'clients','javascript','utils', 'interceptors.js'), interceptors_js(__version__.__version__),force=True)
-    file_system.wFile(file_system.join_path(sylk_json.path,'.sylk','contxt.json'),'{"files":[]}')
-    
+    # sylk_json.path, 'bin', 'proto.js'), protos_compile_script_ts)
+    file_system.wFile(
+        file_system.join_path(
+            sylk_json.path, "clients", "javascript", "utils", "interceptors.js"
+        ),
+        interceptors_js(__version__.__version__),
+        force=True,
+    )
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, ".sylk", "contxt.json"), '{"files":[]}'
+    )
+
     # .gitignore
-    file_system.wFile(file_system.join_path(sylk_json.path,'.gitignore'),gitignore_ts)
+    file_system.wFile(file_system.join_path(sylk_json.path, ".gitignore"), gitignore_ts)
 
     return [directories]
 
+
 @builder.hookimpl
-def write_clients(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext,pre_data):
+def write_clients(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext, pre_data
+):
     imports = []
     exports = []
     override_stubs = {}
-    before_init = ''
+    before_init = ""
     interceptors = []
     client_options = [
         ("grpc.keepalive_time_ms", 120000),
-        ("grpc.http2.min_time_between_pings_ms",120000),
-        ("grpc.keepalive_timeout_ms",20000),
-        ("grpc.http2.max_pings_without_data",0),
-        ("grpc.keepalive_permit_without_calls",1),
-        ("interceptors","interceptorsProviders")
+        ("grpc.http2.min_time_between_pings_ms", 120000),
+        ("grpc.keepalive_timeout_ms", 20000),
+        ("grpc.http2.max_pings_without_data", 0),
+        ("grpc.keepalive_permit_without_calls", 1),
+        ("interceptors", "interceptorsProviders"),
     ]
     """Parse pre data"""
     if pre_data:
         _hook_name = inspect.stack()[0][3]
         for mini_hooks in pre_data:
             for hook in mini_hooks:
-                if __name__ == hook.split(':')[0]:
-                    if hook.split(':')[2] is not None and _hook_name == hook.split(':')[1].replace('()',''):
-                        
-                         # Append to exports
-                        if 'append_imports' in hook.split(':')[2]:
+                if __name__ == hook.split(":")[0]:
+                    if hook.split(":")[2] is not None and _hook_name == hook.split(":")[
+                        1
+                    ].replace("()", ""):
+                        # Append to exports
+                        if "append_imports" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for imp in mini_hooks[hook]:
                                     imports.append(imp)
 
                         # Append to exports
-                        elif 'append_exports' in hook.split(':')[2]:
+                        elif "append_exports" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for exp in mini_hooks[hook]:
                                     exports.append(exp)
-                    
+
                         # Append to exports
-                        elif 'override_stubs' in hook.split(':')[2]:
+                        elif "override_stubs" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for stub in mini_hooks[hook]:
                                     override_stubs[stub] = mini_hooks[hook][stub]
 
-                        elif 'append_client_options' in hook.split(':')[2]:
+                        elif "append_client_options" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
-                                for k,v in mini_hooks[hook]:
-                                    old_value = next((i for i in client_options if i[0] == k),(None,None))[1]
-                                    if k not in list(map(lambda x: x[0], client_options)):
-                                        client_options.append((k,v))
+                                for k, v in mini_hooks[hook]:
+                                    old_value = next(
+                                        (i for i in client_options if i[0] == k),
+                                        (None, None),
+                                    )[1]
+                                    if k not in list(
+                                        map(lambda x: x[0], client_options)
+                                    ):
+                                        client_options.append((k, v))
                                     elif v != old_value:
-                                        client_options.remove((k,old_value))
-                                        client_options.append((k,v))
-                        elif 'add_before_init' in hook.split(':')[2]:
+                                        client_options.remove((k, old_value))
+                                        client_options.append((k, v))
+                        elif "add_before_init" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 before_init = mini_hooks[hook]
 
-                        elif 'append_interceptors' in hook.split(':')[2]:
+                        elif "append_interceptors" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for intrcpt in mini_hooks[hook]:
                                     interceptors.append(intrcpt)
                     else:
-                        pretty.print_warning(f'[{__name__}] `{hook}` missing command')
-
+                        pretty.print_warning(f"[{__name__}] `{hook}` missing command")
 
-    if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path,'clients','javascript')) == False:
-        file_system.mkdir(file_system.join_path(sylk_json.path,'clients','javascript'))
-    
-    client = helpers.SylkClientJs(sylk_json.project.get(
-        'packageName'), sylk_json.services, sylk_json.packages, sylk_context,pre_data={
-            'imports': imports,
-            'exports': exports,
-            'stubs': override_stubs,
-            'client_options': client_options,
-            'before_init':before_init,
-            'interceptors': interceptors
-        })
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'clients','javascript', 'index.js'), client.__str__(), overwrite=True)
+    if (
+        file_system.check_if_dir_exists(
+            file_system.join_path(sylk_json.path, "clients", "javascript")
+        )
+        == False
+    ):
+        file_system.mkdir(
+            file_system.join_path(sylk_json.path, "clients", "javascript")
+        )
+
+    client = helpers.SylkClientJs(
+        sylk_json.project.get("packageName"),
+        sylk_json.services,
+        sylk_json.packages,
+        sylk_context,
+        pre_data={
+            "imports": imports,
+            "exports": exports,
+            "stubs": override_stubs,
+            "client_options": client_options,
+            "before_init": before_init,
+            "interceptors": interceptors,
+        },
+    )
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "clients", "javascript", "index.js"),
+        client.__str__(),
+        overwrite=True,
+    )
```

## sylk/builder/plugins/SylkJsServer.py

```diff
@@ -18,99 +18,139 @@
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import logging
 import subprocess
 import sylk.builder as builder
-from sylk.commons import helpers, file_system, resources,pretty, protos
-from sylk.builder.plugins.static import gitignore_js,logger_js,js_package_json
+from sylk.commons import helpers, file_system, resources, pretty, protos
+from sylk.builder.plugins.static import gitignore_js, logger_js, js_package_json
 
 
 @builder.hookimpl
 def pre_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     pretty.print_info("🔌 Starting sylk build process %s plugin" % (__name__))
 
 
 @builder.hookimpl
 def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # TODO add postbuild validation of generated code
     # pretty.print_success("Finished sylk build process %s plugin" % (__name__))
-    return (__name__,'OK')
+    return (__name__, "OK")
+
 
 @builder.hookimpl
-def init_project_structure(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+def init_project_structure(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext
+):
     directories = [
         # Utils
-        file_system.join_path(sylk_json.path, 'services', 'utils'),
+        file_system.join_path(sylk_json.path, "services", "utils"),
         # Protos
-        file_system.join_path(sylk_json.path, 'services', 'protos')]
+        file_system.join_path(sylk_json.path, "services", "protos"),
+    ]
 
     for dir in directories:
         file_system.mkdir(dir)
     # Utils
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'services','utils', 'logger.js'), logger_js)
-    file_system.wFile(file_system.join_path(sylk_json.path,'package.json'),js_package_json(sylk_json.project.get('packageName')))
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "services", "utils", "logger.js"),
+        logger_js,
+    )
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "package.json"),
+        js_package_json(sylk_json.project.get("packageName")),
+    )
     # Bin files
     services_protoc = []
     packages_protoc = []
     if sylk_json.services is not None:
         for s in sylk_json.services:
             services_protoc.append(s)
-            if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'services', 'protos', s)) == False:
-                file_system.mkdir(file_system.join_path(sylk_json.path, 'services', 'protos',s))
+            if (
+                file_system.check_if_dir_exists(
+                    file_system.join_path(sylk_json.path, "services", "protos", s)
+                )
+                == False
+            ):
+                file_system.mkdir(
+                    file_system.join_path(sylk_json.path, "services", "protos", s)
+                )
             # if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'services', s)) == False:
-                # file_system.mkdir(file_system.join_path(sylk_json.path, 'services',s))
+            # file_system.mkdir(file_system.join_path(sylk_json.path, 'services',s))
     # if sylk_json.packages is not None:
-        # for p in sylk_json.packages:
-            # packages_protoc.append(sylk_json.packages[p].get('name'))
-            # if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'services', 'protos', sylk_json.packages[p].get('name'))) == False:
-                # file_system.mkdir(file_system.join_path(sylk_json.path, 'services', 'protos', sylk_json.packages[p].get('name')))
-    
+    # for p in sylk_json.packages:
+    # packages_protoc.append(sylk_json.packages[p].get('name'))
+    # if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'services', 'protos', sylk_json.packages[p].get('name'))) == False:
+    # file_system.mkdir(file_system.join_path(sylk_json.path, 'services', 'protos', sylk_json.packages[p].get('name')))
+
     # .gitignore
-    file_system.wFile(file_system.join_path(sylk_json.path,'.gitignore'),gitignore_js)
+    file_system.wFile(file_system.join_path(sylk_json.path, ".gitignore"), gitignore_js)
 
     return [directories]
 
 
 @builder.hookimpl
 def write_services(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     for svc in sylk_json.services:
-        if file_system.check_if_file_exists(file_system.join_path(
-            sylk_json.path, 'services',svc, f'{svc}.js')) == False:
-            service_code = helpers.SylkServiceJs(sylk_json.project.get('packageName'), svc, sylk_json.services[svc].get(
-                'dependencies'), sylk_json.services[svc], context=sylk_context,sylk_json=sylk_json).to_str()
-            file_system.wFile(file_system.join_path(
-                sylk_json.path, 'services', f'{svc}.js'), service_code, overwrite=True)
+        if (
+            file_system.check_if_file_exists(
+                file_system.join_path(sylk_json.path, "services", svc, f"{svc}.js")
+            )
+            == False
+        ):
+            service_code = helpers.SylkServiceJs(
+                sylk_json.project.get("packageName"),
+                svc,
+                sylk_json.services[svc].get("dependencies"),
+                sylk_json.services[svc],
+                context=sylk_context,
+                sylk_json=sylk_json,
+            ).to_str()
+            file_system.wFile(
+                file_system.join_path(sylk_json.path, "services", f"{svc}.js"),
+                service_code,
+                overwrite=True,
+            )
         # else:
         #     pretty.print_info("Make sure you are editing the {0} file\n - See how to edit service written in Javascript".format(file_system.join_path(
         #         sylk_json.path, 'services', f'{svc}.js')))
         #     return (f'{svc}.js',)
 
-_OPEN_BRCK = '{'
-_CLOSING_BRCK = '}'
+
+_OPEN_BRCK = "{"
+_CLOSING_BRCK = "}"
+
 
 @builder.hookimpl
-def write_server(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext,pre_data):
+def write_server(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext, pre_data
+):
     # pretty.print_error(pre_data,True,'pre_data')
     temp_imports = []
-    imports = ['const services = require(\'./services\')','let grpc = require(\'@grpc/grpc-js\');','let protoLoader = require(\'@grpc/proto-loader\');']
+    imports = [
+        "const services = require('./services')",
+        "let grpc = require('@grpc/grpc-js');",
+        "let protoLoader = require('@grpc/proto-loader');",
+    ]
     services_bindings = []
     for svc in sylk_json.services:
-        temp_imports.append(f'PROTO_PATH_{svc.upper()}')
-        imports.append(f'const PROTO_PATH_{svc.upper()} = __dirname + \'/protos/{svc}.proto\';')
+        temp_imports.append(f"PROTO_PATH_{svc.upper()}")
+        imports.append(
+            f"const PROTO_PATH_{svc.upper()} = __dirname + '/protos/{svc}.proto';"
+        )
         temp_svc_name = svc[0].capitalize() + svc[1:]
         services_bindings.append(
-            f'server.addService(protoDescriptor{temp_svc_name}.{svc}.service, services.{svc});')
-    services_bindings = '\n\t'.join(services_bindings)
-    imports = '\n\t'.join(imports)
-    port = sylk_json._config.get('port')
-    temp_imports = ', '.join(temp_imports)
-    server_code = f'// sylk.build Generated Server Code\n\
+            f"server.addService(protoDescriptor{temp_svc_name}.{svc}.service, services.{svc});"
+        )
+    services_bindings = "\n\t".join(services_bindings)
+    imports = "\n\t".join(imports)
+    port = sylk_json._config.get("port")
+    temp_imports = ", ".join(temp_imports)
+    server_code = f"// sylk.build Generated Server Code\n\
 {imports}\n\
 var packageDefinition = protoLoader.loadSync(\n\
     [{temp_imports}],\n\
     {_OPEN_BRCK}\n\
         includeDirs: [`${_OPEN_BRCK}__dirname{_CLOSING_BRCK}`],\n\
         keepCase: true,\n\
         longs: String,\n\
@@ -122,18 +162,25 @@
 var protoDescriptorTask = grpc.loadPackageDefinition(packageDefinition);\n\
 function getServer() {_OPEN_BRCK}\n\
     let server = new grpc.Server();\n\
     {services_bindings}\n\
     return server;\n\
 {_CLOSING_BRCK}\n\n\
 const SylkServer = getServer();\n\
-routeServer.bindAsync(\'0.0.0.0:{port}\', grpc.ServerCredentials.createInsecure(), () => {_OPEN_BRCK}\n\
+routeServer.bindAsync('0.0.0.0:{port}', grpc.ServerCredentials.createInsecure(), () => {_OPEN_BRCK}\n\
     console.log(`[i] 🔌 Starting sylk build server [::]:{port}`)\n\
     SylkServer.start();\n\
-{_CLOSING_BRCK});'
-   
-    if file_system.check_if_file_exists(file_system.join_path(
-            sylk_json.path, 'server.js')) == False:
-        file_system.wFile(file_system.join_path(
-            sylk_json.path, 'server.js'), server_code, overwrite=True)
+{_CLOSING_BRCK});"
+
+    if (
+        file_system.check_if_file_exists(
+            file_system.join_path(sylk_json.path, "server.js")
+        )
+        == False
+    ):
+        file_system.wFile(
+            file_system.join_path(sylk_json.path, "server.js"),
+            server_code,
+            overwrite=True,
+        )
     else:
         pretty.print_warning("Make sure you make desired changes on server.js file !")
```

## sylk/builder/plugins/SylkMigrate.py

```diff
@@ -26,330 +26,581 @@
 from typing import Dict, List, Literal
 
 import inquirer
 from sylk.architect import SylkArchitect
 import sylk.builder as builder
 from sylk.cli import prompter
 from sylk.cli.theme import SylkTheme
-from sylk.commons import helpers, file_system, resources, errors,protos as sylk_protos
-from sylk.commons.pretty import print_error, print_info, print_note, print_success, print_warning
-from google.protobuf.struct_pb2 import Value,ListValue,Struct
+from sylk.commons import helpers, file_system, resources, errors, protos as sylk_protos
+from sylk.commons.pretty import (
+    print_error,
+    print_info,
+    print_note,
+    print_success,
+    print_warning,
+)
+from google.protobuf.struct_pb2 import Value, ListValue, Struct
 
 from sylk.commons.protos.sylk.SylkField.v1 import SylkField_pb2
 from sylk.commons.protos.sylk.SylkServer.v1 import SylkServer_pb2
 from sylk.commons.protos.sylk.SylkClient.v1 import SylkClient_pb2
 from sylk.commons.protos.sylk.SylkService.v1 import SylkService_pb2
 from sylk.commons.protos.sylk.SylkProject.v1 import SylkProject_pb2
 
 from google.protobuf.descriptor_pb2 import MessageOptions
+
+
 @builder.hookimpl
 def pre_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     logging.debug("🔌 Starting sylk build process %s plugin" % (__name__))
 
 
 @builder.hookimpl
 def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # logging.debug("Finished sylk build process %s plugin" % (__name__))
-    return (__name__,'OK')
+    return (__name__, "OK")
 
 
 _WELL_KNOWN_LANGUAGED = Literal["python", "typescript"]
 
 
 @builder.hookimpl
-def parse_protos_to_resource(protos_dir, project_name, server_language, clients: List[str],domain=None):
-    
+def parse_protos_to_resource(
+    protos_dir, project_name, server_language, clients: List[str], domain=None
+):
     resources_added = []
     pkgs = {}
     services = []
     prj = {}
-    
+
     project_path = str(Path(protos_dir).parents[0])
 
-    print_info(project_path,True,tag='migrating project at path:')
+    print_info(project_path, True, tag="migrating project at path:")
 
     temp_clients = []
-    print_info(clients,True,"Clients languages")
+    print_info(clients, True, "Clients languages")
 
     for c in clients:
-        temp_clients.append(SylkClient_pb2.SylkClient(language=c, out_dir=file_system.join_path(project_path, 'clients', c)))
+        temp_clients.append(
+            SylkClient_pb2.SylkClient(
+                language=c, out_dir=file_system.join_path(project_path, "clients", c)
+            )
+        )
 
     srvr = SylkServer_pb2.SylkServer(language=server_language)
-    print_info(srvr,True,"Server language")
-    prj = SylkProject_pb2.SylkProject(uri=project_path, name=project_name, package_name=project_name.replace('-', '').replace('_', ''), version='0.0.1',
-                  type=resources.ResourceTypes.project.value, kind=resources.ResourceKinds.sylk_1.value, server=srvr, clients=temp_clients)
+    print_info(srvr, True, "Server language")
+    prj = SylkProject_pb2.SylkProject(
+        uri=project_path,
+        name=project_name,
+        package_name=project_name.replace("-", "").replace("_", ""),
+        version="0.0.1",
+        type=resources.ResourceTypes.project.value,
+        kind=resources.ResourceKinds.sylk_1.value,
+        server=srvr,
+        clients=temp_clients,
+    )
     resources_added.append(prj)
 
     if file_system.walkFiles(protos_dir) is None:
         raise errors.SylkProtoError(
-            "File", "Error on parsing proto files. make sure you have a protos dir under current location.")
+            "File",
+            "Error on parsing proto files. make sure you have a protos dir under current location.",
+        )
 
     for f in file_system.walkFiles(protos_dir):
-
         try:
             """Init parse protos"""
             protos = resources.parse_proto(f)
             # pool = resources.parse_pool(protos.pool)
 
             proto_module = protos[0].DESCRIPTOR
-            domain = proto_module.package.split('.')[0] if proto_module.package is not '' else domain
- 
+            domain = (
+                proto_module.package.split(".")[0]
+                if proto_module.package is not ""
+                else domain
+            )
+
             """File options"""
             proto_file_opt = proto_module.GetOptions()
             proto_file_depend = proto_module.dependencies
 
             _services = proto_module.services_by_name
             # _package = proto_module.package
             # print_note({'file_options':proto_file_opt,'file_dependencies':proto_file_depend},True)
 
-
             """Validations"""
             # TODO Handle project with no service (For future use of protobuf as standalone feature)
 
             if _services != {} and proto_module.message_types_by_name != {}:
                 raise errors.SylkProtoError(
-                    'Service', 'Service MUST NOT hold messages ! Please de-attach the messages to stand-alone package')
-            
+                    "Service",
+                    "Service MUST NOT hold messages ! Please de-attach the messages to stand-alone package",
+                )
+
             # Service
             if _services != {}:
-                print_info("Parsing \"Service\" proto file\n\t-> Services : {0}".format(len(_services)))
+                print_info(
+                    'Parsing "Service" proto file\n\t-> Services : {0}'.format(
+                        len(_services)
+                    )
+                )
 
                 for svc in _services:
-
                     service_name = _services[svc].name
                     service_full_name = _services[svc].full_name
                     service_methods = _services[svc].methods_by_name
-                    service = helpers.SylkService(service_name,methods=[],dependencies=[])
+                    service = helpers.SylkService(
+                        service_name, methods=[], dependencies=[]
+                    )
                     service_options = _services[svc].GetOptions()
                     temp_extensions = {}
                     if service_options is not None:
-                        print_note('Service extension detected : {}'.format(service_options))
-                        for svc_ext in service_options.Extensions._extended_message.ListFields():
+                        print_note(
+                            "Service extension detected : {}".format(service_options)
+                        )
+                        for (
+                            svc_ext
+                        ) in service_options.Extensions._extended_message.ListFields():
                             ext_desc, ext_value = svc_ext
                             temp_extensions[ext_desc.full_name] = None
-                            field_opt_type = SylkField_pb2.SylkFieldTypes.Name(ext_desc.type)
-                            field_opt_label = SylkField_pb2.SylkFieldLabel.Name(ext_desc.label)
-                            temp_extensions = parse_proto_extension(field_opt_type,field_opt_label,ext_desc,ext_value,temp_extensions)
+                            field_opt_type = SylkField_pb2.SylkFieldTypes.Name(
+                                ext_desc.type
+                            )
+                            field_opt_label = SylkField_pb2.SylkFieldLabel.Name(
+                                ext_desc.label
+                            )
+                            temp_extensions = parse_proto_extension(
+                                field_opt_type,
+                                field_opt_label,
+                                ext_desc,
+                                ext_value,
+                                temp_extensions,
+                            )
                         service._extensions = temp_extensions
-                        
+
                     for rpc in service_methods:
                         proto_rpc = service_methods[rpc]
-                        service_rpc = helpers.SylkRPC(proto_rpc.name,proto_rpc.input_type.full_name,proto_rpc.output_type.full_name,proto_rpc.client_streaming,proto_rpc.server_streaming)
+                        service_rpc = helpers.SylkRPC(
+                            proto_rpc.name,
+                            proto_rpc.input_type.full_name,
+                            proto_rpc.output_type.full_name,
+                            proto_rpc.client_streaming,
+                            proto_rpc.server_streaming,
+                        )
                         service._methods.append(service_rpc)
-                    
+
                     services.append(service)
 
             # Package
-            if proto_module.package is not None and proto_module.package != '':
-
-               
-                pkg_name = proto_module.package.split('.')[1]
+            if proto_module.package is not None and proto_module.package != "":
+                pkg_name = proto_module.package.split(".")[1]
                 pkg_messages = proto_module.message_types_by_name
                 pkg_enums = proto_module.enum_types_by_name
-                package = helpers.SylkPackage(pkg_name,messages=[],enums=[],domain=proto_module.package.split('.')[0])
-                
+                package = helpers.SylkPackage(
+                    pkg_name,
+                    messages=[],
+                    enums=[],
+                    domain=proto_module.package.split(".")[0],
+                )
+
                 """Handle extensions for package"""
                 if proto_file_opt is not None:
                     temp_extensions = {}
 
-                    for pkg_ext in proto_file_opt.Extensions._extended_message.ListFields():
-
+                    for (
+                        pkg_ext
+                    ) in proto_file_opt.Extensions._extended_message.ListFields():
                         ext_desc, ext_value = pkg_ext
                         temp_extensions[ext_desc.full_name] = None
-                        field_opt_type = SylkField_pb2.SylkFieldTypes.Name(ext_desc.type)
-                        field_opt_label = SylkField_pb2.SylkFieldLabel.Name(ext_desc.label)
-                        temp_extensions = parse_proto_extension(field_opt_type,field_opt_label,ext_desc,ext_value,temp_extensions)
-                       
+                        field_opt_type = SylkField_pb2.SylkFieldTypes.Name(
+                            ext_desc.type
+                        )
+                        field_opt_label = SylkField_pb2.SylkFieldLabel.Name(
+                            ext_desc.label
+                        )
+                        temp_extensions = parse_proto_extension(
+                            field_opt_type,
+                            field_opt_label,
+                            ext_desc,
+                            ext_value,
+                            temp_extensions,
+                        )
+
                     package._extensions = temp_extensions
 
-                print_info("Parsing \"Package\" proto file\n\t-> Messages : {}\n\t-> Enums : {}".format(len(pkg_messages),len(pkg_enums)))
+                print_info(
+                    'Parsing "Package" proto file\n\t-> Messages : {}\n\t-> Enums : {}'.format(
+                        len(pkg_messages), len(pkg_enums)
+                    )
+                )
 
                 # Iterating package messages
                 for msg in pkg_messages:
-                    message = helpers.SylkMessage(pkg_messages[msg].name,fields=[],domain=proto_module.package.split('.')[0])
+                    message = helpers.SylkMessage(
+                        pkg_messages[msg].name,
+                        fields=[],
+                        domain=proto_module.package.split(".")[0],
+                    )
                     for ext in pkg_messages[msg].extensions:
-                        extensions_list_choice = prompter.QList(name='extension_type',message='Choose which type \'{}\' extending?'.format(message.name),choices=[('FieldOptions','FieldOptions'),('FileOptions','FileOptions'),('MessageOptions','MessageOptions'),('ServiceOptions','ServiceOptions')])
-                        extension_type = prompter.ask_user_question(questions=[extensions_list_choice])
+                        extensions_list_choice = prompter.QList(
+                            name="extension_type",
+                            message="Choose which type '{}' extending?".format(
+                                message.name
+                            ),
+                            choices=[
+                                ("FieldOptions", "FieldOptions"),
+                                ("FileOptions", "FileOptions"),
+                                ("MessageOptions", "MessageOptions"),
+                                ("ServiceOptions", "ServiceOptions"),
+                            ],
+                        )
+                        extension_type = prompter.ask_user_question(
+                            questions=[extensions_list_choice]
+                        )
                         if extension_type is None:
-                            
                             # Currently only supports FieldOptions as auto-detect
-                            extension_type = resources.WebezyExtension.Value(ext.GetOptions().Extensions._extended_message.DESCRIPTOR.name)
-                        
+                            extension_type = resources.WebezyExtension.Value(
+                                ext.GetOptions().Extensions._extended_message.DESCRIPTOR.name
+                            )
+
                         else:
-                            extension_type = extension_type['extension_type']
+                            extension_type = extension_type["extension_type"]
 
                         # TODO HANDLE MULTIPLE OPTIONS TYPES
                         message._extension_type = extension_type
                         for field_extended in ext.extension_scope.extensions:
-                            extended_field_desc = helpers.SylkField(field_extended.name,
-                                type=SylkField_pb2.SylkFieldTypes.Name(field_extended.type),
-                                label=SylkField_pb2.SylkFieldLabel.Name(field_extended.label),
-                                enum_type=field_extended.enum_type.full_name if field_extended.enum_type is not None else None,message_type=field_extended.message_type.full_name if field_extended.message_type is not None else None)
-                            
+                            extended_field_desc = helpers.SylkField(
+                                field_extended.name,
+                                type=SylkField_pb2.SylkFieldTypes.Name(
+                                    field_extended.type
+                                ),
+                                label=SylkField_pb2.SylkFieldLabel.Name(
+                                    field_extended.label
+                                ),
+                                enum_type=field_extended.enum_type.full_name
+                                if field_extended.enum_type is not None
+                                else None,
+                                message_type=field_extended.message_type.full_name
+                                if field_extended.message_type is not None
+                                else None,
+                            )
+
                             message._fields.append(extended_field_desc)
 
                     for field in pkg_messages[msg].fields:
                         is_map_field = False
                         field_extensions = None
                         field_key_type = None
                         field_value_type = None
-                        
+
                         # Handle message as field
                         if field.message_type is not None:
-
                             # Handle map special field type
-                            if 'Entry' == field.message_type.name[-5:]:
+                            if "Entry" == field.message_type.name[-5:]:
                                 is_map_field = True
                                 for entry in field.message_type.fields_by_name:
-                                    if 'key' == entry:
-                                        field_key_type = SylkField_pb2.SylkFieldTypes.Name(field.message_type.fields_by_name[entry].type)
-                                    elif 'value' == entry:
-                                        field_value_type = SylkField_pb2.SylkFieldTypes.Name(field.message_type.fields_by_name[entry].type)
+                                    if "key" == entry:
+                                        field_key_type = (
+                                            SylkField_pb2.SylkFieldTypes.Name(
+                                                field.message_type.fields_by_name[
+                                                    entry
+                                                ].type
+                                            )
+                                        )
+                                    elif "value" == entry:
+                                        field_value_type = (
+                                            SylkField_pb2.SylkFieldTypes.Name(
+                                                field.message_type.fields_by_name[
+                                                    entry
+                                                ].type
+                                            )
+                                        )
                                     else:
                                         # Not a map message
                                         field_key_type = None
                                         field_value_type = None
                                         break
                             else:
                                 pass
 
                         # Handle field extensions
                         if field.has_options:
                             field_extensions = {}
                             field_options = field.GetOptions()
-                            
-                            for f_ext in field_options.Extensions._extended_message.ListFields():
-                                field_opt_type = SylkField_pb2.SylkFieldTypes.Name(f_ext[0].type)
-                                field_opt_label = SylkField_pb2.SylkFieldLabel.Name(f_ext[0].label)
-                                field_extensions = parse_proto_extension(field_opt_type,field_opt_label,f_ext[0],f_ext[1],field_extensions)
-                              
-
-                        field_message_type = field.message_type.full_name if hasattr(field.message_type,'full_name') else None
-                        field_message_type = field_message_type if field_message_type is not None and field_message_type[-5:] != 'Entry' else None
-                        field_enum_type = field.enum_type.full_name if hasattr(field.enum_type,'full_name') else None
+
+                            for (
+                                f_ext
+                            ) in (
+                                field_options.Extensions._extended_message.ListFields()
+                            ):
+                                field_opt_type = SylkField_pb2.SylkFieldTypes.Name(
+                                    f_ext[0].type
+                                )
+                                field_opt_label = SylkField_pb2.SylkFieldLabel.Name(
+                                    f_ext[0].label
+                                )
+                                field_extensions = parse_proto_extension(
+                                    field_opt_type,
+                                    field_opt_label,
+                                    f_ext[0],
+                                    f_ext[1],
+                                    field_extensions,
+                                )
+
+                        field_message_type = (
+                            field.message_type.full_name
+                            if hasattr(field.message_type, "full_name")
+                            else None
+                        )
+                        field_message_type = (
+                            field_message_type
+                            if field_message_type is not None
+                            and field_message_type[-5:] != "Entry"
+                            else None
+                        )
+                        field_enum_type = (
+                            field.enum_type.full_name
+                            if hasattr(field.enum_type, "full_name")
+                            else None
+                        )
                         if field_message_type == None:
-                            if hasattr(field.message_type,'fields_by_name'):
-                                if SylkField_pb2.SylkFieldTypes.Name(field.message_type.fields_by_name.get('value').type) == 'TYPE_MESSAGE':
-                                    field_message_type = field.message_type.fields_by_name.get('value').message_type.full_name
-                                elif SylkField_pb2.SylkFieldTypes.Name(field.message_type.fields_by_name.get('value').type) == 'TYPE_ENUM':
-                                    field_enum_type = field.message_type.fields_by_name.get('value').enum_type.full_name
-                                
-                        field = helpers.SylkField(field.name,
-                                                type=SylkField_pb2.SylkFieldTypes.Name(field.type if is_map_field == False else SylkField_pb2.SylkFieldTypes.TYPE_MAP),
-                                                label=SylkField_pb2.SylkFieldLabel.Name(field.label if field_key_type is None else 1),
-                                                message_type=field_message_type,
-                                                enum_type=field_enum_type,
-                                                extensions=field_extensions,key_type=field_key_type,value_type=field_value_type
-                                                )
+                            if hasattr(field.message_type, "fields_by_name"):
+                                if (
+                                    SylkField_pb2.SylkFieldTypes.Name(
+                                        field.message_type.fields_by_name.get(
+                                            "value"
+                                        ).type
+                                    )
+                                    == "TYPE_MESSAGE"
+                                ):
+                                    field_message_type = (
+                                        field.message_type.fields_by_name.get(
+                                            "value"
+                                        ).message_type.full_name
+                                    )
+                                elif (
+                                    SylkField_pb2.SylkFieldTypes.Name(
+                                        field.message_type.fields_by_name.get(
+                                            "value"
+                                        ).type
+                                    )
+                                    == "TYPE_ENUM"
+                                ):
+                                    field_enum_type = (
+                                        field.message_type.fields_by_name.get(
+                                            "value"
+                                        ).enum_type.full_name
+                                    )
+
+                        field = helpers.SylkField(
+                            field.name,
+                            type=SylkField_pb2.SylkFieldTypes.Name(
+                                field.type
+                                if is_map_field == False
+                                else SylkField_pb2.SylkFieldTypes.TYPE_MAP
+                            ),
+                            label=SylkField_pb2.SylkFieldLabel.Name(
+                                field.label if field_key_type is None else 1
+                            ),
+                            message_type=field_message_type,
+                            enum_type=field_enum_type,
+                            extensions=field_extensions,
+                            key_type=field_key_type,
+                            value_type=field_value_type,
+                        )
                         message._fields.append(field)
                     package._messages.append(message)
 
                 # Iterating package enums
                 for en in pkg_enums:
                     e_values = []
                     for ev in pkg_enums[en].values:
-                        e_value = helpers.SylkEnumValue(ev.name,ev.number)
+                        e_value = helpers.SylkEnumValue(ev.name, ev.number)
                         e_values.append(e_value)
-                    enum_desc = helpers.SylkEnum(pkg_enums[en].name,enum_values=e_values,domain=proto_module.package.split('.')[0])
+                    enum_desc = helpers.SylkEnum(
+                        pkg_enums[en].name,
+                        enum_values=e_values,
+                        domain=proto_module.package.split(".")[0],
+                    )
                     package._enums.append(enum_desc)
 
-                pkgs['protos/v1/{0}.proto'.format(package.name)] = package
+                pkgs["protos/v1/{0}.proto".format(package.name)] = package
                 # package = helpers.SylkPackage(pkg_name,messages=[],enums=[])
-            
+
         except Exception as e:
-            print_error(
-                f'Migration Exception occured during handling of [{f}] : {e}')
-   
-    _migrate_to_sylk_json(file_system.join_path(project_path,'sylk.json'),domain if domain is not None else 'sylk',prj,pkgs,services)
+            print_error(f"Migration Exception occured during handling of [{f}] : {e}")
+
+    _migrate_to_sylk_json(
+        file_system.join_path(project_path, "sylk.json"),
+        domain if domain is not None else "sylk",
+        prj,
+        pkgs,
+        services,
+    )
     return resources_added
 
-def _migrate_to_template(template_name:str,template_path:str):
+
+def _migrate_to_template(template_name: str, template_path: str):
     pass
 
-def _migrate_to_sylk_json(sylk_json_path:str,domain,project,packages:Dict[str,helpers.SylkPackage],services:List[helpers.SylkService]):
+
+def _migrate_to_sylk_json(
+    sylk_json_path: str,
+    domain,
+    project,
+    packages: Dict[str, helpers.SylkPackage],
+    services: List[helpers.SylkService],
+):
     msgs_map = {}
 
     ARCHITECT = SylkArchitect(
-        path=sylk_json_path, domain=domain, project_name=project.name)
+        path=sylk_json_path, domain=domain, project_name=project.name
+    )
     c_languages = []
     for client in project.clients:
-        c_languages.append({'language':SylkClient_pb2.ClientLanguages.Name(client.language)})
+        c_languages.append(
+            {"language": SylkClient_pb2.ClientLanguages.Name(client.language)}
+        )
         # if type(client) == str:
         #     client_lang = client
         # else:
         #     client_lang = Language.Name(client)
         # out_dir = file_system.join_path(
         #     sylk_json_path.replace('sylk.json',''), 'clients', client_lang)
         # print_info(f'Adding client: {client_lang}')
         # c_languages.append(
         #     {'out_dir': out_dir, 'language': client_lang})
-    ARCHITECT.AddProject(server_language=SylkServer_pb2.ServerLanguages.Name(project.server.language), clients=c_languages)
+    ARCHITECT.AddProject(
+        server_language=SylkServer_pb2.ServerLanguages.Name(project.server.language),
+        clients=c_languages,
+    )
     ARCHITECT.SetDomain(domain)
-    ARCHITECT.SetConfig({'host': 'localhost', 'port': 50051 })
+    ARCHITECT.SetConfig({"host": "localhost", "port": 50051})
 
     for p in packages:
-        package_name, package_messages, package_enums, package_extensions, package_domain = packages[p].to_tuple()
-        package_temp = ARCHITECT.AddPackage(package_name,domain=package_domain,extensions=package_extensions)
+        (
+            package_name,
+            package_messages,
+            package_enums,
+            package_extensions,
+            package_domain,
+        ) = packages[p].to_tuple()
+        package_temp = ARCHITECT.AddPackage(
+            package_name, domain=package_domain, extensions=package_extensions
+        )
         for m in package_messages:
             msg_name, msg_fields, msg_desc, msg_opt, msg_domain = m
-            msg_temp = ARCHITECT.AddMessage(package_temp, msg_name, msg_fields, msg_desc, msg_opt, msg_domain)
+            msg_temp = ARCHITECT.AddMessage(
+                package_temp, msg_name, msg_fields, msg_desc, msg_opt, msg_domain
+            )
             msgs_map[msg_temp.full_name] = msg_temp
 
         for e in package_enums:
             enum_name, enum_values, enum_desc, enum_domain = e
-            ARCHITECT.AddEnum(package_temp, enum_name, enum_values, enum_desc, enum_domain)
+            ARCHITECT.AddEnum(
+                package_temp, enum_name, enum_values, enum_desc, enum_domain
+            )
 
     for servc in services:
         svc_name, svc_methods, svc_dependencies, svc_desc, svc_ext = servc.to_tuple()
         print_note(svc_ext)
-        temp_service = ARCHITECT.AddService(svc_name,svc_dependencies,svc_desc,[],extensions=svc_ext)
+        temp_service = ARCHITECT.AddService(
+            svc_name, svc_dependencies, svc_desc, [], extensions=svc_ext
+        )
         for rpc in svc_methods:
             rpc_name, rpc_in_out, rpc_desc = rpc
-            ARCHITECT.AddRPC(temp_service,rpc_name,rpc_in_out,rpc_desc)
+            ARCHITECT.AddRPC(temp_service, rpc_name, rpc_in_out, rpc_desc)
 
     ARCHITECT.Save()
-    print_success("Migrate process done !\n\t-> now you can create and edit resources with your new 'sylk.json' file.")
+    print_success(
+        "Migrate process done !\n\t-> now you can create and edit resources with your new 'sylk.json' file."
+    )
+
 
-def parse_proto_extension(field_opt_type,field_opt_label,description,value,field_extensions):
-    if 'REPEATED' in field_opt_label:
+def parse_proto_extension(
+    field_opt_type, field_opt_label, description, value, field_extensions
+):
+    if "REPEATED" in field_opt_label:
         list_values_temp = []
         for field_opt_value in value:
-            if 'BOOL' in field_opt_type:
-                list_values_temp.append( Value(bool_value=field_opt_value))
-            elif 'STRING' in field_opt_type:
-                list_values_temp.append( Value(string_value=field_opt_value))
-            elif 'INT' in field_opt_type:
-                list_values_temp.append( Value(number_value=field_opt_value))
-            elif 'MESSAGE' in field_opt_type:
+            if "BOOL" in field_opt_type:
+                list_values_temp.append(Value(bool_value=field_opt_value))
+            elif "STRING" in field_opt_type:
+                list_values_temp.append(Value(string_value=field_opt_value))
+            elif "INT" in field_opt_type:
+                list_values_temp.append(Value(number_value=field_opt_value))
+            elif "MESSAGE" in field_opt_type:
                 struct_temp = Struct()
                 for field_ext_temp in description.message_type.fields:
-                    if field_ext_temp.type == 'TYPE_MESSAGE' or field_ext_temp.type == 'TYPE_MAP' or field_ext_temp.type == 'TYPE_ENUM':
-                        raise errors.SylkValidationError('Extension values parse error','There are too many nested levels for {}'.format(field_ext_temp.full_name))
-                    struct_temp.update({field_ext_temp.name:getattr(field_opt_value,field_ext_temp.name)})
+                    if (
+                        field_ext_temp.type == "TYPE_MESSAGE"
+                        or field_ext_temp.type == "TYPE_MAP"
+                        or field_ext_temp.type == "TYPE_ENUM"
+                    ):
+                        raise errors.SylkValidationError(
+                            "Extension values parse error",
+                            "There are too many nested levels for {}".format(
+                                field_ext_temp.full_name
+                            ),
+                        )
+                    struct_temp.update(
+                        {
+                            field_ext_temp.name: getattr(
+                                field_opt_value, field_ext_temp.name
+                            )
+                        }
+                    )
                 list_values_temp.append(Value(struct_value=struct_temp))
-            elif 'ENUM' in field_opt_type:
-                list_values_temp.append(Value(string_value=description.enum_type.values_by_number[field_opt_value].name))
+            elif "ENUM" in field_opt_type:
+                list_values_temp.append(
+                    Value(
+                        string_value=description.enum_type.values_by_number[
+                            field_opt_value
+                        ].name
+                    )
+                )
             else:
-                print_warning("Not supporting field type [{0}] for field extensions {1}".format(field_opt_type,description.full_name))
+                print_warning(
+                    "Not supporting field type [{0}] for field extensions {1}".format(
+                        field_opt_type, description.full_name
+                    )
+                )
 
         list_values = ListValue(values=list_values_temp)
         field_extensions[description.full_name] = Value(list_value=list_values)
     else:
-        if 'BOOL' in field_opt_type:
+        if "BOOL" in field_opt_type:
             field_extensions[description.full_name] = Value(bool_value=value)
-        elif 'STRING' in field_opt_type:
+        elif "STRING" in field_opt_type:
             field_extensions[description.full_name] = Value(string_value=value)
-        elif 'INT' in field_opt_type:
+        elif "INT" in field_opt_type:
             field_extensions[description.full_name] = Value(number_value=value)
-        elif 'MESSAGE' in field_opt_type:
-                struct_temp = Struct()
-                for field_ext_temp in description.message_type.fields:
-                    if field_ext_temp.type == 'TYPE_MESSAGE' or field_ext_temp.type == 'TYPE_MAP' or field_ext_temp.type == 'TYPE_ENUM':
-                        raise errors.SylkValidationError('Extension values parse error','There are too many nested levels for {}'.format(field_ext_temp.full_name))
-                    struct_temp.update({field_ext_temp.name:getattr(value,field_ext_temp.name)})
-                field_extensions[description.full_name] = Value(struct_value=struct_temp)
-        elif 'ENUM' in field_opt_type:
-            field_extensions[description.full_name] = Value(string_value=description.enum_type.values_by_number[value].name)
+        elif "MESSAGE" in field_opt_type:
+            struct_temp = Struct()
+            for field_ext_temp in description.message_type.fields:
+                if (
+                    field_ext_temp.type == "TYPE_MESSAGE"
+                    or field_ext_temp.type == "TYPE_MAP"
+                    or field_ext_temp.type == "TYPE_ENUM"
+                ):
+                    raise errors.SylkValidationError(
+                        "Extension values parse error",
+                        "There are too many nested levels for {}".format(
+                            field_ext_temp.full_name
+                        ),
+                    )
+                struct_temp.update(
+                    {field_ext_temp.name: getattr(value, field_ext_temp.name)}
+                )
+            field_extensions[description.full_name] = Value(struct_value=struct_temp)
+        elif "ENUM" in field_opt_type:
+            field_extensions[description.full_name] = Value(
+                string_value=description.enum_type.values_by_number[value].name
+            )
         else:
-            print_warning("Not supporting field type [{0}] for field extensions {1}".format(field_opt_type,description.full_name))
-    
-    return field_extensions
+            print_warning(
+                "Not supporting field type [{0}] for field extensions {1}".format(
+                    field_opt_type, description.full_name
+                )
+            )
+
+    return field_extensions
```

## sylk/builder/plugins/SylkPlugins.py

```diff
@@ -18,30 +18,29 @@
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import logging
 import subprocess
 import sylk.builder as builder
-from sylk.commons import helpers,file_system,pretty
+from sylk.commons import helpers, file_system, pretty
 from sylk.commons.errors import SylkValidationError
 
 
 @builder.hookimpl
-def post_build(sylk_json:helpers.SylkJson, sylk_context: helpers.SylkContext):
+def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     pretty.print_info("Post sylk.build build process %s plugin" % (__name__))
     # protos = []
     # for p in sylk_json.packages:
     #     pkg = sylk_json.packages[p]
     #     pkg_name = pkg['name']
     #     protos.append(f'./protos/{pkg_name}.proto')
     # pretty.print_info(sylk_json._config.get('plugins'))
-    # protoc_params = ['protoc'] + protos  
+    # protoc_params = ['protoc'] + protos
     # pretty.print_note(protoc_params)
     # process = subprocess.Popen(protoc_params,
-    #                     stdout=subprocess.PIPE, 
+    #                     stdout=subprocess.PIPE,
     #                     stderr=subprocess.PIPE)
     # _, stderr = process.communicate()
     # if stderr:
     #     pretty.print_info(stderr.decode('utf-8'))
-    return (__name__,'OK')
-    
+    return (__name__, "OK")
```

## sylk/builder/plugins/SylkProto.py

```diff
@@ -17,129 +17,387 @@
 # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import inspect
 import logging
+import os
 import subprocess
 import sys
 import sylk.builder as builder
 from sylk.commons import helpers, file_system
 from sylk.commons.pretty import print_error, print_info, print_note
 import pkg_resources
 from grpc_tools import _protoc_compiler
-log = logging.getLogger('sylk.cli.main')
+import sylk_docs
+log = logging.getLogger("sylk.cli.main")
+
 
 @builder.hookimpl
 def pre_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'protos')):
+    if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, "protos")):
         print_info("🔌 Starting sylk build process %s plugin" % (__name__))
     else:
-        file_system.mkdir(file_system.join_path(sylk_json.path, 'protos'))
-    return (__name__,'OK')
+        file_system.mkdir(file_system.join_path(sylk_json.path, "protos"))
+    return (__name__, "OK")
 
 
 @builder.hookimpl
 def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # log.debug("Finished sylk build process %s plugin" % (__name__))
-    return (__name__,'OK')
+    return (__name__, "OK")
+
 
 def run_protoc(command_arguments):
     command_arguments = [argument.encode() for argument in command_arguments]
     return _protoc_compiler.run_main(command_arguments)
 
+
 @builder.hookimpl
-def compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext,pre_data):
-    well_known_protos = pkg_resources.resource_filename('grpc_tools', '_proto')
-    sylk_protos = pkg_resources.resource_filename('sylk', '_proto')
+def compile_protos(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext, pre_data
+):
+    well_known_protos = pkg_resources.resource_filename("grpc_tools", "_proto")
+    sylk_protos = pkg_resources.resource_filename("sylk", "_proto")
     commands = []
-    include_dirs = ['-I{}'.format(well_known_protos),
-        # '-I{}'.format(sylk_json.path+'/protos')
+    include_dirs = [
+        "-I{}".format(well_known_protos),
+        '-I{}'.format(sylk_protos)
     ]
     if pre_data:
         _hook_name = inspect.stack()[0][3]
         for mini_hooks in pre_data:
             for hook in mini_hooks:
-                if __name__ == hook.split(':')[0]:
-                    if hook.split(':')[2] is not None and _hook_name == hook.split(':')[1].replace('()',''):
-                        
-                        if 'include_dirs' in hook.split(':')[2]:
-                            if mini_hooks[hook] is not None and len(mini_hooks[hook]) > 0:
+                if __name__ == hook.split(":")[0]:
+                    if hook.split(":")[2] is not None and _hook_name == hook.split(":")[
+                        1
+                    ].replace("()", ""):
+                        if "include_dirs" in hook.split(":")[2]:
+                            if (
+                                mini_hooks[hook] is not None
+                                and len(mini_hooks[hook]) > 0
+                            ):
                                 for d in mini_hooks[hook]:
-                                    include_dirs.append('-I{}'.format(d))
-                        if 'commands' in hook.split(':')[2]:
-                            if mini_hooks[hook] is not None and len(mini_hooks[hook]) > 0:
+                                    include_dirs.append("-I{}".format(d))
+                        if "commands" in hook.split(":")[2]:
+                            if (
+                                mini_hooks[hook] is not None
+                                and len(mini_hooks[hook]) > 0
+                            ):
                                 # print_error(mini_hooks[hook])
                                 commands = commands + mini_hooks[hook]
 
     proto_files = []
-    for pkg in sylk_json.packages:
-        proto_files.append('/'.join(pkg.split('/')[1:]))
+    files = sylk_json._proto_tree.get_all_file_paths()
+    # for pkg in sylk_json.packages:
+    #     p= sylk_json.packages[pkg]
+    #     msgs = sylk_json.packages[pkg].get('messages') if sylk_json.packages[pkg].get('messages') is not None else []
+    #     svcs = sylk_json.packages[pkg].get('services') if sylk_json.packages[pkg].get('services') is not None else []
+    #     enms = sylk_json.packages[pkg].get('enums') if sylk_json.packages[pkg].get('enums') is not None else []
+    #     tags = [m.get('tag') for m in msgs if m.get('tag') is not None and m.get('tag') != '']
+    #     if len(tags) == 0:
+    #         tags.append(p.get('name'))
+    #     enum_tags = [e.get('tag') for e in enms if e.get('tag') is not None and e.get('tag') != '']
+    #     if len(tags) == 0 and p.get('name') not in tags:
+    #         tags.append(p.get('name'))
+    #     else:
+    #         tags.extend(enum_tags)
+    #     svc_tags = [s.get('tag') for s in svcs if s.get('tag') is not None and s.get('tag') != '']
+    #     if len(svc_tags) == 0 and p.get('name') not in tags:
+    #         tags.append(p.get('name'))
+    #     else:
+    #         tags.extend(svc_tags)
+    #     if len(tags) > 0:
+    #         for t in tags:
+    #             proto_files.append(pkg + '/' + t +'.proto')
+    #     else:
+    #         ver = helpers.parse_version_component(pkg)
+    #         if ver:
+    #             pkg_name = pkg.split('/')[-2].lower()
+    #         else:
+    #             pkg_name = pkg.split('/')[-1].lower()
+    #         proto_files.append(pkg + '/' + pkg_name +'.proto')
     
-    for svc in sylk_json.services:
-        proto_files.append('/'.join(svc.split('/')[1:]))
-
-
     if sylk_json.is_language("python"):
-        protoc_params = [c for c in list(map(lambda f: f if '--python' in f or '--grpc_python_out' in f or '--pyi' in f or '-I' in f or '--proto-path' in f else None,commands)) if c is not None]+ include_dirs + proto_files
-        print_note(protoc_params)
+        protoc_params = (
+            [
+                c
+                for c in list(
+                    map(
+                        lambda f: f
+                        if "--python" in f
+                        or "--grpc_python_out" in f
+                        or "--pyi" in f
+                        or "-I" in f
+                        or "--proto_path" in f
+                        or "--plugin" in f
+                        or "--custom" in f
+                        else None,
+                        commands,
+                    )
+                )
+                if c is not None
+            ]
+            + include_dirs
+            + [f for f in files if 'google/' not in f]
+        )
+        # print_note(protoc_params)
         run_protoc(protoc_params)
+        # protoc_params = ["protoc"] + [
+        #         c
+        #         for c in list(
+        #             map(
+        #                 lambda f: f
+        #                 if "--plugin" in f
+        #                 or "--custom" in f
+        #                 or "--proto_path" in f
+        #                 or "-I" in f
+        #                 else None,
+        #                 commands,
+        #             )
+        #         )
+        #         if c is not None
+        #     ] + include_dirs + [f for f in files if 'google/' not in f]
+        # # print_note(protoc_params)
+        # process = subprocess.Popen(
+        #     protoc_params, stdout=subprocess.PIPE, stderr=subprocess.PIPE
+        # )
+        # _, stderr = process.communicate()
+        # if stderr:
+        #     print_info(stderr.decode("utf-8"))
     else:
-        protoc_params = ['protoc']+ commands +include_dirs+ proto_files
+        protoc_params = ["protoc"] + commands + include_dirs + [f for f in files if 'google/' not in f]
         # print_note(protoc_params)
-        process = subprocess.Popen(protoc_params,
-                    stdout=subprocess.PIPE, 
-                    stderr=subprocess.PIPE)
+        process = subprocess.Popen(
+            protoc_params, stdout=subprocess.PIPE, stderr=subprocess.PIPE
+        )
         _, stderr = process.communicate()
         if stderr:
-            print_info(stderr.decode('utf-8'))
+            print_info(stderr.decode("utf-8"))
 
     if sylk_json.is_language("go"):
-        protoc_params = ['protoc']+ [c for c in list(map(lambda f: f if '--go' in f or '-I' in f or '--proto-path' in f else None,commands)) if c is not None] +include_dirs+ proto_files
-        # print_note(protoc_params)
-        process = subprocess.Popen(protoc_params,
-                    stdout=subprocess.PIPE, 
-                    stderr=subprocess.PIPE)
+        protoc_params = (
+            ["protoc"]
+            + [
+                c
+                for c in list(
+                    map(
+                        lambda f: f
+                        if "--go" in f or "-I" in f or "--proto-path" in f
+                        else None,
+                        commands,
+                    )
+                )
+                if c is not None
+            ]
+            + include_dirs
+            + [f for f in files if 'google/' not in f]
+        )
+        process = subprocess.Popen(
+            protoc_params, stdout=subprocess.PIPE, stderr=subprocess.PIPE
+        )
         _, stderr = process.communicate()
         if stderr:
-            print_info(stderr.decode('utf-8'))
-        
+            print_info(stderr.decode("utf-8"))
+
+
 @builder.hookimpl
 def write_protos(sylk_json: helpers.SylkJson):
-    if sylk_json.services is None:
-        print_error("Not supporting building project without any services",True,'Build process error')
-        exit(1)
-
+    file_system.removeDir(file_system.join_path(sylk_json.path, sylk_json._root_protos if sylk_json._root_protos is not None else '', sylk_json.domain))
     if sylk_json.packages is None:
-        print_error("Not supporting building project without any packages",True,'Build process error')
+        print_error(
+            "Not supporting building project without any packages",
+            True,
+            "Build process error",
+        )
         exit(1)
 
-    for svc in sylk_json.services:
-        if sylk_json.services[svc].get('methods') is None:
-            print_error(f"Cannot build service [{svc}] proto file with 0 methods!")
-            exit(1)
-
-        svc_def = helpers.SylkProto(svc.split('/')[-1].split('.')[0], sylk_json.services[svc].get(
-            'dependencies'), sylk_json.services[svc], description=sylk_json.services[svc].get('description'),extensions=sylk_json.services[svc].get('extensions'),sylk_json=sylk_json)
-        
-        log.debug(f"Writing proto file for service: {svc}")
-        file_system.wFile(file_system.join_path(
-            sylk_json.path, svc), svc_def.__str__(), True,False,True)
-
-    for pkg in sylk_json.packages:
-        pkg_name = sylk_json.packages[pkg].get('name')
-        pkg_full_name = package = sylk_json.packages[pkg].get('package')
-        if sylk_json.packages[pkg].get('messages') is None:
-            print_error(f"Cannot build package [{sylk_json.packages[pkg].get('package')}] proto file with 0 messages!")
-            exit(1)
-        pkg_def = helpers.SylkProto(pkg_name,
-                                  sylk_json.packages[pkg].get('dependencies'),
-                                  package=pkg_full_name,
-                                  messages=sylk_json.packages[pkg].get(
-                                      'messages'),
-                                  enums=sylk_json.packages[pkg].get('enums'),
-                                  extensions=sylk_json.packages[pkg].get('extensions'),
-                                  sylk_json=sylk_json)
-        log.debug(f"Writing proto file for package: {pkg_name}")
-        file_system.wFile(file_system.join_path(
-            sylk_json.path, pkg), pkg_def.__str__(), True,False,True)
+    for p in sylk_json.packages:
+        tmp_pkg = sylk_json.packages[p]
+        pkg = sylk_json.get_package(tmp_pkg.get('package'),False)
+        tags = {}
+        if pkg.services is not None:
+            svcs_tags = [
+                s.tag for s in pkg.services if s.tag != ''
+            ]
+            for t in svcs_tags:
+                if tags.get(t) is None:
+                    tags[t] = []
+                tags[t].extend([
+                    m.full_name for m in pkg.services if m.tag == t
+                ])
+        if pkg.enums is not None:
+            enums_tags = [
+                e.tag for e in pkg.enums if e.tag != ''
+            ]
+            for t in enums_tags:
+                if tags.get(t) is None:
+                    tags[t] = []
+                tags[t].extend([
+                    m.full_name for m in pkg.enums if m.tag == t
+                ])
+        if pkg.messages is not None:
+            messages_tags = [
+                m.tag for m in pkg.messages if m.tag != ''
+            ]
+            for t in messages_tags:
+                if tags.get(t) is None:
+                    tags[t] = []
+                tags[t].extend([
+                    m.full_name for m in pkg.messages if m.tag == t
+                ])
+
+        if len(tags.keys()) > 0:
+            for t in tags:
+                proto = helpers.SylkProtoFile(t,pkg,sylk_json,True)
+                proto._set_file_path()
+                print(proto._file_path)
+                file_system.wFile(
+                    proto._file_path,
+                    proto.to_str(),
+                    True,
+                    False,
+                    True,
+                )
+            if pkg.services is not None:
+                svcs = [
+                    s.full_name for s in pkg.services if s.tag == ''
+                ]
+                
+            if pkg.enums is not None:
+                enums = [
+                    e.full_name for e in pkg.enums if e.tag == ''
+                ]
+                
+            if pkg.messages is not None:
+                msgs = [
+                    m.full_name for m in pkg.messages if m.tag == ''
+                ]
+            
+            if len(enums) > 0 or len(msgs) > 0 or len(svcs) > 0:
+                proto = helpers.SylkProtoFile(pkg.name,pkg,sylk_json)
+                file_system.wFile(
+                    proto._file_path,
+                    proto.to_str(),
+                    True,
+                    False,
+                    True,
+                )
+            
+        else:
+            proto = helpers.SylkProtoFile(pkg.name,pkg,sylk_json)
+            file_system.wFile(
+                proto._file_path,
+                proto.to_str(),
+                True,
+                False,
+                True,
+            )
+
+        #     # print(tags)
+        #     proto = helpers.SylkProto(
+        #         pkg.name,
+        #         imports=pkg.dependencies,
+        #         package=pkg.package,
+        #         services=pkg.services,
+        #         messages=pkg.messages,
+        #         enums=pkg.enums,
+        #         description=pkg.description,
+        #         extensions=pkg.extensions,
+        #         sylk_json=sylk_json,
+        #         tags=tags
+        #     )
+        #     proto.write_files()
+        # else:
+        #     proto = helpers.SylkProto(
+        #         pkg.name,
+        #         imports=pkg.dependencies,
+        #         package=pkg.package,
+        #         services=pkg.services,
+        #         messages=pkg.messages,
+        #         enums=pkg.enums,
+        #         description=pkg.description,
+        #         extensions=pkg.extensions,
+        #         sylk_json=sylk_json,
+        #         tags={}
+        #     )
+        #     proto.write_files()
+    # for svc in sylk_json.services:
+    #     if svc.get("methods") is None:
+    #         print_error(f"Cannot build service [{svc}] proto file with 0 methods!")
+    #         exit(1)
+
+    #     svc_name = svc.get("name")
+    #     svc_pkg_messages = []
+    #     svc_pkg_enums = []
+    #     svc_deps = svc.get("dependencies", [])
+    #     try:
+    #         svc_pkg = sylk_json.get_package(
+    #             svc_name, version=svc.get("fullName").split(".")[-1]
+    #         )
+    #         svc_pkg_messages = sylk_json.packages[svc].get("messages")
+
+    #         svc_pkg_enums = sylk_json.packages[svc].get("enums")
+    #         if svc_pkg.get("dependencies") is not None:
+    #             for d in svc_pkg.get("dependencies"):
+    #                 if d not in svc_deps:
+    #                     svc_deps.append(d)
+
+    #     except Exception:
+    #         pass
+
+    #     svc_def = helpers.SylkProto(
+    #         svc_name,
+    #         imports=svc_deps,
+    #         service=svc,
+    #         package=svc.get("fullName")
+    #         if (len(svc_pkg_messages) > 0 or len(svc_pkg_enums) > 0)
+    #         else None,
+    #         messages=svc_pkg_messages,
+    #         enums=svc_pkg_enums,
+    #         description=svc.get("description"),
+    #         extensions=svc.get("extensions"),
+    #         sylk_json=sylk_json,
+    #     )
+
+    #     log.debug(f"Writing proto file for service: {svc.get('name')}")
+    #     file_system.wFile(
+    #         file_system.join_path(sylk_json.path, svc),
+    #         svc_def.__str__(),
+    #         True,
+    #         False,
+    #         True,
+    #     )
+
+    # for pkg in sylk_json.packages:
+    #     pkg_name = sylk_json.packages[pkg].get("name")
+    #     # Checking if proto file already defined by service with the same name of the package
+    #     svc = sylk_json.get_service(
+    #         pkg_name, version=sylk_json.packages[pkg].get("package").split(".")[-1]
+    #     )
+    #     if svc is None:
+    #         # If no service with the same name then we need to write a standalone proto file for packages
+    #         pkg_full_name = sylk_json.packages[pkg].get("package")
+    #         if sylk_json.packages[pkg].get("messages") is None:
+    #             print_error(
+    #                 f"Cannot build package [{sylk_json.packages[pkg].get('package')}] proto file with 0 messages!"
+    #             )
+    #             exit(1)
+
+    #         pkg_def = helpers.SylkProto(
+    #             pkg_name,
+    #             sylk_json.packages[pkg].get("dependencies"),
+    #             package=pkg_full_name,
+    #             messages=sylk_json.packages[pkg].get("messages"),
+    #             enums=sylk_json.packages[pkg].get("enums"),
+    #             extensions=sylk_json.packages[pkg].get("extensions"),
+    #             sylk_json=sylk_json,
+    #         )
+    #         log.debug(f"Writing proto file for package: {pkg_name}")
+    #         file_system.wFile(
+    #             file_system.join_path(sylk_json.path, pkg),
+    #             pkg_def.__str__(),
+    #             True,
+    #             False,
+    #             True,
+    #         )
```

## sylk/builder/plugins/SylkPyClient.py

```diff
@@ -18,314 +18,495 @@
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import logging
 import subprocess
 import sylk.builder as builder
-from sylk.commons import helpers, file_system, resources,pretty
+from sylk.commons import helpers, file_system, resources, pretty
 from sylk.builder.plugins.static import gitignore_py
 import inspect
 
+
 @builder.hookimpl
 def pre_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     pretty.print_info("🔌 Starting sylk build process %s plugin" % (__name__))
 
 
 @builder.hookimpl
 def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # TODO add postbuild validation of generated code
     # pretty.print_success("Finished sylk build process %s plugin" % (__name__))
-    return (__name__,'OK')
+    for pkg in sylk_json.packages:
+        # pkg_path = '/'.join(pkg.split('/')[:-1])
+        base = f'{sylk_json._root_protos}/' if sylk_json._root_protos != '' else ''
+        target_file = base+"/".join(pkg.split("/"))
+        temp_path = []
+        for d in target_file.split("/"):
+            temp_path.append(d)
+            if (
+                file_system.check_if_dir_exists(
+                    file_system.join_path(
+                        sylk_json.path, "clients", "python", "/".join(temp_path)
+                    )
+                )
+                == False
+            ):
+                file_system.mkdir(
+                    file_system.join_path(
+                        sylk_json.path, "clients", "python", "/".join(temp_path)
+                    )
+                )
+            if (
+                file_system.check_if_file_exists(
+                    file_system.join_path(
+                        sylk_json.path,
+                        "clients",
+                        "python",
+                        "/".join(temp_path),
+                        "__init__.py",
+                    )
+                )
+                == False
+            ):
+                file_system.wFile(
+                    file_system.join_path(
+                        sylk_json.path,
+                        "clients",
+                        "python",
+                        "/".join(temp_path),
+                        "__init__.py",
+                    ),
+                    "",
+                )
+        # name = pkg.split('/')[-1].split('.')[0]
+        # pkg_path = '/'.join(pkg.split('/')[:-1])
+        # if file_system.check_if_file_exists(file_system.join_path(sylk_json.path, 'services', pkg_path,f'{name}_pb2.py')) == False:
+        #     try:
+        #         file_system.copyFile(file_system.join_path(sylk_json.path, 'clients','python', pkg_path,f'{name}_pb2.py'),file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),f'{name}_pb2.py'))
+        #     except Exception as e:
+        #         pass
+        # print(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),'__init__.py'))
+        # file_system.mv(file_system.join_path(sylk_json.path, pkg_path, file),
+        #             file_system.join_path(sylk_json.path, 'services',  target_file, file))
+
+    # for svc in sylk_json.services:
+    #     # svc_path = '/'.join(svc.split('/')[:-1])
+    #     target_file = "/".join(svc.split("/")[:-1])
+    #     temp_path = []
+    #     for d in target_file.split("/"):
+    #         temp_path.append(d)
+    #         if (
+    #             file_system.check_if_dir_exists(
+    #                 file_system.join_path(
+    #                     sylk_json.path, "clients", "python", "/".join(temp_path)
+    #                 )
+    #             )
+    #             == False
+    #         ):
+    #             file_system.mkdir(
+    #                 file_system.join_path(
+    #                     sylk_json.path, "clients", "python", "/".join(temp_path)
+    #                 )
+    #             )
+    #         if (
+    #             file_system.check_if_file_exists(
+    #                 file_system.join_path(
+    #                     sylk_json.path,
+    #                     "clients",
+    #                     "python",
+    #                     "/".join(temp_path),
+    #                     "__init__.py",
+    #                 )
+    #             )
+    #             == False
+    #         ):
+    #             file_system.wFile(
+    #                 file_system.join_path(
+    #                     sylk_json.path,
+    #                     "clients",
+    #                     "python",
+    #                     "/".join(temp_path),
+    #                     "__init__.py",
+    #                 ),
+    #                 "",
+    #             )
+        # name = svc.split('/')[-1].split('.')[0]
+        # svc_path = '/'.join(svc.split('/')[:-1])
+        # if file_system.check_if_file_exists(file_system.join_path(sylk_json.path, 'services', svc_path,f'{name}_pb2.py')) == False:
+        #     try:
+        #         file_system.copyFile(file_system.join_path(sylk_json.path, 'clients','python', svc_path,f'{name}_pb2.py'),file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),f'{name}_pb2.py'))
+        #     except Exception as e:
+        #         pass
+        # print(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),'__init__.py'))
+        # file_system.mv(file_system.join_path(sylk_json.path, svc_path, file),
+        #             file_system.join_path(sylk_json.path, 'services',  target_file, file))
+
+    return (__name__, "OK")
 
 
 @builder.hookimpl
-def init_project_structure(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+def init_project_structure(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext
+):
     directories = [
         # Clients
-        file_system.join_path(sylk_json.path, 'clients', 'python'),
-        file_system.join_path(sylk_json.path, 'clients', 'python', 'protos'),
-
+        file_system.join_path(sylk_json.path, "clients", "python"),
+        file_system.join_path(sylk_json.path, "clients", "python", "protos"),
         # Protos
-        file_system.join_path(sylk_json.path, 'services', 'protos')]
+        file_system.join_path(sylk_json.path, "services", "protos"),
+    ]
 
     for dir in directories:
         file_system.mkdir(dir)
 
     # Init files
     files = [
-        file_system.join_path(sylk_json.path, 'services', '__init__.py'),
-        file_system.join_path(sylk_json.path, 'clients',
-                              'python', '__init__.py'),
-        file_system.join_path(sylk_json.path, 'protos', '__init__.py')]
+        file_system.join_path(sylk_json.path, "services", "__init__.py"),
+        file_system.join_path(sylk_json.path, "clients", "python", "__init__.py"),
+        file_system.join_path(sylk_json.path, "protos", "__init__.py"),
+    ]
     # Bin files
-    if sylk_json.project.get('server').get('language') != 'python':
-        file_system.wFile(file_system.join_path(
-            sylk_json.path, 'bin', 'init-py.sh'), bash_init_script)
-    
+    if sylk_json.project.get("server").get("language") != "python":
+        file_system.wFile(
+            file_system.join_path(sylk_json.path, "bin", "init-py.sh"), bash_init_script
+        )
+
     # .gitignore
-    file_system.wFile(file_system.join_path(sylk_json.path,'.gitignore'),gitignore_py)
+    file_system.wFile(file_system.join_path(sylk_json.path, ".gitignore"), gitignore_py)
     for file in files:
-        file_system.wFile(file, '')
+        file_system.wFile(file, "")
 
     return [directories, files]
 
-@builder.hookimpl
-def pre_compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    if sylk_json.get_server_language() != 'python':
-        pretty.print_info("Running pre compile protos - python")
-        return {
-            'sylk.builder.plugins.SylkProto:compile_protos():commands':[
-                '--proto_path=protos/',
-                '--python_out=./services/protos',
-                '--pyi_out=./services/protos',
-                '--grpc_python_out=./services/protos',
-                '--python_out=./clients/python/protos',
-                '--pyi_out=./clients/python/protos',
-                '--grpc_python_out=./clients/python/protos',
-                '-I./protos/'
-            ],
-            'sylk.builder.plugins.SylkProto:compile_protos():include_dirs':[],
-        }
 
 @builder.hookimpl
-def compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    # Running ./bin/init.sh script for compiling protos
-    for pkg in sylk_json.packages:
-        # pkg_path = '/'.join(pkg.split('/')[:-1])
-        target_file = '/'.join(pkg.split('/')[:-1])
-        temp_path = []
-        for d in target_file.split('/'):
-            temp_path.append(d)
-            if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'clients','python', '/'.join(temp_path))) == False:
-                file_system.mkdir(file_system.join_path(sylk_json.path, 'clients','python', '/'.join(temp_path)))
-            if file_system.check_if_file_exists(file_system.join_path(sylk_json.path, 'clients','python', '/'.join(temp_path),'__init__.py')) == False:
-                file_system.wFile(file_system.join_path(sylk_json.path, 'clients','python', '/'.join(temp_path),'__init__.py'),'')
-                    # print(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),'__init__.py'))
-                # file_system.mv(file_system.join_path(sylk_json.path, pkg_path, file),
-                #             file_system.join_path(sylk_json.path, 'services',  target_file, file))
-
-    for svc in sylk_json.services:
-        # svc_path = '/'.join(svc.split('/')[:-1])
-        target_file = '/'.join(svc.split('/')[:-1])
-        temp_path = []
-        for d in target_file.split('/'):
-            temp_path.append(d)
-            if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'clients', 'python', '/'.join(temp_path))) == False:
-                file_system.mkdir(file_system.join_path(sylk_json.path, 'clients','python', '/'.join(temp_path)))
-            if file_system.check_if_file_exists(file_system.join_path(sylk_json.path, 'clients','python', '/'.join(temp_path),'__init__.py')) == False:
-                file_system.wFile(file_system.join_path(sylk_json.path, 'clients', 'python','/'.join(temp_path),'__init__.py'),'')
-                # print(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),'__init__.py'))
-                # file_system.mv(file_system.join_path(sylk_json.path, svc_path, file),
-                #             file_system.join_path(sylk_json.path, 'services',  target_file, file))
-
-
-    # if sylk_json.project.get('server').get('language') != 'python':
-    #     pretty.print_info("Running ./bin/init-py.sh script for 'protoc' compiler")
-    #     proc = subprocess.run(['bash', file_system.join_path(
-    #         sylk_json.path, 'bin', 'init-py.sh')])
-    #     if proc.returncode != 0:
-    #         pretty.print_error("ERROR occured during building process some more info on specific error can be found above")
-    #         exit(proc.returncode)
-    # # Moving .py files to ./services/protos dir
-    # for file in file_system.walkFiles(file_system.join_path(sylk_json.path, 'protos')):
-    #     if '.py' in file:
-    #         file_system.mv(file_system.join_path(sylk_json.path, 'protos', file),
-    #                        file_system.join_path(sylk_json.path, 'services', 'protos', file))
+def pre_compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+    pretty.print_info("Running pre compile protos - python client")
+    file_system.removeDir(file_system.join_path(sylk_json.path, 'clients', 'python', sylk_json._root_protos, sylk_json.domain))
+    return {
+        "sylk.builder.plugins.SylkProto:compile_protos():commands": [
+            f"--proto_path={sylk_json._root_protos}/",
+            f"--python_out=./clients/python/{sylk_json._root_protos}",
+            f"--pyi_out=./clients/python/{sylk_json._root_protos}",
+            f"--grpc_python_out=./clients/python/{sylk_json._root_protos}",
+            f"-I./{sylk_json._root_protos}/",
+        ],
+        "sylk.builder.plugins.SylkProto:compile_protos():include_dirs": [],
+    }
 
 
 @builder.hookimpl
-def write_clients(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext,pre_data):
+def write_clients(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext, pre_data
+):
     imports = []
     exports = []
     override_stubs = {}
-    before_init = ''
+    before_init = ""
     interceptors = []
     client_options = [
         ("grpc.keepalive_permit_without_calls", 1),
-        ("grpc.keepalive_time_ms",120000),
-        ("grpc.keepalive_timeout_ms",20000),
-        ("grpc.http2.min_time_between_pings_ms",120000),
-        ("grpc.http2.max_pings_without_data",1),
+        ("grpc.keepalive_time_ms", 120000),
+        ("grpc.keepalive_timeout_ms", 20000),
+        ("grpc.http2.min_time_between_pings_ms", 120000),
+        ("grpc.http2.max_pings_without_data", 1),
     ]
     """Parse pre data"""
     if pre_data:
         _hook_name = inspect.stack()[0][3]
         for mini_hooks in pre_data:
             for hook in mini_hooks:
-                if __name__ == hook.split(':')[0]:
-                    if hook.split(':')[2] is not None and _hook_name == hook.split(':')[1].replace('()',''):
-                        
-                         # Append to exports
-                        if 'append_imports' in hook.split(':')[2]:
+                if __name__ == hook.split(":")[0]:
+                    if hook.split(":")[2] is not None and _hook_name == hook.split(":")[
+                        1
+                    ].replace("()", ""):
+                        # Append to exports
+                        if "append_imports" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for imp in mini_hooks[hook]:
                                     imports.append(imp)
 
-    
-                        elif 'append_client_options' in hook.split(':')[2]:
+                        elif "append_client_options" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
-                                for k,v in mini_hooks[hook]:
-                                    old_value = next((i for i in client_options if i[0] == k),(None,None))[1]
-                                    if k not in list(map(lambda x: x[0], client_options)):
-                                        client_options.append((k,v))
+                                for k, v in mini_hooks[hook]:
+                                    old_value = next(
+                                        (i for i in client_options if i[0] == k),
+                                        (None, None),
+                                    )[1]
+                                    if k not in list(
+                                        map(lambda x: x[0], client_options)
+                                    ):
+                                        client_options.append((k, v))
                                     elif v != old_value:
-                                        client_options.remove((k,old_value))
-                                        client_options.append((k,v))
-                                        
-    for f in file_system.walkFiles(file_system.join_path(sylk_json.path, 'services', 'protos')):
-        if '.py' in f:
-            file = file_system.rFile(file_system.join_path(
-                sylk_json.path, 'services', 'protos', f))
-            if '_grpc' not in f:
+                                        client_options.remove((k, old_value))
+                                        client_options.append((k, v))
+
+    for f in file_system.walkFiles(
+        file_system.join_path(sylk_json.path, "services", "protos")
+    ):
+        if ".py" in f:
+            file = file_system.rFile(
+                file_system.join_path(sylk_json.path, "services", "protos", f)
+            )
+            if "_grpc" not in f:
                 index = 13
             else:
                 index = 0
             for l in file[index:]:
-
-                if 'import ' in  l and 'grpc' not in l and 'typing' not in l and 'google.protobuf' not in l:
-                    file[index] = l.replace('import ','from . import ')
+                if (
+                    "import " in l
+                    and "grpc" not in l
+                    and "typing" not in l
+                    and "google.protobuf" not in l
+                ):
+                    file[index] = l.replace("import ", "from . import ")
 
                 index += 1
-            file_system.wFile(file_system.join_path(sylk_json.path, 'clients', 'python', f), ''.join(file),True)
+            file_system.wFile(
+                file_system.join_path(sylk_json.path, "clients", "python", f),
+                "".join(file),
+                True,
+            )
+
+    client = helpers.SylkClientPy(
+        sylk_json.project.get("packageName"),
+        sylk_json.services,
+        sylk_json.packages,
+        sylk_context,
+        pre_data={"imports": imports, "client_options": client_options},
+        sylk_json=sylk_json
+    )
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "clients", "python", "__init__.py"),
+        client.__str__(),
+        overwrite=True,
+    )
 
-    client = helpers.SylkClientPy(sylk_json.project.get(
-        'packageName'), sylk_json.services, sylk_json.packages, sylk_context,pre_data={
-            'imports':imports,
-            'client_options':client_options
-        })
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'clients', 'python', '__init__.py'), client.__str__(), overwrite=True)
 
 @builder.hookimpl
-def override_generated_classes(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    if sylk_json.project.get('server').get('language') != 'python':
-        for f in file_system.walkFiles(file_system.join_path(sylk_json.path, 'services', 'protos')):
-            name = f.split('_pb2')
-            if '_grpc' not in name:
+def override_generated_classes(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext
+):
+    if sylk_json.project.get("server").get("language") != "python":
+        for f in file_system.walkFiles(
+            file_system.join_path(sylk_json.path, "services", "protos")
+        ):
+            name = f.split("_pb2")
+            if "_grpc" not in name:
                 file_content = file_system.rFile(
-                    file_system.join_path(sylk_json.path, 'services', 'protos', f))
+                    file_system.join_path(sylk_json.path, "services", "protos", f)
+                )
                 file_content.insert(
-                    5, '\nfrom typing import overload, Iterator, List, Dict\n')
+                    5, "\nfrom typing import overload, Iterator, List, Dict\n"
+                )
                 if len(name) > 1:
                     name = name[0]
 
                     # svc_proto = next((svc for svc in sylk_json.services if svc == name),None)
-                    pkg_proto = next((pkg for pkg in sylk_json.packages if pkg.split(
-                        '/')[-1].split('.')[0] == name), None)
+                    pkg_proto = next(
+                        (
+                            pkg
+                            for pkg in sylk_json.packages
+                            if pkg.split("/")[-1].split(".")[0] == name
+                        ),
+                        None,
+                    )
                     if pkg_proto is not None:
-                        pkg_proto_name = pkg_proto.split('/')[-1].split('.')[0]
+                        pkg_proto_name = pkg_proto.split("/")[-1].split(".")[0]
 
-                        for m in sylk_json.packages[pkg_proto].get('messages'):
+                        for m in sylk_json.packages[pkg_proto].get("messages"):
                             index = 0
                             for l in file_content:
-                                message_name = m['name']
-                                message_description = m.get('description') if m.get('description') is not None else ''
-                                if f'{message_name} = _reflection' in l[:len(message_name)+15]:
+                                message_name = m["name"]
+                                message_description = (
+                                    m.get("description")
+                                    if m.get("description") is not None
+                                    else ""
+                                )
+                                if (
+                                    f"{message_name} = _reflection"
+                                    in l[: len(message_name) + 15]
+                                ):
                                     temp_fields = []
                                     init_fields = []
                                     docstring_fields = []
                                     # pretty.print_info(init_fields)
-                                    for field in m['fields']:
-
-                                        fName = field['name']
-                                        fDescription = field.get('description') if field.get('description') is not None else ''
-                                        key_type = field.get('keyType').split('_')[-1].lower() if field.get('keyType') is not None and  field.get('keyType') != -1 else None
-                                        value_type = field.get('valueType').split('_')[-1].lower() if field.get('valueType') is not None and field.get('valueType') != -1 else None
-                                        fType = parse_proto_type_to_py(field['fieldType'].split(
-                                                '_')[-1].lower(), field['label'].split('_')[-1].lower(), field.get('messageType'), field.get('enumType'),current_pkg=pkg_proto_name,key_type=key_type,value_type=value_type)
-                                        if field['fieldType'].split(
-                                            '_')[-1].lower() == 'enum':
+                                    for field in m["fields"]:
+                                        fName = field["name"]
+                                        fDescription = (
+                                            field.get("description")
+                                            if field.get("description") is not None
+                                            else ""
+                                        )
+                                        key_type = (
+                                            field.get("keyType").split("_")[-1].lower()
+                                            if field.get("keyType") is not None
+                                            and field.get("keyType") != -1
+                                            else None
+                                        )
+                                        value_type = (
+                                            field.get("valueType")
+                                            .split("_")[-1]
+                                            .lower()
+                                            if field.get("valueType") is not None
+                                            and field.get("valueType") != -1
+                                            else None
+                                        )
+                                        fType = parse_proto_type_to_py(
+                                            field["fieldType"].split("_")[-1].lower(),
+                                            field["label"].split("_")[-1].lower(),
+                                            field.get("messageType"),
+                                            field.get("enumType"),
+                                            current_pkg=pkg_proto_name,
+                                            key_type=key_type,
+                                            value_type=value_type,
+                                        )
+                                        if (
+                                            field["fieldType"].split("_")[-1].lower()
+                                            == "enum"
+                                        ):
                                             temp_fields.append(
-                                                f'{fName} = {fType} # type: int')
-                                        elif field['fieldType'].split(
-                                            '_')[-1].lower() == 'oneof':
-                                            for f_oneof in field.get('oneofFields'):
-                                                fOneofName = f_oneof['name']
-                                                fOneofType = parse_proto_type_to_py(f_oneof['fieldType'].split(
-                                                    '_')[-1].lower(), 'optional', f_oneof.get('messageType'), f_oneof.get('enumType'),current_pkg=pkg_proto_name)
-                                                if f_oneof['fieldType'].split(
-                                                    '_')[-1].lower() == 'enum':
+                                                f"{fName} = {fType} # type: int"
+                                            )
+                                        elif (
+                                            field["fieldType"].split("_")[-1].lower()
+                                            == "oneof"
+                                        ):
+                                            for f_oneof in field.get("oneofFields"):
+                                                fOneofName = f_oneof["name"]
+                                                fOneofType = parse_proto_type_to_py(
+                                                    f_oneof["fieldType"]
+                                                    .split("_")[-1]
+                                                    .lower(),
+                                                    "optional",
+                                                    f_oneof.get("messageType"),
+                                                    f_oneof.get("enumType"),
+                                                    current_pkg=pkg_proto_name,
+                                                )
+                                                if (
+                                                    f_oneof["fieldType"]
+                                                    .split("_")[-1]
+                                                    .lower()
+                                                    == "enum"
+                                                ):
                                                     temp_fields.append(
-                                                        f'{fOneofName} = {fOneofType} # type: int')
+                                                        f"{fOneofName} = {fOneofType} # type: int"
+                                                    )
                                                 else:
                                                     temp_fields.append(
-                                                        f'{fOneofName} = {fOneofType} # type: {fOneofType}')
+                                                        f"{fOneofName} = {fOneofType} # type: {fOneofType}"
+                                                    )
                                         else:
                                             temp_fields.append(
-                                                f'{fName} = {fType} # type: {fType}')
-                                        
-                                        if field.get('fieldType') != 'TYPE_ONEOF':
-                                            init_fields.append(f'{fName}={fType}')
+                                                f"{fName} = {fType} # type: {fType}"
+                                            )
+
+                                        if field.get("fieldType") != "TYPE_ONEOF":
+                                            init_fields.append(f"{fName}={fType}")
                                         else:
-                                            for f_oneof in field.get('oneofFields'):
-                                                fOneofName = f_oneof['name']
-                                                fOneofType = parse_proto_type_to_py(f_oneof['fieldType'].split(
-                                                    '_')[-1].lower(), 'optional', f_oneof.get('messageType'), f_oneof.get('enumType'),current_pkg=pkg_proto_name)
-                                                init_fields.append(f'{fOneofName}={fOneofType}')
-                                        docstring_fields.append(f'{fName} : {fType}\n\t\t\t{fDescription}')
-
-                                    temp_fields = '\n\t'.join(temp_fields)
-                                    init_fields = ', '.join(init_fields)
-                                    docstring = '{0}\n\n\t\tAttributes:\n\t\t----------\n\t\t{1}'.format(message_description,'\n\t\t'.join(docstring_fields))
+                                            for f_oneof in field.get("oneofFields"):
+                                                fOneofName = f_oneof["name"]
+                                                fOneofType = parse_proto_type_to_py(
+                                                    f_oneof["fieldType"]
+                                                    .split("_")[-1]
+                                                    .lower(),
+                                                    "optional",
+                                                    f_oneof.get("messageType"),
+                                                    f_oneof.get("enumType"),
+                                                    current_pkg=pkg_proto_name,
+                                                )
+                                                init_fields.append(
+                                                    f"{fOneofName}={fOneofType}"
+                                                )
+                                        docstring_fields.append(
+                                            f"{fName} : {fType}\n\t\t\t{fDescription}"
+                                        )
+
+                                    temp_fields = "\n\t".join(temp_fields)
+                                    init_fields = ", ".join(init_fields)
+                                    docstring = "{0}\n\n\t\tAttributes:\n\t\t----------\n\t\t{1}".format(
+                                        message_description,
+                                        "\n\t\t".join(docstring_fields),
+                                    )
 
                                     file_content.insert(
-                                        index, f'\n@overload\nclass {message_name}(_message.Message):\n\t"""sylk.build generated message [{sylk_json.domain}.{pkg_proto_name}.v1.{message_name}]\n\tA class respresent a {message_name} type\n\t{message_description}\n\t\t"""\n\t{temp_fields}\n\n\tdef __init__(self, {init_fields}):\n\t\t"""\n\t\t{docstring}\n\t\t"""\n\t\tpass\n')
+                                        index,
+                                        f'\n@overload\nclass {message_name}(_message.Message):\n\t"""sylk.build generated message [{sylk_json.domain}.{pkg_proto_name}.v1.{message_name}]\n\tA class respresent a {message_name} type\n\t{message_description}\n\t\t"""\n\t{temp_fields}\n\n\tdef __init__(self, {init_fields}):\n\t\t"""\n\t\t{docstring}\n\t\t"""\n\t\tpass\n',
+                                    )
                                     break
                                 index += 1
-                        file_system.wFile(file_system.join_path(
-                            sylk_json.path, 'services', 'protos', f), ''.join(file_content), True)
+                        file_system.wFile(
+                            file_system.join_path(
+                                sylk_json.path, "services", "protos", f
+                            ),
+                            "".join(file_content),
+                            True,
+                        )
+
 
 bash_init_script = '#!/bin/bash\n\n\
 declare -a services=("protos")\n\
 echo "[sylk.build] init-py.sh starting protoc compiler"\n\
 DESTDIR="./protos"\n\
 for SERVICE in "${services[@]}"; do\n\
     python3 -m grpc_tools.protoc --proto_path=$SERVICE/ --python_out=$DESTDIR --grpc_python_out=$DESTDIR $SERVICE/*.proto\n\
 done\n\
 statuscode=$?\n\
 echo "Exit code for python protoc -> "$statuscode\n\
 exit 0'
 
-def parse_proto_type_to_py(type, label, messageType=None, enumType=None,current_pkg=None,key_type=None,value_type=None):
-    temp_type = 'None'
-    if 'int' in type:
-        temp_type = 'int'
-    elif type == 'float' or type == 'double':
-        temp_type = 'float'
-    elif type == 'string':
-        temp_type = 'str'
-    elif type == 'byte':
-        temp_type = 'bytes'
-    elif type == 'message':
+
+def parse_proto_type_to_py(
+    type,
+    label,
+    messageType=None,
+    enumType=None,
+    current_pkg=None,
+    key_type=None,
+    value_type=None,
+):
+    temp_type = "None"
+    if "int" in type:
+        temp_type = "int"
+    elif type == "float" or type == "double":
+        temp_type = "float"
+    elif type == "string":
+        temp_type = "str"
+    elif type == "byte":
+        temp_type = "bytes"
+    elif type == "message":
         # pretty.print_info(current_pkg)
-        if messageType.split('.')[1] != current_pkg:
-            if messageType.split('.')[1] == 'protobuf':
-                package_temp_name = messageType.split('.')[-1].lower()
-                msg_temp_name = messageType.split('.')[-1]
-                if messageType.split('.')[-1].lower() == 'value':
-                    package_temp_name = 'struct'
-                temp_type = 'google_dot_protobuf_dot_{0}__pb2.{1}'.format(package_temp_name,msg_temp_name)
+        if messageType.split(".")[1] != current_pkg:
+            if messageType.split(".")[1] == "protobuf":
+                package_temp_name = messageType.split(".")[-1].lower()
+                msg_temp_name = messageType.split(".")[-1]
+                if messageType.split(".")[-1].lower() == "value":
+                    package_temp_name = "struct"
+                temp_type = "google_dot_protobuf_dot_{0}__pb2.{1}".format(
+                    package_temp_name, msg_temp_name
+                )
             else:
-                temp_type = '{0}__pb2.{1}'.format(
-                    messageType.split('.')[1], messageType.split('.')[-1])
+                temp_type = "{0}__pb2.{1}".format(
+                    messageType.split(".")[1], messageType.split(".")[-1]
+                )
         else:
-            temp_type = '{1}'.format(
-                messageType.split('.')[1], messageType.split('.')[-1])
-    elif type == 'enum':
-        if enumType.split('.')[1] != current_pkg:
-            temp_type = '{0}__pb2.{1}'.format(
-                enumType.split('.')[1], enumType.split('.')[-1])
+            temp_type = "{1}".format(
+                messageType.split(".")[1], messageType.split(".")[-1]
+            )
+    elif type == "enum":
+        if enumType.split(".")[1] != current_pkg:
+            temp_type = "{0}__pb2.{1}".format(
+                enumType.split(".")[1], enumType.split(".")[-1]
+            )
         else:
-            temp_type = '{1}'.format(
-                enumType.split('.')[1], enumType.split('.')[-1])
-        temp_type = 'int'
-    elif type == 'bool':
-        temp_type = 'bool'
-    elif type == 'map':
-        temp_type = f'Dict[{parse_proto_type_to_py(key_type,label,messageType,enumType,current_pkg)},{parse_proto_type_to_py(value_type,label,messageType,enumType,current_pkg)}]'
+            temp_type = "{1}".format(enumType.split(".")[1], enumType.split(".")[-1])
+        temp_type = "int"
+    elif type == "bool":
+        temp_type = "bool"
+    elif type == "map":
+        temp_type = f"Dict[{parse_proto_type_to_py(key_type,label,messageType,enumType,current_pkg)},{parse_proto_type_to_py(value_type,label,messageType,enumType,current_pkg)}]"
 
-    if label == 'repeated':
-        temp_type = f'List[{temp_type}]'
+    if label == "repeated":
+        temp_type = f"List[{temp_type}]"
 
     return temp_type
-
```

## sylk/builder/plugins/SylkPyServer.py

```diff
@@ -31,153 +31,254 @@
     pretty.print_info("🔌 Starting sylk build process %s plugin" % (__name__))
 
 
 @builder.hookimpl
 def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # TODO add postbuild validation of generated code
     # pretty.print_success("Finished sylk build process %s plugin" % (__name__))
-    return (__name__,'OK')
+    for pkg in sylk_json.packages:
+        # pkg_path = '/'.join(pkg.split('/')[:-1])
+        base = f'{sylk_json._root_protos}/' if sylk_json._root_protos != '' else ''
+        target_file = base+"/".join(pkg.split("/"))
+        temp_path = []
+
+        for d in target_file.split("/"):
+            temp_path.append(d)
+            if (
+                file_system.check_if_dir_exists(
+                    file_system.join_path(
+                        sylk_json.path, "services", "/".join(temp_path)
+                    )
+                )
+                == False
+            ):
+                file_system.mkdir(
+                    file_system.join_path(
+                        sylk_json.path, "services", "/".join(temp_path)
+                    )
+                )
+            if (
+                file_system.check_if_file_exists(
+                    file_system.join_path(
+                        sylk_json.path, "services", "/".join(temp_path), "__init__.py"
+                    )
+                )
+                == False
+            ):
+                file_system.wFile(
+                    file_system.join_path(
+                        sylk_json.path, "services", "/".join(temp_path), "__init__.py"
+                    ),
+                    "",
+                )
+        name = pkg.split("/")[-1].split(".")[0]
+        pkg_path = "/".join(pkg.split("/")[:-1])
+        # if (
+        #     file_system.check_if_file_exists(
+        #         file_system.join_path(
+        #             sylk_json.path, "services", pkg_path, f"{name}_pb2.py"
+        #         )
+        #     )
+        #     == False
+        # ):
+        #     try:
+        #         file_system.copyFile(
+        #             file_system.join_path(
+        #                 sylk_json.path, "clients", "python", pkg_path, f"{name}_pb2.py"
+        #             ),
+        #             file_system.join_path(
+        #                 sylk_json.path,
+        #                 "services",
+        #                 "/".join(temp_path),
+        #                 f"{name}_pb2.py",
+        #             ),
+        #         )
+        #     except Exception as e:
+        #         pass
+    
+
+    return (__name__, "OK")
 
 
 @builder.hookimpl
-def init_project_structure(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+def init_project_structure(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext
+):
     directories = [
         # Clients
-        file_system.join_path(sylk_json.path, 'clients', 'python'),
+        file_system.join_path(sylk_json.path, "clients", "python"),
         # Protos
-        file_system.join_path(sylk_json.path, 'services', 'protos')]
+        file_system.join_path(sylk_json.path, "services", "protos"),
+    ]
 
     for dir in directories:
         file_system.mkdir(dir)
 
     # Init files
     files = [
-        file_system.join_path(sylk_json.path, 'services', '__init__.py'),
-        file_system.join_path(sylk_json.path, 'clients',
-                              'python', '__init__.py'),
-        file_system.join_path(sylk_json.path, 'protos', '__init__.py')]
+        file_system.join_path(sylk_json.path, "services", "__init__.py"),
+        file_system.join_path(sylk_json.path, "clients", "python", "__init__.py"),
+        file_system.join_path(sylk_json.path, "protos", "__init__.py"),
+    ]
     # Bin files
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'bin', 'init.sh'), bash_init_script)
-    if sylk_json.get_server_language() == 'python':
-        file_system.wFile(file_system.join_path(
-            sylk_json.path, 'bin', 'run-server.sh'), bash_run_server_script)
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "bin", "init.sh"), bash_init_script
+    )
+    if sylk_json.get_server_language() == "python":
+        file_system.wFile(
+            file_system.join_path(sylk_json.path, "bin", "run-server.sh"),
+            bash_run_server_script(sylk_json._root_protos),
+        )
     # file_system.wFile(file_system.join_path(sylk_json.path,'.sylk','contxt.json'),'{"files":[]}')
     # .gitignore
-    file_system.wFile(file_system.join_path(sylk_json.path,'.gitignore'),gitignore_py)
+    file_system.wFile(file_system.join_path(sylk_json.path, ".gitignore"), gitignore_py)
     for file in files:
-        file_system.wFile(file, '')
+        file_system.wFile(file, "")
 
     return [directories, files]
 
 
 @builder.hookimpl
 def write_services(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     for svc in sylk_json.services:
-        service_name = sylk_json.services[svc].get('name')
-        if file_system.check_if_file_exists(file_system.join_path(
-            sylk_json.path, 'services', f'{service_name}.py')) == False:
-            service_code = helpers.SylkServicePy(sylk_json.project.get('packageName'), svc, sylk_json.services[svc].get(
-                'dependencies'), sylk_json.services[svc], context=sylk_context,sylk_json=sylk_json).to_str()
-            file_system.wFile(file_system.join_path(
-                sylk_json.path, 'services', f'{service_name}.py'), service_code, overwrite=True)
+        service_name = svc.get("name")
+        ver = helpers.parse_version_component(svc.get("fullName"))
+        if ver:
+            service_version = svc.get("fullName").split(".")[-2]
+            svc_path = file_system.join_path(
+                    sylk_json.path,
+                    "services",
+                    service_name,
+                    service_version,
+                    f"{service_name}.py",
+                )
+        else:
+            svc_path = file_system.join_path(
+                    sylk_json.path,
+                    "services",
+                    service_name,
+                    f"{service_name}.py",
+                )
+
+        if (
+            file_system.check_if_file_exists(
+                svc_path
+            )
+            == False
+        ):
+            service_code = helpers.SylkServicePy(
+                sylk_json.project.get("packageName"),
+                service_name,
+                svc.get("dependencies"),
+                svc,
+                context=sylk_context,
+                sylk_json=sylk_json,
+            ).to_str()
+            file_system.wFile(
+                file_system.join_path(
+                    sylk_json.path, "services", service_name, "__init__.py"
+                ),
+                "",
+                overwrite=False,
+                force=True,
+            )
+            file_system.wFile(
+                file_system.join_path(
+                    '/'.join(svc_path.split('/')[:-1]),
+                    "__init__.py",
+                ),
+                "",
+                overwrite=False,
+                force=True,
+            )
+            file_system.wFile(
+                svc_path,
+                service_code,
+                overwrite=True,
+                force=True,
+            )
         # else:
         #     pretty.print_info("Make sure you are editing the {0} file\n - See how to edit service written in python".format(file_system.join_path(
         #         sylk_json.path, 'services', f'{svc}.py')))
 
+
 @builder.hookimpl
 def pre_compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    pretty.print_info("Running pre compile protos")
+    pretty.print_info("Running pre compile protos - python server")
+    proto_path = file_system.join_path(sylk_json.path,'services',sylk_json._root_protos, sylk_json.domain)
+    file_system.removeDir(proto_path)
     return {
-        'sylk.builder.plugins.SylkProto:compile_protos():commands':[
-            '--proto_path=protos/',
-            '--python_out=./services/protos',
-            '--pyi_out=./services/protos',
-            '--grpc_python_out=./services/protos',
-            '--python_out=./clients/python/protos',
-            '--pyi_out=./clients/python/protos',
-            '--grpc_python_out=./clients/python/protos',
-            '-I./protos/'
+        "sylk.builder.plugins.SylkProto:compile_protos():commands": [
+            f"--proto_path={sylk_json._root_protos}/",
+            f"--python_out=./services/{sylk_json._root_protos}",
+            f"--pyi_out=./services/{sylk_json._root_protos}",
+            f"--grpc_python_out=./services/{sylk_json._root_protos}",
+            f"-I./{sylk_json._root_protos}/",
         ],
-        'sylk.builder.plugins.SylkProto:compile_protos():include_dirs':[],
+        "sylk.builder.plugins.SylkProto:compile_protos():include_dirs": [],
     }
 
-@builder.hookimpl
-def compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    # Running ./bin/init.sh script for compiling protos
-    # logging.info("Running ./bin/init.sh script for 'protoc' compiler")
-    # subprocess.run(['bash', file_system.join_path(
-    #     sylk_json.path, 'bin', 'init.sh')])
-    # Moving .py files to ./services/protos dir
-    for pkg in sylk_json.packages:
-        # pkg_path = '/'.join(pkg.split('/')[:-1])
-        target_file = '/'.join(pkg.split('/')[:-1])
-        temp_path = []
-        for d in target_file.split('/'):
-            temp_path.append(d)
-            if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path))) == False:
-                file_system.mkdir(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path)))
-            if file_system.check_if_file_exists(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),'__init__.py')) == False:
-                file_system.wFile(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),'__init__.py'),'')
-        name = pkg.split('/')[-1].split('.')[0]
-        pkg_path = '/'.join(pkg.split('/')[:-1])
-        if file_system.check_if_file_exists(file_system.join_path(sylk_json.path, 'services', pkg_path,f'{name}_pb2.py')) == False:
-            try:
-                file_system.copyFile(file_system.join_path(sylk_json.path, 'clients','python', pkg_path,f'{name}_pb2.py'),file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),f'{name}_pb2.py'))
-            except Exception as e:
-                pass
-                    # print(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),'__init__.py'))
-                # file_system.mv(file_system.join_path(sylk_json.path, pkg_path, file),
-                #             file_system.join_path(sylk_json.path, 'services',  target_file, file))
-
-    for svc in sylk_json.services:
-        # svc_path = '/'.join(svc.split('/')[:-1])
-        target_file = '/'.join(svc.split('/')[:-1])
-        temp_path = []
-        for d in target_file.split('/'):
-            temp_path.append(d)
-            if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path))) == False:
-                file_system.mkdir(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path)))
-            if file_system.check_if_file_exists(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),'__init__.py')) == False:
-                file_system.wFile(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),'__init__.py'),'')
-        name = svc.split('/')[-1].split('.')[0]
-        svc_path = '/'.join(svc.split('/')[:-1])
-        if file_system.check_if_file_exists(file_system.join_path(sylk_json.path, 'services', svc_path,f'{name}_pb2.py')) == False:
-            try:
-                file_system.copyFile(file_system.join_path(sylk_json.path, 'clients','python', svc_path,f'{name}_pb2.py'),file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),f'{name}_pb2.py'))
-            except Exception as e:
-                pass
-                # print(file_system.join_path(sylk_json.path, 'services', '/'.join(temp_path),'__init__.py'))
-                # file_system.mv(file_system.join_path(sylk_json.path, svc_path, file),
-                #             file_system.join_path(sylk_json.path, 'services',  target_file, file))
-
-
 
 @builder.hookimpl
-def write_server(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext,pre_data):
+def write_server(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext, pre_data
+):
     # pretty.print_error(pre_data,True,'pre_data')
-    
-    if file_system.check_if_file_exists(file_system.join_path(
-            sylk_json.path, 'server', 'server.py')) == False:
-        imports = ['_ONE_DAY_IN_SECONDS = 60 * 60 * 24',
-                'from concurrent import futures', 'import time', 'import grpc']
+
+    if (
+        file_system.check_if_file_exists(
+            file_system.join_path(sylk_json.path, "server", "server.py")
+        )
+        == False
+    ):
+        imports = [
+            "_ONE_DAY_IN_SECONDS = 60 * 60 * 24",
+            "from concurrent import futures",
+            "import time",
+            "import grpc",
+        ]
         services_bindings = []
         svcs = []
         for svc in sylk_json.services:
-            svc_name = sylk_json.services[svc].get('name')
-            svc_path = '.'.join(svc.split('/')[:-1])
-            svcs.append(svc_name)
-            imports.append(f'from {svc_path} import {svc_name}_pb2_grpc')
+            version = None
+            pkg_path = sylk_json._proto_tree.get_parent(svc.get('fullName')).full_path
+            ver = sylk_json._proto_tree._parse_version_component(pkg_path)
+            base_protos = f'services.{sylk_json._root_protos}' if sylk_json._root_protos is not None and sylk_json._root_protos != '' else 'services'
+            svc_desc_path = f'{base_protos}.{pkg_path}'
+
+            svc_name = svc.get('name')
+            if ver is not None:
+                version = pkg_path.split('.')[-1]
+                svc_impl_path = f'services.{svc_name}.{version}.{svc_name}'
+                svc_desc_module_name = svc.get('tag') if svc.get('tag') is not None else pkg_path.split('.')[-2]
+            else:
+                svc_impl_path = f'services.{svc_name}.{svc_name}'
+                svc_desc_module_name = svc.get('tag') if svc.get('tag') is not None else pkg_path.split('.')[-2]
+
+            # svc_name = sylk_json.services[svc].get("name")
+            svc_ver = version if version is not None else ''
+            svcs.append(
+                (
+                    svc_impl_path,
+                    svc_name,
+                    svc_ver,
+                )
+            )
+            imports.append(
+                f"from {svc_desc_path} import {svc_desc_module_name}_pb2_grpc as {svc_desc_module_name}_{svc_ver}_pb2_grpc"
+            )
             services_bindings.append(
-                f'{svc_name}_pb2_grpc.add_{svc_name}Servicer_to_server({svc_name}.{svc_name}(),server)')
-        svcs = ', '.join(svcs)
-        imports.append(f'import {svcs}')
-        services_bindings = '\n\t'.join(services_bindings)
-        port = sylk_json._config.get('port')
-        imports = '\n'.join(imports)
+                f"{svc_desc_module_name}_{svc_ver}_pb2_grpc.add_{svc_name}Servicer_to_server({svc_name}_{svc_ver}(),server)"
+            )
+        # svcs = ', '.join(svcs)
+        for s in svcs:
+            imports.append(f"from {s[0]} import {s[1]} as {s[1]}_{s[2]}")
+        services_bindings = "\n\t".join(services_bindings)
+        port = sylk_json._config.get("port")
+        imports = "\n".join(imports)
         server_code = f'"""sylk.build Generated Server Code"""\n\
 {imports}\n\n\
 def serve(host="0.0.0.0:{port}"):\n\
 \tserver = grpc.server(futures.ThreadPoolExecutor(max_workers=10))\n\
 \t{services_bindings}\n\
 \tserver.add_insecure_port(host)\n\
 \tserver.start()\n\
@@ -185,84 +286,90 @@
 \ttry:\n\
 \t\twhile True:\n\
 \t\t\ttime.sleep(_ONE_DAY_IN_SECONDS)\n\
 \texcept KeyboardInterrupt:\n\
 \t\tserver.stop(0)\n\n\
 if __name__ == "__main__":\n\
 \tserve()'
-        file_system.wFile(file_system.join_path(
-            sylk_json.path, 'server', 'server.py'), server_code, overwrite=True)
+        file_system.wFile(
+            file_system.join_path(sylk_json.path, "server", "server.py"),
+            server_code,
+            overwrite=True,
+        )
     else:
         pretty.print_info("Make sure you are adding new services into server/server.py")
 
-@builder.hookimpl
-def rebuild_context(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    if sylk_json.services is not None:
-        for svc in sylk_json.services:
-            try:
-                svcFile = file_system.rFile(file_system.join_path(
-                    sylk_json.path, 'services', f'{svc}.py'))
-                is_init = False
-                for l in svcFile:
-                    if '__init__' in l:
-                        is_init = True
-                        break
-                # Non RPC functions should have # @skip line above func name
-                function_code_inlines = helpers.parse_code_file(svcFile, '@skip')
-                # Parse all rpc's in file by default # @rpc seperator
-                rpc_code_inlines = helpers.parse_code_file(svcFile)
-                for f in sylk_context.files:
-
-                    if svc in f.get('file'):
-                        # Iterating all regular functions
-                        for func in function_code_inlines:
-                            func_code = []
-                            for l in func:
-                                if '@rpc @@sylk.build' in l:
-                                    break
-
-                                func_code.append(l)
-
-                            sylk_context.set_method_code(svc, func_code[0].split(
-                                'def ')[1].split('(')[0], ''.join(func_code))
-                        methods_i = 0
-                        for r in sylk_json.services[svc]['methods']:
-                            if next((m for m in f.get('methods') if m['name'] == r['name']),None) is None:
-                                new_rpc_context = {'name': r.get('name'), 'type': 'rpc', 'code': '\t\tpass'}
-                                sylk_context.new_rpc(svc, new_rpc_context)
-                        # Iterating all RPC's functions
-                        for m in f.get('methods'):
-                            if m['type'] == 'rpc':
-                                # Checking if edit to method has happened - meaning canot find in sylk.json all context methods
-                                if next((r for r in sylk_json.services[svc]['methods'] if r['name'] == m['name']), None) == None:
-                                    # Getting method details from sylk.json
-                                    new_method = sylk_json.services[svc]['methods'][methods_i]
-                                    # Building new context with old func code
-                                    new_rpc_context = {'name': new_method.get(
-                                        'name'), 'type': 'rpc', 'code': ''.join(rpc_code_inlines[methods_i][1:])}
-                                    # Editing inplace the RPC context
-                                    sylk_context.edit_rpc(
-                                        svc, m.get('name'), new_rpc_context)
-                                else:
-                                    # Setting new context
-                                    sylk_context.set_rpc_code(svc, m.get('name'), ''.join(
-                                        rpc_code_inlines[methods_i][1:]))
-
-                                methods_i += 1
-
-            except Exception as e:
-                pretty.print_error(e)
-                logging.debug(e)
-    if sylk_context is not None:
-        file_system.wFile(file_system.join_path(
-            sylk_json.path, '.sylk', 'context.json'), sylk_context.dump(), True, True)
+
+# @builder.hookimpl
+# def rebuild_context(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+#     if sylk_json.services is not None:
+#         for svc in sylk_json.services:
+#             try:
+#                 svcFile = file_system.rFile(file_system.join_path(
+#                     sylk_json.path, 'services', f'{svc}.py'))
+#                 is_init = False
+#                 for l in svcFile:
+#                     if '__init__' in l:
+#                         is_init = True
+#                         break
+#                 # Non RPC functions should have # @skip line above func name
+#                 function_code_inlines = helpers.parse_code_file(svcFile, '@skip')
+#                 # Parse all rpc's in file by default # @rpc seperator
+#                 rpc_code_inlines = helpers.parse_code_file(svcFile)
+#                 for f in sylk_context.files:
+
+#                     if svc in f.get('file'):
+#                         # Iterating all regular functions
+#                         for func in function_code_inlines:
+#                             func_code = []
+#                             for l in func:
+#                                 if '@rpc @@sylk.build' in l:
+#                                     break
+
+#                                 func_code.append(l)
+
+#                             sylk_context.set_method_code(svc, func_code[0].split(
+#                                 'def ')[1].split('(')[0], ''.join(func_code))
+#                         methods_i = 0
+#                         for r in sylk_json.services[svc]['methods']:
+#                             if next((m for m in f.get('methods') if m['name'] == r['name']),None) is None:
+#                                 new_rpc_context = {'name': r.get('name'), 'type': 'rpc', 'code': '\t\tpass'}
+#                                 sylk_context.new_rpc(svc, new_rpc_context)
+#                         # Iterating all RPC's functions
+#                         for m in f.get('methods'):
+#                             if m['type'] == 'rpc':
+#                                 # Checking if edit to method has happened - meaning canot find in sylk.json all context methods
+#                                 if next((r for r in sylk_json.services[svc]['methods'] if r['name'] == m['name']), None) == None:
+#                                     # Getting method details from sylk.json
+#                                     new_method = sylk_json.services[svc]['methods'][methods_i]
+#                                     # Building new context with old func code
+#                                     new_rpc_context = {'name': new_method.get(
+#                                         'name'), 'type': 'rpc', 'code': ''.join(rpc_code_inlines[methods_i][1:])}
+#                                     # Editing inplace the RPC context
+#                                     sylk_context.edit_rpc(
+#                                         svc, m.get('name'), new_rpc_context)
+#                                 else:
+#                                     # Setting new context
+#                                     sylk_context.set_rpc_code(svc, m.get('name'), ''.join(
+#                                         rpc_code_inlines[methods_i][1:]))
+
+#                                 methods_i += 1
+
+#             except Exception as e:
+#                 pretty.print_error(e)
+#                 logging.debug(e)
+#     if sylk_context is not None:
+#         file_system.wFile(file_system.join_path(
+#             sylk_json.path, '.sylk', 'context.json'), sylk_context.dump(), True, True)
 
 
 @builder.hookimpl
-def override_generated_classes(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+def override_generated_classes(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext
+):
     pass
     # for f in file_system.walkFiles(file_system.join_path(sylk_json.path, 'services', 'protos')):
     #     name = f.split('_pb2')
     #     if '_grpc' not in name:
     #         file_content = file_system.rFile(
     #             file_system.join_path(sylk_json.path, 'services', 'protos', f))
     #         file_content.insert(
@@ -309,15 +416,15 @@
     #                                                 f'{fOneofName} = {fOneofType} # type: int')
     #                                         else:
     #                                             temp_fields.append(
     #                                                 f'{fOneofName} = {fOneofType} # type: {fOneofType}')
     #                                 else:
     #                                     temp_fields.append(
     #                                         f'{fName} = {fType} # type: {fType}')
-                                    
+
     #                                 if field.get('fieldType') != 'TYPE_ONEOF':
     #                                     init_fields.append(f'{fName}={fType}')
     #                                 else:
     #                                     for f_oneof in field.get('oneofFields'):
     #                                         fOneofName = f_oneof['name']
     #                                         fOneofType = parse_proto_type_to_py(f_oneof['fieldType'].split(
     #                                             '_')[-1].lower(), 'optional', f_oneof.get('messageType'), f_oneof.get('enumType'),current_pkg=pkg_proto_name)
@@ -338,72 +445,89 @@
     #                                 index, f'\n@overload\nclass {message_name}(_message.Message):\n\t"""sylk.build generated message [{sylk_json.domain}.{pkg_proto_name}.v1.{message_name}]\n\tA class respresent a {message_name} type\n\t{message_description}\n\t"""\n\t{temp_fields}\n\n\tdef __init__(self, {init_fields}):\n\t\t"""\n\t\t{docstring}\n\t\t"""\n\t\tpass\n')
     #                             break
     #                         index += 1
     #                 file_system.wFile(file_system.join_path(
     #                     sylk_json.path, 'services', 'protos', f), ''.join(file_content), True)
 
 
-def parse_proto_type_to_py(type, label, messageType=None, enumType=None,current_pkg=None,key_type=None,value_type=None):
-    temp_type = 'None'
-    if 'int' in type:
-        temp_type = 'int'
-    elif type == 'float' or type == 'double':
-        temp_type = 'float'
-    elif type == 'string':
-        temp_type = 'str'
-    elif type == 'byte':
-        temp_type = 'bytes'
-    elif type == 'message':
+def parse_proto_type_to_py(
+    type,
+    label,
+    messageType=None,
+    enumType=None,
+    current_pkg=None,
+    key_type=None,
+    value_type=None,
+):
+    temp_type = "None"
+    if "int" in type:
+        temp_type = "int"
+    elif type == "float" or type == "double":
+        temp_type = "float"
+    elif type == "string":
+        temp_type = "str"
+    elif type == "byte":
+        temp_type = "bytes"
+    elif type == "message":
         # pretty.print_info(current_pkg)
-        if messageType.split('.')[1] != current_pkg:
-            if messageType.split('.')[1] == 'protobuf':
-                package_temp_name = messageType.split('.')[-1].lower()
-                msg_temp_name = messageType.split('.')[-1]
-                if messageType.split('.')[-1].lower() == 'value':
-                    package_temp_name = 'struct'
-                temp_type = 'google_dot_protobuf_dot_{0}__pb2.{1}'.format(package_temp_name,msg_temp_name)
+        if messageType.split(".")[1] != current_pkg:
+            if messageType.split(".")[1] == "protobuf":
+                package_temp_name = messageType.split(".")[-1].lower()
+                msg_temp_name = messageType.split(".")[-1]
+                if messageType.split(".")[-1].lower() == "value":
+                    package_temp_name = "struct"
+                temp_type = "google_dot_protobuf_dot_{0}__pb2.{1}".format(
+                    package_temp_name, msg_temp_name
+                )
             else:
-                temp_type = '{0}__pb2.{1}'.format(
-                    messageType.split('.')[1], messageType.split('.')[-1])
+                temp_type = "{0}__pb2.{1}".format(
+                    messageType.split(".")[1], messageType.split(".")[-1]
+                )
         else:
-            temp_type = '{1}'.format(
-                messageType.split('.')[1], messageType.split('.')[-1])
-    elif type == 'enum':
-        if enumType.split('.')[1] != current_pkg:
-            temp_type = '{0}__pb2.{1}'.format(
-                enumType.split('.')[1], enumType.split('.')[-1])
+            temp_type = "{1}".format(
+                messageType.split(".")[1], messageType.split(".")[-1]
+            )
+    elif type == "enum":
+        if enumType.split(".")[1] != current_pkg:
+            temp_type = "{0}__pb2.{1}".format(
+                enumType.split(".")[1], enumType.split(".")[-1]
+            )
         else:
-            temp_type = '{1}'.format(
-                enumType.split('.')[1], enumType.split('.')[-1])
-        temp_type = 'int'
-    elif type == 'bool':
-        temp_type = 'bool'
-    elif type == 'map':
-        temp_type = f'Dict[{parse_proto_type_to_py(key_type,label,messageType,enumType,current_pkg)},{parse_proto_type_to_py(value_type,label,messageType,enumType,current_pkg)}]'
-    
-    if label == 'repeated':
-        temp_type = f'List[{temp_type}]'
+            temp_type = "{1}".format(enumType.split(".")[1], enumType.split(".")[-1])
+        temp_type = "int"
+    elif type == "bool":
+        temp_type = "bool"
+    elif type == "map":
+        temp_type = f"Dict[{parse_proto_type_to_py(key_type,label,messageType,enumType,current_pkg)},{parse_proto_type_to_py(value_type,label,messageType,enumType,current_pkg)}]"
 
-    return temp_type
+    if label == "repeated":
+        temp_type = f"List[{temp_type}]"
 
+    return temp_type
 
 
 bash_init_script = '#!/bin/bash\n\n\
 declare -a services=("protos")\n\
 echo "[sylk.build] init.sh starting protoc compiler"\n\
 DESTDIR="./protos"\n\
 for SERVICE in "${services[@]}"; do\n\
     python3 -m grpc_tools.protoc --proto_path=$SERVICE/ --python_out=$DESTDIR --grpc_python_out=$DESTDIR $SERVICE/*.proto\n\
 done\n\
 statuscode=$?\n\
 echo "Exit code for protoc -> "$statuscode\n\
 [[ "$statuscode" != "0" ]] && { echo "Some error occured during init script"; exit 1; }\n\
 exit 0'
 
-bash_run_server_script = '#!/bin/bash\n\n\
+def bash_run_server_script(root):
+    pythonpath = f'./services:./:./services/{root}'
+    return f'#!/bin/bash\n\n\
 if [[ $1 == "debug" ]]\n\
 then\n\
 \techo "Debug Mode: $1"\n\
-GRPC_VERBOSITY=DEBUG GRPC_TRACE=all PYTHONPATH=./services/protos:./services python3 server/server.py\n\
+\tGRPC_VERBOSITY=DEBUG GRPC_TRACE=all PYTHONPATH={pythonpath} python3 server/server.py\n\
+elif [[ $1 == "info" ]]\n\
+then\n\
+\techo "Info Mode: $1"\n\
+\tGRPC_VERBOSITY=INFO GRPC_TRACE=all PYTHONPATH={pythonpath} python3 server/server.py\n\
 else\n\
-\tPYTHONPATH=./services/protos:./services python3 server/server.py\n\
+\tPYTHONPATH={pythonpath} python3 server/server.py\n\
 fi'
```

## sylk/builder/plugins/SylkReadme.py

```diff
@@ -16,129 +16,165 @@
 # MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 from sylk import builder
-from sylk.commons import helpers, file_system,pretty
+from sylk.commons import helpers, file_system, pretty
 import logging
 
 
 @builder.hookimpl
 def pre_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     pretty.print_info("🔌 Starting sylk build process %s plugin" % (__name__))
 
 
 @builder.hookimpl
 def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # pretty.print_success("Finished sylk build process %s plugin" % (__name__))
-    return (__name__,'OK')
+    return (__name__, "OK")
 
 
 @builder.hookimpl
 def write_readme(sylk_json: helpers.SylkJson):
-    file_path = 'README.md' 
-    if sylk_json._config.get('docs') is not None:
-        alt_path = sylk_json._config.get('docs').get('file')
+    file_path = "README.md"
+    if sylk_json._config.get("docs") is not None:
+        alt_path = sylk_json._config.get("docs").get("file")
         file_path = file_path if alt_path is None else alt_path
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, file_path), get_readme(sylk_json), overwrite=True)
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, file_path),
+        get_readme(sylk_json),
+        overwrite=True,
+    )
+
+
+_OPEN_BRCK = "{"
+_CLOSING_BRCK = "}"
 
-_OPEN_BRCK = '{'
-_CLOSING_BRCK = '}'
 
 def get_readme(sylk_json: helpers.SylkJson):
-    project_name = sylk_json.project.get('name')
-    index = {'services':[],'packages':[]}
-    project_package_name = sylk_json.project.get('packageName')
+    project_name = sylk_json.project.get("name")
+    index = {"services": [], "packages": []}
+    project_package_name = sylk_json.project.get("packageName")
 
     svcs = []
-    for svc in sylk_json.services:
-        service = sylk_json.services[svc]
+    for service in sylk_json.services:
         rpcs = []
-        index['services'].append(service.get('name'))
-        for rpc in service['methods']:
-            rpc_name = rpc['name']
-            type = 'Unary'
+        index["services"].append(service.get("name"))
+        for rpc in service["methods"]:
+            rpc_name = rpc["name"]
+            type = "Unary"
             _client_stream = False
             _server_stream = False
-            if rpc.get('clientStreaming'):
+            if rpc.get("clientStreaming"):
                 _client_stream = True
-            if rpc.get('serverStreaming'):
+            if rpc.get("serverStreaming"):
                 _server_stream = True
             if _client_stream and _server_stream:
-                type = 'Bidi stream'
+                type = "Bidi stream"
             elif _client_stream and _server_stream == False:
-                type = 'Client stream'
+                type = "Client stream"
             elif _client_stream == False and _server_stream:
-                type = 'Server stream'
-            in_type = rpc.get('inputType')
-            out_type = rpc.get('outputType')
-            in_type_name = in_type.split('.')[-1].lower()
-            out_type_name = out_type.split('.')[-1].lower()
-
-            rpcs.append(f'__`{rpc_name}`__ [{type}]\n- Input: [{in_type}](#{in_type_name})\n- Output: [{out_type}](#{out_type_name})')
-
-        rpcs = '\n\n'.join(rpcs)
-        svcs.append(f'## {svc}\n\n{rpcs}')
-    
+                type = "Server stream"
+            in_type = rpc.get("inputType")
+            out_type = rpc.get("outputType")
+            in_type_name = in_type.split(".")[-1].lower()
+            out_type_name = out_type.split(".")[-1].lower()
+
+            rpcs.append(
+                f"__`{rpc_name}`__ [{type}]\n- Input: [{in_type}](#{in_type_name})\n- Output: [{out_type}](#{out_type_name})"
+            )
+
+        rpcs = "\n\n".join(rpcs)
+        svcs.append(f"## {service.get('name')}\n\n{rpcs}")
+
     pkgs = []
     for pkg in sylk_json.packages:
         package = sylk_json.packages[pkg]
-        package_name = package['package']
+        package_name = package["package"]
         msgs = []
-        index['packages'].append(package_name)
-        for msg in package['messages']:
-            msg_name = msg['name']
+        index["packages"].append(package_name)
+        for msg in package.get("messages",[]):
+            msg_name = msg["name"]
             fields = []
-            for f in msg['fields']:
-                field_name = f['name']
-                f_type = f['fieldType']
-                f_type = '[{0}](#{0})'.format(f['messageType'].split('.')[-1]) if f['fieldType'] == 'TYPE_MESSAGE' else f_type
-                f_type = '[{0}](#{0})'.format(f['enumType'].split('.')[-1]) if f['fieldType'] == 'TYPE_ENUM' else f_type
-                f_desc = '' if f.get('description') is None else f.get('description')
-                fields.append(f'* __{field_name}__ [{f_type}]\n{f_desc}\n')
-            fields = '\n'.join(fields)
-            msg_desc = '' if msg.get('description') is None else '{0}\n'.format(msg.get('description')) 
-            msgs.append(f'\n<details id="#{msg_name}">\n<summary><b>{msg_name}</b></summary>\n\n### __{msg_name}__\n: {msg_desc}\n{fields}</details>')
-        msgs = '\n\n'.join(msgs)
-        pkgs.append(f'## `{package_name}`\n\n{msgs}')
-    
-    pkgs = '\n\n'.join(pkgs)
-    svcs = '\n\n'.join(svcs)
+            for f in msg["fields"]:
+                field_name = f["name"]
+                f_type = f["fieldType"]
+                f_type = (
+                    "[{0}](#{0})".format(f["messageType"].split(".")[-1])
+                    if f["fieldType"] == "TYPE_MESSAGE"
+                    else f_type
+                )
+                f_type = (
+                    "[{0}](#{0})".format(f["enumType"].split(".")[-1])
+                    if f["fieldType"] == "TYPE_ENUM"
+                    else f_type
+                )
+                f_desc = "" if f.get("description") is None else f.get("description")
+                fields.append(f"* __{field_name}__ [{f_type}]\n{f_desc}\n")
+            fields = "\n".join(fields)
+            msg_desc = (
+                ""
+                if msg.get("description") is None
+                else "{0}\n".format(msg.get("description"))
+            )
+            msgs.append(
+                f'\n<details id="#{msg_name}">\n<summary><b>{msg_name}</b></summary>\n\n### __{msg_name}__\n: {msg_desc}\n{fields}</details>'
+            )
+        msgs = "\n\n".join(msgs)
+        pkgs.append(f"## `{package_name}`\n\n{msgs}")
+
+    pkgs = "\n\n".join(pkgs)
+    svcs = "\n\n".join(svcs)
     clients_usage_i = []
     clients_usage = []
-    for c in sylk_json.project.get('clients'):
-        client_lang = c.get('language')
-        client_lang = client_lang[0].upper()+client_lang[1:]
-        clients_usage_i.append(f'- [{client_lang}](#{client_lang.lower()})')
-        if client_lang=='Python':
-            clients_usage.append(f'### Python\n\n```py\nfrom clients.python import {project_package_name}\n\nclient = {project_package_name}()\n\n# Unary call\nresponse = stub.<Unary>(<InMessage>())\nprint(response)\n\n# Server stream\nresponses = stub.<ServerStream>(<InMessage>())\nfor res in responses:\n\tprint(res)\n\n# Client Stream\nrequests = iter([<InMessage>(),<InMessage>()])\nresponse = client.<ClientStream>(requests)\nprint(response)\n\n# Bidi Stream\nresponses = client.<BidiStream>(requests)\nfor res in responses:\n\tprint(res)\n```\n')
-        elif client_lang=='Typescript':
-            clients_usage.append(f'### Typescript\n\n```ts\nimport {_OPEN_BRCK} {project_package_name} {_CLOSING_BRCK} from \'./clients/typescript/\';\n\nlet client = new {project_package_name}();\n\n// Unary call\nclient.<Unary>(<InMessage>)\n\t.then((res:<OutMessage>) => {_OPEN_BRCK}\n\t\tconsole.log(res);\n\t{_CLOSING_BRCK}).catch((err: any) => console.log(err));\n\n// Server Stream\nclient.<ServerStream>(<InMessage>)\n\t.subscribe((res: <OutMessage>) => {_OPEN_BRCK}\n\t\tconsole.log(res);\n\t{_CLOSING_BRCK})\n\n// Client Stream\n\n// Bidi Stream\nresponses = client.<BidiStream>()\n\t.subscribe((res: <OutMessage>) => {_OPEN_BRCK}\n\t\tconsole.log(res)\n\t{_CLOSING_BRCK})\n\nresponses.write(<InMessage>)\n```\n')
-        elif client_lang=='Go':
-            go_package_name = sylk_json.project.get('goPackage')
-            clients_usage.append(f'### Go\n\n```go\npackage main\nimport (\n\t"fmt"\n\n\tclient "{go_package_name}/clients/go"\n)\n\nfunc main() {_OPEN_BRCK}\n\t//Init the client\n\tc := client.Default()\n\n\t// Construct a message\n\tmsg :=  <SomePackage>.<SomeMessage>{_OPEN_BRCK}{_CLOSING_BRCK}\n\n\t// Send unary\n\tres := c.<SomeRpc>(&msg)\n\tfm.tPrintf("Got server unary response: %v",res)\n\n\t// Client Stream\n\tListMessages := []*<Package>.<Message>{_OPEN_BRCK}\n\t\t{_OPEN_BRCK}{_CLOSING_BRCK},\n\t{_CLOSING_BRCK}\n\tclientStream := c.<ClientStreamingRPC>(ListMessages)\n\tfmt.Printf("Got response for client stream: %v", clientStream)\n\n\t// Server stream\n\tresponse_stream := c.<SomeServerStreamRPC>(&msg)\n\tfmt.Prontf("Got server stream response: %v", response_stream)\n\n{_CLOSING_BRCK}\n```\n')
+    for c in sylk_json.project.get("clients"):
+        client_lang = c.get("language")
+        client_lang = client_lang[0].upper() + client_lang[1:]
+        clients_usage_i.append(f"- [{client_lang}](#{client_lang.lower()})")
+        if client_lang == "Python":
+            clients_usage.append(
+                f"### Python\n\n```py\nfrom clients.python import {project_package_name}\n\nclient = {project_package_name}()\n\n# Unary call\nresponse = stub.<Unary>(<InMessage>())\nprint(response)\n\n# Server stream\nresponses = stub.<ServerStream>(<InMessage>())\nfor res in responses:\n\tprint(res)\n\n# Client Stream\nrequests = iter([<InMessage>(),<InMessage>()])\nresponse = client.<ClientStream>(requests)\nprint(response)\n\n# Bidi Stream\nresponses = client.<BidiStream>(requests)\nfor res in responses:\n\tprint(res)\n```\n"
+            )
+        elif client_lang == "Typescript":
+            clients_usage.append(
+                f"### Typescript\n\n```ts\nimport {_OPEN_BRCK} {project_package_name} {_CLOSING_BRCK} from './clients/typescript/';\n\nlet client = new {project_package_name}();\n\n// Unary call\nclient.<Unary>(<InMessage>)\n\t.then((res:<OutMessage>) => {_OPEN_BRCK}\n\t\tconsole.log(res);\n\t{_CLOSING_BRCK}).catch((err: any) => console.log(err));\n\n// Server Stream\nclient.<ServerStream>(<InMessage>)\n\t.subscribe((res: <OutMessage>) => {_OPEN_BRCK}\n\t\tconsole.log(res);\n\t{_CLOSING_BRCK})\n\n// Client Stream\n\n// Bidi Stream\nresponses = client.<BidiStream>()\n\t.subscribe((res: <OutMessage>) => {_OPEN_BRCK}\n\t\tconsole.log(res)\n\t{_CLOSING_BRCK})\n\nresponses.write(<InMessage>)\n```\n"
+            )
+        elif client_lang == "Go":
+            go_package_name = sylk_json.project.get("goPackage")
+            clients_usage.append(
+                f'### Go\n\n```go\npackage main\nimport (\n\t"fmt"\n\n\tclient "{go_package_name}/clients/go/<path-to-service>"\n)\n\nfunc main() {_OPEN_BRCK}\n\t//Init the client\n\tc := client.Default()\n\n\t// Construct a message\n\tmsg :=  <SomePackage>.<SomeMessage>{_OPEN_BRCK}{_CLOSING_BRCK}\n\n\t// Send unary\n\tres, _, _ := c.<SomeRpc>(&msg)\n\tfmt.Printf("Got server unary response: %v",res)\n\n\t// Client Stream\n\tListMessages := []*<Package>.<Message>{_OPEN_BRCK}\n\t\t{_OPEN_BRCK}{_CLOSING_BRCK},\n\t{_CLOSING_BRCK}\n\tclientStream := c.<ClientStreamingRPC>(ListMessages)\n\tfmt.Printf("Got response for client stream: %v", clientStream)\n\n\t// Server stream\n\tresponse_stream := c.<SomeServerStreamRPC>(&msg)\n\tfmt.Printf("Got server stream response: %v", response_stream)\n\n{_CLOSING_BRCK}\n```\n'
+            )
     temp_index = []
     for k in index:
         for i in index[k]:
             temp_i = i
             link = i
-            if len(i.split('.')) > 1:
-                temp_i = i.split('.')[1]
-            temp_index.append(f'- [{temp_i}](#{temp_i.lower()})')
-    index = '\n'.join(temp_index)
-    clients_usage = '\n'.join(clients_usage)
-    clients_usage_i = '\n'.join(clients_usage_i)
-    extra_links = sylk_json._config.get('docs')
-    temp_links = ''
+            if len(i.split(".")) > 1:
+                temp_i = i.split(".")[1]
+            temp_index.append(f"- [{temp_i}](#{temp_i.lower()})")
+    index = "\n".join(temp_index)
+    clients_usage = "\n".join(clients_usage)
+    clients_usage_i = "\n".join(clients_usage_i)
+    extra_links = sylk_json._config.get("docs")
+    temp_links = ""
     if extra_links is not None:
         for k in extra_links:
-            if file_system.check_if_file_exists(sylk_json.project.get('uri')+''+ extra_links[k]):
-                temp_links += '{2}\n[{0}]({1})'.format(k,extra_links[k],temp_links)
-            else :
-                pretty.print_error("Extra docs file is not found ! [{0}]({1})".format(k,extra_links[k]))
-    temp_links = '\n### Further Reading\n{0}'.format(temp_links) if extra_links is not None else ''
+            if file_system.check_if_file_exists(
+                sylk_json.project.get("uri") + "" + extra_links[k]
+            ):
+                temp_links += "{2}\n[{0}]({1})".format(k, extra_links[k], temp_links)
+            else:
+                pretty.print_error(
+                    "Extra docs file is not found ! [{0}]({1})".format(
+                        k, extra_links[k]
+                    )
+                )
+    temp_links = (
+        "\n### Further Reading\n{0}".format(temp_links)
+        if extra_links is not None
+        else ""
+    )
 
-    readme_file = f'# {project_name}\n\nThis project has been generated thanks to [```sylk.build```](https://www.sylk.build) !\n\nThis project is using gRPC as main code generator and utilize HTTP2 + protobuf protocols for communication.\n\n# Index\nUsage:\n{clients_usage_i}\n\nResources:\n{index}\n\n# Services\n\n{svcs}\n\n# Packages\n\n{pkgs}\n\n\n# Usage\n\nThis project supports clients communication in the following languages:\n\n{clients_usage}\n{temp_links}\n* * *\n__This project and README file has been created thanks to [sylk.build](https://www.sylk.build)__'
+    readme_file = f"# {project_name}\n\nThis project has been generated thanks to [```sylk.build```](https://www.sylk.build) !\n\nThis project is using gRPC as main code generator and utilize HTTP2 + protobuf protocols for communication.\n\n# Index\nUsage:\n{clients_usage_i}\n\nResources:\n{index}\n\n# Services\n\n{svcs}\n\n# Packages\n\n{pkgs}\n\n\n# Usage\n\nThis project supports clients communication in the following languages:\n\n{clients_usage}\n{temp_links}\n* * *\n__This project and README file has been created thanks to [sylk.build](https://www.sylk.build)__"
     return readme_file
```

## sylk/builder/plugins/SylkTsClient.py

```diff
@@ -19,172 +19,290 @@
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import logging
 import subprocess
 import sylk.builder as builder
 from sylk.commons import helpers, file_system, resources, pretty
-from sylk.builder.plugins.static import gitignore_ts,package_json,bash_init_script_ts,protos_compile_script_ts,main_ts_config_client_only,protos_ts_config_client_only
+from sylk.builder.plugins.static import (
+    gitignore_ts,
+    package_json,
+    bash_init_script_ts,
+    protos_compile_script_ts,
+    main_ts_config_client_only,
+    protos_ts_config_client_only,
+)
 import inspect
 
+
 @builder.hookimpl
 def pre_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     pretty.print_info("🔌 Starting sylk build process %s plugin" % (__name__))
 
 
 @builder.hookimpl
 def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
-    if file_system.check_if_file_exists(file_system.join_path(sylk_json.path,'server', 'services','index.js')):
-        file_system.copyFile(file_system.join_path(sylk_json.path,'server','services','index.d.ts'),file_system.join_path(sylk_json.path,'clients','typescript','index.d.ts'))
-        file_system.copyFile(file_system.join_path(sylk_json.path,'server','services','index.js'),file_system.join_path(sylk_json.path,'clients','typescript','index.js'))
-        file_system.copyFile(file_system.join_path(sylk_json.path,'server','services','index.js.map'),file_system.join_path(sylk_json.path,'clients','typescript','index.js.map'))
+    if file_system.check_if_file_exists(
+        file_system.join_path(sylk_json.path, "server", "services", "index.js")
+    ):
+        file_system.copyFile(
+            file_system.join_path(sylk_json.path, "server", "services", "index.d.ts"),
+            file_system.join_path(
+                sylk_json.path, "clients", "typescript", "index.d.ts"
+            ),
+        )
+        file_system.copyFile(
+            file_system.join_path(sylk_json.path, "server", "services", "index.js"),
+            file_system.join_path(sylk_json.path, "clients", "typescript", "index.js"),
+        )
+        file_system.copyFile(
+            file_system.join_path(sylk_json.path, "server", "services", "index.js.map"),
+            file_system.join_path(
+                sylk_json.path, "clients", "typescript", "index.js.map"
+            ),
+        )
     else:
-        subprocess.run(['tsc', '-b'])
-        if file_system.check_if_file_exists(file_system.join_path(sylk_json.path,'server', 'services','index.js')):
-            file_system.copyFile(file_system.join_path(sylk_json.path,'server','services','index.d.ts'),file_system.join_path(sylk_json.path,'clients','typescript','index.d.ts'))
-            file_system.copyFile(file_system.join_path(sylk_json.path,'server','services','index.js'),file_system.join_path(sylk_json.path,'clients','typescript','index.js'))
-            file_system.copyFile(file_system.join_path(sylk_json.path,'server','services','index.js.map'),file_system.join_path(sylk_json.path,'clients','typescript','index.js.map'))
-    
-    if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path,'clients', 'typescript','utils')) == False:
-        file_system.mkdir(file_system.join_path(sylk_json.path,'clients', 'typescript','utils'))
-
-    file_system.cpDir(file_system.join_path(sylk_json.path,'server','services','utils'),file_system.join_path(sylk_json.path,'clients','typescript','utils'))
+        subprocess.run(["tsc", "-b"])
+        if file_system.check_if_file_exists(
+            file_system.join_path(sylk_json.path, "server", "services", "index.js")
+        ):
+            file_system.copyFile(
+                file_system.join_path(
+                    sylk_json.path, "server", "services", "index.d.ts"
+                ),
+                file_system.join_path(
+                    sylk_json.path, "clients", "typescript", "index.d.ts"
+                ),
+            )
+            file_system.copyFile(
+                file_system.join_path(sylk_json.path, "server", "services", "index.js"),
+                file_system.join_path(
+                    sylk_json.path, "clients", "typescript", "index.js"
+                ),
+            )
+            file_system.copyFile(
+                file_system.join_path(
+                    sylk_json.path, "server", "services", "index.js.map"
+                ),
+                file_system.join_path(
+                    sylk_json.path, "clients", "typescript", "index.js.map"
+                ),
+            )
+
+    if (
+        file_system.check_if_dir_exists(
+            file_system.join_path(sylk_json.path, "clients", "typescript", "utils")
+        )
+        == False
+    ):
+        file_system.mkdir(
+            file_system.join_path(sylk_json.path, "clients", "typescript", "utils")
+        )
+
+    file_system.cpDir(
+        file_system.join_path(sylk_json.path, "server", "services", "utils"),
+        file_system.join_path(sylk_json.path, "clients", "typescript", "utils"),
+    )
 
     # file_system.cpDir(file_system.join_path(sylk_json.path,'server','services','p'),file_system.join_path(sylk_json.path,'clients','typescript','index.js.map'))
-    
+
     # pretty.print_success("Finished sylk build process %s plugin" % (__name__))
-    return (__name__,'OK')
+    return (__name__, "OK")
 
 
 @builder.hookimpl
-def init_project_structure(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+def init_project_structure(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext
+):
     directories = [
         # Clients
-        file_system.join_path(sylk_json.path, 'clients', 'typescript'),
-        file_system.join_path(sylk_json.path, 'clients', 'typescript','protos'),
+        file_system.join_path(sylk_json.path, "clients", "typescript"),
+        file_system.join_path(sylk_json.path, "clients", "typescript", "protos"),
         # Utils
-        file_system.join_path(sylk_json.path, 'services', 'utils'),
+        file_system.join_path(sylk_json.path, "services", "utils"),
         # Protos
-        file_system.join_path(sylk_json.path, 'services', 'protos')]
+        file_system.join_path(sylk_json.path, "services", "protos"),
+    ]
 
     for dir in directories:
         file_system.mkdir(dir)
     # package.json
-    if sylk_json.get_server_language() != 'typescript':
-        pretty.print_info('Removing rimraf server dir')
-        tmp_pkg_json = package_json.replace('rimraf server &&','')
+    if sylk_json.get_server_language() != "typescript":
+        pretty.print_info("Removing rimraf server dir")
+        tmp_pkg_json = package_json.replace("rimraf server &&", "")
     else:
         tmp_pkg_json = package_json
-    file_system.wFile(file_system.join_path(sylk_json.path,'package.json'),tmp_pkg_json.replace('REPLACEME',sylk_json.project.get('packageName')))
-    
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "package.json"),
+        tmp_pkg_json.replace("REPLACEME", sylk_json.project.get("packageName")),
+    )
+
     # Bin files
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'bin', 'init-ts.sh'), bash_init_script_ts)
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'bin', 'proto.js'), protos_compile_script_ts)
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "bin", "init-ts.sh"), bash_init_script_ts
+    )
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "bin", "proto.js"),
+        protos_compile_script_ts,
+    )
 
     # tsconfig.json
-    if sylk_json.get_server_language() != 'typescript':
-        file_system.wFile(file_system.join_path(sylk_json.path, 'tsconfig.json'),main_ts_config_client_only)
-        file_system.wFile(file_system.join_path(sylk_json.path, 'services', 'protos', 'tsconfig.json'),protos_ts_config_client_only(sylk_json.domain))
-    
+    if sylk_json.get_server_language() != "typescript":
+        file_system.wFile(
+            file_system.join_path(sylk_json.path, "tsconfig.json"),
+            main_ts_config_client_only,
+        )
+        file_system.wFile(
+            file_system.join_path(
+                sylk_json.path, "services", "protos", "tsconfig.json"
+            ),
+            protos_ts_config_client_only(sylk_json.domain),
+        )
+
     # file_system.wFile(file_system.join_path(sylk_json.path,'.sylk','contxt.json'),'{"files":[]}')
-    
+
     # .gitignore
-    file_system.wFile(file_system.join_path(sylk_json.path,'.gitignore'),gitignore_ts)
+    file_system.wFile(file_system.join_path(sylk_json.path, ".gitignore"), gitignore_ts)
 
     return [directories]
 
+
 @builder.hookimpl
 def compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # Running ./bin/init-ts.sh script for compiling protos
-    if sylk_json.get_server_language() != 'typescript':
+    if sylk_json.get_server_language() != "typescript":
         logging.info("Running ./bin/init-ts.sh script for 'protoc' compiler")
-        subprocess.run(['bash', file_system.join_path(
-            sylk_json.path, 'bin', 'init-ts.sh')])
+        subprocess.run(
+            ["bash", file_system.join_path(sylk_json.path, "bin", "init-ts.sh")]
+        )
+
 
 @builder.hookimpl
-def write_clients(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext,pre_data):
+def write_clients(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext, pre_data
+):
     imports = []
     exports = []
     override_stubs = {}
-    before_init = ''
+    before_init = ""
     interceptors = []
     client_options = [
         ("grpc.keepalive_time_ms", 120000),
-        ("grpc.http2.min_time_between_pings_ms",120000),
-        ("grpc.keepalive_timeout_ms",20000),
-        ("grpc.http2.max_pings_without_data",0),
-        ("grpc.keepalive_permit_without_calls",1),
-        ("interceptors","interceptorsProviders")
+        ("grpc.http2.min_time_between_pings_ms", 120000),
+        ("grpc.keepalive_timeout_ms", 20000),
+        ("grpc.http2.max_pings_without_data", 0),
+        ("grpc.keepalive_permit_without_calls", 1),
+        ("interceptors", "interceptorsProviders"),
     ]
     """Parse pre data"""
     if pre_data:
         _hook_name = inspect.stack()[0][3]
         for mini_hooks in pre_data:
             for hook in mini_hooks:
-                if __name__ == hook.split(':')[0]:
-                    if hook.split(':')[2] is not None and _hook_name == hook.split(':')[1].replace('()',''):
-                        
-                         # Append to exports
-                        if 'append_imports' in hook.split(':')[2]:
+                if __name__ == hook.split(":")[0]:
+                    if hook.split(":")[2] is not None and _hook_name == hook.split(":")[
+                        1
+                    ].replace("()", ""):
+                        # Append to exports
+                        if "append_imports" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for imp in mini_hooks[hook]:
                                     imports.append(imp)
 
                         # Append to exports
-                        elif 'append_exports' in hook.split(':')[2]:
+                        elif "append_exports" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for exp in mini_hooks[hook]:
                                     exports.append(exp)
-                    
+
                         # Append to exports
-                        elif 'override_stubs' in hook.split(':')[2]:
+                        elif "override_stubs" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for stub in mini_hooks[hook]:
                                     override_stubs[stub] = mini_hooks[hook][stub]
 
-                        elif 'append_client_options' in hook.split(':')[2]:
+                        elif "append_client_options" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
-                                for k,v in mini_hooks[hook]:
-                                    old_value = next((i for i in client_options if i[0] == k),(None,None))[1]
-                                    if k not in list(map(lambda x: x[0], client_options)):
-                                        client_options.append((k,v))
+                                for k, v in mini_hooks[hook]:
+                                    old_value = next(
+                                        (i for i in client_options if i[0] == k),
+                                        (None, None),
+                                    )[1]
+                                    if k not in list(
+                                        map(lambda x: x[0], client_options)
+                                    ):
+                                        client_options.append((k, v))
                                     elif v != old_value:
-                                        client_options.remove((k,old_value))
-                                        client_options.append((k,v))
-                        elif 'add_before_init' in hook.split(':')[2]:
+                                        client_options.remove((k, old_value))
+                                        client_options.append((k, v))
+                        elif "add_before_init" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 before_init = mini_hooks[hook]
 
-                        elif 'append_interceptors' in hook.split(':')[2]:
+                        elif "append_interceptors" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for intrcpt in mini_hooks[hook]:
                                     interceptors.append(intrcpt)
                     else:
-                        pretty.print_warning(f'[{__name__}] `{hook}` missing command')
-
+                        pretty.print_warning(f"[{__name__}] `{hook}` missing command")
 
-    if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path,'clients','typescript')):
-        file_system.mkdir(file_system.join_path(sylk_json.path,'clients','typescript','protos'))
+    if file_system.check_if_dir_exists(
+        file_system.join_path(sylk_json.path, "clients", "typescript")
+    ):
+        file_system.mkdir(
+            file_system.join_path(sylk_json.path, "clients", "typescript", "protos")
+        )
     else:
-        file_system.mkdir(file_system.join_path(sylk_json.path,'clients','typescript'))
-        file_system.mkdir(file_system.join_path(sylk_json.path,'clients','typescript','protos'))
-    
-    if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'server','services','protos')):
-        for f in file_system.walkFiles(file_system.join_path(sylk_json.path, 'server','services','protos')):
-            file_system.copyFile(file_system.join_path(sylk_json.path,'server','services', 'protos', f), file_system.join_path(sylk_json.path,'clients','typescript','protos',f))
-        
-        if file_system.check_if_dir_exists(file_system.join_path(sylk_json.path, 'server','services','protos','google')):
-            file_system.cpDir(file_system.join_path(sylk_json.path, 'server','services','protos','google'),file_system.join_path(sylk_json.path, 'clients','typescript','protos','google'))
-
-    client = helpers.SylkClientTs(sylk_json.project.get(
-        'packageName'), sylk_json.services, sylk_json.packages, sylk_context,pre_data={
-            'imports': imports,
-            'exports': exports,
-            'stubs': override_stubs,
-            'client_options': client_options,
-            'before_init':before_init,
-            'interceptors': interceptors
-        })
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'services', 'index.ts'), client.__str__(), overwrite=True)
+        file_system.mkdir(
+            file_system.join_path(sylk_json.path, "clients", "typescript")
+        )
+        file_system.mkdir(
+            file_system.join_path(sylk_json.path, "clients", "typescript", "protos")
+        )
+
+    if file_system.check_if_dir_exists(
+        file_system.join_path(sylk_json.path, "server", "services", "protos")
+    ):
+        for f in file_system.walkFiles(
+            file_system.join_path(sylk_json.path, "server", "services", "protos")
+        ):
+            file_system.cpDir(
+                file_system.join_path(sylk_json.path, "server", "services", "protos"),
+                file_system.join_path(
+                    sylk_json.path, "clients", "typescript", "protos"
+                ),
+            )
+
+        if file_system.check_if_dir_exists(
+            file_system.join_path(
+                sylk_json.path, "server", "services", "protos", "google"
+            )
+        ):
+            file_system.cpDir(
+                file_system.join_path(
+                    sylk_json.path, "server", "services", "protos", "google"
+                ),
+                file_system.join_path(
+                    sylk_json.path, "clients", "typescript", "protos", "google"
+                ),
+            )
+
+    client = helpers.SylkClientTs(
+        sylk_json.project.get("packageName"),
+        sylk_json.services,
+        sylk_json.packages,
+        sylk_context,
+        pre_data={
+            "imports": imports,
+            "exports": exports,
+            "stubs": override_stubs,
+            "client_options": client_options,
+            "before_init": before_init,
+            "interceptors": interceptors,
+        },
+        sylk_json=sylk_json
+    )
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "services", "index.ts"),
+        client.__str__(),
+        overwrite=True,
+    )
```

## sylk/builder/plugins/SylkTsServer.py

```diff
@@ -18,123 +18,169 @@
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import logging
 import subprocess
 import sylk.builder as builder
-from sylk.commons import helpers, file_system, resources,pretty, protos
-from sylk.builder.plugins.static import gitignore_ts,utils_errors_ts,utils_interfaces,package_json,bash_init_script_ts,bash_run_server_script_ts,protos_compile_script_ts,main_ts_config,clients_ts_configs,protos_ts_config
+from sylk.commons import helpers, file_system, resources, pretty, protos
+from sylk.builder.plugins.static import (
+    gitignore_ts,
+    utils_errors_ts,
+    utils_interfaces,
+    package_json,
+    bash_init_script_ts,
+    bash_run_server_script_ts,
+    protos_compile_script_ts,
+    main_ts_config,
+    clients_ts_configs,
+    protos_ts_config,
+)
 import inspect
 
 
 @builder.hookimpl
 def pre_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     pretty.print_info("🔌 Starting sylk build process %s plugin" % (__name__))
 
 
 @builder.hookimpl
 def post_build(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # TODO add postbuild validation of generated code
     # pretty.print_success("Finished sylk build process %s plugin" % (__name__))
-    return (__name__,'OK')
-
+    return (__name__, "OK")
 
 @builder.hookimpl
-def init_project_structure(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
+def init_project_structure(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext
+):
     directories = [
         # Utils
-        file_system.join_path(sylk_json.path, 'services', 'utils'),
+        file_system.join_path(sylk_json.path, "services", "utils"),
         # Protos
-        file_system.join_path(sylk_json.path, 'services', 'protos')]
+        file_system.join_path(sylk_json.path, "services", "protos"),
+    ]
 
     for dir in directories:
         file_system.mkdir(dir)
     # Utils error
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'services','utils', 'error.ts'), utils_errors_ts)
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "services", "utils", "error.ts"),
+        utils_errors_ts,
+    )
     # Utils Interfaces
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'services','utils', 'interfaces.ts'), utils_interfaces)
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "services", "utils", "interfaces.ts"),
+        utils_interfaces,
+    )
     # package.json
-    file_system.wFile(file_system.join_path(sylk_json.path,'package.json'),package_json.replace('REPLACEME',sylk_json.project.get('packageName')))
-    
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "package.json"),
+        package_json.replace("REPLACEME", sylk_json.project.get("packageName")),
+    )
+
     # Bin files
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'bin', 'init-ts.sh'), bash_init_script_ts)
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'bin', 'proto.js'), protos_compile_script_ts)
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "bin", "init-ts.sh"), bash_init_script_ts
+    )
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "bin", "proto.js"),
+        protos_compile_script_ts,
+    )
 
     # tsconfig.json
-    file_system.wFile(file_system.join_path(sylk_json.path, 'tsconfig.json'),main_ts_config)
-    file_system.wFile(file_system.join_path(sylk_json.path, 'services', 'protos', 'tsconfig.json'),protos_ts_config(sylk_json.domain))
-    
-    if sylk_json.get_server_language() == 'typescript':
-        file_system.wFile(file_system.join_path(
-            sylk_json.path, 'bin', 'run-server.sh'), bash_run_server_script_ts)
-    
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "tsconfig.json"), main_ts_config
+    )
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "services", "protos", "tsconfig.json"),
+        protos_ts_config(sylk_json.domain),
+    )
+
+    if sylk_json.get_server_language() == "typescript":
+        file_system.wFile(
+            file_system.join_path(sylk_json.path, "bin", "run-server.sh"),
+            bash_run_server_script_ts,overwrite=True
+        )
+
     # file_system.wFile(file_system.join_path(sylk_json.path,'.webezy','contxt.json'),'{"files":[]}')
-    
+
     # .gitignore
-    file_system.wFile(file_system.join_path(sylk_json.path,'.gitignore'),gitignore_ts)
+    file_system.wFile(file_system.join_path(sylk_json.path, ".gitignore"), gitignore_ts)
 
     return [directories]
 
 
 @builder.hookimpl
 def write_services(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     for svc in sylk_json.services:
-        svc_name = svc.split('/')[-1].split('.')[0]
-        if file_system.check_if_file_exists(file_system.join_path(
-            sylk_json.path, 'services', f'{svc_name}.ts')) == False:
-            service_code = helpers.SylkServiceTs(sylk_json.project.get('packageName'), svc, sylk_json.services[svc].get(
-                'dependencies'), sylk_json.services[svc], context=sylk_context,sylk_json=sylk_json).to_str()
-            file_system.wFile(file_system.join_path(
-                sylk_json.path, 'services', f'{svc_name}.ts'), service_code, overwrite=True)
+        svc_name = svc.get('name')
+        svc_ver = helpers.parse_version_component(svc.get('fullName'))
+        if svc_ver is not None:
+            svc_ver = f'v{svc_ver.get("version")}{svc_ver.get("channel") if svc_ver.get("channel") is not None else ""}{svc_ver.get("release") if svc_ver.get("release") is not None else ""}'
+        else:
+            svc_ver = ''
+        svc_path = file_system.join_path(
+            sylk_json.path, "services", svc_name, svc_ver, f"{svc_name}.ts"
+        )
+        if file_system.check_if_file_exists(svc_path) == False:
+            service_code = helpers.SylkServiceTs(
+                sylk_json.project.get("packageName"),
+                svc_name,
+                svc.get("dependencies"),
+                svc,
+                context=sylk_context,
+                sylk_json=sylk_json,
+            ).to_str()
+            file_system.wFile(svc_path, service_code, overwrite=True, force=True)
         # else:
         #     pretty.print_info("Make sure you are editing the {0} file\n - See how to edit service written in Typescript".format(file_system.join_path(
         #         sylk_json.path, 'services', f'{svc}.ts')))
-            # return (f'{svc}.ts',)
-            
+        # return (f'{svc}.ts',)
+
 
 @builder.hookimpl
 def compile_protos(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     # Running ./bin/init.sh script for compiling protos
     pretty.print_note("Running ./bin/init-ts.sh script for 'protoc' compiler")
-    proc = subprocess.run(['bash', file_system.join_path(
-        sylk_json.path, 'bin', 'init-ts.sh')])
-    pretty.print_note(proc,True)
+    proc = subprocess.run(
+        ["bash", file_system.join_path(sylk_json.path, "bin", "init-ts.sh")]
+    )
+    pretty.print_note(proc, True)
     if int(proc.returncode) != 0:
-        pretty.print_error("ERROR occured during building process some more info on specific error can be found above")
+        pretty.print_error(
+            "ERROR occured during building process some more info on specific error can be found above"
+        )
         exit(proc.returncode)
     pretty.print_success("Compiled protos %s" % (__name__))
-    
 
 
 def parse_proto_type_to_ts(type, label, messageType=None, enumType=None):
-    temp_type = 'None'
-    if 'int' in type or type == 'float' or type == 'double':
-        temp_type = 'number'
-    elif type == 'string':
-        temp_type = 'string'
-    elif type == 'message' or type == 'enum':
-        temp_type = '{0}__pb2.{1}'.format(
-            messageType.split('.')[1], messageType.split('.')[-1])
-    elif type == 'enum':
-        temp_type = '{0}__pb2.{1}'.format(
-            enumType.split('.')[1], enumType.split('.')[-1])
-    elif type == 'bool':
-        temp_type = 'boolean'
-    if label == 'repeated':
-        temp_type = f'{temp_type}[]'
+    temp_type = "None"
+    if "int" in type or type == "float" or type == "double":
+        temp_type = "number"
+    elif type == "string":
+        temp_type = "string"
+    elif type == "message" or type == "enum":
+        temp_type = "{0}__pb2.{1}".format(
+            messageType.split(".")[1], messageType.split(".")[-1]
+        )
+    elif type == "enum":
+        temp_type = "{0}__pb2.{1}".format(
+            enumType.split(".")[1], enumType.split(".")[-1]
+        )
+    elif type == "bool":
+        temp_type = "boolean"
+    if label == "repeated":
+        temp_type = f"{temp_type}[]"
     return temp_type
 
 
-_OPEN_BRCK = '{'
-_CLOSING_BRCK = '}'
+_OPEN_BRCK = "{"
+_CLOSING_BRCK = "}"
 
 
 @builder.hookimpl
 def rebuild_context(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext):
     pass
     # pretty.print_note("Re-Building sylk.context")
     # if sylk_json.services is not None:
@@ -193,15 +239,15 @@
     #                                 temp_lines = []
     #                                 num_lines = 4
     #                                 for l in rpc_code_inlines[methods_i]:
     #                                     if 'ServerWritableStream<' in l:
     #                                         num_lines = 3
     #                                         break
     #                                 for line in rpc_code_inlines[methods_i][num_lines:]:
-                                        
+
     #                                     if '\t}\n' == line:
     #                                         if '\n' == temp_lines[-1]:
     #                                             break
 
     #                                     if 'export {' in line:
     #                                         break
 
@@ -214,133 +260,155 @@
 
     #         except Exception as e:
     #             pretty.print_error(e)
     # if sylk_context is not None:
     #     file_system.wFile(file_system.join_path(
     #         sylk_json.path, '.sylk', 'context.json'), sylk_context.dump(), True, True)
 
+
 @builder.hookimpl
-def write_server(sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext,pre_data):
-    
-    imports = ['import { Server, ServerCredentials } from \'@grpc/grpc-js\';']
+def write_server(
+    sylk_json: helpers.SylkJson, sylk_context: helpers.SylkContext, pre_data
+):
+    imports = ["import { Server, ServerCredentials } from '@grpc/grpc-js';"]
     services_init_impl = []
     services_bindings = []
     overwrite = False
     server_options = [
-        ('grpc.max_receive_message_length',-1),
-        ('grpc.max_send_message_length',-1)
+        ("grpc.max_receive_message_length", -1),
+        ("grpc.max_send_message_length", -1),
     ]
-    before_init = ''
+    before_init = ""
     injects_service = {}
-    startup_promises =[]
-    after_startup = ''
+    startup_promises = []
+    after_startup = ""
     """Parse pre data"""
     if pre_data:
         _hook_name = inspect.stack()[0][3]
         for mini_hooks in pre_data:
             for hook in mini_hooks:
-                if __name__ == hook.split(':')[0]:
-
-                    if hook.split(':')[2] is not None and _hook_name == hook.split(':')[1].replace('()',''):
-
+                if __name__ == hook.split(":")[0]:
+                    if hook.split(":")[2] is not None and _hook_name == hook.split(":")[
+                        1
+                    ].replace("()", ""):
                         # Pre consume imports
-                        if 'append_imports' in hook.split(':')[2]:
+                        if "append_imports" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for imp in mini_hooks[hook]:
                                     imports.append(imp)
-                        
+
                         # Pre consume services bindings
-                        elif 'append_services_bindings' in hook.split(':')[2]:
-                            if mini_hooks[hook] is not None and len(mini_hooks[hook]) > 1:
+                        elif "append_services_bindings" in hook.split(":")[2]:
+                            if (
+                                mini_hooks[hook] is not None
+                                and len(mini_hooks[hook]) > 1
+                            ):
                                 for imp in mini_hooks[hook]:
                                     imports.append(imp)
-                        
+
                         # Force rewriting of server each build
-                        elif 'overwrite' in hook.split(':')[2]:
+                        elif "overwrite" in hook.split(":")[2]:
                             if mini_hooks[hook] == True:
                                 overwrite = True
 
-                        elif 'append_server_options' in hook.split(':')[2]:
+                        elif "append_server_options" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
-                                for k,v in mini_hooks[hook]:
-                                    old_value = next((i for i in server_options if i[0] == k),(None,None))[1]
-                                    if k not in list(map(lambda x: x[0], server_options)):
-                                        server_options.append((k,v))
+                                for k, v in mini_hooks[hook]:
+                                    old_value = next(
+                                        (i for i in server_options if i[0] == k),
+                                        (None, None),
+                                    )[1]
+                                    if k not in list(
+                                        map(lambda x: x[0], server_options)
+                                    ):
+                                        server_options.append((k, v))
                                     elif v != old_value:
-                                        server_options.remove((k,old_value))
-                                        server_options.append((k,v))
+                                        server_options.remove((k, old_value))
+                                        server_options.append((k, v))
 
                         # Add code before server init
-                        elif 'add_before_init' in hook.split(':')[2]:
+                        elif "add_before_init" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 before_init = mini_hooks[hook]
-                        
+
                         # Inject the service classes with additional objects
-                        elif 'inject_service' in hook.split(':')[2]:
+                        elif "inject_service" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for svc in mini_hooks[hook]:
                                     injects_service[svc] = mini_hooks[hook][svc]
-                        
+
                         # Inject the service classes with additional objects
-                        elif 'wrap_service' in hook.split(':')[2]:
+                        elif "wrap_service" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for svc in mini_hooks[hook]:
                                     injects_service[svc] = mini_hooks[hook][svc]
-                        
+
                         # Inject the service classes with additional objects
-                        elif 'append_startup_promise' in hook.split(':')[2]:
+                        elif "append_startup_promise" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 for promise in mini_hooks[hook]:
                                     startup_promises.append(promise)
 
                         # Append code block after startup
-                        elif 'append_after_startup' in hook.split(':')[2]:
+                        elif "append_after_startup" in hook.split(":")[2]:
                             if mini_hooks[hook] is not None:
                                 after_startup = mini_hooks[hook]
 
-
                     else:
-                        pretty.print_warning(f'[{__name__}] `{hook}` missing command')
+                        pretty.print_warning(f"[{__name__}] `{hook}` missing command")
 
-                    
-    
     for svc in sylk_json.services:
-        svc_name = svc.split('/')[-1].split('.')[0]
-        imports.append(f'import {_OPEN_BRCK} {svc_name}, {svc_name}Service {_CLOSING_BRCK} from \'./services/{svc_name}\';')
+        svc_name = svc.get('name')
+        pkg_ver = helpers.parse_version_component(svc.get('fullName'))
+        if pkg_ver is not None:
+            svc_ver = f'v{pkg_ver.get("version")}{pkg_ver.get("channel") if pkg_ver.get("channel") is not None else ""}{pkg_ver.get("release") if pkg_ver.get("release") is not None else ""}'
+        else:
+            svc_ver =  ''
+        imports.append(
+            f"import {_OPEN_BRCK} {svc_name} as {svc_name}{svc_ver}, {svc_name}Service as {svc_name}Service{svc_ver} {_CLOSING_BRCK} from './services/{svc_name}/{svc_ver}/{svc_name}';"
+        )
         injects = []
         if svc_name in injects_service:
             injects.append(injects_service[svc_name])
-        
-        injects = ', '.join(injects)
-        services_init_impl.append(f'const {svc_name}Impl = new {svc_name}({injects})')
+
+        injects = ", ".join(injects)
+        services_init_impl.append(
+            f"const {svc_name}{svc_ver}Impl = new {svc_name}{svc_ver}({injects})"
+        )
 
         services_bindings.append(
-            f'server.addService({svc_name}Service, {svc_name}Impl);')
-    services_bindings = '\n\t'.join(services_bindings)
-    services_init_impl = '\n\t'.join(services_init_impl)
-    imports = '\n'.join(imports)
-    port = sylk_json._config.get('port')
-    startup_promises = ',\n\t'.join(startup_promises)
-    server_options = '\n\t'.join(list(map(lambda opt: '"{}": {},'.format(opt[0],opt[1]),server_options)))
-    server_code = f'// sylk.build Generated Server Code\n\
+            f"server.addService({svc_name}Service{svc_ver}, {svc_name}{svc_ver}Impl);"
+        )
+    services_bindings = "\n\t".join(services_bindings)
+    services_init_impl = "\n\t".join(services_init_impl)
+    imports = "\n".join(imports)
+    port = sylk_json._config.get("port")
+    startup_promises = ",\n\t".join(startup_promises)
+    server_options = "\n\t".join(
+        list(map(lambda opt: '"{}": {},'.format(opt[0], opt[1]), server_options))
+    )
+    server_code = f"// sylk.build Generated Server Code\n\
 {imports}\n\n\
 let _PORT:number = {port};\n\
-let _HOST:string = \'0.0.0.0\';\n\
+let _HOST:string = '0.0.0.0';\n\
 let _ADDR = `${_OPEN_BRCK}_HOST{_CLOSING_BRCK}:${_OPEN_BRCK}_PORT{_CLOSING_BRCK}`\n\
 {before_init}\n\
 const server = new Server({_OPEN_BRCK}\n\
 \t{server_options}\n\
 {_CLOSING_BRCK});\n\n\
 async function startServer() {_OPEN_BRCK}\n\
 \tconst promises: Promise<number>[] = [\n\
 \t{startup_promises}\n\
 \t];\n\
 \tconst results = await Promise.all(promises);\n\
 \tconsole.log(results);\n\n\
 \t{after_startup}\n\n\
 \t{services_init_impl}\n\
 \t{services_bindings}\n\n\
-\tserver.bindAsync(_ADDR, ServerCredentials.createInsecure(), (err: Error | null, bindPort: number) => {_OPEN_BRCK}\n\tif (err) {_OPEN_BRCK}\n\t\tthrow err;\n\t{_CLOSING_BRCK}\n\n\tconsole.log(`[sylk.build] Starting gRPC:server:${_OPEN_BRCK}bindPort{_CLOSING_BRCK}`,`at -> ${_OPEN_BRCK}new Date().toLocaleString(){_CLOSING_BRCK})`);\n\tserver.start();\n\t{_CLOSING_BRCK});\n{_CLOSING_BRCK}\n\nstartServer().then(res => console.log("Service Start Up...")).catch(err => console.log(err));'
-   
-    file_system.wFile(file_system.join_path(
-        sylk_json.path, 'server.ts'), server_code,overwrite=overwrite)
+\tserver.bindAsync(_ADDR, ServerCredentials.createInsecure(), (err: Error | null, bindPort: number) => {_OPEN_BRCK}\n\tif (err) {_OPEN_BRCK}\n\t\tthrow err;\n\t{_CLOSING_BRCK}\n\n\tconsole.log(`[sylk.build] Starting gRPC:server:${_OPEN_BRCK}bindPort{_CLOSING_BRCK}`,`at -> ${_OPEN_BRCK}new Date().toLocaleString(){_CLOSING_BRCK})`);\n\tserver.start();\n\t{_CLOSING_BRCK});\n{_CLOSING_BRCK}\n\nstartServer().then(res => console.log(\"Service Start Up...\")).catch(err => console.log(err));"
+
+    file_system.wFile(
+        file_system.join_path(sylk_json.path, "server.ts"),
+        server_code,
+        overwrite=overwrite,
+    )
     pretty.print_warning("Make sure you make desired changes on server.ts file !")
```

## sylk/builder/plugins/static.py

```diff
@@ -15,15 +15,15 @@
 # EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 # MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
-gitignore_py = '# Byte-compiled / optimized / DLL files\n\
+gitignore_py = "# Byte-compiled / optimized / DLL files\n\
 __pycache__/\n\
 *.py[cod]\n\
 *$py.class\n\n\
 # C extensions\n\
 *.so\n\n\
 # Distribution / packaging\n\
 .Python\n\
@@ -89,17 +89,17 @@
 # Environments\n\n\
 .env\n\
 .venv\n\
 env/\n\
 venv/\n\
 ENV/\n\
 env.bak/\n\
-venv.bak/\n'
+venv.bak/\n"
 
-gitignore_go = '# If you prefer the allow list template instead of the deny list, see community template:\n\
+gitignore_go = "# If you prefer the allow list template instead of the deny list, see community template:\n\
 # https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore\n\
 #\n\
 # Binaries for programs and plugins\n\
 *.exe\n\
 *.exe~\n\
 *.dll\n\
 *.so\n\
@@ -107,17 +107,17 @@
 # Test binary, built with `go test -c`\n\
 *.test\n\n\
 # Output of the go coverage tool, specifically when used with LiteIDE\n\
 *.out\n\n\
 # Dependency directories (remove the comment below to include it)\n\n\
 # vendor/\n\n\
 # Go workspace file\n\
-go.work'
+go.work"
 
-gitignore_js = '# Logs\n\
+gitignore_js = "# Logs\n\
 logs\n\
 *.log\n\
 npm-debug.log*\n\
 yarn-debug.log*\n\
 yarn-error.log*\n\
 lerna-debug.log*\n\
 .pnpm-debug.log*\n\n\
@@ -163,17 +163,17 @@
 .env.production.local\n\
 .env.local\n\n\
 # yarn v2\n\
 .yarn/cache\n\
 .yarn/unplugged\n\
 .yarn/build-state.yml\n\
 .yarn/install-state.gz\n\
-.pnp.*\n'
+.pnp.*\n"
 
-gitignore_ts = 'lib-cov\n\
+gitignore_ts = "lib-cov\n\
 *.seed\n\
 *.log\n\
 *.csv\n\
 *.dat\n\
 *.out\n\
 *.pid\n\
 *.gz\n\
@@ -197,17 +197,18 @@
 # OS metadata\n\
 .DS_Store\n\
 Thumbs.db\n\n\
 # Ignore built ts files\n\
 dist/**/*\n\
 # ignore yarn.lock\n\
 yarn.lock\n\n\
-.sylk\n'
-_OPEN_BRCK='{'
-_CLOSING_BRCK = '}'
+.sylk\n"
+_OPEN_BRCK = "{"
+_CLOSING_BRCK = "}"
+
 
 def bash_init_script_go(project_package, services, packages):
     services_protoc = []
     packages_protoc = []
     # for s in services:
     #     services_protoc.append('mkdir $DST_DIR"/{0}"\nprotoc -I=$SRC_DIR --go_out=$DST_DIR --go_opt=paths=source_relative --go-grpc_out=$DST_DIR"/{0}"  --go-grpc_opt=paths=source_relative protos/{0}.proto'.format(s))
     # for p in packages:
@@ -220,15 +221,22 @@
 DST_DIR="services/protos"\n\
 {1}\n\
 {2}\n\
 go mod tidy\n\
 go test\n\
 statuscode=$?\n\
 echo "Exit code for go.mod tidy and test -> "$statuscode\n\
-[[ "$statuscode" != "0" ]] && {3} echo "Some error occured during init script for Go"; echo "Running init for : {0}"; go mod init {0}; {4}\n'.format(project_package,'\n'.join(services_protoc),'\n'.join(packages_protoc),_OPEN_BRCK,_CLOSING_BRCK)
+[[ "$statuscode" != "0" ]] && {3} echo "Some error occured during init script for Go"; echo "Running init for : {0}"; go mod init {0}; {4}\n'.format(
+        project_package,
+        "\n".join(services_protoc),
+        "\n".join(packages_protoc),
+        _OPEN_BRCK,
+        _CLOSING_BRCK,
+    )
+
 
 bash_init_script_ts = '#!/bin/bash\n\n\
 echo "[sylk.build] init.sh starting protoc compiler"\n\
 npm i\n\
 node ./bin/proto.js\n\
 npm run build\n\
 statuscode=$?\n\
@@ -246,42 +254,74 @@
         search="protos\/"\n\
         replace=""\n\
         sed -i\'.bak\' -e "1,8 s/$search/$replace/gi" $filename\n\
         rm -f *.bak\n\
         echo "[sylk-script] Compiling -> "$filename\n\
         sudo protoc -I=../protos $filename  --js_out=import_style=commonjs,binary:../clients/webpack   --grpc-web_out=import_style=typescript,mode=grpcwebtext:../clients/webpack\n\
     done\n\
-done'.format(_OPEN_BRCK,_CLOSING_BRCK)
+done'.format(
+    _OPEN_BRCK, _CLOSING_BRCK
+)
 
 bash_run_server_script_ts = '#!/bin/bash\n\n\
 if [[ $1 == "debug" ]]\n\
 then\n\
 \techo "Debug mode: $1"\n\
 \tGRPC_VERBOSITY=DEBUG GRPC_TRACE=all node ./server/server.js\n\
+elif [[ $1 == "info" ]]\n\
+then\n\
+\techo "Info Mode: $1"\n\
+\tGRPC_VERBOSITY=INFO GRPC_TRACE=all node ./server/server.js\n\
 else\n\
 \tnode ./server/server.js\n\
 fi'
 
 protos_compile_script_ts = 'const path = require("path");\n\
 const { execSync } = require("child_process");\n\
 const rimraf = require("rimraf");\n\n\
 const PROTO_DIR = path.join(__dirname, "../protos");\n\
 const MODEL_DIR = path.join(__dirname, "../services/protos");\n\
 const PROTOC_PATH = path.join(__dirname, "../node_modules/grpc-tools/bin/protoc");\n\
 const PLUGIN_PATH = path.join(__dirname, "../node_modules/.bin/protoc-gen-ts_proto");\n\n\
 const pkgJson = require("../sylk.json");\n\
 let protos = [];\n\n\
+function getUniqueStrings(arr) {\n\
+  const uniqueSet = new Set(arr);\n\
+  return Array.from(uniqueSet);\n\
+}\n\n\
 for (const pkg in pkgJson.packages) {\n\
   if (Object.hasOwnProperty.call(pkgJson.packages, pkg)) {\n\
-    protos.push(`${pkg.split("/").slice(1).join("/")}`)\n\
-  }\n\
-}\n\
-for (const svc in pkgJson.services) {\n\
-  if (Object.hasOwnProperty.call(pkgJson.services, svc)) {\n\
-    protos.push(`${svc.split("/").slice(1).join("/")}`)\n\
+    let files = [];\n\
+    let standaloneFile = false;\n\
+    if(pkgJson.packages[pkg].services) {\n\
+      pkgJson.packages[pkg]?.services.map(s => s.tag).map(s => files.push(s))\n\
+      if(pkgJson.packages[pkg]?.services.map(s => !s.tag).includes(true)) {\n\
+        standaloneFile = true;\n\
+      }\n\
+    }\n\
+    if(pkgJson.packages[pkg].messages) {\n\
+      pkgJson.packages[pkg]?.messages.map(m => m.tag).map(m => files.push(m))\n\
+      if(pkgJson.packages[pkg]?.messages.map(m => !m.tag).includes(true)) {\n\
+        standaloneFile = true;\n\
+      }\n\
+    }\n\
+    if(pkgJson.packages[pkg].enums) {\n\
+      pkgJson.packages[pkg]?.enums.map(e => e.tag).map(e => files.push(e))\n\
+      if(pkgJson.packages[pkg]?.enums.map(e => !e.tag).includes(true)) {\n\
+        standaloneFile = true;\n\
+      }\n\
+    }\n\
+    if(files.length>0) {\n\
+      getUniqueStrings(files).map(f => protos.push(`${pkg}/${f}.proto`))\n\
+      if(standaloneFile) {\n\
+        protos.push(`${pkg}/${pkgJson.packages[pkg].name}.proto`)  \n\
+      }\n\
+    } else {\n\
+      protos.push(`${pkg}/${pkgJson.packages[pkg].name}.proto`)\n\
+    }\n\
   }\n\
 }\n\
 rimraf.sync(`${MODEL_DIR}/*.ts`, {\n\
   glob: { ignore: `${MODEL_DIR}/tsconfig.json` },\n\
 });\n\n\
 const protoConfig = [\n\
   `--plugin=${PLUGIN_PATH}`,\n\n\
@@ -290,16 +330,17 @@
   `--ts_proto_out=${MODEL_DIR}`,\n\
   `--proto_path ${PROTO_DIR} ${protos.join(" ")}`,\n\
 ];\n\n\
 // https://github.com/stephenh/ts-proto#usage\n\
 execSync(`${PROTOC_PATH} ${protoConfig.join(" ")}`);\n\
 console.log(`> Proto models created: ${MODEL_DIR}`);'
 
+
 def interceptors_js(version):
-    return f'const unpack = (...args) => ({_OPEN_BRCK}\n\
+    return f"const unpack = (...args) => ({_OPEN_BRCK}\n\
 	request: args[1], // Outgoing client call.request object\n\
 	metadata: args[2], // Outgoing client call.metadata object\n\
 	cb: args[3], // Client passed CallBack function\n\
 	options: args[4], // Additional interceptors options\n\
 	...args.slice(5) // for forward compatibility with future params\n\
 {_CLOSING_BRCK})\n\n\
 const defaultRetriesPolicy = {_OPEN_BRCK}\n\
@@ -310,16 +351,16 @@
 {_CLOSING_BRCK}\n\n\
 function _preMethodCallDecorator(fn) {_OPEN_BRCK}\n\
 	return function (...args) {_OPEN_BRCK}\n\
 	  // Do something before calling the method here\n\
 	  // For example, you could log the method name and arguments\n\
 	  const req = args[1];\n\
 	  const md = args[2];\n\
-	  if(md.get(\'sylk-version\').length === 0) {_OPEN_BRCK}\n\
-		  md.add(\'sylk-version\',\'{version}\')\n\
+	  if(md.get('sylk-version').length === 0) {_OPEN_BRCK}\n\
+		  md.add('sylk-version','{version}')\n\
 	  {_CLOSING_BRCK}\n\
 	  // Call the method\n\
 	  return fn.apply(this, args);\n\
 	{_CLOSING_BRCK};\n\
 {_CLOSING_BRCK}\n\n\
 function _retry(next) {_OPEN_BRCK}\n\
 	return function (...args) {_OPEN_BRCK}\n\
@@ -340,15 +381,15 @@
 		let interval = retriesPolicy.interval ? retriesPolicy.interval : 100;\n\
 		const retryCB = (err,res) => {_OPEN_BRCK}\n\
 			if(err) {_OPEN_BRCK}\n\
                 if (!retryCodes.includes(err.code)) {_OPEN_BRCK}\n\
 					return originalCB ? originalCB(err,null) : err\n\
 				{_CLOSING_BRCK} else {_OPEN_BRCK}\n\
                     retryAttempt += 1;\n\
-                    const sylkMaxRetries = \'x-sylk-retries\';\n\
+                    const sylkMaxRetries = 'x-sylk-retries';\n\
                     let maxRetriesCount = metadata.get(sylkMaxRetries)\n\
                     maxRetriesCount.length>0 ? metadata.set(sylkMaxRetries,Number(maxRetriesCount[0])+1) : metadata.add(sylkMaxRetries,retryAttempt)\n\n\
                     if(retryAttempt >= maxRetries) {_OPEN_BRCK}\n\
                         args[3]=originalCB\n\
                     {_CLOSING_BRCK}\n\
                     setTimeout(() => {_OPEN_BRCK}\n\
                         request.todo_id = Number(request.todo_id) - 1\n\
@@ -363,15 +404,16 @@
 		const result =  next(...args);\n\
 		return result\n\
 	{_CLOSING_BRCK};\n\
 {_CLOSING_BRCK}\n\n\
 module.exports = {_OPEN_BRCK}\n\
 	clientMethodWrapper : _preMethodCallDecorator,\n\
     clientRetries : _retry\n\
-{_CLOSING_BRCK}'
+{_CLOSING_BRCK}"
+
 
 def js_package_json(prj_name):
     return '{\n\
 \t"name": "REPLACEME",\n\
 \t"version": "1.0.0",\n\
 \t"description": "",\n\
 \t"main": "index.js",\n\
@@ -380,17 +422,20 @@
 \t},\n\
 \t"keywords": [],\n\
 \t"author": "",\n\
 \t"license": "ISC",\n\
 \t"dependencies": {\n\
 \t"@grpc/grpc-js": "^1.8.14"\n\
 \t}\n\
-}'.replace("REPLACEME",prj_name)
+}'.replace(
+        "REPLACEME", prj_name
+    )
+
 
-package_json ='{\n\
+package_json = '{\n\
     "name": "REPLACEME",\n\
     "version": "1.0.0",\n\
     "description": "This project has been generated thanks to ```sylk.io``` CLI. For start using it please run  ```sylk run --build```  and see the magic in action. For more information please visit https://docs.sylk.build",\n\
     "main": "bin/proto.js",\n\
     "scripts": {\n\
         "test": "echo \\"Error: no test specified\\" && exit 1",\n\
         "lint": "eslint --ext .ts .",\n\
@@ -450,37 +495,37 @@
     "grpc-web": "~1.4.2",\n\
     "lodash": "~4.17.0",\n\
     "webpack": "~4.43.0",\n\
     "webpack-cli": "~3.3.11"\n\
   }\n\
 }'
 
-utils_errors_ts = 'import { Metadata, ServiceError as grpcServiceError, status } from \'@grpc/grpc-js\';\n\n\
+utils_errors_ts = "import { Metadata, ServiceError as grpcServiceError, status } from '@grpc/grpc-js';\n\n\
 /**\n\
  * https://grpc.io/grpc/node/grpc.html#~ServiceError__anchor\n\
  */\n\
 export class ServiceError extends Error implements Partial<grpcServiceError> {\n\
-	public override name: string = \'ServiceError\';\n\n\
+	public override name: string = 'ServiceError';\n\n\
 	constructor(\n\
 		public code: status,\n\
 		public override message: string,\n\
 		public details?: string,\n\
 		public metadata?: Metadata,\n\
 	) {\n\
 		super(message);\n\
 	}\n\
-}'
+}"
 
-utils_interfaces = '// Insert here more interfaces to service will be able to speak with\n\
+utils_interfaces = "// Insert here more interfaces to service will be able to speak with\n\
 interface Api<T> {\n\
 	[method: string]: T;\n\
 }\n\n\
 export type ApiType<T> = Api<T> & {\n\
 \n\
-}'
+}"
 
 main_ts_config = '{\n\
     "compilerOptions": {\n\
         "baseUrl": ".",\n\
         "paths": {},\n\
         "target": "ES2019",\n\
         "outDir": "server",\n\
@@ -531,14 +576,15 @@
         "client.ts","protos/**/*","protos/*.ts"\n\
     ],\n\
     "exclude": [\n\
         "node_modules"\n\
     ]\n\
 }'
 
+
 def protos_ts_config(domain):
     return f'{_OPEN_BRCK}\n\
     "extends": "../../tsconfig.json",\n\
     "compilerOptions": {_OPEN_BRCK}\n\
         "composite": true,\n\
         "outDir": "../../server/services/protos",\n\
         "noImplicitReturns": false\n\
@@ -589,14 +635,15 @@
     "references": [\n\
         {\n\
             "path": "services/protos"\n\
         }\n\
     ]\n\
 }'
 
+
 def protos_ts_config_client_only(domain):
     return f'{_OPEN_BRCK}\n\
     "extends": "../../tsconfig.json",\n\
     "compilerOptions": {_OPEN_BRCK}\n\
         "composite": true,\n\
         "outDir": "../../clients/typescript/protos",\n\
         "noImplicitReturns": false\n\
@@ -605,24 +652,29 @@
         "{domain}/**/*","google/**/*"\n\
     ],\n\
     "exclude": [\n\
         "node_modules"\n\
     ]\n\
 {_CLOSING_BRCK}'
 
+
 bash_run_server_script_go = '#!/bin/bash\n\n\
 if [[ $1 == "debug" ]]\n\
 then\n\
 \techo "Debug mode: $1"\n\
-\tGRPC_VERBOSITY=DEBUG GRPC_TRACE=all ngo run ./server/server.go\n\
+\tGRPC_VERBOSITY=DEBUG GRPC_TRACE=all go run ./server/server.go\n\
+elif [[ $1 == "info" ]]\n\
+then\n\
+\techo "Info Mode: $1"\n\
+\tGRPC_VERBOSITY=INFO GRPC_TRACE=all go run ./server/server.go\n\
 else\n\
-go run ./server/server.go\n\
+\tgo run ./server/server.go\n\
 fi'
 
-logger_js = ''
+logger_js = ""
 
 utils_go = 'package utils\n\n\
 import (\n\
 	"log"\n\
 )\n\n\
 var (\n\
 	WarningLogger *log.Logger\n\
@@ -748,8 +800,8 @@
 }\n\n\
 func (b *GrpcConnBuilder) getContext() context.Context {\n\
 	ctx := b.ctx\n\
 	if ctx == nil {\n\
 		ctx = context.Background()\n\
 	}\n\
 	return ctx\n\
-}'
+}'
```

## sylk/cli/main.py

```diff
@@ -21,81 +21,108 @@
 from datetime import datetime
 from importlib import reload
 import logging
 import argparse
 import os
 from platform import platform
 import subprocess
+from sys import flags
 from inquirer import errors
 import re
 from sylk import __version__, config
 from sylk.architect import SylkArchitect
-from sylk.cli import theme,prompter
-from sylk.commons import helpers,file_system,errors,resources, parser, config as prj_conf, protos
-from sylk.commons.pretty import print_info, print_note, print_version, print_success, print_warning, print_error
+from sylk.cli import theme, prompter
+from sylk.commons import (
+    helpers,
+    file_system,
+    errors,
+    resources,
+    parser,
+    config as prj_conf,
+    protos,
+)
+from sylk.commons.pretty import (
+    print_info,
+    print_note,
+    print_version,
+    print_success,
+    print_warning,
+    print_error,
+)
 from sylk.commons.protos.sylk.SylkField.v1 import SylkField_pb2
-from sylk.cli.commands import call, \
-    extend, \
-    migrate, \
-    new, \
-    build, \
-    generate, \
-    ls, \
-    package as pack, \
-    run, \
-    edit, \
-    template, \
-    config as config_command, \
-    cloud, \
-    plugin
+from sylk.cli.commands import (
+    call,
+    extend,
+    migrate,
+    new,
+    build,
+    generate,
+    ls,
+    package as pack,
+    run,
+    edit,
+    template,
+    config as config_command,
+    cloud,
+    plugin,
+)
 from pathlib import Path
 
 _TEMPLATES = config.configs.sylk_templates
 # _TEMPLATES = []
 # templates_dir = os.path.dirname(os.path.dirname(__file__))+'/commons/templates'
 # for d in file_system.walkDirs(templates_dir):
 #     if d != templates_dir:
 #         for f in file_system.walkFiles(d):
 #             domain = d.split('/')[-1]
 #             template_name = f.split('.')[0]
 #             _TEMPLATES.append(f'@{domain}/{template_name}')
 
+
 def field_exists_validation(new_field, fields, msg):
     if new_field in fields:
         raise errors.SylkProtoError(
-            'Message', f'Field {new_field} already exits under {msg}')
+            "Message", f"Field {new_field} already exits under {msg}"
+        )
     return True
 
+
 def enum_value_validate(answers, current):
     try:
         int(current)
     except Exception:
         raise errors.SylkValidationError(
-            current, reason='Enum Value MUST be an integer value')
+            current, reason="Enum Value MUST be an integer value"
+        )
     return True
 
 
 def validation(answers, current):
-
     if len(current) == 0:
         raise prompter.inquirer_errors.ValidationError(
-            current, reason='Resource name must not be blank')
-    if len(re.findall('\s', current)) > 0:
+            current, reason="Resource name must not be blank"
+        )
+    if len(re.findall("\s", current)) > 0:
         raise prompter.inquirer_errors.ValidationError(
-            current, reason='Resource name must not include blank spaces')
-    if len(re.findall('-', current)) > 0:
+            current, reason="Resource name must not include blank spaces"
+        )
+    if len(re.findall("-", current)) > 0:
         raise prompter.inquirer_errors.ValidationError(
-            current, reason='Resource name must not include hyphens, underscores are allowed')
-    regex = re.compile('[@_!#$%^&*()<>?/\|}{~:]')
-    if(regex.search(current) != None):
+            current,
+            reason="Resource name must not include hyphens, underscores are allowed",
+        )
+    regex = re.compile("[@_!#$%^&*()<>?/\|}{~:]")
+    if regex.search(current) != None:
         raise prompter.inquirer_errors.ValidationError(
-            current, reason='Resource name must not include special charcters')
-    
+            current, reason="Resource name must not include special charcters"
+        )
+
     return True
 
+
 log = logging.getLogger(__name__)
 well_known_type = helpers._WellKnowns
 
 fields_opt = [
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.TYPE_DOUBLE),
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.TYPE_FLOAT),
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.TYPE_INT64),
@@ -104,813 +131,1392 @@
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.TYPE_STRING),
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.TYPE_MESSAGE),
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.TYPE_BYTES),
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.TYPE_ENUM),
 ]
 field_label = [
     SylkField_pb2.SylkFieldLabels.Name(SylkField_pb2.LABEL_OPTIONAL),
-    SylkField_pb2.SylkFieldLabels.Name(SylkField_pb2.LABEL_REPEATED)
+    SylkField_pb2.SylkFieldLabels.Name(SylkField_pb2.LABEL_REPEATED),
 ]
 
-
-
-# sylk_new_q = [
-#     inquirer.List("server", message="Choose server language", choices=[
-#                   ('Python', Language.python), ('Typescript', Language.typescript)], default=Language.python),
-#     inquirer.Checkbox("clients", message="Choose clients languages (Use arrows keys to enable disable a language)", choices=[
-#                       ('Python', Language.python), ('Typescript', Language.typescript)], default=[Language.python]),
-#     inquirer.Text("domain", message="Enter domain name", default='domain'),
-# ]
-
-sylk_g_p_q = [
-    prompter.QText(name="package",message="Enter package name",validate=validation)
-]
 sylk_g_s_q = [
-    prompter.QText(name="service",message="Enter service name",validate=validation)
+    prompter.QText(name="service", message="Enter service name", validate=validation)
 ]
 sylk_g_e_q = [
-    prompter.QText(name="enum",message="Enter enum name",validate=validation)
+    prompter.QText(name="enum", message="Enter enum name", validate=validation)
 ]
 
 
 DEFAULT_PORT = 44880
 
 
 def main(args=None):
     # Print sylk 'Logo'
     print(theme.logo_ascii_art_color)
     # If first run of CLI ask for analytic usage
     if config.configs.first_run:
-        confirm_analytics = prompter.QConfirm(name='analytic',message='We want to gather some basic usage and bug report while you are using sylk.build CLI',color='warning',default=True)
+        confirm_analytics = prompter.QConfirm(
+            name="analytic",
+            message="We want to gather some basic usage and bug report while you are using sylk.build CLI",
+            color="warning",
+            default=True,
+        )
         analytic = prompter.ask_user_question(questions=[confirm_analytics])
         p = Path(__file__).parents[1]
-        hash_token=platform()+':'+datetime.today().isoformat()
+        hash_token = platform() + ":" + datetime.today().isoformat()
 
-        config_file = ''.join(file_system.rFile(file_system.join_path(p,'config.py')))
-        config_file = config_file.replace('token=""','token="{}"'.format(hash_token))
-        file_system.wFile(file_system.join_path(p,'config.py'),content=config_file,overwrite=True)
+        config_file = "".join(file_system.rFile(file_system.join_path(p, "config.py")))
+        config_file = config_file.replace('token=""', 'token="{}"'.format(hash_token))
+        file_system.wFile(
+            file_system.join_path(p, "config.py"), content=config_file, overwrite=True
+        )
 
-        if analytic is None or analytic.get('analytic') == False:
+        if analytic is None or analytic.get("analytic") == False:
             reload(config)
             # helpers.send_analytic_event({'DisabledAnalytic':hash_token})
-            config_file = config_file.replace('analytics=True','analytics=False')
+            config_file = config_file.replace("analytics=True", "analytics=False")
         else:
-            config_file = config_file.replace('analytics=False','analytics=True')
-        config_file = config_file.replace('first_run=True','first_run=False')
-        file_system.wFile(file_system.join_path(p,'config.py'),content=config_file,overwrite=True)
+            config_file = config_file.replace("analytics=False", "analytics=True")
+        config_file = config_file.replace("first_run=True", "first_run=False")
+        file_system.wFile(
+            file_system.join_path(p, "config.py"), content=config_file, overwrite=True
+        )
 
     """
     Main CLI processing, with argpars package.
     """
     # Main cli parser
-    parser = argparse.ArgumentParser(prog='sylk',
-                                     description='Command line interface for the sylk.build package build awesome gRPC micro-services. For more information please visit https://www.sylk.build there you can find additional documentation and tutorials.',
-                                     epilog=f'For more information see - https://docs.sylk.build | Created with love by Amit Shmulevitch. 2022 © sylk.build [{__version__.__version__}]')
+    parser = argparse.ArgumentParser(
+        prog="sylk",
+        description="Command line interface for the sylk.build package build awesome gRPC micro-services. For more information please visit https://www.sylk.build there you can find additional documentation and tutorials.",
+        epilog=f"For more information see - https://docs.sylk.build | Created with love by Amit Shmulevitch. 2022 © sylk.build [{__version__.__version__}]",
+    )
 
     # parser.add_argument('test', help='test')
     # Instantiating sub parsers object
-    subparsers = parser.add_subparsers(dest='command',title='command',
-        help='Main modules to interact with sylk CLI.')
+    subparsers = parser.add_subparsers(
+        dest="command", title="command", help="Main modules to interact with sylk CLI."
+    )
     # subparsers.required = True
 
-
     """Cloud commands"""
-    parser_login = subparsers.add_parser('login', help='Login to sylk cloud organziation')
-    parser_login.add_argument('organization', help='Set the login by organization id')
-
-    parser_cloud = subparsers.add_parser('registry', help='Interact with sylk\'s cloud API')
-    parser_cloud.add_argument('project_id', help='Set you sylk cli to default organization via personal access token')
-    group_cloud = parser_cloud.add_argument_group('Projects')
-    group_cloud.add_argument('action', help='Pull / Push / Build a sylk project',default='pull',choices=['pull','push','build'])
+    parser_login = subparsers.add_parser(
+        "login", help="Login to sylk cloud organziation"
+    )
+    parser_login.add_argument("organization", help="Set the login by organization id")
+
+    parser_cloud = subparsers.add_parser(
+        "registry", help="Interact with sylk's cloud API"
+    )
+    parser_cloud.add_argument(
+        "project_id",
+        help="Set you sylk cli to default organization via personal access token",
+    )
+    group_cloud = parser_cloud.add_argument_group("Projects")
+    group_cloud.add_argument(
+        "action",
+        help="Pull / Push / Build a sylk project",
+        default="pull",
+        choices=["pull", "push", "build"],
+    )
     # group_cloud.add_argument('push', help='Set you sylk cli to default organization via personal access token')
 
-
     """New command"""
-    parser_new = subparsers.add_parser('new', help='Create new project')
-    parser_new.add_argument('project', help='Project name')
-    parser_new.add_argument('-p', '--path', required=False,
-                            help='Path for the project root directory')
-    parser_new.add_argument('--port', default=DEFAULT_PORT,
-                            required=False, help='Port server will run on')
-    parser_new.add_argument('--host', default='localhost',
-                            required=False, help='Host name for server')
-    parser_new.add_argument('--domain',
-                            required=False, help='Project domain')
-    parser_new.add_argument('-s','--server',
-                            required=False, help='Server language')
-    parser_new.add_argument('-c','--clients', nargs='*',
-                            required=False, help='Clients language list seprated by spaces')
-    parser_new.add_argument('--template', default=_TEMPLATES[0] if len(_TEMPLATES) > 0 else None,
-                            required=False, help='Create new project based on template')
-    parser_new.add_argument('--project-id', default=None,
-                            required=False, help='The project id from sylk.build cloud platform')
-
-    parser_n = subparsers.add_parser('n', help='A shortend for new commands')
-    parser_n.add_argument('project', help='Project name')
-    parser_n.add_argument('-p', '--path', required=False,
-                          help='Path for the project root directory')
-    parser_n.add_argument('--port', default=DEFAULT_PORT,
-                            required=False, help='Port server will run on')
-    parser_n.add_argument('--host', default='localhost',
-                            required=False, help='Host name for server')
-    parser_n.add_argument('--domain',
-                            required=False, help='Project domain')
-    parser_n.add_argument('-s','--server',
-                            required=False, help='Server language')
-    parser_n.add_argument('-c','--clients', nargs='*',
-                            required=False, help='Clients language list seprated by spaces')
-    parser_n.add_argument('--template', choices=_TEMPLATES,default=_TEMPLATES[0] if len(_TEMPLATES) > 0 else None,
-                            required=False, help='Create new project based on template')
-    parser_n.add_argument('--project-id', default=None,
-                            required=False, help='The project id from sylk.build cloud platform')
-    
+    parser_new = subparsers.add_parser("new", help="Create new project")
+    parser_new.add_argument("project", help="Project name")
+    parser_new.add_argument(
+        "-p", "--path", required=False, help="Path for the project root directory"
+    )
+    parser_new.add_argument(
+        "--port", default=DEFAULT_PORT, required=False, help="Port server will run on"
+    )
+    parser_new.add_argument(
+        "--host", default="localhost", required=False, help="Host name for server"
+    )
+    parser_new.add_argument("--domain", required=False, help="Project domain")
+    parser_new.add_argument("-s", "--server", required=False, help="Server language")
+    parser_new.add_argument(
+        "-c",
+        "--clients",
+        nargs="*",
+        required=False,
+        help="Clients language list seprated by spaces",
+    )
+    parser_new.add_argument(
+        "--template",
+        default=_TEMPLATES[0] if len(_TEMPLATES) > 0 else None,
+        required=False,
+        help="Create new project based on template",
+    )
+    parser_new.add_argument(
+        "--project-id",
+        default=None,
+        required=False,
+        help="The project id from sylk.build cloud platform",
+    )
+    parser_new.add_argument(
+        "--token",
+        default=None,
+        required=False,
+        help="The access token for sylk platform needed if used with --project-id",
+    )
+    parser_new.add_argument(
+        "--base-protos", default="protos", required=False, help="The base sub-directory under root project which will hold all protobuf files"
+    )
+    parser_new.add_argument(
+        "--format", default="json", required=False, choices=['json','textpb'], help="The sylk local schema format, for large schemas it is recommended to save the schema into protobuf with 'textpb' option"
+    )
+
+    parser_n = subparsers.add_parser("n", help="A shortand for new commands")
+    parser_n.add_argument("project", help="Project name")
+    parser_n.add_argument(
+        "-p", "--path", required=False, help="Path for the project root directory"
+    )
+    parser_n.add_argument(
+        "--port", default=DEFAULT_PORT, required=False, help="Port server will run on"
+    )
+    parser_n.add_argument(
+        "--host", default="localhost", required=False, help="Host name for server"
+    )
+    parser_n.add_argument("--domain", required=False, help="Project domain")
+    parser_n.add_argument("-s", "--server", required=False, help="Server language")
+    parser_n.add_argument(
+        "-c",
+        "--clients",
+        nargs="*",
+        required=False,
+        help="Clients language list seprated by spaces",
+    )
+    parser_n.add_argument(
+        "--template",
+        choices=_TEMPLATES,
+        default=_TEMPLATES[0] if len(_TEMPLATES) > 0 else None,
+        required=False,
+        help="Create new project based on template",
+    )
+    parser_n.add_argument(
+        "--project-id",
+        default=None,
+        required=False,
+        help="The project id from sylk.build cloud platform",
+    )
+    parser_n.add_argument(
+        "--token",
+        default=None,
+        required=False,
+        help="The access token for sylk platform needed if used with --project-id",
+    )
+    parser_n.add_argument(
+        "--base-protos", default="protos", required=False, help="The base sub-directory under root project which will hold all protobuf files"
+    )
+    parser_n.add_argument(
+        "--format", default="json", required=False, choices=['json','textpb'], help="The sylk local schema format, for large schemas it is recommended to save the schema into protobuf with 'textpb' option"
+    )
+
     """Generate command"""
 
     parser_generate = subparsers.add_parser(
-        'generate', help='Generate resources commands')
-    parser_generate.add_argument('resource', choices=[
-                                 'service', 'package', 'message', 'rpc', 'enum'], help='Generate a sylk.build resource from specific resource type')
-    parser_generate.add_argument('-n', '--name', help='Name for the resource')
-    parser_generate.add_argument('-p', '--parent', help='Name for the parent resource')
-    parser_generate.add_argument('--build', action='store_true',
-                            required=False, help='Auto build resources')
-
-    parser_g = subparsers.add_parser(
-        'g', help='A shortend for generate commands')
-    parser_g.add_argument('resource', choices=[
-                          's', 'p', 'm', 'r', 'e'], help='Generate a sylk.build resource from specific resource type, for e.x "s" stands for "service"')
-    parser_g.add_argument('-n', '--name', help='Name for the resource')
-    parser_g.add_argument('-p', '--parent', help='Name for the parent resource')
-    parser_g.add_argument('--build', action='store_true',
-                            required=False, help='Auto build resources')
+        "generate", help="Generate resources commands"
+    )
+    parser_generate.add_argument(
+        "resource",
+        choices=["service", "package", "message", "rpc", "enum"],
+        help="Generate a sylk.build resource from specific resource type",
+    )
+    parser_generate.add_argument(
+        "name",
+        help="The resource path for ex' google/protobuf/Timestamp to create 'Timestamp' message under 'google.protobuf' package. note that the path can be filesystem like or proto path with '.' seperating the namespaces.",
+    )
+    # parser_generate.add_argument("-n", "--name", help="Name for the resource")
+    parser_generate.add_argument("-p", "--parent", help="Name for the parent resource if creating an 'inline' resource")
+    parser_generate.add_argument(
+        "-d",
+        "--deps",nargs='*', default=[],required=False, help="The resource dependencies"
+    )
+    parser_generate.add_argument(
+        "-t",
+        "--tag", default=None,required=False, help="The filename to host the protobuf resource"
+    )
+    parser_generate.add_argument(
+        "--build", action="store_true", required=False, help="Auto build resources"
+    )
+
+    parser_g = subparsers.add_parser("g", help="A shortand for generate commands")
+    parser_g.add_argument(
+        "resource",
+        choices=["s", "p", "m", "r", "e"],
+        help='Generate a sylk.build resource from specific resource type, for e.x "s" stands for "service"',
+    )
+    parser_g.add_argument(
+        "name",
+        help="The resource path for ex' google/protobuf/Timestamp to create 'Timestamp' message under 'google.protobuf' package. note that the path can be filesystem like or proto path with '.' seperating the namespaces.",
+    )
+    # parser_g.add_argument("-n", "--name", help="Name for the resource")
+    parser_g.add_argument("-p", "--parent", help="Name for the parent resource if creating an 'inline' resource")
+    parser_g.add_argument(
+        "-d",
+        "--deps", nargs='*',default=[], required=False, help="The resource dependencies"
+    )
+    parser_g.add_argument(
+        "-t",
+        "--tag", default=None,required=False, help="The filename to host the protobuf resource"
+    )
+    parser_g.add_argument(
+        "--build", action="store_true", required=False, help="Auto build resources"
+    )
 
     """List command"""
 
-    parser_list = subparsers.add_parser('ls', help='List resources commands')
+    parser_list = subparsers.add_parser("ls", help="List resources commands")
 
     parser_list.add_argument(
-        '--full-name',metavar='fullName',required=False, help='Display a resource report for specific resoource by passing in a full name, for e.x domain.test.GetTest will return "GetTest" (RPC) which under "test" (service)')
-    parser_list.add_argument('-t', '--type', choices=['service', 'package', 'message',
-                             'rpc', 'enum','extension'], help='List a sylk.build resource from specific resource type')
-    parser_list.add_argument('-d', '--dependencies',action='store_true', help='List the dependencies graph for your project')
-    parser_list.add_argument('-c', '--cloud',action='store_true', help='List the cloud project for your sylk.build account')
-    parser_list.add_argument('--templates',action='store_true', help='List all available templates')
-    
+        "--full-name",
+        metavar="fullName",
+        required=False,
+        help='Display a resource report for specific resoource by passing in a full name, for e.x domain.test.GetTest will return "GetTest" (RPC) which under "test" (service)',
+    )
+    parser_list.add_argument(
+        "-t",
+        "--type",
+        choices=["service", "package", "message", "rpc", "enum", "extension"],
+        help="List a sylk.build resource from specific resource type",
+    )
+    parser_list.add_argument(
+        "-d",
+        "--dependencies",
+        action="store_true",
+        help="List the dependencies graph for your project",
+    )
+    parser_list.add_argument(
+        "-c",
+        "--cloud",
+        action="store_true",
+        help="List the cloud project for your sylk.build account",
+    )
+    parser_list.add_argument(
+        "--templates", action="store_true", help="List all available templates"
+    )
+
     """Package command"""
-    
+
     parser_pkg = subparsers.add_parser(
-        'package', help='Attach a package into other services / package')
-    parser_pkg.add_argument('source', help='Package full name')
-    parser_pkg.add_argument('target', help='Package path or service name')
-    parser_pkg.add_argument('-r','--remove',action='store_true', help='Package path or service name')
+        "package", help="Attach a package into other services / package"
+    )
+    parser_pkg.add_argument("source", help="Package full name")
+    parser_pkg.add_argument("target", help="Package path or service name")
+    parser_pkg.add_argument(
+        "-r", "--remove", action="store_true", help="Package path or service name"
+    )
 
     """Edit command"""
-    
-    parser_edit = subparsers.add_parser(
-        'edit', help='Edit any sylk.build resource')
-    parser_edit.add_argument('name', help='Resource full name')
-    parser_edit.add_argument('-a','--action',choices=['add','remove','modify'], help='Choose which action to preform on resource')
-    parser_edit.add_argument('--sub-actions',nargs='*', help='Choose which sub-action to preform on resource')
+
+    parser_edit = subparsers.add_parser("edit", help="Edit any sylk.build resource")
+    parser_edit.add_argument("name", help="Resource full name")
+    parser_edit.add_argument(
+        "-a",
+        "--action",
+        choices=["add", "remove", "modify"],
+        help="Choose which action to preform on resource",
+    )
+    parser_edit.add_argument(
+        "--sub-actions",
+        nargs="*",
+        help="Choose which sub-action to preform on resource",
+    )
 
     """Template command"""
     parser_template = subparsers.add_parser(
-        'template', help='Create a template from your sylk.json / proto files directory / sylk.template.py')
-    parser_template.add_argument('path', help='Path for sylk.json / protos files directory / sylk.template.py')
-    parser_template.add_argument('-c','--code', action='store_true', help='Create a template including code files')
-    parser_template.add_argument('--out-path', help='Specify the template file location, defaulted to root project dir')
-    parser_template.add_argument('--template-name', help='Specify the template name, defaulted to project package name')
-    parser_template.add_argument('--load',action='store_true', help='Initalize a template')
+        "template",
+        help="Create a template from your sylk.json / proto files directory / sylk.template.py",
+    )
+    parser_template.add_argument(
+        "path", help="Path for sylk.json / protos files directory / sylk.template.py"
+    )
+    parser_template.add_argument(
+        "-c",
+        "--code",
+        action="store_true",
+        help="Create a template including code files",
+    )
+    parser_template.add_argument(
+        "--out-path",
+        help="Specify the template file location, defaulted to root project dir",
+    )
+    parser_template.add_argument(
+        "--template-name",
+        help="Specify the template name, defaulted to project package name",
+    )
+    parser_template.add_argument(
+        "--load", action="store_true", help="Initalize a template"
+    )
 
     """Build command"""
-    parser_build = subparsers.add_parser(
-        'build', help='Build project resources')
-    parser_build.add_argument('--protos',action='store_true', help='Build resources protos files only')
-    parser_build.add_argument('--code',action='store_true', help='Build resources code classes files only')
+    parser_build = subparsers.add_parser("build", help="Build project resources")
+    parser_build.add_argument(
+        "--protos", action="store_true", help="Build resources protos files only"
+    )
+    parser_build.add_argument(
+        "--code", action="store_true", help="Build resources code classes files only"
+    )
 
     """Call command"""
-    parser_call = subparsers.add_parser(
-        'call', help='Call a RPC')
-    parser_call.add_argument('service', help='Service full path')
-    parser_call.add_argument('rpc', help='RPC name')
-    parser_call.add_argument('--debug',action='store_true', help='Debug the call process')
-    parser_call.add_argument('--host',default='localhost', help='Pass a host of service')
-    parser_call.add_argument('--port',default=DEFAULT_PORT, help='Pass a port for service')
-    parser_call.add_argument('--timeout',default=10, help='An optional duration of time in seconds to allow for the RPC')
+    parser_call = subparsers.add_parser("call", help="Call a RPC")
+    parser_call.add_argument("service", help="Service full path")
+    parser_call.add_argument("rpc", help="RPC name")
+    parser_call.add_argument(
+        "--debug", action="store_true", help="Debug the call process"
+    )
+    parser_call.add_argument(
+        "--host", default="localhost", help="Pass a host of service"
+    )
+    parser_call.add_argument(
+        "--port", default=DEFAULT_PORT, help="Pass a port for service"
+    )
+    parser_call.add_argument(
+        "--timeout",
+        default=10,
+        help="An optional duration of time in seconds to allow for the RPC",
+    )
 
     """Extend command"""
-    
+
     parser_extend = subparsers.add_parser(
-        'extend', help='Extend any sylk.build resource')
-    parser_extend.add_argument('name', help='Resource full name')
-    parser_extend.add_argument('--extension', help='Extension full name')
+        "extend", help="Extend any sylk.build resource"
+    )
+    parser_extend.add_argument("name", help="Resource full name")
+    parser_extend.add_argument("--extension", help="Extension full name")
 
     """Run server"""
     parser_run_server = subparsers.add_parser(
-        'run', help='Run server on current active project')
+        "run", help="Run server on current active project"
+    )
     parser_run_server.add_argument(
-        '--debug',action='store_true', help='Start the gRPC server with debug mode attached')
-
+        "--log-level",
+        choices=['debug','info'],
+        help="Start the gRPC server with debug mode attached",
+    )
 
     """Migrate command"""
-    praser_migrate = subparsers.add_parser('migrate',help='Migrate existing gRPC project to sylk.build project')
-    praser_migrate.add_argument('protos',help='Relative path of proto directory')
-    praser_migrate.add_argument('--format',choices=['json','python'],help='Relative path of proto directory')
-    praser_migrate.add_argument('--server-language',default='python',choices=['python','typescript'],help='Chose a server language for migration')
-    praser_migrate.add_argument('--clients',nargs='*',default=['python'],choices=['python','typescript'],help='Enter one or more clients')
+    praser_migrate = subparsers.add_parser(
+        "migrate", help="Migrate existing gRPC project to sylk.build project"
+    )
+    praser_migrate.add_argument("protos", help="Relative path of proto directory")
+    praser_migrate.add_argument(
+        "--format", choices=["json", "python"], help="Relative path of proto directory"
+    )
+    praser_migrate.add_argument(
+        "--server-language",
+        default="python",
+        choices=["python", "typescript"],
+        help="Chose a server language for migration",
+    )
+    praser_migrate.add_argument(
+        "--clients",
+        nargs="*",
+        default=["python"],
+        choices=["python", "typescript"],
+        help="Enter one or more clients",
+    )
 
     """Configs command"""
     parse_configs = subparsers.add_parser(
-        'configs', help='Display sylk.build Configurations')
-    parse_configs.add_argument('--edit',action="store_true", help='Edit configurations')
-    parse_configs.add_argument('--dict',action="store_true",default=False, help='Display all configs of of current project in dictionary mode')
-    parse_configs.add_argument('--token', action="store_true",help="Refresh 'Personal Access Token' with new one")
-
+        "configs", help="Display sylk.build Configurations"
+    )
+    parse_configs.add_argument(
+        "--edit", action="store_true", help="Edit configurations"
+    )
+    parse_configs.add_argument(
+        "--dict",
+        action="store_true",
+        default=False,
+        help="Display all configs of of current project in dictionary mode",
+    )
+    parse_configs.add_argument(
+        "--token",
+        action="store_true",
+        help="Refresh 'Personal Access Token' with new one",
+    )
 
     """Plugins command"""
-    parser_plugin = subparsers.add_parser('plugin', help='Sylk plugin command')
-    plugin_subparser = parser_plugin.add_subparsers(dest='action')
+    parser_plugin = subparsers.add_parser("plugin", help="Sylk plugin command")
+    plugin_subparser = parser_plugin.add_subparsers(dest="action")
+
+    run_plugin_parser = plugin_subparser.add_parser("run")
+    run_plugin_parser.add_argument(
+        "plugin",
+        nargs="*",
+        metavar="plugin-name",
+        help="The executable path for protoc plugin",
+    )
+    run_plugin_parser.add_argument(
+        "--protos", nargs="*", help="List of proto files relative to current directory"
+    )
+    run_plugin_parser.add_argument(
+        "-d",
+        "--dir",
+        help="The plugin base directory, if not specified it will lookup sylk base plugins",
+    )
+    run_plugin_parser.add_argument(
+        "--out-dir",
+        default=".",
+        help="The plugin output directory",
+    )
+    run_plugin_parser.add_argument(
+        "--opt",
+        default="",
+        help="The plugin options, in a text format e.g: some_key=somevalue,some_other_key=2",
+    )
+    run_plugin_parser.add_argument(
+        "-I",
+        nargs='*',
+        default=[],
+        help="Include directories",
+    )
 
-    run_plugin_parser = plugin_subparser.add_parser('run')
-    run_plugin_parser.add_argument('plugin',nargs='*',metavar='plugin-name',help='The executable path for protoc plugin')
-    run_plugin_parser.add_argument('--protos',nargs='*',help='List of proto files relative to current directory')
-    run_plugin_parser.add_argument('-d','--dir',help='The plugin base directory, if not specified it will lookup sylk base plugins')
-  
 
     # Utils
-    parser.add_argument('-v', '--version', action='store_true',
-                        help='Display sylk.build current installed version')
+    parser.add_argument(
+        "-v",
+        "--version",
+        action="store_true",
+        help="Display sylk.build current installed version",
+    )
 
-    parser.add_argument('-e', '--expand', action='store_true',
-                        help='Expand optional fields for each resource')
+    parser.add_argument(
+        "-e",
+        "--expand",
+        action="store_true",
+        help="Expand optional fields for each resource",
+    )
 
     # Log level optional argument
     parser.add_argument(
-        '--loglevel', default='ERROR', help='Log level',
-        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL', ])
+        "--loglevel",
+        default="ERROR",
+        help="Log level",
+        choices=[
+            "DEBUG",
+            "INFO",
+            "WARNING",
+            "ERROR",
+            "CRITICAL",
+        ],
+    )
 
     parser.add_argument(
-        '--verbose', action='store_true', help='Control on verbose logging')
-    
+        "--verbose", action="store_true", help="Control on verbose logging"
+    )
+
     parser.add_argument(
-        '-u','--undo', action='store_true', help='Undo last sylk.json modification')
+        "-u", "--undo", action="store_true", help="Undo last sylk.json modification"
+    )
     parser.add_argument(
-        '-r','--redo', action='store_true', help='Redo sylk.json modification, if undo has been made.')
-
+        "-r",
+        "--redo",
+        action="store_true",
+        help="Redo sylk.json modification, if undo has been made.",
+    )
 
-    parser.add_argument('--purge',action='store_true',help='Purge .sylk/contxt.json file')
+    parser.add_argument(
+        "--purge", action="store_true", help="Purge .sylk/contxt.json file"
+    )
     # Parse all command line arguments
     args = parser.parse_args(args)
-    
+
     # New sub-parsers
-    if hasattr(args,"command"):
-        if args.command == 'plugin':
-            if args.action == 'run':
+    if hasattr(args, "command"):
+        if args.command == "plugin":
+            if args.action == "run":
                 plugin.run(args)
             else:
-                print_error("Action '{0}' is not supported yet on {1}".format(args.action,args.command))
-            
+                print_error(
+                    "Action '{0}' is not supported yet on {1}".format(
+                        args.action, args.command
+                    )
+                )
+
     log.setLevel(args.loglevel)
     log.debug(args)
 
     if config.configs.analytics:
         helpers.send_analytic_event(args)
 
-    # Logging version
-    if args.version:
-        print_version(__version__.__version__)
-        exit(0)
-
     if args.verbose:
-        print_note(args,True,'Argument passed to sylk CLI')
+        print_note(args, True, "Argument passed to sylk CLI")
 
-    if hasattr(args, 'project'):
+    if hasattr(args, "project"):
         """New command process"""
-        sylk_project_config = prj_conf.parse_project_config(os.getcwd())
-
+        sylk_project_config = prj_conf.parse_project_config(os.getcwd(),proto=True)
         # print_info(args,True)
-        new.create_new_project(args.project,args.path,args.host,args.port,args.server,args.clients,domain=args.domain,template=args.template,project_id=args.project_id,configs=sylk_project_config)
+        new.create_new_project(
+            args.project,
+            args.path,
+            args.host,
+            args.port,
+            args.server,
+            args.clients,
+            domain=args.domain,
+            template=args.template,
+            project_id=args.project_id,
+            configs=sylk_project_config,
+            base_proto_path=args.base_protos,
+            format=args.format,
+            token=args.token
+        )
         exit(0)
     else:
         if helpers.check_if_under_project():
-            
             sylk_project_config = prj_conf.parse_project_config(os.getcwd())
             # print_info(sylk_project_config,True)
-            sylk_json_path = file_system.join_path(os.getcwd(), 'sylk.json')
-
+            sylk_json_path = file_system.join_path(os.getcwd(), "sylk.json")
+            sylk_format = sylk_project_config.get('format','json')
             try:
-                # print_note(sylk_json_path)
-                SYLK_JSON = file_system.rFile(sylk_json_path, json=True)
+                SYLK_JSON = file_system.rFile(sylk_json_path, json=True, flags='rb' if sylk_format == 'json' else 'r')
                 SYLK_JSON = helpers.SylkJson(sylk_json=SYLK_JSON)
             except Exception as e:
                 print_error("Error - sylk.json file is not valid !")
                 print_error(e)
                 exit(1)
-                
+
             if args.expand:
-                print_note('Creating resource in expanded mode')
+                print_note("Creating resource in expanded mode")
 
             if args.verbose:
-                print_note(SYLK_JSON._sylk_json, True, 'sylk.json')
+                print_note(SYLK_JSON._sylk_json, True, "sylk.json")
 
             """Cloud commands"""
-            if hasattr(args, 'project_id'):
-                sylkCloud = cloud.SylkCloud(token=sylk_project_config.get('token'),SylkJson=SYLK_JSON)
-                if args.action == 'build':
+            if hasattr(args, "project_id"):
+                sylkCloud = cloud.SylkCloud(
+                    token=sylk_project_config.get("token"), SylkJson=SYLK_JSON
+                )
+                if args.action == "build":
                     sylkCloud.buildProject()
-                elif args.action == 'pull':
-                    sylkCloud.pull_project(project_id=args.project_id,overwrite=True)
+                elif args.action == "pull":
+                    sylkCloud.pull_project(project_id=args.project_id, overwrite=True)
                 else:
-                    print_error('Pushing local project to registry is not supported yet.')            
+                    print_error(
+                        "Pushing local project to registry is not supported yet."
+                    )
                     exit(1)
-                    
-            elif hasattr(args, 'organization'):
+
+            elif hasattr(args, "organization"):
                 sylk_project_config = prj_conf.parse_project_config(os.getcwd())
                 # print_note(sylk_project_config,True)
                 print_info(f'Logging into "{args.organization}"')
-                cloud.SylkCloud(sylk_project_config.get('token'),args.organization,None)
+                cloud.SylkCloud(
+                    sylk_project_config.get("token"), args.organization, None
+                )
                 print_success(f'Logged into: "{args.organization}"')
 
-            elif hasattr(args, 'resource'):
+            elif hasattr(args, "resource"):
                 """Generate command process"""
 
                 # Small validations:
                 # Project name
-                if SYLK_JSON.project.get('name') is None:
+                if SYLK_JSON.project.get("name") is None:
                     print_warning("Project name value is not specified !")
-                # Project domain 
+                # Project domain
                 if SYLK_JSON.domain is None:
                     print_warning("Project domain value is not specified !")
 
                 namespace = parse_namespace_resource(
-                    args.resource, SYLK_JSON, args.parent)
-                resource_name = f' [{args.name}]' if args.name is not None else ''
+                    args.resource, args.name, SYLK_JSON
+                )
                 
-                print_info(
-                    f"Generating new resource '{namespace[0]}'{resource_name}")
+                resource_name = f" [{args.name}]" if args.name is not None else ""
+
+                print_info(f"Generating new resource '{namespace[0]}'{resource_name}")
                 results = prompter.ask_user_question(
-                    questions=namespace[1] if args.name is None else namespace[1][1:])
+                    questions=namespace[1] if args.name is None else namespace[1][1:]
+                )
                 if results is None:
-                    print_error('Must answer all questions')
+                    print_error("Must answer all questions")
                     exit(1)
                 elif args.name is not None:
                     results[namespace[0]] = args.name
                 ARCHITECT = SylkArchitect(
-                    path=sylk_json_path,domain=SYLK_JSON.domain,project_name=SYLK_JSON.project.get('name'))
-                if namespace[0] == 'package':
-                    generate.package(results,SYLK_JSON,ARCHITECT,args.expand,args.verbose)
-                
-                elif namespace[0] == 'service':
-                    generate.service(results,SYLK_JSON,ARCHITECT,args.expand,args.verbose)
-                
-                elif namespace[0] == 'message':
-                    generate.message(results,SYLK_JSON,ARCHITECT,args.expand,args.verbose,args.parent)
-
-                elif namespace[0] == 'rpc':
-                    generate.rpc(results,SYLK_JSON,ARCHITECT,parent=args.parent,expand=args.expand)
-
-                elif namespace[0] == 'enum':
-                    generate.enum(results,SYLK_JSON,ARCHITECT,parent=args.parent)
+                    path=sylk_json_path,
+                    domain=SYLK_JSON.domain,
+                    project_name=SYLK_JSON.project.get("name"),
+                )
+                if namespace[0] == "package":
+                    generate.package(
+                        results,
+                        SYLK_JSON,
+                        ARCHITECT,
+                        args.expand,
+                        args.verbose,
+                        args.deps
+                    )
+
+                elif namespace[0] == "service":
+                    generate.service(
+                        results,
+                        SYLK_JSON,
+                        ARCHITECT,
+                        args.expand,
+                        args.verbose,
+                        args.deps,
+                        args.tag
+                    )
+
+                elif namespace[0] == "message":
+                    generate.message(
+                        results,
+                        SYLK_JSON,
+                        ARCHITECT,
+                        args.expand,
+                        args.verbose,
+                        args.parent,
+                        # generate_package_func=generate.package,
+                        args.deps,
+                        args.tag
+                    )
+
+                elif namespace[0] == "rpc":
+                    generate.rpc(
+                        results,
+                        SYLK_JSON,
+                        ARCHITECT,
+                        parent=args.parent,
+                        expand=args.expand,
+                        deps=args.deps
+                    )
+
+                elif namespace[0] == "enum":
+                    generate.enum(
+                        results,
+                        SYLK_JSON,
+                        ARCHITECT,
+                        parent=args.parent,
+                        generate_package_func=generate.package,
+                        tag=args.tag
+                    )
 
                 if args.build:
                     build.build_all(sylk_json_path)
 
-            elif hasattr(args, 'source') and hasattr(args, 'target'):
+            elif hasattr(args, "source") and hasattr(args, "target"):
                 """Package command process"""
 
                 if args.remove:
-                    pack.remove_import(args.source,args.target,sylk_json_path,SYLK_JSON)
+                    pack.remove_import(
+                        args.source, args.target, sylk_json_path, SYLK_JSON
+                    )
                 else:
-                    pack.import_package(args.source,args.target,sylk_json_path,SYLK_JSON)
-            
+                    pack.import_package(
+                        args.source, args.target, sylk_json_path, SYLK_JSON
+                    )
+
             elif args.undo:
                 """Undo command process"""
 
-                path = sylk_json_path.replace('sylk.json','.sylk/cache')
-            
+                path = sylk_json_path.replace("sylk.json", ".sylk/cache")
+
                 cache_files = file_system.walkFiles(path)
                 cache_files.sort()
-                last_save = cache_files[len(cache_files)-2 if len(cache_files) > 1 else 1]
-                print_note({'cache':cache_files,'action':'undo','active':last_save},pprint=True)
-                
+                last_save = cache_files[
+                    len(cache_files) - 2 if len(cache_files) > 1 else 1
+                ]
+                print_note(
+                    {"cache": cache_files, "action": "undo", "active": last_save},
+                    pprint=True,
+                )
+
                 # ARCHITECT = SylkArchitect(
-                    # path=sylk_json_path,save=last_save)
+                # path=sylk_json_path,save=last_save)
                 # ARCHITECT.Save(undo_save=True)
             elif args.redo:
                 """Redo command process"""
-                
-                path = sylk_json_path.replace('sylk.json','.sylk/cache')
-            
+
+                path = sylk_json_path.replace("sylk.json", ".sylk/cache")
+
                 cache_files = file_system.walkFiles(path)
                 cache_files.sort(reverse=True)
                 # logging.error(cache_files)
                 # ARCHITECT = SylkArchitect(
                 #     path=sylk_json_path,save=cache_files[len(cache_files)-2 if len(cache_files) > 1 else 1])
                 # ARCHITECT.Save()
-            elif hasattr(args, 'protos') and hasattr(args, 'code'):
+            elif hasattr(args, "protos") and hasattr(args, "code"):
                 """Build command process"""
 
                 if args.code:
                     print_info("🔨 Building project resources code files")
                     build.build_code(sylk_json_path)
                 elif args.protos:
                     print_info("🔨 Building project resources proto's files")
                     build.build_protos(sylk_json_path)
                 elif args.code == False and args.protos == False:
                     print_info("🔨 Building project resources")
                     build.build_all(sylk_json_path)
-                    
+
             elif args.purge:
                 """Purge command process"""
 
-                temp_path = sylk_json_path.replace('sylk.json','.sylk/context.json')
-                confirm_purge = prompter.QConfirm(name='confirm',message='You are about to purge the sylk context are you sure?',default=False)
+                temp_path = sylk_json_path.replace("sylk.json", ".sylk/context.json")
+                confirm_purge = prompter.QConfirm(
+                    name="confirm",
+                    message="You are about to purge the sylk context are you sure?",
+                    default=False,
+                )
                 confirm = prompter.ask_user_question(questions=[confirm_purge])
-                if confirm.get('confirm'):
+                if confirm.get("confirm"):
                     file_system.removeFile(temp_path)
                     print_success("Purged sylk context !")
                 else:
                     print_warning("Cancelling purge for sylk context")
-            elif hasattr(args,'debug') and hasattr(args, 'rpc') == False:
+            elif hasattr(args, "log_level") and hasattr(args, "rpc") == False:
                 """Run command process"""
 
-                run.run_server(SYLK_JSON,args.debug)
+                run.run_server(SYLK_JSON, args.log_level)
 
-            elif hasattr(args, 'name') and hasattr(args,'extension') == False:
+            elif hasattr(args, "name") and hasattr(args, "extension") == False:
                 """Edit command process"""
 
-                resource = parse_name_to_resource(args.name,SYLK_JSON)
-                type = resource.get('type')
+                resource = parse_name_to_resource(args.name, SYLK_JSON)
+                type = resource.get("type")
                 ARCHITECT = SylkArchitect(
-                    path=sylk_json_path,domain=SYLK_JSON.domain,project_name=SYLK_JSON.project.get('name'))
-                if type == 'packages':
-                    edit.edit_package(resource,args.action,SYLK_JSON,ARCHITECT)
-                elif type == 'service':
-                    edit.edit_service(resource,args.action,SYLK_JSON,ARCHITECT)
-                elif type == 'descriptors':
-                    kind = resource.get('kind')
+                    path=sylk_json_path,
+                    domain=SYLK_JSON.domain,
+                    project_name=SYLK_JSON.project.get("name"),
+                )
+                print(type)
+
+                if type == "packages":
+                    edit.edit_package(resource, args.action, SYLK_JSON, ARCHITECT)
+                elif type == "service":
+                    edit.edit_service(resource, args.action, SYLK_JSON, ARCHITECT)
+                elif type == "descriptor":
+                    kind = resource.get("kind")
                     if kind == resources.ResourceKinds.enum.value:
-                        edit.edit_enum(resource,action=args.action,sub_actions=args.sub_actions,sylk_json=SYLK_JSON,architect=ARCHITECT,expand=args.expand)
+                        edit.edit_enum(
+                            resource,
+                            action=args.action,
+                            sub_actions=args.sub_actions,
+                            sylk_json=SYLK_JSON,
+                            architect=ARCHITECT,
+                            expand=args.expand,
+                        )
                     elif kind == resources.ResourceKinds.enum_value.value:
-                        edit.edit_enum_value(resource,args.action,SYLK_JSON,ARCHITECT)
+                        edit.edit_enum_value(
+                            resource, args.action, SYLK_JSON, ARCHITECT
+                        )
                     elif kind == resources.ResourceKinds.field.value:
-                        edit.edit_field(resource,action=args.action,sub_actions=args.sub_actions,sylk_json=SYLK_JSON,architect=ARCHITECT,expand=args.expand)
+                        edit.edit_field(
+                            resource,
+                            action=args.action,
+                            sub_actions=args.sub_actions,
+                            sylk_json=SYLK_JSON,
+                            architect=ARCHITECT,
+                            expand=args.expand,
+                        )
                     elif kind == resources.ResourceKinds.message.value:
-                        edit.edit_message(resource=resource,action=args.action,sub_actions=args.sub_actions,sylk_json=SYLK_JSON,architect=ARCHITECT,expand=args.expand)
+                        edit.edit_message(
+                            resource=resource,
+                            action=args.action,
+                            sub_actions=args.sub_actions,
+                            sylk_json=SYLK_JSON,
+                            architect=ARCHITECT,
+                            expand=args.expand,
+                        )
                     elif kind == resources.ResourceKinds.method.value:
-                        edit.edit_rpc(resource=resource,action=args.action,sub_actions=args.sub_actions,sylk_json=SYLK_JSON,architect=ARCHITECT,expand=args.expand)
-            
-            elif hasattr(args,'name') and hasattr(args,'extension'):
+                        edit.edit_rpc(
+                            resource=resource,
+                            action=args.action,
+                            sub_actions=args.sub_actions,
+                            sylk_json=SYLK_JSON,
+                            architect=ARCHITECT,
+                            expand=args.expand,
+                        )
+
+            elif hasattr(args, "name") and hasattr(args, "extension"):
                 """Extend command process"""
 
-                resource = parse_name_to_resource(args.name,SYLK_JSON)
-                extend.extend_resource(resource,args.extension,SYLK_JSON)
+                resource = parse_name_to_resource(args.name, SYLK_JSON)
+                extend.extend_resource(resource, args.extension, SYLK_JSON)
 
-            elif hasattr(args, 'path'):
+            elif hasattr(args, "path"):
                 """Template command process"""
                 ARCHITECT = SylkArchitect(
-                    path=sylk_json_path,domain=SYLK_JSON.domain,project_name=SYLK_JSON.project.get('name'))
-                template_commands(args,SYLK_JSON,ARCHITECT)
-            
-            elif hasattr(args, 'service') and hasattr(args, 'rpc'):
+                    path=sylk_json_path,
+                    domain=SYLK_JSON.domain,
+                    project_name=SYLK_JSON.project.get("name"),
+                )
+                template_commands(args, SYLK_JSON, ARCHITECT)
+
+            elif hasattr(args, "service") and hasattr(args, "rpc"):
                 """Call command process"""
                 print_note(f"Calling {args.service}->{args.rpc}")
-                call.CallRPC(args.service,args.rpc,SYLK_JSON,host=args.host,port=args.port,debug=args.debug,timeout=int(args.timeout))
-            
-            elif hasattr(args, 'edit'):
+                call.CallRPC(
+                    args.service,
+                    args.rpc,
+                    SYLK_JSON,
+                    host=args.host,
+                    port=args.port,
+                    debug=args.debug,
+                    timeout=int(args.timeout),
+                )
+
+            elif hasattr(args, "edit"):
                 """Config command"""
                 if args.edit:
-                    print_warning('Not supporting editing of sylk.build configurations through the CLI yet...')
+                    print_warning(
+                        "Not supporting editing of sylk.build configurations through the CLI yet..."
+                    )
                 if args.token:
                     config_command.refresh_global_token()
                 else:
-                    config_command.display_configs(SYLK_JSON.path,dictionary=args.dict)
+                    config_command.display_configs(SYLK_JSON.path, dictionary=args.dict)
             else:
                 # List command execution
-                if hasattr(args, 'full_name'):
+                if hasattr(args, "full_name"):
                     if args.full_name is None:
                         if args.dependencies == True:
-                            ls.list_dependencies(args.type,SYLK_JSON)
+                            ls.list_dependencies(args.type, SYLK_JSON)
                         elif args.cloud:
-                            sylk_project_config = prj_conf.parse_project_config(os.getcwd())
-                            print_info(f'Listing all projects')
-                            sylkCloud = cloud.SylkCloud(sylk_project_config.get('token'),None,None)
+                            sylk_project_config = prj_conf.parse_project_config(
+                                os.getcwd()
+                            )
+                            print_info(f"Listing all projects")
+                            sylkCloud = cloud.SylkCloud(
+                                sylk_project_config.get("token"), None, None
+                            )
                             cloud_projects = []
                             for prj in sylkCloud.listProjects():
                                 cloud_projects.append(prj)
 
-                            ls.list_projects(sylkCloud._org_id,cloud_projects) 
+                            ls.list_projects(sylkCloud._org_id, cloud_projects)
                         # List templates execution
                         elif args.templates:
-                            sylk_project_config = prj_conf.parse_project_config(os.getcwd())
-                            ls.list_templates(sylk_project_config,SYLK_JSON)
+                            sylk_project_config = prj_conf.parse_project_config(
+                                os.getcwd()
+                            )
+                            ls.list_templates(sylk_project_config, SYLK_JSON)
                             # ls.list_cloud_projects(args.full_name,SYLK_JSON)
-                        elif hasattr(args, 'type'):
-                            ls.list_by_resource(args.type,SYLK_JSON)
+                        elif hasattr(args, "type"):
+                            ls.list_by_resource(args.type, SYLK_JSON)
                     else:
-                        ls.list_by_name(args.full_name,SYLK_JSON)
+                        ls.list_by_name(args.full_name, SYLK_JSON)
                 else:
-                    if hasattr(args,'protos'):
+                    if hasattr(args, "protos"):
                         print_warning("Cant migrate existing sylk.build project !")
                         exit(1)
+                        # Logging version
+                    if args.version:
+                        print_version(__version__.__version__)
+                        exit(0)
                     parser.print_help()
-            
+
         else:
             # Global sylk cli commands
             # sylk_project_config = prj_conf.parse_project_config(os.getcwd())
             # print_note(sylk_project_config,True)
-            if hasattr(args,'protos') and hasattr(args,'server_language'):
+            if hasattr(args, "protos") and hasattr(args, "server_language"):
                 """Migrations commands"""
-                migrate.migrate_project(args.protos,output_path=file_system.get_current_location(),format='json',server_language=args.server_language,clients=args.clients)
-            elif hasattr(args, 'path'):
+                migrate.migrate_project(
+                    args.protos,
+                    output_path=file_system.get_current_location(),
+                    format="json",
+                    server_language=args.server_language,
+                    clients=args.clients,
+                )
+            elif hasattr(args, "path"):
                 """Templates command"""
                 template_commands(args)
-            elif hasattr(args, 'organization'):
+            elif hasattr(args, "organization"):
                 """Cloud commands - login"""
                 sylk_project_config = prj_conf.parse_project_config(os.getcwd())
                 # print_note(sylk_project_config,True)
                 print_info(f'Logging into "{args.organization}"')
-                cloud.SylkCloud(sylk_project_config.get('token'),args.organization,None)
+                cloud.SylkCloud(
+                    sylk_project_config.get("token"), args.organization, None
+                )
                 print_success(f'Logged into: "{args.organization}"')
-            if args.command == 'ls':
+            if args.command == "ls":
                 if args.cloud:
                     """Cloud commands - list projects"""
                     sylk_project_config = prj_conf.parse_project_config(os.getcwd())
-                    print_info(f'Listing cloud projects')
-                    sylkCloud = cloud.SylkCloud(sylk_project_config.get('token'),None,None)
+                    print_info(f"Listing cloud projects")
+                    sylkCloud = cloud.SylkCloud(
+                        sylk_project_config.get("token"), None, None
+                    )
                     cloud_projects = []
                     for prj in sylkCloud.listProjects():
                         cloud_projects.append(prj)
 
-                    ls.list_projects(sylkCloud._org_id,cloud_projects) 
+                    ls.list_projects(sylkCloud._org_id, cloud_projects)
                 elif args.templates:
                     """Templates commands - list templates"""
                     sylk_project_config = prj_conf.parse_project_config(os.getcwd())
-                    print_info(f'Listing sylk templates')
+                    print_info(f"Listing sylk templates")
 
-                    ls.list_templates(sylk_project_config,None) 
-            elif hasattr(args,'edit'):
+                    ls.list_templates(sylk_project_config, None)
+            elif hasattr(args, "edit"):
                 """Configs commands"""
                 if args.token is not None:
                     # print(args.token)
                     config_command.refresh_global_token()
+            elif args.version:
+                print_version(__version__.__version__)
             else:
                 print_warning(
-                    'Not under valid sylk.build project !\n\tMake sure you are on the root directory of your project')
+                    "Not under valid sylk.build project !\n\tMake sure you are on the root directory of your project"
+                )
                 parser.print_help()
 
-def parse_name_to_resource(full_name,sylk_json: helpers.SylkJson):
-    resource = None
-    if len(full_name.split('.')) > 4:
-        log.debug("Searching for fields / enum values")
-        # Field / Enum Value
-        domain = full_name.split('.')[0]
-        pkg_name = full_name.split('.')[1]
-        pkg_v = full_name.split('.')[2]
-        pkg_path = f'protos/{domain}/{pkg_name}/{pkg_v}/{pkg_name}.proto'
-        if sylk_json.packages[pkg_path].get('messages') is not None:
-            msg_name = '.'.join(full_name.split('.')[:-1])
-            search_msg = next((m for m in sylk_json.packages[pkg_path].get('messages') if m.get('fullName') == msg_name),None)
-            if search_msg is not None:
-                search_field = next((f for f in search_msg.get('fields') if f.get('fullName') == full_name), None)
-                if search_field is not None:
-                    resource = search_field
-       
-    elif len(full_name.split('.')) == 4:
-        #  Message / Enum 
-        log.debug("Searching for Messages / enum")
-        domain = full_name.split('.')[0]
-        pkg_name = full_name.split('.')[1]
-        pkg_v = full_name.split('.')[2]
-        pkg_path = f'protos/{domain}/{pkg_name}/{pkg_v}/{pkg_name}.proto'
-        if sylk_json.packages.get(pkg_path) is None:
-
-            if sylk_json.services.get(pkg_name).get('methods') is not None and resource is None:
-                log.debug("Searching for RPC")
-                rpc_name = full_name.split('.')[-1]
-                search_rpc = next((e for e in sylk_json.services[pkg_name].get('methods') if e.get('name') == rpc_name),None)
-                if search_rpc is not None:
-                    resource = search_rpc
-            else:
-                print_error(f'Resource cant be found as {pkg_path} does not exists')
-                exit(1)
-        else:
 
-            if sylk_json.packages.get(pkg_path).get('messages') is not None:
-                search_msg = next((m for m in sylk_json.packages[pkg_path].get('messages') if m.get('fullName') == full_name),None)
-                if search_msg is not None:
-                    resource = search_msg
-            
-            if sylk_json.packages.get(pkg_path).get('enums') is not None and resource is None:
-                search_enum = next((e for e in sylk_json.packages[pkg_path].get('enums') if e.get('fullName') == full_name),None)
-                if search_enum is not None:
-                    resource = search_enum
-
-    elif len(full_name.split('.')) == 3:
-        # Package
-        log.debug("Searching for Package")
-        domain = full_name.split('.')[0]
-        pkg_name = full_name.split('.')[1]
-        pkg_v = full_name.split('.')[2]
-        pkg_path = f'protos/{domain}/{pkg_name}/{pkg_v}/{pkg_name}.proto'
-        if sylk_json.packages.get(pkg_path) is not None:
-           resource = sylk_json.packages.get(pkg_path)
-    elif len(full_name.split('.')) == 1:
-        # Service / Project
-        if sylk_json.services.get(full_name) is not None:
-           resource = sylk_json.services.get(full_name)
-
-    if resource is None:
-        print_error(f'Can not find any resource by the name -> {full_name}\n\t-> Try running: $ sylk ls')
-        exit(1)
-    else:
-        log.debug('Found resource {0}:{1}'.format(resource.get('type'),resource.get('kind')))
+def parse_name_to_resource(full_name, sylk_json: helpers.SylkJson):
+    resource = None
+    try:
+        resource = sylk_json.get_package(full_name)
+        if resource is not None:
+                return resource
+    except:
+        resource = sylk_json.get_service(full_name)
+        if resource is not None:
+            return resource
+        resource = sylk_json.get_enum(full_name)
+        if resource is not None:
+            return resource
+        resource = sylk_json.get_message(full_name)
+        if resource is not None:
+            return resource
+
+    print_error(
+        f"Can not find any resource by the name -> {full_name}\n\t-> Try running: $ sylk ls"
+    )
+    exit(1)
 
-    return resource
 
-def parse_namespace_resource(name, sylk_json: helpers.SylkJson,parent:str=None):
+def parse_namespace_resource(name, path: str, sylk_json: helpers.SylkJson):
+    path = path.replace('.','/')
     questions = []
     namespace = name[0]
-    if namespace == 's':
-        namespace = 'service'
-        questions = sylk_g_s_q
-    elif namespace == 'p':
-        namespace = 'package'
-
-        questions = sylk_g_p_q
-    elif namespace == 'r':
-        namespace = 'rpc'
+    # if namespace == 's':
+    #     namespace = 'service'
+    #     questions = sylk_g_s_q
+    if namespace == "p":
+        namespace = "package"
+        # questions = sylk_g_p_q
+    elif namespace == "r":
+        namespace = "rpc"
         services = sylk_json.services
         temp_s = []
+        parent = None
         if services is None or len(services) == 0:
             print_error(
-                "No listed services in sylk.json file\n\tCreate a new service first then return to create a 'message'")
+                "No listed services in sylk.json file\n\tCreate a new service first then return to create a 'message'"
+            )
             exit(1)
 
         for svc in services:
-            temp_s.append((services[svc]['name'], services[svc]['fullName']))
+            temp_s.append(
+                (
+                    "{} [{}]".format(svc["name"], svc["fullName"]),
+                    svc["fullName"],
+                )
+            )
+        if len(path.split('/'))>1:
+            parent = '.'.join(path.replace('/','.').split('.')[:-1])
         has_service = False
         if parent is not None:
             for s in temp_s:
                 if parent in s[0]:
                     parent = s[1]
                     has_service = True
 
             if has_service == False:
-                print_error(f"Service -> {parent} not exists under {sylk_json.project.get('name')}")
+                print_error(
+                    f"Service -> {parent} not exists under {sylk_json.project.get('name')}"
+                )
                 exit(1)
         sylk_g_r_q = [
-            prompter.QText(name="rpc",message="Enter rpc name",validate=validation),
-            prompter.QList(name="type", message="Choose message type", choices=[('Unary', (False, False)), (
-                'Client stream', (True, False)), ('Server stream', (False, True)), ('Bidi stream', (True, True))]),
+            prompter.QText(name="rpc", message="Enter rpc name", validate=validation),
+            prompter.QList(
+                name="type",
+                message="Choose message type",
+                choices=[
+                    ("Unary", (False, False)),
+                    ("Client stream", (True, False)),
+                    ("Server stream", (False, True)),
+                    ("Bidi stream", (True, True)),
+                ],
+            ),
         ]
 
         if has_service == False:
-            sylk_g_r_q.append(prompter.QList(
-                "service", message="Choose a service to attach the rpc", choices=temp_s))
+            sylk_g_r_q.append(
+                prompter.QList(
+                    "service",
+                    message="Choose a service to attach the rpc",
+                    choices=temp_s,
+                )
+            )
         questions = sylk_g_r_q
 
-    elif namespace == 'm':
-        namespace = 'message'
+    elif namespace == "m":
+        namespace = "message"
         packages = sylk_json.packages
         temp_p = []
-
+        parent = None
         if packages is None or len(packages) == 0:
             print_error(
-                "No listed packages in sylk.json file\n\tCreate a new package first then return to create a 'message'")
+                "No listed packages in sylk.json file\n\tCreate a new package first then return to create a 'message'"
+            )
             exit(1)
-
-        for pkg in packages:
-            temp_p.append(('{0} [{1}]'.format(packages[pkg]['name'],packages[pkg]['package'])))
-        
+        if packages is not None and len(packages) != 0:
+            for pkg in packages:
+                temp_p.append(
+                    (
+                        "{0} [{1}]".format(
+                            packages[pkg]["name"], packages[pkg]["package"]
+                        ),
+                        packages[pkg]["package"],
+                    )
+                )
+        if len(path.split('/'))>1:
+            parent = '.'.join(path.replace('/','.').split('.')[:-1])
+            
         has_package = False
         if parent is not None:
-            for p in temp_p:
+            for _,p in temp_p:
                 if parent in p:
                     has_package = True
             if has_package == False:
-                print_error(f"Package -> {parent} not exists under {sylk_json.project.get('name')}")
+                print_error(
+                    f"Package -> {parent} not exists under {sylk_json.project.get('name')}"
+                )
                 exit(1)
 
         sylk_g_m_q = [
-            prompter.QText(name="message", message="Enter message name",
-                          validate=validation),
+            prompter.QText(
+                name="message", message="Enter message name", validate=validation
+            ),
         ]
 
         if has_package == False:
-            sylk_g_m_q.append(prompter.QList(
-            name="package", message="Choose a package to attach the message", choices=temp_p))
+            sylk_g_m_q.append(
+                prompter.QList(
+                    name="package",
+                    message="Choose a package to attach the message",
+                    choices=sorted(temp_p,key=lambda x: x[1]),
+                )
+            )
 
         questions = sylk_g_m_q
 
-    elif namespace == 'e':
-        namespace = 'enum'
+    elif namespace == "e":
+        namespace = "enum"
         packages = sylk_json.packages
+        services = sylk_json.services
         temp_p = []
-
-        if packages is None or len(packages) == 0:
+        parent = None
+        if (packages is None or len(packages) == 0) and (
+            services is None or len(services) == 0
+        ):
             print_error(
-                "No listed packages in sylk.json file\n\tCreate a new package first then return to create a 'message'")
+                "No listed packages and services in sylk.json file\n\tCreate a new package or service first then return to create a 'enum'"
+            )
             exit(1)
 
-        for pkg in packages:
-            temp_p.append(('{0} [{1}]'.format(packages[pkg]['name'],packages[pkg]['package']), packages[pkg]['package']))
+        if packages is not None and len(packages) != 0:
+            for pkg in packages:
+                temp_p.append(
+                    (
+                        "{0} [{1}]".format(
+                            packages[pkg]["name"], packages[pkg]["package"]
+                        ),
+                        packages[pkg]["package"],
+                    )
+                )
+           
+        if len(path.split('/'))>1:
+            parent = '.'.join(path.replace('/','.').split('.')[:-1])
         has_parent = False
-
         if parent is not None:
             for p in temp_p:
                 if p[1] == parent:
                     has_parent = True
             if has_parent == False:
                 print_error(f"{parent} Is not under current project")
                 exit(1)
         else:
             sylk_g_e_q.append(
-                prompter.QList(name='package',message='Choose a package',choices=temp_p))
+                prompter.QList(
+                    name="package", message="Choose a package", choices=temp_p
+                )
+            )
 
         questions = sylk_g_e_q
 
+    elif namespace == "s":
+        parent = '.'.join(path.replace('/','.').split('.')[:-1])
+        namespace = "service"
+        packages = sylk_json.packages
+        services = sylk_json.services
+        temp_p = []
+        parent = None
+        if packages is None or len(packages) == 0:
+            print_error(
+                "No listed packages in sylk.json file\n\tCreate a new package first then return to create a 'service'"
+            )
+            exit(1)
+
+        if packages is not None and len(packages) != 0:
+            for pkg in packages:
+                temp_p.append(
+                    (
+                        "{0} [{1}]".format(
+                            packages[pkg]["name"], packages[pkg]["package"]
+                        ),
+                        packages[pkg]["package"],
+                    )
+                )
+        if len(path.split('/'))>1:
+            parent = '.'.join(path.replace('/','.').split('.')[:-1])
+
+        has_parent = False
+        if parent is not None:
+            for _,p in temp_p:
+                if p == sylk_json.domain + '.' + parent:
+                    has_parent = True
+            if has_parent == False:
+                print_error(
+                    f"cannot create service inside '{parent}' is not found in current project"
+                )
+                exit(1)
+        else:
+            sylk_g_s_q.append(
+                prompter.QList(
+                    name="package",
+                    message="Choose a package to host the service",
+                    choices=temp_p,
+                )
+            )
+
+        questions = sylk_g_s_q
+
     return namespace, questions
 
-def template_commands(args,sylk_json:helpers.SylkJson=None,architect=None):
+
+def template_commands(args, sylk_json: helpers.SylkJson = None, architect=None):
     try:
-        if args.path == 'list':
+        if args.path == "list":
             prj_configs = prj_conf.parse_project_config(sylk_json.path)
-            print_info([temp for temp in prj_configs.get('sylk_templates') if 'Blank' not in temp],True,'sylk Builtins')
+            print_info(
+                [
+                    temp
+                    for temp in prj_configs.get("sylk_templates")
+                    if "Blank" not in temp
+                ],
+                True,
+                "sylk Builtins",
+            )
             if prj_configs is not None:
-                print_note(prj_configs.get('custom_templates'),True,'Custom Templates [config.py]')
+                print_note(
+                    prj_configs.get("custom_templates"),
+                    True,
+                    "Custom Templates [config.py]",
+                )
         else:
             if file_system.check_if_file_exists(args.path):
                 if args.load:
                     template.load_template(args.path)
                 else:
-                    if 'sylk.json' in args.path:
-                        prj_configs = prj_conf.parse_sylk_config(sylk_json.path,proto=True)
+                    if "sylk.json" in args.path:
+                        prj_configs = prj_conf.parse_sylk_config(
+                            sylk_json.path, proto=True
+                        )
                         # print(prj_configs)
                         SYLK_JSON = file_system.rFile(args.path, json=True)
                         SYLK_JSON = helpers.SylkJson(sylk_json=SYLK_JSON)
-                        filename = SYLK_JSON.project.get('packageName') if args.template_name is None else args.template_name
-                        save_file_location = args.path.replace('sylk.json','{0}.template.py'.format(filename)) if args.out_path is None else file_system.join_path(args.out_path,'{0}.template.py'.format(filename))
+                        filename = (
+                            SYLK_JSON.project.get("packageName")
+                            if args.template_name is None
+                            else args.template_name
+                        )
+                        save_file_location = (
+                            args.path.replace(
+                                "sylk.json", "{0}.template.py".format(filename)
+                            )
+                            if args.out_path is None
+                            else file_system.join_path(
+                                args.out_path, "{0}.template.py".format(filename)
+                            )
+                        )
                         if prj_configs.template is not None:
-                            filename = filename if prj_configs.template.name is None else filename
-                            save_file_location = save_file_location if prj_configs.template.out_path is None else file_system.join_path(SYLK_JSON.path.replace('sylk.json',''),prj_configs.template.out_path,'{0}.template.py'.format(filename))
-
-                        parent_path = file_system.join_path(file_system.get_current_location(),os.path.dirname(save_file_location))
-                        include_code = args.code if prj_configs.template is None else prj_configs.template.include_code if  prj_configs.template.include_code is not None else False
+                            filename = (
+                                filename
+                                if prj_configs.template.name is None
+                                else filename
+                            )
+                            save_file_location = (
+                                save_file_location
+                                if prj_configs.template.out_path is None
+                                else file_system.join_path(
+                                    SYLK_JSON.path.replace("sylk.json", ""),
+                                    prj_configs.template.out_path,
+                                    "{0}.template.py".format(filename),
+                                )
+                            )
+
+                        parent_path = file_system.join_path(
+                            file_system.get_current_location(),
+                            os.path.dirname(save_file_location),
+                        )
+                        include_code = (
+                            args.code
+                            if prj_configs.template is None
+                            else prj_configs.template.include_code
+                            if prj_configs.template.include_code is not None
+                            else False
+                        )
 
                         if file_system.check_if_dir_exists(parent_path):
-                            file_system.wFile(save_file_location,template.create_sylk_template_py(SYLK_JSON,include_code,prj_configs),overwrite=True)
-                            print_success("Generated project template for '{0}'\n\t-> {1}".format(SYLK_JSON.project.get('name'),save_file_location))
+                            file_system.wFile(
+                                save_file_location,
+                                template.create_sylk_template_py(
+                                    SYLK_JSON, include_code, prj_configs
+                                ),
+                                overwrite=True,
+                            )
+                            print_success(
+                                "Generated project template for '{0}'\n\t-> {1}".format(
+                                    SYLK_JSON.project.get("name"), save_file_location
+                                )
+                            )
                         else:
-                            print_warning("Path to template output path does not exist ! [{0}] - Will try to create the sub-dir".format(save_file_location))                        
-                            file_system.wFile(save_file_location,template.create_sylk_template_py(SYLK_JSON,include_code,prj_configs),overwrite=True,force=True)
-                            print_success("Generated project template for '{0}'\n\t-> {1}".format(SYLK_JSON.project.get('name'),save_file_location))
+                            print_warning(
+                                "Path to template output path does not exist ! [{0}] - Will try to create the sub-dir".format(
+                                    save_file_location
+                                )
+                            )
+                            file_system.wFile(
+                                save_file_location,
+                                template.create_sylk_template_py(
+                                    SYLK_JSON, include_code, prj_configs
+                                ),
+                                overwrite=True,
+                                force=True,
+                            )
+                            print_success(
+                                "Generated project template for '{0}'\n\t-> {1}".format(
+                                    SYLK_JSON.project.get("name"), save_file_location
+                                )
+                            )
                             exit(1)
                     # elif '.proto' in args.path:
                     #     parse = parser.sylkParser(path=args.path)
                     #     print(parse)
                     else:
                         if file_system.check_if_dir_exists(args.path):
                             # builder = sylkBuilder(path=file_system.get_current_location(),hooks=[sylkMigrate])
                             # builder.PreBuild()
                             # print_info(file_system.join_path(file_system.get_current_location(),args.path))
                             # builder.ParseProtosToResource(project_name="test",protos_dir=file_system.join_path(file_system.get_current_location(),args.path),clients=[],server_language="python")
                             # builder.PostBuild()
-                            raise errors.SylkProtoError("Not supported yet","Will be used to pass a directory path which holds proto files")
+                            raise errors.SylkProtoError(
+                                "Not supported yet",
+                                "Will be used to pass a directory path which holds proto files",
+                            )
                         else:
-                            raise errors.SylkProtoError("Export Service Template Error","File type not supported")
+                            raise errors.SylkProtoError(
+                                "Export Service Template Error",
+                                "File type not supported",
+                            )
             elif file_system.check_if_dir_exists(args.path):
-                raise errors.SylkProtoError("Not supported yet","Will be used to pass a directory path which holds proto files")
+                raise errors.SylkProtoError(
+                    "Not supported yet",
+                    "Will be used to pass a directory path which holds proto files",
+                )
             else:
                 # Handle custom template import / builtin template
-                if '@' in args.path:
+                if "@" in args.path:
                     prj_configs = prj_conf.parse_project_config(sylk_json.path)
                     if args.path in config.configs.sylk_templates:
                         # Check if suffix of template name is Py
-                        if 'Py' == args.path[len(args.path)-2:] and sylk_json.project.get('server').get('language') != 'python':
-                            raise errors.SylkValidationError("Not supporting server language","The [{0}] template is only supporting 'python' as server language please try and run - sylk template {1} --load".format(args.path,args.path.replace('Py','Ts')))
+                        if (
+                            "Py" == args.path[len(args.path) - 2 :]
+                            and sylk_json.project.get("server").get("language")
+                            != "python"
+                        ):
+                            raise errors.SylkValidationError(
+                                "Not supporting server language",
+                                "The [{0}] template is only supporting 'python' as server language please try and run - sylk template {1} --load".format(
+                                    args.path, args.path.replace("Py", "Ts")
+                                ),
+                            )
                         # Check if suffix of template name is Ts
-                        if 'Ts' == args.path[len(args.path)-2:] and sylk_json.project.get('server').get('language') != 'typescript':
-                            raise errors.SylkValidationError("Not supporting server language","The [{0}] template is only supporting 'typescript' as server language please try and run - sylk template {1} --load".format(args.path,args.path.replace('Ts','Py')))
+                        if (
+                            "Ts" == args.path[len(args.path) - 2 :]
+                            and sylk_json.project.get("server").get("language")
+                            != "typescript"
+                        ):
+                            raise errors.SylkValidationError(
+                                "Not supporting server language",
+                                "The [{0}] template is only supporting 'typescript' as server language please try and run - sylk template {1} --load".format(
+                                    args.path, args.path.replace("Ts", "Py")
+                                ),
+                            )
                         # Attach template from builtins
-                        helpers.attach_template(architect,args.path)
+                        helpers.attach_template(architect, args.path)
                     else:
                         # Handle custom templates
                         if prj_configs is not None:
-                            print_warning("Attaching custom templates. If you want to attach a builtin template drop the 'templates' array in config.py file.")
-                            if prj_configs.get('custom_templates'):
-                                for temp in prj_configs.get('custom_templates'):
-                                    template_path = file_system.join_path(file_system.get_current_location(),temp[1])
+                            print_warning(
+                                "Attaching custom templates. If you want to attach a builtin template drop the 'templates' array in config.py file."
+                            )
+                            if prj_configs.get("custom_templates"):
+                                for temp in prj_configs.get("custom_templates"):
+                                    template_path = file_system.join_path(
+                                        file_system.get_current_location(), temp[1]
+                                    )
                                     if temp[0] == args.path:
-                                        if file_system.check_if_file_exists(template_path):
+                                        if file_system.check_if_file_exists(
+                                            template_path
+                                        ):
                                             # Attach template from custom templates
-                                            print_info("Running template file for {0}".format(args.path))
-                                            subprocess.run(['python',template_path,'--domain',architect._domain,'--project-name',architect._project_name])
+                                            print_info(
+                                                "Running template file for {0}".format(
+                                                    args.path
+                                                )
+                                            )
+                                            subprocess.run(
+                                                [
+                                                    "python",
+                                                    template_path,
+                                                    "--domain",
+                                                    architect._domain,
+                                                    "--project-name",
+                                                    architect._project_name,
+                                                ]
+                                            )
                                         else:
-                                            raise errors.SylkValidationError("Template not found","The template file is not found on : {0}".format(template_path))
+                                            raise errors.SylkValidationError(
+                                                "Template not found",
+                                                "The template file is not found on : {0}".format(
+                                                    template_path
+                                                ),
+                                            )
                                     else:
-                                        raise errors.SylkValidationError("Template not found","Custom template [{0}] not listed on 'templates' array at config.py file.".format(args.path))
+                                        raise errors.SylkValidationError(
+                                            "Template not found",
+                                            "Custom template [{0}] not listed on 'templates' array at config.py file.".format(
+                                                args.path
+                                            ),
+                                        )
                             else:
-                                raise errors.SylkValidationError("Config templates are empty","Please make sure you configurd a list of templates in your custom config.py file under root project directory")
+                                raise errors.SylkValidationError(
+                                    "Config templates are empty",
+                                    "Please make sure you configurd a list of templates in your custom config.py file under root project directory",
+                                )
                 else:
-                    raise errors.SylkProtoError("Export Service Template Error","Make sure you are passing a valid path to sylk.json / protos directory / sylk.template.py script for SylkArchitect - or a valid id for the template!")
+                    raise errors.SylkProtoError(
+                        "Export Service Template Error",
+                        "Make sure you are passing a valid path to sylk.json / protos directory / sylk.template.py script for SylkArchitect - or a valid id for the template!",
+                    )
     except Exception as e:
-        print_error(e,True,e.__class__.__name__+' : '+e.resource if hasattr(e,'resource') else '')
+        print_error(
+            e,
+            True,
+            e.__class__.__name__ + " : " + e.resource if hasattr(e, "resource") else "",
+        )
```

## sylk/cli/commands/call.py

```diff
@@ -62,29 +62,33 @@
         _pretty.print_error("Error RPC : \"{0}\", is not found under service -> [{1}]".format(rpc,service_name))
         exit(1)
 
     _pretty.print_info(f'calling {path = } [{stub_name}]\n\t-> {rpc  = } [{rpc_full_name}]\n\t-> {host = }\n\t-> {port = }')
     
     # Dynamic import module (Only supporting clients proto modules)
     # print()
-    sys.path.append(os.getcwd()+'/'+'/'.join(service_module_path.split('/')[0:2]))
+    sys.path.append(os.getcwd()+'/'+'/'.join(service_module_path.split('/')[0:1]))
     service_module = importlib.import_module(path)
     # Init the service stub
     stub = client_wrapper.SylkClient(service_module,stub_name,host,port,timeout)
     # Get RPC description from sylk.json file
     rpc_description = sylk_json.get_rpc(rpc_full_name)
 
     input_package_name = rpc_description['inputType'].split('.')[1]
     input_message_name = rpc_description['inputType'].split('.')[-1]
     
     input_message_description = sylk_json.get_message(rpc_description['inputType'])
     output_message_description = sylk_json.get_message(rpc_description['outputType'])
 
     # Get modules objects
-    package_proto = getattr(service_module,input_package_name+'__pb2')
+    pkg_full_name = '_dot_'.join(rpc_description['inputType'].split('.')[:-1])
+    if 'protos_dot_'+pkg_full_name+f'_dot_{input_package_name}__pb2' in dir(service_module):
+        package_proto = getattr(service_module,'protos_dot_'+pkg_full_name+f'_dot_{input_package_name}__pb2')
+    else:
+        package_proto = getattr(service_module,pkg_full_name+f'_dot_{input_package_name}__pb2')
     message_proto = getattr(package_proto,input_message_name)
 
     # TODO allow support iterator for client stream
     msg = message_proto()
     # Ask for seed data
     confirm_seed_data = prompter.QConfirm(name='seed',message='Do you want to send seed data?',default=True)
     seed_data = prompter.ask_user_question(questions=[confirm_seed_data])
@@ -131,33 +135,39 @@
                         question.append(bool_value)
                     elif f['fieldType'] == 'TYPE_INT32' or f['fieldType'] =='TYPE_INT64':
                         fields[f.get('name')] = None
                         number_value = prompter.QText(name=f.get('name'),message='Choose value for "{0}" key (Integer)'.format(f.get('name')),default='1')
                         question.append(number_value)
                     elif f['fieldType'] == 'TYPE_DOUBLE' or f['fieldType'] =='TYPE_FLOAT':
                         fields[f.get('name')] = None
-                        number_value = prompter.QText(name=f.get('name'),message='Choose value for "{0}" key (Float)'.format(f.get('name')),default='1.0')
+                        number_value = prompter.QText(name=f.get('name'),message='Choose value for "{0}" key (Float)'.format(f.get('name')),default=1.0)
                         question.append(number_value)
                     if len(question) == 0:
                         pass
                     else:
                         fields[f.get('name')] = prompter.ask_user_question(questions=question).get(f.get('name')) 
+                        print(fields)
                 else:
                     _pretty.print_warning('Skipping {0}->{1}:{2}'.format(f['name'],f['fieldType'],f['messageType']))
                     
             for k in fields:
+                if f['fieldType'] == 'TYPE_INT32' or f['fieldType'] =='TYPE_INT64':
+                    fields[k] = int(fields[k])
+                elif f['fieldType'] == 'TYPE_DOUBLE' or f['fieldType'] =='TYPE_FLOAT':
+                    fields[k] = float(fields[k])
                 setattr(msg,k,fields[k])
 
     _pretty.print_info(msg,True,'Request Object [{0}]'.format(input_message_description['fullName']))
     # TODO allow support for UNARY / STREAM
     # get the start time
     if debug:
         st = time.time()
     try:
-        response , call = getattr(stub,rpc)(msg)
+        client = getattr(stub,'stub')
+        response , call = getattr(client,rpc)(msg)
         _pretty.print_info('Waiting for server response... [{0}]'.format(output_message_description['fullName']))
         if debug:
             # get the end time
             et = time.time()
             # get the execution time
             elapsed_time = et - st
             if elapsed_time < 1:
```

## sylk/cli/commands/cloud.py

```diff
@@ -18,52 +18,73 @@
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 from importlib import import_module,util
 from pathlib import Path
 from sylk.cli import prompter
-from sylk import __version__
+from sylk import __version__, config
 
 from sylk.commons import helpers as _helpers, file_system as _fs, pretty as _pretty
-from sylk.commons.protos import sylkcore
+from sylk.commons.protos import Projects_v1, Packages_v2, Messages_v2, Organizations_v1, Methods_v2, Enums_v2,  Users_v1,EnumValues_v2, Tags_v2, Folders_v2, Fields_v2, Services_v2
 import ast
 from sylk.commons.helpers import Graph, MessageToDict,MessageToJson, is_semver_less, read_to_parse_protos
 
-from sylk.commons.protos.sylk.SylkApi.v1.SylkApi_pb2 import GetAccessTokenRequest, GetProjectRequest, ListPackagesRequest, ListProjectsRequest, ListServicesRequest
+from sylk.commons.protos.sylk.SylkApi.v1.SylkApi_pb2 import GetAccessTokenRequest, GetOrganizationRequest, GetProjectRequest, ListPackagesRequest, ListProjectsRequest, ListServicesRequest
 from sylk.commons.protos.sylk.SylkConfigs.v1.SylkConfigs_pb2 import SylkProjectConfigs
 from sylk.commons.protos.sylk.SylkOrganization.v1.SylkOrganization_pb2 import SylkOrganization
-from sylk.commons.protos.sylk.Sylk.v1.Sylk_pb2 import SylkJson
+from sylk.commons.protos.sylk.Sylk.v2.Sylk_pb2 import SylkJson
 from datetime import datetime
 
 from sylk.tools.sylkprotoc import sylkprotoc, API as protocAPI
 
 def validation_sylk_token(answers, current):
     if current[:5] != 'sylk_':
       raise prompter.inquirer_errors.ValidationError('', reason='Token is not valid')
     return True
 
+class sylkcore:
+
+    def __init__(self) -> None:
+        _configs = {
+            "host": config.sylk_api_host,
+            "port": 9000
+        }
+        self._organizations = Organizations_v1(client_opt=_configs)
+        self._projects = Projects_v1(client_opt=_configs)
+        self._folders = Folders_v2(client_opt=_configs)
+        self._packages = Packages_v2(client_opt=_configs)
+        self._messages = Messages_v2(client_opt=_configs)
+        self._enums = Enums_v2(client_opt=_configs)
+        self._services = Services_v2(client_opt=_configs)
+        self._fields = Fields_v2(client_opt=_configs)
+        self._tags = Tags_v2(client_opt=_configs)
+        self._methods = Methods_v2(client_opt=_configs)
+        self._users = Users_v1(client_opt=_configs)
+        self._enum_values = EnumValues_v2(client_opt=_configs)
+
+
 class SylkCloud:
 
     def __init__(self,token=None,org_id=None,SylkJson=_helpers.SylkJson) -> None:
         self._token = token
         self.sylkJson = SylkJson
         self._org_id = org_id
-        self._sylk_cloud = sylkcore('api.sylk.build',80)
+        self._sylk_cloud = sylkcore()
         # Check if configs have valid token
         self.set_token()
         # Check if organization has orgId field
         self.set_org_id()
     
     def _validate_token(self):
         _pretty.print_note(f'🔑 Validating token: {self._token[0:5]}[REDACTED]')
-        res, call = self._sylk_cloud.GetAccessToken_WithCall(GetAccessTokenRequest(token=self._token))
-        for key, value in call.trailing_metadata():
-            _pretty.print_note('cloud client received trailing metadata: key=%s value=%s' %
-              (key, value))
+        res = self._sylk_cloud._users.GetAccessToken(GetAccessTokenRequest(token=self._token))
+        # for key, value in call.trailing_metadata():
+            # _pretty.print_note('cloud client received trailing metadata: key=%s value=%s' %
+            #   (key, value))
         if res.result.expires_at.ToDatetime() <= datetime.now():
             _pretty.print_error('Token is expired!')
             exit(1)
         elif res.result.org_id != self._org_id and self._org_id is not None:
             _pretty.print_error(f'Token is not valid for organization ID: "{self._org_id}"')
             exit(1)
         else:
@@ -92,26 +113,27 @@
                         config_file[i] = '    ' + config_file[i].strip()[:6] + f'"{self._token}",\n'
                     _fs.wFile(_fs.join_path(p,'config.py'),content=''.join(config_file),overwrite=True)
             else:
                 _pretty.print_info('Generate cloud tokens to remotly interacte with your sylk.build projects\n\t- See more information on https://docs.sylk.build/')
         else:
             self._validate_token()
 
-    def pull_project(self,project_id=None,overwrite=False):
+    def pull_project(self,project_id=None,overwrite=False,domain=None) -> SylkJson:
         projectId = project_id if project_id is not None else self._org_id+'.'+self.sylkJson.project.get('packageName')
         try:
+            
             _md = (('sylk-build-token',self._token),)
 
             org_id = projectId.split('.')[0]
 
             # org = self._sylk_cloud.GetOrganization(request=GetOrganizationRequest(
             #     org_id=org_id,
             # ),metadata=_md)
 
-            project = self._sylk_cloud.GetProject(
+            project = self._sylk_cloud._projects.GetProject(
                 request=GetProjectRequest(
                     project=projectId
                 ),
                 metadata=_md
             )
             # org = self._sylk_cloud.GetOrganization(
             #     request=GetOrganizationRequest(
@@ -119,90 +141,104 @@
             #     ),
             #     metadata=(('sylk-build-token',self._token),)
             # )
 
             packages = {}
             services = {}
 
-            pkgs = self._sylk_cloud.ListPackages(
+            folders = self._sylk_cloud._folders.ListFolders(
                 ListPackagesRequest(
                     project_id=projectId
                 ),
                 _md
             )
 
-            for p in pkgs:
-                domain = p.result.package.package.split('.')[0]
-                p_ver = p.result.package.package.split('.')[-1]
-                packages[f'protos/{domain}/{p.result.package.name}/{p_ver}/{p.result.package.name}.proto'] = p.result.package
-
-            svcs = self._sylk_cloud.ListServices(
-                ListServicesRequest(
-                    project_id=projectId
-                ),
-                _md
-            )
+            def parse_folder(folders,packages):
+                for f in folders:
+                    parse_folder(f.folders,packages=packages)
+                    for p in f.packages:
+                        pkg_path = p.package.replace('.','/')
+                        packages[f'{pkg_path}'] = p
+            parse_folder(folders=folders,packages=packages)
+            # svcs = self._sylk_cloud._services.ListServices(
+            #     ListServicesRequest(
+            #         project_id=projectId
+            #     ),
+            #     _md
+            # )
 
-            for s in svcs:
-                domain = s.result.service.full_name.split('.')[0]
-                s_ver = s.result.service.full_name.split('.')[2]
-                services[f'protos/{domain}/{s.result.service.name}/{s_ver}/{s.result.service.name}.proto'] = s.result.service
+            # for s in svcs:
+            #     domain = s.result.service.full_name.split('.')[0]
+            #     s_ver = s.result.service.full_name.split('.')[2]
+            #     services[f'protos/{domain}/{s.result.service.name}/{s_ver}/{s.result.service.name}.proto'] = s.result.service
+            org = None
+            if domain is None:
+                org = self._sylk_cloud._organizations.GetOrganization(GetOrganizationRequest(org_id=org_id))
 
             sylk_org = SylkOrganization(
-                domain="sylk",
+                domain=domain if org is None else org.result.organization.domain,
                 orgId=org_id
             )
             project.result.project.uri = _fs.get_current_location()
 
             sylk = SylkJson(
                 organization=sylk_org,
                 project=project.result.project,
                 packages=packages,
-                services=services,
                 configs=SylkProjectConfigs(
                     host='localhost',
-                    port=48800
+                    port=48800,
+                    proto_base_path='protos'
                 ),
                 sylk_version=__version__.__version__
             )
 
             resources = []
             sylkDict = MessageToDict(sylk)
             for pkg in sylkDict['packages']:
                 resources.append(sylkDict['packages'][pkg])
-                try:
-                    sort_topological = Graph(sylkDict['packages'][pkg]['messages']).topologicalSort()
-                    temp_messages = []
-                    for m in sort_topological[::-1]:
-                        temp_messages.append(next((tmpM for tmpM in sylkDict['packages'][pkg]['messages'] if tmpM.get('fullName') == m),None))
-                    sylkDict['packages'][pkg]['messages'] = temp_messages
-                except KeyError as e:
-                    _pretty.print_warning("Error while sorting the dependencies graph of package messages\n\t- If this error appeared right after making rename of message then ignore it...\n\t- Else please issue a bug report !")
+                # try:
+                #     sort_topological = Graph(sylkDict['packages'][pkg]['messages']).topologicalSort()
+                #     temp_messages = []
+                #     for m in sort_topological[::-1]:
+                #         temp_messages.append(next((tmpM for tmpM in sylkDict['packages'][pkg]['messages'] if tmpM.get('fullName') == m),None))
+                #     sylkDict['packages'][pkg]['messages'] = temp_messages
+                # except KeyError as e:
+                #     # _pretty.print_warning("Error while sorting the dependencies graph of package messages\n\t- If this error appeared right after making rename of message then ignore it...\n\t- Else please issue a bug report !")
+                #     raise Exception('Seems like your project is not ready to be built locally.. missing fields maybe?')
                 
             
+            
+
+            # temp_json = _helpers.SylkJson(sylkDict)
+            # for p in sylkDict['packages']:
+            #     pkg = sylkDict['packages'][p]
+            #     msgs = temp_json._proto_tree.resolve_dependency_order(pkg['messages'])
+            #     p['messages'] = msgs
+            #     sylkDict['packages'][p]['messages'] = msgs
             if overwrite:
                 _fs.wFile('sylk.json',sylkDict,True,True)
             return sylk
         except Exception as e:
             _pretty.print_error(e.details(),True,f'Error occured during pulling project {projectId}')
             exit(1)
 
         
     def get_project(self):
 
-        projects = self._sylk_cloud.GetProject(
+        projects = self._sylk_cloud._projects.GetProject(
             request=GetProjectRequest(project=self._org_id),
             metadata=(('sylk-build-token',self._token),)
         )
         for p in projects:
             print(p.result)
         
 
     def listProjects(self):
-        return self._sylk_cloud.ListProjects(ListProjectsRequest(org_id=self._org_id),(('sylk-build-token',self._token),))
+        return self._sylk_cloud._projects.ListProjects(ListProjectsRequest(org_id=self._org_id),(('sylk-build-token',self._token),))
 
     def buildProject(self):
         
         if is_semver_less(self.sylkJson.sylk_version,"1.0.0"):
             _pretty.print_error("current project built with {} sylk cli version, build remote project is will be supported only later versions".format(self.sylkJson.sylk_version)) 
             exit(1)
```

## sylk/cli/commands/edit.py

```diff
@@ -38,15 +38,14 @@
     resource - a dictionary full resource description to be edited
     action - remove / edit
     sub_action - Deeper action fo edit option: fields / name
     sylk_json - sylk.json context
     architect - The architect class instantiated to the sylk.json context
     expand - If expanding optional inputs
     """
-
     if action is None:
         if sub_actions is not None:
             print_warning("Passed sub actions before passing action")
         action = choose_action()
 
     # Remove message
     if action.lower() == 'remove':
@@ -92,24 +91,26 @@
                 print_success("Removed {0} [{1}] and all dependent resources".format(resource.get('fullName'),resource.get('kind')))
             else:
                 print_error("Cancelling deletion process")
     # Edit
     else:
         # Prompting for sub-action
         if sub_actions is None:
-            sub_actions = modify_resource([('Add fields','fields'),('Rename','name')])
+            sub_actions = modify_resource([('Add fields','fields'),('Tag message', 'tag'),('Rename','name')])
         # Edit fields
         if sub_actions[0] == 'fields' :
             add_fields(resource,sylk_json,architect=architect,expand=expand)
         # Renaming message
         elif sub_actions[0] == 'name':
             # Getting dependencies for resources
             dependencies = get_dependencies(full_name=resource.get('fullName'),sylk_json=sylk_json)
             display_dependencies(dependencies,resource,'rename')
             rename_message(resource,sylk_json,architect,dependencies)
+        elif sub_actions[0] == 'tag':
+            tag_message(resource,sylk_json,architect)
         # Not supporting option
         else:
             print_error("Not supporting editing {}".format(sub_actions))
             exit(1)
 
 def edit_enum(resource,action,sub_actions,sylk_json:helpers.SylkJson,architect:SylkArchitect,expand):
     """A function to edit enum resource type"""
@@ -152,18 +153,20 @@
                 print_success("Removed {0} [{1}] and all dependent resources".format(resource.get('fullName'),resource.get('kind')))
             else:
                 print_error("Cancelling deletion process")
     # Edit enum
     else:
         # Prompting for sub-action
         if sub_actions is None:
-            sub_actions = modify_resource([('Add values','values'),('Rename','name')])
+            sub_actions = modify_resource([('Add values','values'),('Tag enum','tag'),('Rename','name')])
         # Add values
         if sub_actions[0] == 'values' :
             add_values(resource,sylk_json,architect=architect,expand=expand)
+        elif sub_actions[0] == 'tag':
+            tag_enum(resource,sylk_json,architect)
         # Not supported option for enum editing
         else:
             print_error('{} Not supported yet !'.format(sub_actions[0]))
             exit(1)
 
 def edit_rpc(resource,action,sub_actions,sylk_json:helpers.SylkJson,architect:SylkArchitect,expand):
     """A function to edit RPC resource type"""
@@ -958,56 +961,86 @@
             """Unknown"""
             pass
     
     return dependent_resources
     
 
 def display_dependencies(dependencies,resource,action):
-    """Display the depndencies for the specified resources"""
+    """Display the dependencies for the specified resources"""
 
     if len(dependencies) > 0:
         print_warning("The following resources are going to be affected from {0} {1}:\n".format(action,resource.get('fullName')))
         for d in dependencies:
             if d.get('name') is not None:
                 print_warning('- {0} [{1}]'.format(d.get('name'),d.get('kind')))
             else:
                 for k in d:
                     depend = (k,d[k])
 
                 print_warning('- {0} -> {1} [{2}]'.format(depend[0],depend[1].get('name'),depend[1].get('kind')))
     print('')
 
+def tag_enum(resource,sylk_json:helpers.SylkJson,architect:SylkArchitect):
+    tag_name = inquirer.prompt([inquirer.Text('tag_name','Enter tag name for enum',validate=tag_name_validator)],theme=SylkTheme())
+    if tag_name is None:
+        print_warning("Exiting editing process for message {}".format(resource.get('fullName')))
+        exit(1)
+    else:
+        tag_name = tag_name['tag_name']
+        _pkg = sylk_json._resolve_path_backwards(resource.get('fullName'))
+        pkg = sylk_json.get_package(_pkg.get('package'),False)
+        old_name = resource.get('name')
+        print_success("Tagging {} -> {}".format(resource.get('fullName'),tag_name))
+        resource['tag'] = tag_name
+        architect.EditEnum(pkg, resource.get('name'),
+                            resource.get('values'),description=resource.get('description'),tag=resource.get('tag'))
+        architect.Save()
+
+def tag_message(resource,sylk_json:helpers.SylkJson,architect:SylkArchitect):
+    tag_name = inquirer.prompt([inquirer.Text('tag_name','Enter tag name for message',validate=tag_name_validator)],theme=SylkTheme())
+    if tag_name is None:
+        print_warning("Exiting editing process for message {}".format(resource.get('fullName')))
+        exit(1)
+    else:
+        tag_name = tag_name['tag_name']
+        _pkg = sylk_json._resolve_path_backwards(resource.get('fullName'))
+        pkg = sylk_json.get_package(_pkg.get('package'),False)
+        old_name = resource.get('name')
+        print_success("Tagging {} -> {}".format(resource.get('fullName'),tag_name))
+        resource['tag'] = tag_name
+        architect.EditMessage(pkg, resource.get('name'),
+                            resource.get('fields'), resource.get('description'), resource.get('extensionType'),old_name=old_name,extensions=resource.get('extensions'),tag=resource.get('tag'))
+        architect.Save()
 
 def rename_message(resource,sylk_json:helpers.SylkJson,architect:SylkArchitect,dependencies):
     """A function to rename the message"""
 
     message_name = inquirer.prompt([inquirer.Text('message_name','Enter new name for the message',validate=message_name_validation)],theme=SylkTheme())
     if message_name is None:
         print_warning("Exiting editing process for message {}".format(resource.get('fullName')))
         exit(1)
     else:
         message_name = message_name['message_name']
     
-    _pkg = sylk_json.get_package(resource.get('fullName').split('.')[1],False)
     new_full_name = '{}.{}'.format('.'.join(resource.get('fullName').split('.')[:-1]),message_name)
+    _pkg = sylk_json._resolve_path_backwards(resource.get('fullName'))
+    pkg = sylk_json.get_package(_pkg.get('package'),False)
 
-   
-
-    if next((msg for msg in _pkg.messages if msg.name == message_name),None) is None:
+    if next((msg for msg in pkg.messages if msg.name == message_name),None) is None:
         print_success("Renaming {} -> {}".format(resource.get('fullName'),new_full_name))
         # Handling all dependencies and rename the type as well
         for d in dependencies:
             if d.get('kind') == resources.ResourceKinds.field.value:
                 edit_field(d,'modify',['message_type',new_full_name],sylk_json,architect,False,True)
 
         old_name = resource['name']
         resource['name'] = message_name
         resource['fullName'] = new_full_name
-        architect.EditMessage(_pkg, resource.get('name'),
-                            resource.get('fields'), resource.get('description'), resource.get('extensionType'),old_name=old_name,extensions=resource.get('extensions'))
+        architect.EditMessage(pkg, resource.get('name'),
+                            resource.get('fields'), resource.get('description'), resource.get('extensionType'),old_name=old_name,extensions=resource.get('extensions'),tag=resource.get('tag'))
         architect.Save()
     else:
         print_error("{} is already existing under {} package !".format(message_name,resource.get('fullName').split('.')[1]))
         exit(1)
     
 
     
@@ -1020,8 +1053,22 @@
             current, reason='Resource name must not be blank')
     if len(re.findall('\s', current)) > 0:
         raise inquirerErrors.ValidationError(
             current, reason='Resource name must not include blank spaces')
     if len(re.findall('-', current)) > 0:
         raise inquirerErrors.ValidationError(
             current, reason='Resource name must not include hyphens, underscores are allowed')
+    return True
+
+def tag_name_validator(answers, current):
+    """Validate tag of messages"""
+
+    if len(current) == 0:
+        raise inquirerErrors.ValidationError(
+            current, reason='Resource tag must not be blank')
+    if len(re.findall('\s', current)) > 0:
+        raise inquirerErrors.ValidationError(
+            current, reason='Resource tag must not include blank spaces')
+    if len(re.findall('-', current)) > 0:
+        raise inquirerErrors.ValidationError(
+            current, reason='Resource tag must not include hyphens, underscores are allowed')
     return True
```

## sylk/cli/commands/generate.py

```diff
@@ -17,601 +17,1071 @@
 # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import logging
 from pprint import pprint
-from sylk.cli.prompter import QCheckbox,QConfirm,QList,QText,ask_user_question
+from sylk.cli.prompter import QCheckbox, QConfirm, QList, QText, ask_user_question
 from sylk.architect import SylkArchitect
 from sylk.cli.theme import SylkTheme
-from sylk.commons.helpers import SylkJson, SylkField, SylkEnumValue,_WellKnowns
-from sylk.commons.pretty import print_info, print_warning, print_error, print_note, print_success, bcolors
-from sylk.commons.protos.sylk.SylkField.v1.SylkField_pb2 import SylkFieldLabels, SylkFieldTypes
+from sylk.commons.helpers import SylkJson, SylkField, SylkEnumValue, _WellKnowns,_WellMap, parse_version_component
+from sylk.commons.pretty import (
+    print_info,
+    print_warning,
+    print_error,
+    print_note,
+    print_success,
+    bcolors,
+)
+from sylk.commons.protos.sylk.SylkField.v1.SylkField_pb2 import (
+    SylkFieldLabels,
+    SylkFieldTypes,
+)
 from sylk.commons.errors import SylkProtoError
-from sylk.commons.protos.sylk.SylkCommons.v1.SylkCommons_pb2 import FieldOptions,MessageOptions,MethodOptions,ServiceOptions,SylkExtensions
+from sylk.commons.protos.sylk.SylkCommons.v1.SylkCommons_pb2 import (
+    FieldOptions,
+    MessageOptions,
+    MethodOptions,
+    ServiceOptions,
+    SylkExtensions,
+)
 
 import inquirer
 from inquirer import errors
 import re
 
+from sylk.commons.sylk import SylkTree
+
 fields_opt = [
     SylkFieldTypes.Name(SylkFieldTypes.TYPE_DOUBLE),
     SylkFieldTypes.Name(SylkFieldTypes.TYPE_FLOAT),
     SylkFieldTypes.Name(SylkFieldTypes.TYPE_INT64),
     SylkFieldTypes.Name(SylkFieldTypes.TYPE_INT32),
     SylkFieldTypes.Name(SylkFieldTypes.TYPE_BOOL),
     SylkFieldTypes.Name(SylkFieldTypes.TYPE_STRING),
     SylkFieldTypes.Name(SylkFieldTypes.TYPE_MESSAGE),
     SylkFieldTypes.Name(SylkFieldTypes.TYPE_BYTES),
     SylkFieldTypes.Name(SylkFieldTypes.TYPE_ENUM),
     SylkFieldTypes.Name(SylkFieldTypes.TYPE_ONEOF),
     SylkFieldTypes.Name(SylkFieldTypes.TYPE_MAP),
-
 ]
 field_label = [
     SylkFieldLabels.Name(SylkFieldLabels.LABEL_OPTIONAL),
     SylkFieldLabels.Name(SylkFieldLabels.LABEL_REPEATED),
 ]
 
 well_known_type = _WellKnowns
 
 
-def package(results, sylk_json: SylkJson, architect: SylkArchitect, expand=False, verbose=False):
-    pkg = results['package']
-    if pkg.lower() == 'package':
+def package(
+    results,
+    sylk_json: SylkJson,
+    architect: SylkArchitect,
+    expand=False,
+    verbose=False,
+    deps=[]
+):
+    pkg = results["package"].replace('/','.')
+    pkg_name = ""
+    ver = parse_version_component(pkg)
+    if ver:
+        pkg_name = pkg.split('.')[-2]
+    else:
+        print_warning('creating package without a version component is risky for backward and forward compatibility\nmake sure you know what your doing: https://docs.sylk.build/proto/packages#unversioned-packages')
+        pkg_name = pkg.split('.')[-1]
+    if pkg_name.lower() == "package":
         print_error(
-            "Do not name your package as 'package' it can cause issues down the road\n\t-> please choose another name for your package")
+            "Do not name your package as 'package' it can cause issues down the road\n\t-> please choose another name for your package"
+        )
         exit(1)
     list_depend = well_known_type
-    prj_name = sylk_json.project.get('name')
+    prj_name = sylk_json.project.get("name")
     description = None
     if sylk_json.packages is not None:
         try:
-            if sylk_json.get_package(pkg):
+            if sylk_json.domain == pkg:
+                pkg_name = sylk_json.domain
+            else:
+                pkg_name = sylk_json.domain+'.'+pkg
+            if sylk_json.get_package(pkg_name):
                 print_error(
-                    f'Package [{pkg}] is already defined under "{prj_name}" project')
+                    f'Package [{pkg}] is already defined under "{prj_name}" project'
+                )
                 exit(1)
         except Exception:
-            logging.debug("Package not found continuing...")
+            pass
+            # logging.debug("Package not found continuing...")
         for p in sylk_json.packages:
-            list_depend.append(sylk_json.packages[p]['package'])
+            if sylk_json.packages[p]["package"] not in deps:
+                list_depend.append(sylk_json.packages[p]["package"])
     temp_d_list = []
     if expand:
-        description = ask_user_question(questions=[QText(name='description',message='Enter package description')])
-        description = description.get('description') if description.get('description') is not None else ''
-        
-        dependencies = ask_user_question(questions=[
-                QCheckbox(name="dependencies", message="Choose package dependencies (Use arrows keys to enable disable a language)", choices=list_depend)
-            ])
+        description = ask_user_question(
+            questions=[QText(name="description", message="Enter package description")]
+        )
 
-        temp_d_list = dependencies['dependencies']
+        if description is not None:
+            description = description.get("description")
+        else:
+            description = ''
+            print_warning('canceling description for package')
 
-    if verbose:
-        print_note(pkg, True, 'Added package')
+        dependencies = ask_user_question(
+            questions=[
+                QCheckbox(
+                    name="dependencies",
+                    message="Choose package dependencies (Use arrows keys to enable disable a language)",
+                    choices=list_depend,
+                )
+            ]
+        )
+        if dependencies:
+            temp_d_list = dependencies["dependencies"]
+            list_depend.extend(deps)
+        else:
+            print_warning('canceling dependencies attachment to package')
+            
 
-    architect.AddPackage(pkg, temp_d_list, description=description)
+    if verbose:
+        print_note(pkg, True, "Adding package")
+    sylk_json._proto_tree.add_node(sylk_json.domain+'.'+pkg_name,'package')
+    new_pkg = sylk_json._proto_tree._find_node(pkg,sylk_json._proto_tree.root)
+    if len(deps) > 0:
+        for d in deps:
+            temp_d_list.append(d)
+            new_pkg.references.append(d)
+    pkgs = sylk_json._proto_tree.topological_sort()[::-1]
+    if pkg_name not in pkgs:
+        pkgs.append(pkg_name)
+    architect.AddPackage(pkg, temp_d_list, description=description, version_component=ver, order_pkg=pkgs)
     architect.Save()
-    print_success(f'Success !\n\tCreated new package "{pkg}"')
+    print_success(f'Success !\n\t- Created new package "{pkg_name}"')
 
 
-def service(results, sylk_json: SylkJson, architect: SylkArchitect, expand=False, verbose=False):
-    svc = results['service']
-    if svc.lower() == 'service':
+def service(
+    results,
+    sylk_json: SylkJson,
+    architect: SylkArchitect,
+    expand=False,
+    verbose=False,
+    deps=[],
+    tag=None,
+):
+    svc = results["service"]
+    svc = results["service"].replace('/','.')
+    svc_name = ""
+    parent=results.get('package') if results.get('package') is not None else sylk_json.domain+'.'+'.'.join(svc.split('.')[:-1])
+    ver = parse_version_component(svc)
+    svc_name = svc.split('.')[-1]
+    description=None
+    if svc_name.lower() == "service":
         print_error(
-            "Do not set service name as 'service' it can cause issues down the road\n\t-> Please choose another name for your service")
+            "Do not set service name as 'service' it can cause issues down the road\n\t-> Please choose another name for your service"
+        )
         exit(1)
     list_depend = []
     if expand:
         if sylk_json.packages is not None:
             for p in sylk_json.packages:
-                if sylk_json.packages[p]['name'].lower() == svc:
+                if sylk_json.packages[p]["name"].lower() == svc_name:
                     print_error(
-                        f"Cannot create service {svc}, package by the same name is already exists !")
+                        f"Cannot create service {svc}, package by the same name is already exists !"
+                    )
                     exit(1)
-                list_depend.append((sylk_json.packages[p]['package'],sylk_json.packages[p]['package']))
-            depend = ask_user_question(questions=[
-                QCheckbox(name="dependencies", message="Choose service dependencies (Use arrows keys to enable disable a language)", choices=list_depend)
-            ])
+                if sylk_json.packages[p]["package"] not in deps:
+                    list_depend.append(
+                        (sylk_json.packages[p]["package"], sylk_json.packages[p]["package"])
+                    )
+            description = ask_user_question(
+                questions=[QText(name="description", message="Enter service description")]
+            )
+            if description is not None:
+                description = description.get("description")
+            else:
+                description = ''
+                print_warning('canceling description for package')
+            depend = ask_user_question(
+                questions=[
+                    QCheckbox(
+                        name="dependencies",
+                        message="Choose service dependencies (Use arrows keys to enable disable a language)",
+                        choices=list_depend,
+                    )
+                ]
+            )
             if depend is not None:
-                list_depend = depend['dependencies']
+                list_depend = depend["dependencies"]
+            else:
+                print_warning('canceling dependencies attachment to package')
+            list_depend.extend(deps)
 
     if sylk_json.services is not None:
-        if svc in sylk_json.services:
+        service = sylk_json.get_service(svc_name, sylk_json.domain +'.'+ parent)
+        if service is not None:
             print_error(
-                f"Service '{svc}' already exists under '{sylk_json.project.get('name')}'")
+                f"Service '{svc}' already exists under '{sylk_json.project.get('name')}'\n\t- Create the service under new package version"
+            )
             exit(1)
 
     if verbose:
-        print_note(svc, True, 'Added Service')
-
-    architect.AddService(svc, list_depend, None, [])
+        print_note(svc, True, "Added Service")
+    package = sylk_json.get_package(parent, False)
+    if len(deps) > 0:
+        for d in deps:
+            if d not in package.dependencies:
+                package.dependencies.append(d)
+            else:
+                print_warning('skipping attaching \'{}\' as it is already attached to package dependencies'.format(d))
+    pkgs = sylk_json._proto_tree.topological_sort()[::-1]
+    if package.package not in pkgs:
+        pkgs.append(package.package)
+    architect.AddService(svc_name, list_depend, description=description, methods=[], package=package,tag=tag,order_pkg=pkgs)
     architect.Save()
 
-    print_success(f'Success !\n\tCreated new service "{svc}"')
+    print_success(f'Success !\n\t- Created new service : "{svc}"')
 
 
-def message(results, sylk_json: SylkJson, architect: SylkArchitect, expand=False, verbose=False, parent: str = None):
-    msg_name = results['message']
-    if msg_name.lower() == 'message':
+def message(
+    results,
+    sylk_json: SylkJson,
+    architect: SylkArchitect,
+    expand=False,
+    verbose=False,
+    parent: str = None,
+    deps = [],
+    tag = None
+):
+    msg = results["message"].replace('/','.')
+    msg_name = msg.split('.')[-1]
+    description=None
+    
+    if '.'.join(msg.split('.')[:-1]) == sylk_json.domain:
+        pkg_name = sylk_json.domain
+    else:
+        pkg_name = sylk_json.domain+'.'+'.'.join(msg.split('.')[:-1])
+    pkg=results.get('package') if results.get('package') is not None else pkg_name
+    if msg_name.lower() == "message":
         print_error(
-            "Do not name your message as 'message' it can cause issues down the road\n\t-> please choose another name for your message")
+            "Do not name your message as 'message' it can cause issues down the road\n\t-> please choose another name for your message"
+        )
         exit(1)
-
-    pkg = results.get('package') if parent is None else parent
-    msg_full_name = '{0}.{1}'.format(pkg, msg_name)
-    description = ''
+    msg_full_name = "{0}.{1}".format(pkg, msg_name)
+    description = ""
     add_field = True
     temp_fields = []
     msg_fields = []
-    package = sylk_json.get_package(pkg.split('.')[1], False)
+    pkg = sylk_json.get_package(
+        pkg, False
+    )
     avail_msgs = []
     avail_field_ext = []
     avail_msg_ext = []
+    sylk_json._proto_tree.add_node(msg_full_name,'message')
 
-    for msg in package.messages:
+    for msg in pkg.messages:
         if msg.extension_type == 0:
             if msg.description is not None and msg.full_name != msg_full_name:
-                desc = f' - '+bcolors.OKBLUE+msg.description + bcolors.ENDC
+                desc = f" - " + bcolors.OKBLUE + msg.description + bcolors.ENDC
             else:
-                desc = ''
-            avail_msgs.append((f'{msg.name}{desc}', msg.full_name))
+                desc = ""
+            avail_msgs.append((f"{msg.name}{desc}", msg.full_name))
         else:
-            if SylkExtensions.Name(msg.extension_type) == 'FieldOptions':
+            if SylkExtensions.Name(msg.extension_type) == "FieldOptions":
                 for f in msg.fields:
-                    avail_field_ext.append((f'FieldOptions | {f.name}', f.full_name))
-            elif SylkExtensions.Name(msg.extension_type) == 'MessageOptions':
+                    avail_field_ext.append((f"FieldOptions | {f.name}", f.full_name))
+            elif SylkExtensions.Name(msg.extension_type) == "MessageOptions":
                 for f in msg.fields:
-                    avail_msg_ext.append((f'MessageOptions | {f.name}', f.full_name))
+                    avail_msg_ext.append((f"MessageOptions | {f.name}", f.full_name))
 
     avail_enums = []
-    for enum in package.enums:
+    for enum in pkg.enums:
         avail_enums.append((enum.name, enum.full_name))
-    for d in package.dependencies:
-
-        if 'google.protobuf' in d:
-            # sylk_json.get_package()
-            ext_msg_pkg = '.'.join(d.split('.')[:-1])
-            # Adding all Struct messages
-            if d.split('.')[-1] == 'Struct':
-                avail_msgs.append(
-                    ('{} [Google]'.format('Value'), '{0}.{1}'.format(ext_msg_pkg, 'Value')))
-            avail_msgs.append(
-                (d.split('.')[-1], '{0}.{1}'.format(ext_msg_pkg, d.split('.')[-1])))
+    
+    dependencies = pkg.dependencies
+    for d in deps:
+        if d not in dependencies:
+            dependencies.append(d)
+    for d in dependencies:
+        if "google.protobuf" in d:
+            for _,msgs in _WellMap:
+                for m in msgs:
+                    avail_msgs.append(
+                            (
+                                "{} [{}]".format(m,d+'.'+m),
+                                "{0}.{1}".format(d, m),
+                            )
+                        )
         else:
             d_package = sylk_json.get_package(
-                d.split('.')[1], False)
+                d,False
+            )
             if d_package is not None:
                 for msg in d_package.messages:
                     if msg.description is not None:
-                        desc = ' - '+bcolors.OKBLUE+msg.description + bcolors.ENDC
+                        desc = " - " + bcolors.OKBLUE + msg.description + bcolors.ENDC
                     else:
-                        desc = ''
+                        desc = ""
                     avail_msgs.append(
-                        (f'{msg.name} [{msg.full_name}]'+desc, msg.full_name))
+                        (f"{msg.name} [{msg.full_name}]" + desc, msg.full_name)
+                    )
+                for enm in d_package.enums:
+                    if enm.description is not None:
+                        desc = " - " + bcolors.OKBLUE + enm.description + bcolors.ENDC
+                    else:
+                        desc = ""
+                    avail_enums.append(
+                        (f"{enm.name} [{enm.full_name}]" + desc, enm.full_name)
+                    )
 
             for m in d_package.messages:
                 if m.extension_type is not None:
-                    if SylkExtensions.Name(msg.extension_type) == 'FieldOptions':
+                    if SylkExtensions.Name(msg.extension_type) == "FieldOptions":
                         for f in msg.fields:
-                            avail_field_ext.append((f'FieldOptions | {f.name}', f.full_name))
-                    elif SylkExtensions.Name(msg.extension_type) == 'MessageOptions':
+                            avail_field_ext.append(
+                                (f"FieldOptions | {f.name}", f.full_name)
+                            )
+                    elif SylkExtensions.Name(msg.extension_type) == "MessageOptions":
                         for f in msg.fields:
-                            avail_msg_ext.append((f'MessageOptions | {f.name}', f.full_name))
+                            avail_msg_ext.append(
+                                (f"MessageOptions | {f.name}", f.full_name)
+                            )
     extend = None
     if expand:
-        extend = ask_user_question(questions=[QConfirm(name='extend',message='Do you want to extend a message?')])
-        
-        if extend.get('extend'):
-            avail_options = [SylkExtensions.Name(
-                SylkExtensions.FieldOptions), SylkExtensions.Name(SylkExtensions.MessageOptions), SylkExtensions.Name(SylkExtensions.FileOptions),SylkExtensions.Name(SylkExtensions.ServiceOptions),SylkExtensions.Name(SylkExtensions.MethodOptions)]
-            extend = ask_user_question(questions=[QList(name='extend',message='Choose message extension',choices=avail_options)])
-            extend = SylkExtensions.Value(extend['extend'])
+        extend = ask_user_question(
+            questions=[
+                QConfirm(name="extend", message="Do you want to extend a message?")
+            ]
+        )
+
+        if extend.get("extend"):
+            avail_options = [
+                SylkExtensions.Name(SylkExtensions.FieldOptions),
+                SylkExtensions.Name(SylkExtensions.MessageOptions),
+                SylkExtensions.Name(SylkExtensions.FileOptions),
+                SylkExtensions.Name(SylkExtensions.ServiceOptions),
+                SylkExtensions.Name(SylkExtensions.MethodOptions),
+            ]
+            extend = ask_user_question(
+                questions=[
+                    QList(
+                        name="extend",
+                        message="Choose message extension",
+                        choices=avail_options,
+                    )
+                ]
+            )
+            extend = SylkExtensions.Value(extend["extend"])
         else:
             extend = None
             # add_extension = inquirer.prompt([inquirer.List('add_message_extension','Do you want to add message level extension?')],theme=SylkTheme())
-        
-        description = inquirer.prompt([inquirer.Text(
-            'description', 'Enter message description', '')], theme=SylkTheme())
+
+        description = inquirer.prompt(
+            [inquirer.Text("description", "Enter message description", "")],
+            theme=SylkTheme(),
+        )
         if description is not None:
-            description = description['description']
+            description = description["description"]
 
     while add_field == True:
-
         opt = []
         for f in fields_opt:
-            opt.append((f.split('_')[1].lower(), f))
+            opt.append((f.split("_")[1].lower(), f))
         labels = []
         for l in field_label:
-            labels.append((l.split('_')[1].lower(), l))
-
-        field = inquirer.prompt([
-            inquirer.Text(
-                'field', 'Enter field name', validate=validation),
-            inquirer.List(
-                'fieldType', 'Choose field type', choices=opt),
+            labels.append((l.split("_")[1].lower(), l))
 
-        ], theme=SylkTheme())
+        field = inquirer.prompt(
+            [
+                inquirer.Text("field", "Enter field name", validate=validation),
+                inquirer.List("fieldType", "Choose field type", choices=opt),
+            ],
+            theme=SylkTheme(),
+        )
         label = None
         if field is not None:
-            if field.get('fieldType') != 'TYPE_MAP' and field.get('fieldType') != 'TYPE_ONEOF':
-                label = inquirer.prompt([inquirer.List(
-                    'fieldLabel', 'Choose field label', choices=labels)], theme=SylkTheme())
+            if (
+                field.get("fieldType") != "TYPE_MAP"
+                and field.get("fieldType") != "TYPE_ONEOF"
+            ):
+                label = inquirer.prompt(
+                    [inquirer.List("fieldLabel", "Choose field label", choices=labels)],
+                    theme=SylkTheme(),
+                )
 
         message_type = None
         enum_type = None
 
-        if field['fieldType'] == SylkFieldTypes.Name(SylkFieldTypes.TYPE_MESSAGE):
+        if field["fieldType"] == SylkFieldTypes.Name(SylkFieldTypes.TYPE_MESSAGE):
             if len(avail_msgs) == 0:
                 print_warning("No messages availabe for field")
                 exit(1)
             else:
-                message = inquirer.prompt([
-                    inquirer.List(
-                        'message', 'Choose available messages', choices=avail_msgs)
-                ], theme=SylkTheme())
-                message_type = message['message']
+                message = inquirer.prompt(
+                    [
+                        inquirer.List(
+                            "message", "Choose available messages", choices=avail_msgs
+                        )
+                    ],
+                    theme=SylkTheme(),
+                )
+                message_type = message["message"]
+                sylk_json._proto_tree.add_field_reference(msg_full_name,field["field"],message_type)
 
-        elif field['fieldType'] == SylkFieldTypes.Name(SylkFieldTypes.TYPE_ENUM):
+        elif field["fieldType"] == SylkFieldTypes.Name(SylkFieldTypes.TYPE_ENUM):
             if len(avail_enums) == 0:
                 print_warning("No enums available for field")
                 exit(1)
             else:
-                message = inquirer.prompt([
-                    inquirer.List(
-                        'enum', 'Choose available enums', choices=avail_enums)
-                ], theme=SylkTheme())
-                enum_type = message['enum']
+                message = inquirer.prompt(
+                    [
+                        inquirer.List(
+                            "enum", "Choose available enums", choices=avail_enums
+                        )
+                    ],
+                    theme=SylkTheme(),
+                )
+                enum_type = message["enum"]
+                sylk_json._proto_tree.add_field_reference(msg_full_name,field["field"],enum_type)
 
         if field is None:
             add_field = False
         else:
-            new_field = field['field']
-            field_exists_validation(
-                new_field, temp_fields, msg_full_name)
+            new_field = field["field"]
+            field_exists_validation(new_field, temp_fields, msg_full_name)
+            sylk_json._proto_tree.add_node(msg_full_name+'.'+new_field,'field')
             f_ext = None
             if expand:
                 if len(avail_field_ext) > 0 and extend == None:
-                    extend_field = inquirer.prompt([inquirer.Confirm(
-                        'extend', message='Do you want to add field extension?')], theme=SylkTheme())
-                    if extend_field.get('extend'):
-                        f_ext = inquirer.prompt([inquirer.List(
-                            'extensions', 'Choose extension', choices=avail_field_ext)], theme=SylkTheme())
+                    extend_field = inquirer.prompt(
+                        [
+                            inquirer.Confirm(
+                                "extend", message="Do you want to add field extension?"
+                            )
+                        ],
+                        theme=SylkTheme(),
+                    )
+                    if extend_field.get("extend"):
+                        f_ext = inquirer.prompt(
+                            [
+                                inquirer.List(
+                                    "extensions",
+                                    "Choose extension",
+                                    choices=avail_field_ext,
+                                )
+                            ],
+                            theme=SylkTheme(),
+                        )
                         temp_pkg = sylk_json.get_package(
-                            f_ext['extensions'].split('.')[1], False)
+                            f_ext["extensions"].split(".")[1], False
+                        )
                         temp_msg = next(
-                            (m for m in temp_pkg.messages if m.name == f_ext['extensions'].split('.')[3]), None)
+                            (
+                                m
+                                for m in temp_pkg.messages
+                                if m.name == f_ext["extensions"].split(".")[3]
+                            ),
+                            None,
+                        )
                         temp_field = next(
-                            (f for f in temp_msg.fields if f.name == f_ext['extensions'].split('.')[-1]), None)
-                        if SylkFieldTypes.Name(temp_field.field_type) == 'TYPE_BOOL':
-                            f_ext_v = inquirer.prompt([inquirer.Confirm(
-                                'ext_value', 'Enter extension bool value', default=False)], theme=SylkTheme())
-                        elif SylkFieldTypes.Name(temp_field.field_type) == 'TYPE_DOUBLE' or SylkFieldTypes.Name(temp_field.field_type) == 'TYPE_FLOAT':
-                            f_ext_v = inquirer.prompt([inquirer.Text(
-                                'ext_value', 'Enter extension float value', validate=float_value_validate)], theme=SylkTheme())
+                            (
+                                f
+                                for f in temp_msg.fields
+                                if f.name == f_ext["extensions"].split(".")[-1]
+                            ),
+                            None,
+                        )
+                        if SylkFieldTypes.Name(temp_field.field_type) == "TYPE_BOOL":
+                            f_ext_v = inquirer.prompt(
+                                [
+                                    inquirer.Confirm(
+                                        "ext_value",
+                                        "Enter extension bool value",
+                                        default=False,
+                                    )
+                                ],
+                                theme=SylkTheme(),
+                            )
+                        elif (
+                            SylkFieldTypes.Name(temp_field.field_type) == "TYPE_DOUBLE"
+                            or SylkFieldTypes.Name(temp_field.field_type)
+                            == "TYPE_FLOAT"
+                        ):
+                            f_ext_v = inquirer.prompt(
+                                [
+                                    inquirer.Text(
+                                        "ext_value",
+                                        "Enter extension float value",
+                                        validate=float_value_validate,
+                                    )
+                                ],
+                                theme=SylkTheme(),
+                            )
                             try:
-                                f_ext_v = float(f_ext_v['ext_value'])
+                                f_ext_v = float(f_ext_v["ext_value"])
                             except Exception as e:
                                 logging.exception(e)
                                 exit(1)
-                        elif SylkFieldTypes.Name(temp_field.field_type) == 'TYPE_INT32' or SylkFieldTypes.Name(temp_field.field_type) == 'TYPE_INT64':
-                            f_ext_v = inquirer.prompt([inquirer.Text(
-                                'ext_value', 'Enter extension integer value', validate=int_value_validate)], theme=SylkTheme())
+                        elif (
+                            SylkFieldTypes.Name(temp_field.field_type) == "TYPE_INT32"
+                            or SylkFieldTypes.Name(temp_field.field_type)
+                            == "TYPE_INT64"
+                        ):
+                            f_ext_v = inquirer.prompt(
+                                [
+                                    inquirer.Text(
+                                        "ext_value",
+                                        "Enter extension integer value",
+                                        validate=int_value_validate,
+                                    )
+                                ],
+                                theme=SylkTheme(),
+                            )
                             try:
-                                f_ext_v = int(f_ext_v['ext_value'])
+                                f_ext_v = int(f_ext_v["ext_value"])
                             except Exception as e:
                                 logging.exception(e)
                                 exit(1)
-                        elif SylkFieldTypes.Name(temp_field.field_type) == 'TYPE_STRING':
-                            f_ext_v = inquirer.prompt([inquirer.Text(
-                                'ext_value', 'Enter extension string value')], theme=SylkTheme())
-                        temp_ext_name = f_ext['extensions'].split('.')
-                        if '.'.join(temp_ext_name[:-2]) == pkg:
-                            f_ext = {'.'.join(temp_ext_name[-2:]): f_ext_v}
+                        elif (
+                            SylkFieldTypes.Name(temp_field.field_type) == "TYPE_STRING"
+                        ):
+                            f_ext_v = inquirer.prompt(
+                                [
+                                    inquirer.Text(
+                                        "ext_value", "Enter extension string value"
+                                    )
+                                ],
+                                theme=SylkTheme(),
+                            )
+                        temp_ext_name = f_ext["extensions"].split(".")
+                        if ".".join(temp_ext_name[:-2]) == pkg.name:
+                            f_ext = {".".join(temp_ext_name[-2:]): f_ext_v}
                         else:
-                            f_ext = {f_ext['extensions']: f_ext_v}
+                            f_ext = {f_ext["extensions"]: f_ext_v}
 
-                f_description = inquirer.prompt([inquirer.Text(
-                    'description', 'Enter field description', '')], theme=SylkTheme())
+                f_description = inquirer.prompt(
+                    [inquirer.Text("description", "Enter field description", "")],
+                    theme=SylkTheme(),
+                )
                 if f_description is not None:
-                    f_description = f_description['description']
+                    f_description = f_description["description"]
             else:
-                f_description = ''
+                f_description = ""
 
             temp_fields.append(new_field)
             map_types = None
             oneof_fields = []
-            if field['fieldType'] == 'TYPE_MAP':
-                map_types = inquirer.prompt([
-                    inquirer.List(
-                        'keyType', '[MAP] Choose key type', choices=[o for o in opt if  o[1] != 'TYPE_BOOL' and o[1] != 'TYPE_FLOAT' and o[1] != 'TYPE_DOUBLE' and o[1] != 'TYPE_ENUM' and o[1] != 'TYPE_MESSAGE' and o[1] != 'TYPE_MAP' and o[1] != 'TYPE_ONEOF' and o[1] != 'TYPE_BYTES']),
-                    inquirer.List(
-                        'valueType', '[MAP] Choose value type', choices=[o for o in opt if o[1] != 'TYPE_MAP' and o[1] != 'TYPE_ONEOF'])
-                ], theme=SylkTheme())
-                
-                if map_types.get('valueType') == 'TYPE_MESSAGE' or map_types.get('valueType') == 'TYPE_ENUM':
-                    if map_types.get('valueType') == 'TYPE_MESSAGE':
+            if field["fieldType"] == "TYPE_MAP":
+                map_types = inquirer.prompt(
+                    [
+                        inquirer.List(
+                            "keyType",
+                            "[MAP] Choose key type",
+                            choices=[
+                                o
+                                for o in opt
+                                if o[1] != "TYPE_BOOL"
+                                and o[1] != "TYPE_FLOAT"
+                                and o[1] != "TYPE_DOUBLE"
+                                and o[1] != "TYPE_ENUM"
+                                and o[1] != "TYPE_MESSAGE"
+                                and o[1] != "TYPE_MAP"
+                                and o[1] != "TYPE_ONEOF"
+                                and o[1] != "TYPE_BYTES"
+                            ],
+                        ),
+                        inquirer.List(
+                            "valueType",
+                            "[MAP] Choose value type",
+                            choices=[
+                                o
+                                for o in opt
+                                if o[1] != "TYPE_MAP" and o[1] != "TYPE_ONEOF"
+                            ],
+                        ),
+                    ],
+                    theme=SylkTheme(),
+                )
+
+                if (
+                    map_types.get("valueType") == "TYPE_MESSAGE"
+                    or map_types.get("valueType") == "TYPE_ENUM"
+                ):
+                    if map_types.get("valueType") == "TYPE_MESSAGE":
                         if len(avail_msgs) == 0:
                             print_warning("[MAP] No messages availabe for field")
                             exit(1)
                         else:
-                            message = inquirer.prompt([
-                                inquirer.List(
-                                    'message', '[MAP] Choose available messages', choices=avail_msgs)
-                            ], theme=SylkTheme())
-                            message_type = message['message']
-                    elif map_types.get('valueType') == 'TYPE_ENUM':
+                            message = inquirer.prompt(
+                                [
+                                    inquirer.List(
+                                        "message",
+                                        "[MAP] Choose available messages",
+                                        choices=avail_msgs,
+                                    )
+                                ],
+                                theme=SylkTheme(),
+                            )
+                            message_type = message["message"]
+                            sylk_json._proto_tree.add_field_reference(msg_full_name,new_field,message_type)
+
+                    elif map_types.get("valueType") == "TYPE_ENUM":
                         if len(avail_enums) == 0:
                             print_warning("[MAP] No enums available for field")
                             exit(1)
                         else:
-                            message = inquirer.prompt([
-                                inquirer.List(
-                                    'enum', '[MAP] Choose available enums', choices=avail_enums)
-                            ], theme=SylkTheme())
-                            enum_type = message['enum']
-            elif field['fieldType'] == 'TYPE_ONEOF':
+                            message = inquirer.prompt(
+                                [
+                                    inquirer.List(
+                                        "enum",
+                                        "[MAP] Choose available enums",
+                                        choices=avail_enums,
+                                    )
+                                ],
+                                theme=SylkTheme(),
+                            )
+                            enum_type = message["enum"]
+                            sylk_json._proto_tree.add_field_reference(msg_full_name,new_field,enum_type)
+
+            elif field["fieldType"] == "TYPE_ONEOF":
                 temp_fields_oneof = []
                 add_field_oneof = True
-                oneof_fields = add_fields_oneof(add_field_oneof,avail_msgs=avail_msgs,avail_enums=avail_enums,pre_fields=temp_fields_oneof,msg_full_name=msg_full_name)
-            msg_fields.append(SylkField(
-                new_field, field['fieldType'], label['fieldLabel'] if label is not None else 'LABEL_OPTIONAL',
-                message_type=message_type, enum_type=enum_type, description=f_description,
-                extensions=f_ext, key_type=map_types.get('keyType') if map_types is not None else None, value_type=map_types.get('valueType') if map_types is not None else None, oneof_fields=oneof_fields).to_dict())
-
-            nextfield = inquirer.prompt([
-                inquirer.Confirm(
-                    'continue', message='Add more fields?', default=True)
-            ], theme=SylkTheme())
+                oneof_fields = add_fields_oneof(
+                    add_field_oneof,
+                    avail_msgs=avail_msgs,
+                    avail_enums=avail_enums,
+                    pre_fields=temp_fields_oneof,
+                    msg_full_name=msg_full_name,
+                    parent_field=new_field,
+                    tree=sylk_json._proto_tree
+                )
+
+
+            msg_fields.append(
+                SylkField(
+                    new_field,
+                    field["fieldType"],
+                    label["fieldLabel"] if label is not None else "LABEL_OPTIONAL",
+                    message_type=message_type,
+                    enum_type=enum_type,
+                    description=f_description,
+                    extensions=f_ext,
+                    key_type=map_types.get("keyType")
+                    if map_types is not None
+                    else None,
+                    value_type=map_types.get("valueType")
+                    if map_types is not None
+                    else None,
+                    oneof_fields=oneof_fields,
+                ).to_dict()
+            )
+
+            nextfield = inquirer.prompt(
+                [
+                    inquirer.Confirm(
+                        "continue", message="Add more fields?", default=True
+                    )
+                ],
+                theme=SylkTheme(),
+            )
             if nextfield is None:
                 add_field = False
             else:
-                if nextfield['continue'] == False:
+                if nextfield["continue"] == False:
                     add_field = False
 
         if verbose:
-            print_note(field, True, 'Added field')
-    package = sylk_json.get_package(pkg.split('.')[1], False)
-    if next((m for m in package.messages if m.name == msg_name), None) is None:
+            print_note(field, True, "Added field")
+    if next((m for m in pkg.messages if m.name == msg_name), None) is None:
         if verbose:
-            print_note(msg_name, True, 'Added Message')
-
-        architect.AddMessage(package, msg_name,
-                             msg_fields, description, extend)
+            print_note(msg_name, True, "Added Message")
+        
+        # msg_node = sylk_json._proto_tree.get_references(pkg.package + '.' msg_name)
+        pkgs = sylk_json._proto_tree.topological_sort()[::-1]
+        if pkg.package not in pkgs:
+            pkgs.append(pkg.package)
+        architect.AddMessage(
+            pkg,
+            msg_name,
+            msg_fields,
+            description,
+            extend,
+            tag=tag,
+            order_pkg=pkgs
+        )
         architect.Save()
         print_success(f"Created Message !\n\t- {msg_name}\n")
     else:
-        print_error(
-            f'Message "{msg_name}" already exists under "{package.package}"')
+        print_error(f'Message "{msg_name}" already exists under "{pkg.package}"')
 
 
-def add_fields_oneof(add_field:bool,avail_msgs,avail_enums,pre_fields,msg_full_name):
+def add_fields_oneof(
+    add_field: bool, avail_msgs, avail_enums, pre_fields, msg_full_name, parent_field, tree: SylkTree
+):
     final_fields = pre_fields
     while add_field:
         opt = []
         for f in fields_opt:
-            opt.append((f.split('_')[1].lower(), f))
+            opt.append((f.split("_")[1].lower(), f))
         labels = []
         for l in field_label:
-            labels.append((l.split('_')[1].lower(), l))
+            labels.append((l.split("_")[1].lower(), l))
 
-        field = inquirer.prompt([
-            inquirer.Text(
-                'field', '[ONEOF] Enter field name', validate=validation),
-            inquirer.List(
-                'fieldType', '[ONEOF] Choose field type', choices=[o for o in opt if o != 'TYPE_MAP' and o != 'TYPE_ONEOF']),
-
-        ], theme=SylkTheme())
+        field = inquirer.prompt(
+            [
+                inquirer.Text("field", "[ONEOF] Enter field name", validate=validation),
+                inquirer.List(
+                    "fieldType",
+                    "[ONEOF] Choose field type",
+                    choices=[o for o in opt if o != "TYPE_MAP" and o != "TYPE_ONEOF"],
+                ),
+            ],
+            theme=SylkTheme(),
+        )
 
         label = None
         message_type = None
         enum_type = None
-
-        if field['fieldType'] == SylkFieldTypes.Name(SylkFieldTypes.TYPE_MESSAGE):
+        tree.add_node(msg_full_name+'.'+parent_field+'.'+field['field'],'field')
+        if field["fieldType"] == SylkFieldTypes.Name(SylkFieldTypes.TYPE_MESSAGE):
             if len(avail_msgs) == 0:
                 print_warning("[ONEOF] No messages availabe for field")
                 exit(1)
             else:
-                message = inquirer.prompt([
-                    inquirer.List(
-                        'message', '[ONEOF] Choose available messages', choices=avail_msgs)
-                ], theme=SylkTheme())
-                message_type = message['message']
+                message = inquirer.prompt(
+                    [
+                        inquirer.List(
+                            "message",
+                            "[ONEOF] Choose available messages",
+                            choices=avail_msgs,
+                        )
+                    ],
+                    theme=SylkTheme(),
+                )
+                message_type = message["message"]
+                tree.add_field_reference(msg_full_name,field['field'],message_type)
 
-        elif field['fieldType'] == SylkFieldTypes.Name(SylkFieldTypes.TYPE_ENUM):
+        elif field["fieldType"] == SylkFieldTypes.Name(SylkFieldTypes.TYPE_ENUM):
             if len(avail_enums) == 0:
                 print_warning("[ONEOF] No enums available for field")
                 exit(1)
             else:
-                message = inquirer.prompt([
-                    inquirer.List(
-                        'enum', '[ONEOF] Choose available enums', choices=avail_enums)
-                ], theme=SylkTheme())
-                enum_type = message['enum']
-
+                message = inquirer.prompt(
+                    [
+                        inquirer.List(
+                            "enum",
+                            "[ONEOF] Choose available enums",
+                            choices=avail_enums,
+                        )
+                    ],
+                    theme=SylkTheme(),
+                )
+                enum_type = message["enum"]
+                tree.add_field_reference(msg_full_name,field['field'],enum_type)
         if field is None:
             add_field = False
         else:
-            new_field = field['field']
+            new_field = field["field"]
             field_exists_validation(
-                new_field, final_fields, msg_full_name+'.'+new_field)
+                new_field, final_fields, msg_full_name + "." + new_field
+            )
+
+        final_fields.append(
+            SylkField(
+                new_field,
+                field["fieldType"],
+                label["fieldLabel"] if label is not None else "LABEL_OPTIONAL",
+                message_type=message_type,
+                enum_type=enum_type,
+                description=None,
+                extensions=None,
+                key_type=None,
+                value_type=None,
+                oneof_fields=[],
+            ).to_dict()
+        )
 
-        final_fields.append(SylkField(
-                new_field, field['fieldType'], label['fieldLabel'] if label is not None else 'LABEL_OPTIONAL',
-                message_type=message_type, enum_type=enum_type, description=None,
-                extensions=None, key_type=None, value_type=None, oneof_fields=[]).to_dict())
-
-        nextfield = inquirer.prompt([
-            inquirer.Confirm(
-                'continue', message='[ONEOF] Add more fields?', default=True)
-        ], theme=SylkTheme())
+        nextfield = inquirer.prompt(
+            [
+                inquirer.Confirm(
+                    "continue", message="[ONEOF] Add more fields?", default=True
+                )
+            ],
+            theme=SylkTheme(),
+        )
         if nextfield is None:
             add_field = False
         else:
-            if nextfield['continue'] == False:
+            if nextfield["continue"] == False:
                 add_field = False
     return final_fields
 
-def rpc(results, sylk_json: SylkJson, architect: SylkArchitect, expand=None, parent: str = None):
-    rpc = results['rpc']
-    svc = results.get(
-        'service') if parent is None else f'{sylk_json.domain}.{parent}.v1'
-    full_name = '{0}.{1}'.format(svc, rpc)
 
+def rpc(
+    results,
+    sylk_json: SylkJson,
+    architect: SylkArchitect,
+    expand=None,
+    parent: str = None,
+    deps = [],
+):
+    rpc = results["rpc"].replace('/','.')
+    svc = results.get('service') if results.get('service') is not None else sylk_json.domain+'.'+'.'.join(rpc.split('.')[:-1])
+    pkg_path = '.'.join(svc.split('.')[:-1])
+    full_name = "{0}.{1}".format(svc, rpc)
     if sylk_json.get_rpc(full_name) is not None:
-        print_error(
-            f'RPC [{rpc}] is already defined under "{svc}" service')
+        print_error(f'RPC [{rpc}] is already defined under "{svc}" service')
         exit(1)
-
-    dependencies = sylk_json.services['protos/{0}/{1}/{2}/{1}.proto'.format(svc.split('.')[0],svc.split('.')[1],svc.split('.')[2])].get('dependencies')
-
+    
+    package = sylk_json.get_package(pkg_path,False)
+    service = sylk_json.get_service(svc,False)
+    dependencies = package.dependencies
     if dependencies is None:
-        svc_name = svc.split('.')[1]
-        print_error(
-            f'Dependencies not listed under "{svc}"\n\tTry attache first a packge to service\n\tRun: \'sylk package <some.package.v1> {svc_name}\'')
-        print_warning("Try and list all available packages with `$ sylk ls --type package`")
-        exit(1)
-
+        try:
+            sylk_json.get_package(pkg_path)
+            dependencies = [svc]
+        except Exception:
+            svc_name = svc.split(".")[1]
+            print_error(
+                f"Dependencies not listed under \"{svc}\"\n\tTry to attach a package to service\n\tRun: 'sylk package <some.package.v1> {svc}'"
+            )
+            print_warning(
+                "Try and list all available packages with `$ sylk ls --type package`"
+            )
+            exit(1)
+    
     avail = []
+    for d in deps:
+        if d not in dependencies:
+            dependencies.append(d)
     for d in dependencies:
-        pkg = sylk_json.get_package(d.split('.')[1])
-        msgs = pkg.get('messages')
-        if msgs is not None:
-            for m in msgs:
-                avail.append(m['fullName'])
+        if "google.protobuf" in d:
+            for _, msgs in _WellMap:
+                for m in msgs:
+                    wellknown_msg = d+'.'+m
+                    avail.append(('{} [{}]'.format(wellknown_msg.split('.')[-1],wellknown_msg),wellknown_msg))
+        else:
+            pkg = sylk_json.get_package(d)
+            msgs = pkg.get("messages")
+            if msgs is not None:
+                for m in msgs:
+                    avail.append(('{} [{}]'.format(m["fullName"].split('.')[-1],m["fullName"]),m["fullName"]))
+    
+    for m in package.messages:
+        avail.append(('{} [{}]'.format(m.full_name.split('.')[-1],m.full_name),m.full_name))
+
     if len(avail) == 0:
-        print_error('Messages not listed under packages')
+        print_error("Messages not listed under packages")
         exit(1)
 
     description = None
     if expand:
         description = inquirer.prompt(
-            [inquirer.Text('description', 'Enter RPC description', '')], theme=SylkTheme())
+            [inquirer.Text("description", "Enter RPC description", "")],
+            theme=SylkTheme(),
+        )
         if description is not None:
-            description = description['description']
+            description = description["description"]
 
-    inputs_outputs = inquirer.prompt([
-        inquirer.List(
-            "input_type", message="Choose the input type", choices=avail),
-        inquirer.List(
-            "output_type", message="Choose the output type", choices=avail),
-    ], theme=SylkTheme())
+    inputs_outputs = inquirer.prompt(
+        [
+            inquirer.List("input_type", message="Choose the input type", choices=avail),
+            inquirer.List(
+                "output_type", message="Choose the output type", choices=avail
+            ),
+        ],
+        theme=SylkTheme(),
+    )
     if inputs_outputs is None:
-        print_error('IN/OUT Types are required for RPC')
+        print_error("IN/OUT Types are required for RPC")
         exit(1)
-    architect.AddRPC(sylk_json.get_service(svc.split('.')[1], False,sylk_json=sylk_json._sylk_json), rpc, [
-        (results['type'][0], inputs_outputs['input_type']), (results['type'][1], inputs_outputs['output_type'])], description)
+    pkgs = sylk_json._proto_tree.topological_sort()[::-1]
+    if package.package not in pkgs:
+        pkgs.append(package.package)
+    architect.AddRPC(
+        package,
+        service,
+        rpc,
+        pkgs,
+        [
+            (results["type"][0], inputs_outputs["input_type"]),
+            (results["type"][1], inputs_outputs["output_type"]),
+        ],
+        description,
+    )
     architect.Save()
     print_success(f'Success !\n\tCreated new RPC "{rpc}"')
-    lang = sylk_json.project.get('server').get('language')
-    lang_suffix = 'ts' if lang == 'typescript' else 'py' if lang == 'python' else 'Unknown'
-    path_to_svc = sylk_json.path+'/services/' + \
-        svc.split('.')[1]+'.'+lang_suffix
+    lang = sylk_json.project.get("server").get("language")
+    lang_suffix = (
+        "ts" if lang == "typescript" else "py" if lang == "python" else "Unknown"
+    )
+    path_to_svc = sylk_json.path + "/services/" + svc.split(".")[1] + "." + lang_suffix
     print_warning(
-        f'\t- Make sure you are adding the new RPC "{rpc}" method to your service implemantation file at {path_to_svc}')
+        f'\t- Make sure you are adding the new RPC "{rpc}" method to your service implemantation file at {path_to_svc}'
+    )
     print_warning(
-        f'\t- For more information on how to edit your service implemantation files see https://docs.sylk.build/cli/edit?lang='+lang)
-
+        f"\t- For more information on how to edit your service implemantation files see https://docs.sylk.build/cli/edit?lang="
+        + lang
+    )
+
+
+def enum(
+    results,
+    sylk_json: SylkJson,
+    architect: SylkArchitect,
+    parent: str,
+    generate_package_func=None,
+    tag = None
+):
+    enum = results["enum"].replace('/','.')
+    enum_name = enum.split('.')[-1]
+    description=None
+    if sylk_json.domain == '.'.join(enum.split('.')[:-1]):
+        pkg_name = sylk_json.domain
+    else:
+        pkg_name = sylk_json.domain + '.' + '.'.join(enum.split('.')[:-1])
+    pkg=results.get('package') if results.get('package') is not None else pkg_name
+    # pkg = results['package'] if parent is None else parent
+    try:
+        package = sylk_json.get_package(
+            pkg, False
+        )
+    except Exception as e:
+        if generate_package_func is not None:
+            print_note(
+                "Package {} is not valid, will create new default package.".format(pkg)
+            )
+            results["package"] = pkg.split(".")[1]
+            generate_package_func(
+                results, sylk_json, architect
+            )
+            sylk_json = SylkJson(architect._sylk.sylkJson.copy())
+            package = sylk_json.get_package(
+                pkg, False
+            )
+        else:
+            print_error(
+                "A function to create package instance is not specified. please create the package before creating message."
+            )
+            exit(1)
 
-def enum(results, sylk_json: SylkJson, architect: SylkArchitect, parent: str):
-    enum_name = results['enum']
-    pkg = results['package'] if parent is None else parent
-    package = sylk_json.get_package(pkg.split('.')[1], False)
+    # package = sylk_json.get_package(pkg.split('.')[1], False)
     if package.enums:
         if next((e for e in package.enums if e.name == enum_name), None) is not None:
-            print_error(
-                f'Enum "{enum_name}" already exists under "{pkg}" package')
+            print_error(f'Enum "{enum_name}" already exists under "{pkg}" package')
             exit(1)
     add_value = True
     e_values = []
     while add_value:
-        ev = inquirer.prompt([
-            inquirer.Text(
-                'name', 'Enter value name', validate=validation),
-            inquirer.Text(
-                'value', 'Enter enum value', validate=enum_value_validate),
-        ], theme=SylkTheme())
+        ev = inquirer.prompt(
+            [
+                inquirer.Text("name", "Enter value name", validate=validation),
+                inquirer.Text(
+                    "value", "Enter enum value", validate=enum_value_validate
+                ),
+            ],
+            theme=SylkTheme(),
+        )
         if ev is not None:
-            if int(ev['value']) == 0:
+            if int(ev["value"]) == 0:
                 print_warning(
-                    'Enum values with 0 will be ignored by gRPC and should be used only as default value')
-            confirm = inquirer.prompt([inquirer.Confirm(
-                'continue', message='Add more values?', default=True)], theme=SylkTheme())
-            v_name = ev['name']
+                    "Enum values with 0 will be ignored by gRPC and should be used only as default value"
+                )
+            confirm = inquirer.prompt(
+                [
+                    inquirer.Confirm(
+                        "continue", message="Add more values?", default=True
+                    )
+                ],
+                theme=SylkTheme(),
+            )
+            v_name = ev["name"]
 
-            if confirm.get('continue') == False or confirm.get('continue') == None:
+            if confirm.get("continue") == False or confirm.get("continue") == None:
                 add_value = False
-            if next((v for v in e_values if v['name'] == ev['name']), None) is not None:
+            if next((v for v in e_values if v["name"] == ev["name"]), None) is not None:
                 print_error(
-                    f'Enum values names must be unique ! {v_name} appears already in {enum_name}')
+                    f"Enum values names must be unique, {v_name} appears already in {enum_name}"
+                )
                 exit(1)
-            if next((v for v in e_values if v.get('number') == int(ev.get('value'))), None) is not None:
-                print_error(
-                    'Enum values must be unique inside the enum scope !')
+            if (
+                next(
+                    (v for v in e_values if v.get("number") == int(ev.get("value"))),
+                    None,
+                )
+                is not None
+            ):
+                print_error("Enum values must be unique inside the enum scope")
                 exit(1)
 
             for e in package.enums:
-                if next((v for v in e.values if v.name == ev['name']), None):
+                if next((v for v in e.values if v.name == ev["name"]), None):
+                    print_error(
+                        f"Enum values names must be unique in all enums in package, {v_name} appears already in {e.full_name}"
+                    )
+                    exit(1)
+            for e in package.enums:
+                if ev['name'] == e.name:
                     print_error(
-                        f'Enum values names must be unique in all enums in package ! {v_name} appears already in {e.full_name}')
+                        f"Enum values names cannot be the same as messages names or enums that are already described in the proto package"
+                    )
                     exit(1)
 
-            e_values.append(SylkEnumValue(
-                ev['name'], int(ev['value'])).to_dict())
+            e_values.append(SylkEnumValue(ev["name"], int(ev["value"])).to_dict())
         else:
             print_error("Enum values are required")
             exit(1)
-    if next((v for v in e_values if v['number'] == 0), None) is None:
-        e_values.insert(0, SylkEnumValue(
-            f'UNKNOWN_{enum_name.upper()}', 0).to_dict())
-        print_warning(
-            f'Adding default enum value "UNKNOWN_{enum_name.upper()}" : 0')
-    architect.AddEnum(package, enum_name, e_values)
+    if next((v for v in e_values if v["number"] == 0), None) is None:
+        e_values.insert(0, SylkEnumValue(f"UNKNOWN_{enum_name.upper()}", 0).to_dict())
+        print_warning(f'Adding default enum value "UNKNOWN_{enum_name.upper()}" : 0')
+    pkgs = sylk_json._proto_tree.topological_sort()[::-1]
+    if package.package not in pkgs:
+        pkgs.append(package.package)
+    architect.AddEnum(package, enum_name, e_values, tag, order_pkg=pkgs)
     architect.Save()
 
 
 def field_exists_validation(new_field, fields, msg):
     if new_field in fields:
-        raise SylkProtoError(
-            'Message', f'Field {new_field} already exits under {msg}')
+        raise SylkProtoError("Message", f"Field {new_field} already exits under {msg}")
     return True
 
 
 def enum_value_validate(answers, current):
     try:
         int(current)
     except Exception:
         raise errors.ValidationError(
-            current, reason='Enum Value MUST be an integer value')
+            current, reason="Enum Value MUST be an integer value"
+        )
     return True
 
 
 def float_value_validate(answers, current):
     try:
         float(current)
     except Exception:
-        raise errors.ValidationError(
-            current, reason='Value must be valid float type')
+        raise errors.ValidationError(current, reason="Value must be valid float type")
     return True
 
 
 def int_value_validate(answers, current):
     try:
         int(current)
     except Exception:
-        raise errors.ValidationError(
-            current, reason='Value must be valid integer type')
+        raise errors.ValidationError(current, reason="Value must be valid integer type")
     return True
 
 
 def validation(answers, current):
-
     if len(current) == 0:
+        raise errors.ValidationError(current, reason="Resource name must not be blank")
+    if len(re.findall("\s", current)) > 0:
         raise errors.ValidationError(
-            current, reason='Resource name must not be blank')
-    if len(re.findall('\s', current)) > 0:
-        raise errors.ValidationError(
-            current, reason='Resource name must not include blank spaces')
-    if len(re.findall('-', current)) > 0:
+            current, reason="Resource name must not include blank spaces"
+        )
+    if len(re.findall("-", current)) > 0:
         raise errors.ValidationError(
-            current, reason='Resource name must not include hyphens, underscores are allowed')
+            current,
+            reason="Resource name must not include hyphens, underscores are allowed",
+        )
     return True
```

## sylk/cli/commands/ls.py

```diff
@@ -64,68 +64,71 @@
     for tmp in configs.get('sylk_templates'):
         print_info(tmp)
     print()
     print_note("In order to create a new project based on template run the following\n\t-> $ sylk new MyTodo --template @sylk/TodoAppPy")
 
 def list_dependencies(resource,sylk_json:SylkJson):
     resources = []
-
+    print(sylk_json._proto_tree.topological_sort())
     if resource is None or resource in ['service','package']:
         for p in sylk_json.packages:
             pkg = sylk_json.packages[p]
             resources.append(pkg)
         for s in sylk_json.services:
-            svc = sylk_json.services[s]
-            resources.append(svc)
+            resources.append(s)
 
         resourcesSorted = Graph(resources,True).topologicalSort()
     elif resource == 'message':
         for p in sylk_json.packages:
             pkg = sylk_json.packages[p]
             for m in pkg.get('messages'):
                 resources.append(m)
         resourcesSorted = dict(Graph(resources).graph)
         del resourcesSorted[None]
+    else:
+        print_error("not supporting listing dependencies for: rpc / fields / enums / enum values")
+        exit(1)
 
     print_info('Listing Dependencies {}'.format(resource if resource is not None else 'All'),True)
     
     for dep in resourcesSorted:
-        if len(dep.split('.')) == 1:
+        try:
+            pkg = sylk_json.get_package(dep)
+            if resource is None or resource == 'package':
+                print()
+                print_note('|| Package: {}'.format(dep))
+                pkg_name = '{0}/{1}'.format(sylk_json._root_protos,dep.replace('.','/'))
+                if sylk_json.packages[pkg_name].get('dependencies'):
+                    for d in sylk_json.packages[pkg_name].get('dependencies'):
+                        print('    ||\t     |\n    ||\t      -- {}'.format(d))
+        except:
+            svc = sylk_json.get_service(dep)
             if resource is None or resource == 'service':
                 print()
                 # display_resource(dep,sylk_json,1)
                 print_success('|| Service: {}'.format(dep))
 
-                if sylk_json.services[dep].get('dependencies'):
-                    for d in sylk_json.services[dep].get('dependencies'):
+                if svc.get('dependencies'):
+                    for d in svc.get('dependencies'):
                         print('    ||\t     |\n    ||\t     Package -- {}'.format(d))
                         if 'google.protobuf.' not in d:
-                            deep_pkg_domain = d.split('.')[0]
-                            deep_pkg = d.split('.')[1]
-                            deep_pkg_version = d.split('.')[2]
-                            pkg_proto_path = f'protos/{deep_pkg_domain}/{deep_pkg}/{deep_pkg_version}/{deep_pkg}.proto'
+                            pkg_proto_path = '.'.join(d.split('.')[:-1])
                             if sylk_json.packages[pkg_proto_path].get('dependencies'):
                                 for deep_dep in sylk_json.packages[pkg_proto_path].get('dependencies'):
                                     if 'google.protobuf.' not in deep_dep:
                                         print('    ||\t\t     |\n    ||\t             Package -- {}'.format(deep_dep))
                                     else: 
                                         print('    ||\t\t     |\n    ||\t             Package -- {}'.format(deep_dep))
 
                             # for deep_dep in sylk_json.packages[f'protos/{deep_pkg_version}/{deep_pkg}.proto'].get('dependencies'):
                         else:
                             print('    ||\t     |\n    ||\t      Package -- {}'.format(d))
-        elif resource is None or resource == 'package':
-            print()
-            print_note('| Package: {}'.format(dep))
-            pkg_name = 'protos/{0}/{1}/{2}/{1}.proto'.format(dep.split('.')[0],dep.split('.')[1],dep.split('.')[2])
-            if sylk_json.packages[pkg_name].get('dependencies'):
-                for d in sylk_json.packages[pkg_name].get('dependencies'):
-                    print('    ||\t     |\n    ||\t      -- {}'.format(d))
         
-        elif resource == 'message':
+        
+        if resource == 'message':
             msg = resourcesSorted[dep]
             print()
             print_note('|| Message: {}'.format(dep))
             for m in msg:
                 if m is not None:
                     print('    ||\t     |\n    |\t      - * {}'.format(m))
 
@@ -152,15 +155,15 @@
             print_warning(f'Resource {full_name} wasnt found services')
     # Packages list
     elif args_split == 3:
         try:
             pkg = sylk_json.get_package(full_name.split('.')[1])
             header = ['Package','Messages','Enums','Dependencies']
             tab = PrettyTable(header)
-            tab.add_row([pkg['name'],len(pkg.get('messages') if pkg.get('messages') is not None else []),len(pkg.get('enums')) if pkg.get('enums') is not None else 0,pkg.get('dependencies')])
+            tab.add_row([pkg['name']+ ' [{}]'.format(pkg['package'].split('.')[-1]),len(pkg.get('messages') if pkg.get('messages') is not None else []),len(pkg.get('enums')) if pkg.get('enums') is not None else 0,pkg.get('dependencies')])
             print_info(tab,True,'Listing package resource')
         except Exception as e:
             logging.error(e)
             print_warning(f'Resource {full_name} wasnt found on packages')
     # Enums list
     elif args_split > 3 and args_split <= 4:
         try:
@@ -249,15 +252,15 @@
 
             for pkg in sylk_json.packages:
                 pkg = sylk_json.packages[pkg]
                 ext = []
                 if pkg.get('extensions') is not None:
                     ext = list(map(lambda k: k,pkg.get('extensions')))
                 ext = ext if len(ext) >0 else '-'
-                tab.add_row([pkg['name'],len(pkg.get('messages') if pkg.get('messages') is not None else []),len(pkg.get('enums') if pkg.get('enums') is not None else []),pkg.get('dependencies'),ext ])
+                tab.add_row([pkg['name']+ ' [{}]'.format(pkg['package'].split('.')[-1]),len(pkg.get('messages') if pkg.get('messages') is not None else []),len(pkg.get('enums') if pkg.get('enums') is not None else []),pkg.get('dependencies'),ext ])
             print_info(tab,True,'Listing packages resources')
         else:
             print_warning("No packages under {}".format(sylk_json.project.get('packageName')))
 
     # Messages List
     elif type == 'message':
         header = ['Message','Fields','Package','Extensions','Extending']
@@ -324,22 +327,21 @@
     
     if sylk_json.services:
         # RPC's list
         header = ['RPC','Type','Input','Output']
         tab_rpcs = PrettyTable(header)
         
         for svc in sylk_json.services:
-            service=sylk_json.services[svc]
             ext = []
-            if service.get('extensions') is not None:
-                ext = list(map(lambda k: k,service.get('extensions')))
+            if svc.get('extensions') is not None:
+                ext = list(map(lambda k: k,svc.get('extensions')))
             ext = ext if len(ext) >0 else '-'
-            add_service_desc(tab,service,ext)
-            if service.get('methods') is not None:
-                for rpc in service.get('methods'):
+            add_service_desc(tab,svc,ext)
+            if svc.get('methods') is not None:
+                for rpc in svc.get('methods'):
                     add_rpc_desc(tab_rpcs,rpc,)
     
         print_info(tab,True,'📡 Listing services resources')
         print_info(tab_rpcs,True,'Listing RPC\'s')
     
     # Packages list
     header = ['Package','Messages','Enums','Dependencies','Extensions']
@@ -393,24 +395,24 @@
 
 
 def add_project_desc(tab,prj,org):
     
     tab.add_row([f'{org}.{prj.project.package_name}',prj.project.name, SylkServerLanguages.Name(prj.project.server.language),[SylkClientLanguages.Name(c.language) for c in prj.project.clients],prj.numServices,prj.numPackages,prj.numMethods,prj.numMessages])
 
 def add_service_desc(tab,svc_description,extensions=None):
-    tab.add_row([svc_description.get('name'),len(svc_description.get('methods') if svc_description.get('methods') is not None else []),svc_description.get('dependencies'),extensions])
+    tab.add_row([svc_description.get('name') + ' [{}]'.format(svc_description.get('fullName')),len(svc_description.get('methods') if svc_description.get('methods') is not None else []),svc_description.get('dependencies'),extensions])
 
 def add_package_desc(tab,package_desc,ext):
-    tab.add_row([package_desc.get('name'),len(package_desc.get('messages') if package_desc.get('messages') is not None else []),len(package_desc.get('enums') if package_desc.get('enums') is not None else []),package_desc.get('dependencies'),ext ])
+    tab.add_row([package_desc.get('name') + ' [{}]'.format(package_desc.get('package')),len(package_desc.get('messages') if package_desc.get('messages') is not None else []),len(package_desc.get('enums') if package_desc.get('enums') is not None else []),package_desc.get('dependencies'),ext ])
 
 def add_message_desc(tab,msg_desc,package_desc, ext,ext_type ):
-    tab.add_row([msg_desc.get('name'),len(msg_desc.get('fields') if msg_desc.get('fields') is not None else []),package_desc.get('package'), ext,ext_type ])
+    tab.add_row([msg_desc.get('name') + ' [{}]'.format(msg_desc.get('fullName')),len(msg_desc.get('fields') if msg_desc.get('fields') is not None else []),package_desc.get('package'), ext,ext_type ])
 
 def add_enum_desc(tab,enum_desc,package_desc):
-    tab.add_row([enum_desc.get('name'),len(enum_desc.get('values') if enum_desc.get('values') is not None else []),package_desc.get('package')])
+    tab.add_row([enum_desc.get('name') + ' [{}]'.format(enum_desc.get('fullName')),len(enum_desc.get('values') if enum_desc.get('values') is not None else []),package_desc.get('package')])
 
 def add_rpc_desc(tab,rpc_desc):
     rpc_type_server = rpc_desc.get('serverStreaming')
     rpc_type_client = rpc_desc.get('clientStreaming')
     rpc_type = 'Unary' if (rpc_type_client == False or rpc_type_client is None ) and (rpc_type_server == False or rpc_type_server is None) else 'Client stream' if rpc_type_client == True and (rpc_type_server == False or rpc_type_server is None) else 'Server Stream' if rpc_type_server == True and (rpc_type_client == False or rpc_type_client is None ) else 'Bidi' if rpc_type_client == True and rpc_type_server == True else ''
     tab.add_row([rpc_desc.get('name'),rpc_type,rpc_desc.get('inputType'),rpc_desc.get('outputType')])
```

## sylk/cli/commands/new.py

```diff
@@ -20,219 +20,397 @@
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import logging
 import subprocess
 from typing import List, Literal
 from sylk import architect
 from sylk.cli import prompter
-from sylk.cli.prompter import QCheckbox,QConfirm,QList,QText,ask_user_question
+from sylk.cli.prompter import QCheckbox, QConfirm, QList, QText, ask_user_question
 from sylk.cli.theme import SylkTheme
-from sylk.commons import file_system,protos
-from sylk.commons.helpers import SylkEnumValue, SylkField,_BUILTINS_TEMPLATES
-from sylk.commons.pretty import print_info,print_warning,print_error,print_note,print_success
-from sylk.commons.file_system import join_path,mkdir, wFile
+from sylk.commons import file_system, protos
+from sylk.commons.helpers import SylkEnumValue, SylkField, _BUILTINS_TEMPLATES
+from sylk.commons.pretty import (
+    print_info,
+    print_warning,
+    print_error,
+    print_note,
+    print_success,
+)
+from sylk.commons.file_system import join_path, mkdir, wFile
 from sylk.architect import SylkArchitect
 from sylk.cli.commands.cloud import SylkCloud
 import os
 import inquirer
 from inquirer import errors
 from sylk.commons.protos.sylk.SylkClient.v1 import SylkClient_pb2
 from sylk.commons.protos.sylk.SylkServer.v1 import SylkServer_pb2
 from google.protobuf.json_format import MessageToDict
 
 _TEMPLATES = _BUILTINS_TEMPLATES
 
+
 def validate_client(answers, current):
-    if len(current) ==0:
-        raise errors.ValidationError(current,"Must chose at least 1 client !")
+    if len(current) == 0:
+        raise errors.ValidationError(current, "Must chose at least 1 client !")
     return True
 
+
 def validate_domain(answers, current):
-    if '.' in current:
-        raise errors.ValidationError(current,"Domain name MUST not include suffix like '.com' / '.io' and so on.")
+    if "." in current:
+        raise errors.ValidationError(
+            current,
+            "Domain name MUST not include suffix like '.com' / '.io' and so on.",
+        )
     return True
 
-server_language_q = QList(name="server", message="Choose server language", choices=[('Python', SylkServer_pb2.python), ('Typescript', SylkServer_pb2.typescript), ('Go', SylkServer_pb2.go), ('NodeJs', SylkServer_pb2.nodejs)], default=SylkServer_pb2.python)
-clients_languages_q = QCheckbox(name="clients", message="Choose clients languages (Use arrows keys to enable disable a language)", choices=[('Python', SylkClient_pb2.python), ('Typescript', SylkClient_pb2.typescript), ('Go',SylkClient_pb2.go), ('NodeJs',SylkClient_pb2.nodejs)], default=[SylkClient_pb2.python],validate=validate_client)
-domain_q = QText(name="domain", message="Enter domain name", default='domain',validate=validate_domain)
-
-sylk_neq_q = [server_language_q,clients_languages_q,domain_q]
-
-def create_new_project(project_name:str,path:str=None,host:str=None,port:int=None,server_language:str=None,clients=[],domain:str=None,template:_TEMPLATES='@sylk/Blank',project_id=None,configs=None):
-    domain_name = 'domain'
-    
+
+server_language_q = QList(
+    name="server",
+    message="Choose server language",
+    choices=[
+        ("Python", SylkServer_pb2.python),
+        ("Typescript", SylkServer_pb2.typescript),
+        ("Go", SylkServer_pb2.go),
+        ("NodeJs", SylkServer_pb2.nodejs),
+    ],
+    default=SylkServer_pb2.python,
+)
+clients_languages_q = QCheckbox(
+    name="clients",
+    message="Choose clients languages (Use arrows keys to enable disable a language)",
+    choices=[
+        ("Python", SylkClient_pb2.python),
+        ("Typescript", SylkClient_pb2.typescript),
+        ("Go", SylkClient_pb2.go),
+        ("NodeJs", SylkClient_pb2.nodejs),
+    ],
+    default=[SylkClient_pb2.python],
+    validate=validate_client,
+)
+domain_q = QText(
+    name="domain",
+    message="Enter domain name",
+    default="domain",
+    validate=validate_domain,
+)
+
+sylk_neq_q = [server_language_q, clients_languages_q, domain_q]
+
+
+def create_new_project(
+    project_name: str,
+    path: str = None,
+    host: str = None,
+    port: int = None,
+    server_language: str = None,
+    clients=[],
+    domain: str = None,
+    template: _TEMPLATES = "@sylk/Blank",
+    project_id=None,
+    configs=None,
+    base_proto_path=None,
+    format='json',
+    token=None
+):
+    domain_name = "domain"
+
     if project_id is not None:
-        sylkCloud = SylkCloud(token=configs.get('token') if configs is not None else None,org_id=project_id.split('.')[0])
+
+        sylkCloud = SylkCloud(
+            token=token if token is not None else configs.token if configs is not None else None,
+            org_id=project_id.split(".")[0],
+        )
+
+        # If no options passed
+        if server_language is None and clients == None and domain is None:
+            results = ask_user_question(questions=sylk_neq_q)
+
+            if results is None:
+                print_warning("Must answer project creation questions")
+                exit(1)
+        # If someof the options has passed
+        elif server_language is not None or clients is not None or domain is not None:
+            questions = []
+
+            if server_language is None:
+                questions.append(server_language_q)
+            else:
+                print_note(f"Passed server language: {server_language}")
+
+            if clients is None:
+                questions.append(clients_languages_q)
+            else:
+                clients_display = ", ".join(clients)
+                print_note(f"Passed client languages: {clients_display}")
+
+            results = ask_user_question(questions=questions)
+
+            if results is None:
+                print_warning("Must answer project creation questions")
+                exit(1)
+            else:
+                if results.get("server") is None:
+                    results["server"] = server_language
+                if results.get("clients") is None:
+                    results["clients"] = clients
+
+        else:
+            results = {}
+            results["server"] = server_language
+            results["clients"] = clients
+
         project = sylkCloud.pull_project(project_id)
         if path is None:
             try:
                 root = os.getcwd()
-                result_path = inquirer.prompt([inquirer.Path('root_dir', default=join_path(
-                    root, project_name), message="Enter a root dir path", exists=False)], theme=SylkTheme())
+                result_path = inquirer.prompt(
+                    [
+                        inquirer.Path(
+                            "root_dir",
+                            default=join_path(root, project_name),
+                            message="Enter a root dir path",
+                            exists=False,
+                        )
+                    ],
+                    theme=SylkTheme(),
+                )
                 if result_path is not None:
-                    result_path = result_path['root_dir']
+                    result_path = result_path["root_dir"]
             except Exception:
-                print_error(
-                    f"Error root dir exists\n[{join_path(root,project_name)}]")
+                print_error(f"Error root dir exists\n[{join_path(root,project_name)}]")
                 exit(1)
         else:
-            if path == '.':
+            if path == ".":
                 path = os.getcwd()
                 result_path = join_path(path)
             else:
                 result_path = join_path(path, project_name)
         project.project.uri = result_path
-        project_path = join_path(
-                    result_path,'sylk.json')
-        if project.project.server.language == SylkServer_pb2.SylkServerLanguages.go and project.project.go_package == '':
-            go_package_input = prompter.QText(name='go_package',message='Enter a prefix to support Go package',default='github.com/{}'.format(project.project.package_name))
+        project_path = join_path(result_path, "sylk.json")
+        if (
+            project.project.server.language == SylkServer_pb2.SylkServerLanguages.go
+            and project.project.go_package == ""
+        ):
+            go_package_input = prompter.QText(
+                name="go_package",
+                message="Enter a prefix to support Go package",
+                default="github.com/{}".format(project.project.package_name),
+            )
             go_package = prompter.ask_user_question(questions=[go_package_input])
             if go_package is not None:
-                go_package = go_package['go_package']
+                go_package = go_package["go_package"]
             else:
-                go_package = 'github.com/{}'.format(project.project.package_name)
+                go_package = "github.com/{}".format(project.project.package_name)
             project.project.go_package = go_package
-            
+
+
         mkdir(result_path)
         # print_info(MessageToDict(project),True,'JSON:')
-        wFile(project_path, MessageToDict(project),
-                        overwrite=True, json=True)
+        wFile(project_path, MessageToDict(project), overwrite=True, json=True)
+        print_info(f'saved sylk schema into: {project_path}')
         ARCHITECT = SylkArchitect(
-            path=project_path, domain=domain_name, project_name=project_name)
-        ARCHITECT.AddProject(project_name,project.project.server.language,project.project.clients)
+            path=project_path, domain=domain_name, project_name=project_name, format=format
+        )
+        print_info(clients)
+        print_info(server_language)
+        ARCHITECT.AddProject(
+            project_name, project.project.server.language if server_language is None else server_language, project.project.clients if len(clients) == 0 else list(map(lambda c: {"language": c}, clients))
+        )
         # ARCHITECT._sylk = project
-        ARCHITECT.SetConfig({'host': host, 'port': int(port) })
+        ARCHITECT.SetConfig({"host": host, "port": int(port)})
         ARCHITECT.SetSylkVersion()
         ARCHITECT.Save()
 
         print_success(
-            f'Success pulling ☁️  project!\n\tCreated new project "{project_name}"\n\t-> cd {project_path}\n\t-> And then continue developing your awesome services !\n\t-> For more info on how to use the sylk.build CLI go to https://docs.sylk.build/')
-        
+            f'Success pulling ☁️  project!\n\tCreated new project "{project_name}"\n\t-> cd {project_path}\n\t-> And then continue developing your awesome services !\n\t-> For more info on how to use the sylk.build CLI go to https://docs.sylk.build/'
+        )
+
     else:
         # If no options passed
         if server_language is None and clients == None and domain is None:
             results = ask_user_question(questions=sylk_neq_q)
-        
+
             if results is None:
                 print_warning("Must answer project creation questions")
                 exit(1)
         # If someof the options has passed
         elif server_language is not None or clients is not None or domain is not None:
             questions = []
 
             if server_language is None:
                 questions.append(server_language_q)
             else:
-                print_note(f'Passed server language: {server_language}')
+                print_note(f"Passed server language: {server_language}")
 
             if clients is None:
                 questions.append(clients_languages_q)
             else:
-                clients_display = ', '.join(clients)
-                print_note(f'Passed client languages: {clients_display}')
-            
+                clients_display = ", ".join(clients)
+                print_note(f"Passed client languages: {clients_display}")
+
             if domain is None:
                 questions.append(domain_q)
             else:
-                print_note(f'Passed domain: {domain}')
+                print_note(f"Passed domain: {domain}")
 
             results = ask_user_question(questions=questions)
 
             if results is None:
                 print_warning("Must answer project creation questions")
                 exit(1)
             else:
-                if results.get('server') is None:
-                    results['server'] = server_language
-                if results.get('clients') is None:
-                    results['clients'] = clients
-                if results.get('domain') is None:
-                    results['domain'] = domain
+                if results.get("server") is None:
+                    results["server"] = server_language
+                if results.get("clients") is None:
+                    results["clients"] = clients
+                if results.get("domain") is None:
+                    results["domain"] = domain
 
         else:
             results = {}
-            results['server'] = server_language
-            results['clients'] = clients
-            results['domain'] = domain
+            results["server"] = server_language
+            results["clients"] = clients
+            results["domain"] = domain
 
         if path is None:
             try:
                 root = os.getcwd()
-                result_path = inquirer.prompt([inquirer.Path('root_dir', default=join_path(
-                    root, project_name), message="Enter a root dir path", exists=False)], theme=SylkTheme())
+                result_path = inquirer.prompt(
+                    [
+                        inquirer.Path(
+                            "root_dir",
+                            default=join_path(root, project_name),
+                            message="Enter a root dir path",
+                            exists=False,
+                        )
+                    ],
+                    theme=SylkTheme(),
+                )
                 if result_path is not None:
-                    result_path = result_path['root_dir']
+                    result_path = result_path["root_dir"]
             except Exception:
-                print_error(
-                    f"Error root dir exists\n[{join_path(root,project_name)}]")
+                print_error(f"Error root dir exists\n[{join_path(root,project_name)}]")
                 exit(1)
         else:
             result_path = join_path(path, project_name)
 
         clients = []
         for k in results:
-            if k == 'server':
+            if k == "server":
                 if type(results[k]) == str:
                     server_langugae = results[k]
                 else:
-                    server_langugae = SylkServer_pb2.SylkServerLanguages.Name(results[k])
-                print_info(f'Server language: {server_langugae}')
-            if k == 'clients':
+                    server_langugae = SylkServer_pb2.SylkServerLanguages.Name(
+                        results[k]
+                    )
+                print_info(f"Server language: {server_langugae}")
+            if k == "clients":
                 for c in results[k]:
                     if type(c) == str:
                         client_lang = c
                     else:
                         client_lang = SylkClient_pb2.SylkClientLanguages.Name(c)
-                    out_dir = join_path(
-                        result_path, 'clients', client_lang)
-                    print_info(f'Adding client: {client_lang}\n\t-> {out_dir}')
-                    clients.append(
-                        {'out_dir': out_dir, 'language': client_lang})
-            if k == 'domain':
+                    out_dir = join_path(result_path, "clients", client_lang)
+                    print_info(f"Adding client: {client_lang}\n\t-> {out_dir}")
+                    clients.append({"out_dir": out_dir, "language": client_lang})
+            if k == "domain":
                 domain_name = results[k]
-                print_info(f'Project domain: {domain_name}\n')
+                print_info(f"Project domain: {domain_name}\n")
 
         out_dir = join_path(
-                        result_path, 'clients',results['server'] if type(results['server']) == str else SylkClient_pb2.SylkClientLanguages.Name(results['server']))
-        if next((c for c in clients if c.get('language') == (results['server'] if type(results['server']) == str else SylkServer_pb2.SylkServerLanguages.Name(results['server'])) ),None) is None:
-            print_warning('Auto-Adding client {} - Any project by default is assigned with client in the server specified language !'.format(SylkServer_pb2.SylkServerLanguages.Name(results['server']) if type(results['server']) != str else results['server'] ))
-            clients.append({'out_dir': out_dir, 'language': SylkClient_pb2.SylkClientLanguages.Name(results['server']) if type(results['server']) != str else results['server'] })
+            result_path,
+            "clients",
+            results["server"]
+            if type(results["server"]) == str
+            else SylkClient_pb2.SylkClientLanguages.Name(results["server"]),
+        )
+        if (
+            next(
+                (
+                    c
+                    for c in clients
+                    if c.get("language")
+                    == (
+                        results["server"]
+                        if type(results["server"]) == str
+                        else SylkServer_pb2.SylkServerLanguages.Name(results["server"])
+                    )
+                ),
+                None,
+            )
+            is None
+        ):
+            print_warning(
+                "Auto-Adding client {} - Any project by default is assigned with client in the server specified language !".format(
+                    SylkServer_pb2.SylkServerLanguages.Name(results["server"])
+                    if type(results["server"]) != str
+                    else results["server"]
+                )
+            )
+            clients.append(
+                {
+                    "out_dir": out_dir,
+                    "language": SylkClient_pb2.SylkClientLanguages.Name(
+                        results["server"]
+                    )
+                    if type(results["server"]) != str
+                    else results["server"],
+                }
+            )
         root_dir = result_path
-        sylk_json_path = join_path(root_dir, 'sylk.json')
+        sylk_json_path = join_path(root_dir, "sylk.json")
         mkdir(result_path)
 
         ARCHITECT = SylkArchitect(
-            path=sylk_json_path, domain=domain_name, project_name=project_name)
-        if template != '@sylk/Blank' and template is not None:
-            print_info('Starting sylk build project from template:')
+            path=sylk_json_path, domain=domain_name, project_name=project_name
+        )
+        if template != "@sylk/Blank" and template is not None:
+            print_info("Starting sylk build project from template:")
             print_info(f'Creating new sylk.build project "{project_name}" [{template}]')
-            attach_template(ARCHITECT,template)
+            attach_template(ARCHITECT, template)
             print_success(
-            f'Success !\n\tCreated new project "{project_name}" from [{template}] template\n\t-> cd {root_dir}\n\t-> And then continue developing your awesome services !\n\t-> For more info on how to use the sylk.build CLI go to https://docs.sylk.build/')
+                f'Success !\n\tCreated new project "{project_name}" from [{template}] template\n\t-> cd {root_dir}\n\t-> And then continue developing your awesome services !\n\t-> For more info on how to use the sylk.build CLI go to https://docs.sylk.build/'
+            )
             # ARCHITECT = SylkArchitect(
-                # path=sylk_json_path, domain=domain_name, project_name=project_name)
+            # path=sylk_json_path, domain=domain_name, project_name=project_name)
             # ARCHITECT.AddProject(server_language=server_langugae, clients=clients)
             # ARCHITECT.AddProject(server_language=server_langugae, clients=clients)
             # ARCHITECT.SetDomain(domain_name)
             exit(1)
 
         ARCHITECT.AddProject(server_language=server_langugae, clients=clients)
         ARCHITECT.SetDomain(domain_name)
-        
-        ARCHITECT.SetConfig({'host': host, 'port': int(port) })
+        ARCHITECT.SetConfig({"host": host, "port": int(port), "protoBasePath": base_proto_path})
         ARCHITECT.SetSylkVersion()
         ARCHITECT.Save()
-        
+
         print_success(
-            f'🚀 Success !\n\tCreated new project "{project_name}"\n\t-> cd {root_dir}\n\t-> And then continue developing your awesome services !\n\t-> For more info on how to use the sylk.build CLI go to https://docs.sylk.build/')
+            f'🚀 Success !\n\tCreated new project "{project_name}"\n\t-> cd {root_dir}\n\t-> And then continue developing your awesome services !\n\t-> For more info on how to use the sylk.build CLI go to https://docs.sylk.build/'
+        )
+
 
-def attach_template(ARCHITECT:SylkArchitect,template:_TEMPLATES):
-    if template != '@sylk/Blank' and template is not None:
+def attach_template(ARCHITECT: SylkArchitect, template: _TEMPLATES):
+    if template != "@sylk/Blank" and template is not None:
         file_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
-        template_domain_name = template.split('/')[0].split('@')[-1]
-        template_name = template.split('/')[-1]
-        print(file_dir + '/commons/templates/{0}/{1}.template.py'.format(template_domain_name,template_name))
+        template_domain_name = template.split("/")[0].split("@")[-1]
+        template_name = template.split("/")[-1]
+        print(
+            file_dir
+            + "/commons/templates/{0}/{1}.template.py".format(
+                template_domain_name, template_name
+            )
+        )
         # print(file_system.get_current_location())
-        os.chdir(ARCHITECT._path.split('sylk.json')[0])
+        os.chdir(ARCHITECT._path.split("sylk.json")[0])
         # print(file_system.get_current_location())
 
-        subprocess.run(['python',file_dir + '/commons/templates/{0}/{1}.template.py'.format(template_domain_name,template_name),'--project-name',ARCHITECT._project_name])
+        subprocess.run(
+            [
+                "python",
+                file_dir
+                + "/commons/templates/{0}/{1}.template.py".format(
+                    template_domain_name, template_name
+                ),
+                "--project-name",
+                ARCHITECT._project_name,
+            ]
+        )
```

## sylk/cli/commands/package.py

```diff
@@ -26,72 +26,85 @@
 def import_package(source,target,path,sylk_json:SylkJson):
     importing_into_pkg = False
     old_pkg = None
     old_svc = None
     ARCHITECT = SylkArchitect(
         path=path,domain=sylk_json.domain,project_name=sylk_json.project.get('name'))
 
-    if len(target.split('.')) > 2:
+    if len(target.split('.')) > 1:
         importing_into_pkg = True
-        old_pkg = sylk_json.get_package(
-            target.split('.')[1])
-        dep = []
-        if old_pkg is None:
-            print_error(f"Package '{target}' not exists")
-            exit(1)
-        if old_pkg.get('dependencies') is not None:
-            dep = old_pkg.get('dependencies')
-            if source not in old_pkg.get('dependencies'):
+        try:
+            old_pkg = sylk_json.get_package(target)
+            pkg = sylk_json.get_package(old_pkg.get('package'),False)
+            dep = []
+            if old_pkg is None:
+                print_error(f"Package '{target}' not exists")
+                exit(1)
+            if old_pkg.get('dependencies') is not None:
                 dep = old_pkg.get('dependencies')
+                if source not in old_pkg.get('dependencies'):
+                    dep = old_pkg.get('dependencies')
+                    dep.append(source)
+                    pkg.dependencies.append(source)
+                else:
+                    print_warning(
+                        f"Package '{source}' already injected into '{target}' package")
+                    exit(1)
+            else:
                 dep.append(source)
+                pkg.dependencies.append(source)
+            temp_msgs = []
+            for m in pkg.messages:
+                temp_msgs.append(MessageToDict(m))
+            pkg_node = sylk_json._proto_tree._find_node(pkg.package,sylk_json._proto_tree.root)
+            pkg_node.references.append(source)
+            circular_deps = sylk_json._proto_tree._resolve_dependencies_refs(pkg_node) 
+            if circular_deps is None:
+                ARCHITECT.EditPackage(old_pkg.get('package'), pkg.dependencies,temp_msgs,description=old_pkg.get('description'),enums=old_pkg.get('enums'),extensions=old_pkg.get('extensions'),version=old_pkg.get('package').split('.')[-1])
+                ARCHITECT.Save()
+                print_info(
+                    f"Attaching package '{source}' -> '{target}' {importing_into_pkg}")
             else:
-                print_warning(
-                    f"Package '{source}' already injected into '{target}' package")
+                print_error(f"could not resolve references, detected circular dependencies:\n\t- {circular_deps}")
+        except Exception as e:
+            print(e)
+            dep = []
+            old_svc = sylk_json.get_service(target.split('.')[1])
+            if old_svc is None:
+                print_error(f"Service '{target}' not exists")
                 exit(1)
-        else:
-            dep.append(source)
-        pkg = sylk_json.get_package(old_pkg.get('name'),False)
-        temp_msgs = []
-        for m in pkg.messages:
-            temp_msgs.append(MessageToDict(m))
-        ARCHITECT.EditPackage(old_pkg.get('name'), dep,temp_msgs,description=old_pkg.get('description'),enums=old_pkg.get('enums'),extensions=old_pkg.get('extensions'))
-        ARCHITECT.Save()
-
-    else:
-        dep = []
-        old_svc = sylk_json.get_service(target,sylk_json=sylk_json._sylk_json)
-        if old_svc is None:
-            print_error(f"Service '{target}' not exists")
-            exit(1)
-        if old_svc.get('dependencies') is not None:
-            dep = old_svc.get('dependencies')
-            if source not in old_svc.get('dependencies'):
+            if old_svc.get('dependencies') is not None:
                 dep = old_svc.get('dependencies')
-                dep.append(source)
+                if source not in old_svc.get('dependencies'):
+                    dep = old_svc.get('dependencies')
+                    dep.append(source)
+                else:
+                    print_warning(
+                        f"Package '{source}' already injected into '{target}' service")
+                    exit(1)
             else:
-                print_warning(
-                    f"Package '{source}' already injected into '{target}' service")
-                exit(1)
-        else:
-            dep.append(source)
-
-        ARCHITECT.EditService(old_svc.get('name'), dep, old_svc.get('description'),old_svc.get('methods'),extensions=old_svc.get('extensions'))
-        ARCHITECT.Save()
+                dep.append(source)
 
-    importing_into_pkg = 'package' if importing_into_pkg == True else 'service'
-    print_info(
-        f"Attaching package '{source}' -> '{target}' {importing_into_pkg}")
+            ARCHITECT.EditService(old_svc.get('name'), dep, old_svc.get('description'),old_svc.get('methods'),extensions=old_svc.get('extensions'),version=old_svc.get('fullName').split('.')[-1])
+            ARCHITECT.Save()
+            importing_into_pkg = 'package' if importing_into_pkg == True else 'service'
+            print_info(
+                f"Attaching package '{source}' -> '{target}' {importing_into_pkg}")
+    else:
+        print_error('target {} for import is not valid'.format(target))
+        exit(1)
+    
 
 def remove_import(source,target,path,sylk_json:SylkJson):
     ARCHITECT = SylkArchitect(
         path=path,domain=sylk_json.domain,project_name=sylk_json.project.get('name'))
 
     if len(target.split('.')) > 2:
         old_pkg = sylk_json.get_package(
-            target.split('.')[1])
+            target.split('.')[1], version=target.split('.')[-1])
         dep = []
         if old_pkg is None:
             print_error(f"Package '{target}' not exists")
             exit(1)
         if old_pkg.get('dependencies') is not None:
             dep = old_pkg.get('dependencies')
             if source not in old_pkg.get('dependencies'):
@@ -101,19 +114,20 @@
             else:
                 dep = old_pkg.get('dependencies')
                 dep.remove(source)
         else:
             print_error(f"'{source}' cannot be found under '{target}'")
             exit(1)
             
-        pkg = sylk_json.get_package(old_pkg.get('name'),False)
+        pkg = sylk_json.get_package(old_pkg.get('name'),False,version=old_pkg.get('package').split('.')[-1])
         temp_msgs = []
         for m in pkg.messages:
             temp_msgs.append(MessageToDict(m))
-        ARCHITECT.EditPackage(old_pkg.get('name'), dep,temp_msgs,description=old_pkg.get('description'),enums=old_pkg.get('enums'),extensions=old_pkg.get('extensions'))
+
+        ARCHITECT.EditPackage(old_pkg.get('name'), dep,temp_msgs,description=old_pkg.get('description'),enums=old_pkg.get('enums'),extensions=old_pkg.get('extensions'),version=old_pkg.get('package').split('.')[-1])
         ARCHITECT.Save()
 
     else:
         dep = []
         old_svc = sylk_json.get_service(target,sylk_json=sylk_json._sylk_json)
         if old_svc is None:
             print_error(f"Service '{target}' not exists")
@@ -124,12 +138,12 @@
                 print_warning(
                     f"Package '{source}' not injected into '{target}' service")
                 exit(1)
             else:
                 dep = old_svc.get('dependencies')
                 dep.remove(source)
         
-        ARCHITECT.EditService(old_svc.get('name'), dep,methods=old_svc.get('methods'),description=old_svc.get('description'),extensions=old_svc.get('extensions'))
+        ARCHITECT.EditService(old_svc.get('name'), dep,methods=old_svc.get('methods'),description=old_svc.get('description'),extensions=old_svc.get('extensions'),version=old_svc.get('fullName').split('.')[-1])
         ARCHITECT.Save()
 
     print_warning(
         f"Removed package '{source}' -> '{target}'")
```

## sylk/cli/commands/plugin.py

```diff
@@ -15,61 +15,81 @@
 # EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 # MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
+from time import time
 import os
+import shutil
 import subprocess
 from sylk.architect import SylkArchitect
 from sylk.commons import file_system
 from sylk.commons.helpers import SylkJson
-from sylk.commons.pretty import print_info, print_warning
+from sylk.commons.pretty import print_info, print_warning, print_note
+
+
+def is_module_executable(module_name):
+    return shutil.which(module_name) is not None
 
 
 def run(args):
+    st = time()
+
     path = os.getcwd()
     plugs = []
-    
+    includes = ['-I']
     plug_path = ''
+    for i in args.I:
+        includes.append(i)
+    print(includes)
     for p in args.plugin:
-        if '.py' not in p:
+        # print(os.access(p, os.X_OK))
+        spec = is_module_executable(p)
+        if spec:
+            plug_name = p.split('protoc-gen-')[1]
+            plugs = plugs + [
+                f'--{plug_name}_out={args.out_dir}',
+                f'--{plug_name}_opt={args.opt}',
+            ]
+        elif '.py' not in p:
             if args.dir is not None:
                 plug_path = args.dir + '/' + p + '.py'
             else:
                 plug_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) + f'/protoc/plugins/{p}.py'
             plugs = plugs + [
                 f'--plugin=protoc-gen-{p}={plug_path}',
-                f'--{p}_out=.'
+                f'--{p}_out={args.out_dir}'
             ]
         else:
             if args.dir is not None:
                 plug_path =  os.path.abspath(args.dir + '/' + p + '.py')
             else:
                 plug_path = os.path.abspath(os.getcwd() +'/'+ p)
             plug_name = p.split('.')[0]
             plugs = plugs + [
                     f'--plugin=protoc-gen-{plug_name}={plug_path}',
-                    f'--{plug_name}_out=.',
+                    f'--{plug_name}_out={args.out_dir}',
 
             ]
-            
-        if file_system.is_file_executable(plug_path):
+        if file_system.is_file_executable(plug_path) or spec:
             print_info(f"🔌 Running plugin: {p}")
 
             # if len(args.protos) == 0:
                 # sylk = SylkArchitect('./sylk.json')
-
-            protoc_params = ['protoc'] + args.protos + plugs
+            proto_files = args.protos if args.protos is not None else []
+            protoc_params = ['protoc'] + proto_files + plugs + includes
+            print(protoc_params)
             process = subprocess.Popen(protoc_params,
                         stdout=subprocess.PIPE, 
                         stderr=subprocess.PIPE)
             _, stderr = process.communicate()
             if stderr:
                 print_info(stderr.decode('utf-8'))
         else:
             print_warning(f'plugin {p} is not executable file')
             print_info(f'Make sure you have permissions to edit the file mode and make it excutable.')
-
-
+    et = time()
+    rt = et - st
+    print_note(f'Plugin time: {rt:.3f}s')
     exit(0)
```

## sylk/cli/commands/run.py

```diff
@@ -20,13 +20,13 @@
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 import subprocess
 from sylk.commons.helpers import SylkJson
 from sylk.commons.pretty import print_warning
 
 
-def run_server(sylk_json:SylkJson,debug:bool):
-    commands = ['bash',sylk_json.path+'/bin/run-server.sh'] if debug == False else ['bash',sylk_json.path+'/bin/run-server.sh','debug']
+def run_server(sylk_json:SylkJson,level):
+    commands = ['bash',sylk_json.path+'/bin/run-server.sh'] if level is None else ['bash',sylk_json.path+'/bin/run-server.sh',level]
     try:
         subprocess.run(commands)
     except KeyboardInterrupt:
         print_warning("Sylk Server Stopped By User.")
```

## sylk/commons/config.py

```diff
@@ -48,14 +48,15 @@
         self.custom_templates = kwargs.get('custom_templates')
         self.custom_plugins = kwargs.get('custom_plugins')
         self.template = kwargs.get('template')
         self.deployment = kwargs.get('deployment')
         self.monitor = kwargs.get('monitor')
         self.proxy = kwargs.get('proxy')
         self.docs = kwargs.get('docs')
+        self.format = kwargs.get('format','json')
 
     def config(self):
         temp_dict = {}
         if self.client_channel_opt:
             temp_dict['client_channel_opt'] = self.client_channel_opt
         if self.custom_templates:
             temp_dict['custom_templates'] = self.custom_templates
@@ -67,14 +68,16 @@
             temp_dict['deployment'] = self.deployment
         if self.monitor:
             temp_dict['monitor'] = self.monitor
         if self.proxy:
             temp_dict['proxy'] = self.proxy
         if self.docs:
             temp_dict['docs'] = self.docs
+        if self.format:
+            temp_dict['format'] = self.format
 
         return temp_dict
 
 
 def parse_sylk_config(root_path:str,proto=False):
     if proto:
         sylk_config = SylkConfigs.SylkProjectConfigs()
@@ -147,17 +150,17 @@
         if SYLK_JSON._config:
             return ParseDict(SYLK_JSON._config,SylkConfigs.SylkProjectConfigs())
         else:
             return None
 
 def parse_sylk_json_configs_proto(root_path):
     SYLK_JSON = None
+    if 'sylk.json' not in root_path:
+        root_path = root_path +'/sylk.json'
     if _fs.check_if_file_exists(root_path):
-        if 'sylk.json' not in root_path:
-            root_path = root_path +'/sylk.json'
         print_note(f'Loading sylk.build project from: {root_path}')
 
         SYLK_JSON = _fs.rFile(root_path, json=True)
         SYLK_JSON = _helpers.SylkJson(sylk_json=SYLK_JSON)
         if SYLK_JSON._config:
             if SYLK_JSON._config.get('template') is not None:
                 del SYLK_JSON._config['template']
@@ -197,21 +200,22 @@
                 # Client channel options see:  https://github.com/grpc/grpc/blob/v1.46.x/include/grpc/impl/codegen/grpc_types.h
                 client_channel_opt = prj_conf_module.client_channel_opt  if hasattr(prj_conf_module,'client_channel_opt') else None,
                 # Custom templates
                 custom_templates = prj_conf_module.custom_templates  if hasattr(prj_conf_module,'custom_templates') else None,
                 # Custom plugins
                 custom_plugins = prj_conf_module.custom_plugins  if hasattr(prj_conf_module,'custom_plugins') else None,
                 # Templating options
-                template = prj_conf_module.template  if hasattr(prj_conf_module,'template') else None,
+                template = prj_conf_module.template if hasattr(prj_conf_module,'template') else None,
                 deployment = temp_configs.deployment,
                 monitor = MessageToDict(temp_configs.monitor),
                 proxy =  MessageToDict(temp_configs.proxy),
                 host = temp_configs.host,
                 plugins = temp_configs.plugins,
-                docs = temp_configs.docs
+                docs = temp_configs.docs,
+                format = temp_configs.format
 
             )
         else:
             print_warning('You must configure the parameters under \'configs = SylkConfig.Config()\' variable')
        
 
     else:
```

## sylk/commons/errors.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Sylk.io.
+# Copyright (c) 2023 Sylk.build.
 
 # Permission is hereby granted, free of charge, to any person obtaining
 # a copy of this software and associated documentation files (the
 # "Software"), to deal in the Software without restriction, including
 # without limitation the rights to use, copy, modify, merge, publish,
 # distribute, sublicense, and/or sell copies of the Software, and to
 # permit persons to whom the Software is furnished to do so, subject to
```

## sylk/commons/file_system.py

```diff
@@ -47,73 +47,88 @@
 def cpDir(dir_path,target_path):
     if check_if_dir_exists(dir_path):
         copy_tree(dir_path, target_path)
 
 def removeFile(path):
     os.remove(path)
 
+def removeDir(path):
+    try:
+        # Delete all files within the directory
+        for filename in os.listdir(path):
+            file_path = os.path.join(path, filename)
+            if os.path.isfile(file_path):
+                os.remove(file_path)
+            elif os.path.isdir(file_path):
+                removeDir(file_path)
+
+        # Remove the empty directory
+        os.rmdir(path)
+    except OSError as e:
+        print(f"Error: {e}. Failed to remove the directory.")
+
 def walkDirs(path):
     return [x[0] for x in os.walk(path)]
 
 def walkFiles(path):
     for p in os.walk(path):
         return p[2]
 
 def copyFile(file, new_file):
     shutil.copy2(file, new_file)
 
-def wFile(path, content, overwrite=False, json=False,force=False):
+def wFile(path, content, overwrite=False, json=False,force=False,flags='w'):
     if check_if_file_exists(path) == True:
         if force:
             os.makedirs(os.path.dirname(path),mode=0o777, exist_ok=True)
             os.chmod(os.path.dirname(path),0o777)
         if overwrite == True:
             if json:
                 # Serializing json
                 json_object = JSON.dumps(content, indent=4)
                 # Writing to sample.json
                 log.debug(f"Overwriting json file {path}")
-                with open(path, "w") as outfile:
+                with open(path, flags) as outfile:
                     outfile.write(json_object)
             else:
 
                 log.debug(f"Overwriting file {path}")
-                with open(path, 'w') as file:
+                with open(path, flags) as file:
                     file.write(content)
                     file.close()
         else:
             log.debug("{0} File is already existing ! [pass function with 'overwrite' argument if you want to override this behaviour]"
                           .format(path))
     else:
         if force:
             os.makedirs(os.path.dirname(path),mode=0o777, exist_ok=True)
             os.chmod(os.path.dirname(path),0o777)
         if json:
             # Serializing json
             json_object = JSON.dumps(content, indent=4)
             # Writing to sample.json
             log.debug(f"Writing json file {path}")
-            with open(path, "w") as outfile:
+            with open(path, flags) as outfile:
                 outfile.write(json_object)
         else:
             log.debug(f"Writing file {path}")
-            with open(path, 'w') as file:
+            with open(path, flags) as file:
                 file.write(content)
                 file.close()
 
-def rFile(path, json=False):
+def rFile(path, json=False, flags='r'):
     log.debug(f"Reading file -> {path}")
     if check_if_file_exists(path) == True:
         if json:
             f = open(path)
             data = JSON.load(f)
             f.close()
             return data
         else:
-            with open(path, 'r') as file:
+            with open(path, flags) as file:
                 lines = file.readlines()
                 file.close()
                 return lines
     else:
         raise Exception("File path is not valid ! {0}".format(path))
 
 def check_if_dir_exists(dir_path):
```

## sylk/commons/helpers.py

```diff
@@ -22,141 +22,232 @@
 from collections import defaultdict
 import logging
 from ntpath import join
 import os
 import re
 import subprocess
 from typing import List, Literal
-from sylk import __version__,config
+from sylk import __version__, config
 from sylk.commons import file_system
 
 from sylk.commons import errors, pretty
+from sylk.commons.modules.google import google
+from sylk.commons.protos.sylk.SylkEnum.v2 import SylkEnum_pb2
+from sylk.commons.protos.sylk.SylkMessage.v2 import SylkMessage_pb2
 from sylk.commons.resources import generate_package, generate_service
 from sylk.commons.errors import SylkCoderError, SylkValidationError
 from sylk.commons.file_system import check_if_file_exists, join_path
-from sylk.commons.protos.sylk.Sylk.v1 import Sylk_pb2 as SylkCore
+from sylk.commons.protos.sylk.Sylk.v2 import Sylk_pb2 as SylkCore
+from sylk.commons.protos.sylk.SylkField.v1 import SylkField_pb2
+from sylk.commons.protos.sylk.SylkCommons.v1 import SylkCommons_pb2
+
 from itertools import groupby
 from google.protobuf.struct_pb2 import Value
-from google.protobuf.json_format import ParseDict, MessageToDict,MessageToJson
+from google.protobuf.json_format import ParseDict, MessageToDict, MessageToJson
 from google.protobuf import text_format
+from google.protobuf.any_pb2 import Any
+
 from google.protobuf.timestamp_pb2 import Timestamp
 from platform import platform
 from inquirer import errors as inquirerErrors
 
 import concurrent.futures
 
-log = logging.getLogger('sylk.cli.main')
-
-_WELL_KNOWN_PY_IMPORTS = [
-    "from google.protobuf.timestamp_pb2 import Timestamp", "from typing import Iterator"]
-
-_WELL_KNOWN_TS_IMPORTS = ["import { \n\thandleUnaryCall,\n\thandleClientStreamingCall,\n\thandleServerStreamingCall,\n\thandleBidiStreamingCall,\n\tsendUnaryData,\n\tServerDuplexStream,\n\tServerReadableStream,\n\tServerUnaryCall,\n\tServerWritableStream,\n\tstatus,\n\tUntypedHandleCall,\n\tMetadata\n } from '@grpc/grpc-js';","import { ServiceError } from './utils/error';","import { ApiType } from './utils/interfaces';"]
+from sylk.commons.sylk import SylkTree
 
-_WELL_KNOWN_GO_IMPORTS = ['"context"','"io"','"google.golang.org/grpc/metadata"']
+log = logging.getLogger("sylk.cli.main")
 
-_FIELD_TYPES = Literal["TYPE_INT32", "TYPE_INT64", "TYPE_STRING", "TYPE_BOOL",
-                       "TYPE_MESSAGE", "TYPE_ENUM", "TYPE_DOUBLE", "TYPE_FLOAT", "TYPE_BYTE"]
+_WELL_KNOWN_PY_IMPORTS = [
+    "from google.protobuf.timestamp_pb2 import Timestamp",
+    "from typing import Iterator",
+]
+
+_WELL_KNOWN_TS_IMPORTS = [
+    "import { \n\thandleUnaryCall,\n\thandleClientStreamingCall,\n\thandleServerStreamingCall,\n\thandleBidiStreamingCall,\n\tsendUnaryData,\n\tServerDuplexStream,\n\tServerReadableStream,\n\tServerUnaryCall,\n\tServerWritableStream,\n\tstatus,\n\tUntypedHandleCall,\n\tMetadata,\n\tInterceptor,\n\tcredentials\n } from '@grpc/grpc-js';",
+    "import { ServiceError } from '../../utils/error';",
+    "import { ApiType } from '../../utils/interfaces';",
+]
+
+_WELL_KNOWN_TS_CLIENT_IMPORTS = [
+    "import { \n\thandleUnaryCall\n\t,ClientUnaryCall\n\t,ClientReadableStream,\n\thandleClientStreamingCall,\n\thandleServerStreamingCall,\n\thandleBidiStreamingCall,\n\tsendUnaryData,\n\tServerDuplexStream,\n\tServerReadableStream,\n\tServerUnaryCall,\n\tServerWritableStream,\n\tstatus,\n\tUntypedHandleCall,\n\tMetadata,\n\tInterceptor,\n\tcredentials,\n\tChannelCredentials,\n\tServiceError as _service_error\n } from '@grpc/grpc-js';",
+    "import { ServiceError } from './utils/error';",
+    "import { ApiType } from './utils/interfaces';",
+    "import { promisify } from 'util';",
+    "import { Observable } from 'rxjs';",
+]
+
+_WELL_KNOWN_GO_IMPORTS = ['"context"', '"io"', '"google.golang.org/grpc/metadata"']
+
+_FIELD_TYPES = Literal[
+    "TYPE_INT32",
+    "TYPE_INT64",
+    "TYPE_STRING",
+    "TYPE_BOOL",
+    "TYPE_MESSAGE",
+    "TYPE_ENUM",
+    "TYPE_DOUBLE",
+    "TYPE_FLOAT",
+    "TYPE_BYTE",
+]
 _FIELD_LABELS = Literal["LABEL_OPTIONAL", "LABEL_REPEATED"]
-_EXTENSIONS_TYPE = Literal["FileOptions", "MessageOptions", "FieldOptions","ServiceOptions","MethodOptions"]
+_EXTENSIONS_TYPE = Literal[
+    "FileOptions", "MessageOptions", "FieldOptions", "ServiceOptions", "MethodOptions"
+]
+
+_OPEN_BRCK = "{"
+_CLOSING_BRCK = "}"
+
+
+def parse_version_component(full_name: str) -> dict or None:
+    full_name = full_name.replace("/", ".")
+    if full_name:
+        segments = full_name.split(".")
+
+        pattern = r"^v(\d+)(alpha|beta)?(\d+)?$"
+
+        for segment in segments:
+            regex = re.compile("[@!#$%^&*()<>?/\|}{~:]")
+            # Pass the string in search
+            # method of regex object.
+            if regex.search(segment) is not None:
+                raise SylkValidationError(
+                    "package", "package name cannot hold any special characters"
+                )
+
+            match = re.match(pattern, segment)
+
+            if match:
+                version = int(match.group(1))
+                channel = match.group(2)
+                release = int(match.group(3)) if match.group(3) else None
+                return {"version": version, "channel": channel, "release": release}
+
+        # if segments[-1][0] == "v":
+        #     regex = r"^v(\d+)?$"
+        #     match = re.match(regex, segments[-1])
+        #     if match is None:
+        #         pretty.print_warning(
+        #             "seems like you tried to pass version component that is not valid -> {}\nversion component must follow these rules:\n\t- Start with a lower case 'v'\n\t- Followed by a decimal number\n\t- Optionaly can have a 'channel' from the following: 'alpha' | 'beta'\n\t- Optionaly specify 'release' with decimal number".format(
+        #                 segments[-1]
+        #             )
+        #         )
+
+    return None
 
-_OPEN_BRCK = '{'
-_CLOSING_BRCK = '}'
 
 def to_camel_case(string):
-    words = re.findall(r'[A-Z]?[a-z0-9]+|[A-Z]+(?![a-z])', string)
-    return words[0].lower() + ''.join(word.title() for word in words[1:])
+    words = re.findall(r"[A-Z]?[a-z0-9]+|[A-Z]+(?![a-z])", string)
+    return words[0].lower() + "".join(word.title() for word in words[1:])
 
 
 def check_if_under_project():
-    return check_if_file_exists(join_path(os.getcwd(),'sylk.json'))
+    return check_if_file_exists(join_path(os.getcwd(), "sylk.json"))
 
 
 def SylkJsonCacheToMessage(path) -> SylkCore.SylkJson:
     data = open(path, "rb").read()  # read file as string
     msg = SylkJson()
     msg.ParseFromString(data)
 
 
-def SylkJsonToMessage(sylk_json,validate:bool=False) -> SylkCore.SylkJson:
+def SylkJsonToMessage(sylk_json, validate: bool = False) -> SylkCore.SylkJson:
     if validate:
-        pretty.print_info("Validating sylk.json",True)
+        pass
+        # pretty.print_info("Validating sylk.json", True)
         # assert(sylk_json.get('project') is not None)
         # assert(sylk_json.get('config') is not None)
         # assert(sylk_json.get('packages') is not None)
         # assert(sylk_json.get('services') is not None)
         # for p in sylk_json.get('packages'):
         #     pkg = sylk_json.get('packages')[p]
         #     reorder = []
         #     index = 0
         #     for m in pkg.get('messages'):
         #         dependency_in_pkg = next((f for f in m.get('fields') if f.get('messageType') is not None),None)
-                
+
         #         reorder.append(index)
         #         if dependency_in_pkg is not None:
         #             if pkg.get('package') in dependency_in_pkg.get('messageType'):
         #                 pretty.print_error(dependency_in_pkg)
         #                 pretty.print_info(reorder,True,"{0} / {1}".format(index,max(reorder)))
         #                 if index > max(reorder):
         #                     reorder = [x+1 for x in reorder]
         #                     reorder[index] = max(reorder) -1
-        #                 else: 
+        #                 else:
         #                     reorder[index] = index +1
         #             else:
         #                 if index >= reorder[index]:
         #                     reorder = [x+1 for x in reorder]
 
         #                 reorder[index] = index
         #         else:
         #             reorder[index] = max(reorder) +1
         #         pretty.print_info(dependency_in_pkg,True)
         #         pretty.print_info(reorder,True,"After changes")
-            
+
         #         index += 1
         #     reorder = [x-1 for x in reorder]
         #     mylist = [pkg.get('messages')[i] for i in reorder]
         #     pkg['messages'] = mylist
 
         #     pretty.print_info(mylist,True,"Last step")
         #     sylk_json['packages'][p] = pkg
         #     pretty.print_info(sylk_json['packages'][p],True,"Package After Change step")
-    
+
     return ParseDict(sylk_json, SylkCore.SylkJson())
 
 
-class SylkProject():
+class SylkProject:
     """sylk top level object that defines the required meta data properties."""
 
-    def __init__(self, sylk_json_path: str, project_name: str, domain: str,) -> None:
+    def __init__(
+        self,
+        sylk_json_path: str,
+        project_name: str,
+        domain: str,
+    ) -> None:
         """Parses a fields into a :module:`sylk.commons.protos.sylk_pb2.Project` representation.
 
         Parameters
         ----------
             sylk_json_path (str): Absoulute path of sylk JSON file.
             project_name (str): A project name, can include hyphens or
                  underscores but not blank spaces.
             domain (Str): A company domain name,
-                it is not the full domain your company holds 
+                it is not the full domain your company holds
                 for e.x all `sylk.build` projects are inputed on gRPC
                 as `sylk` without any suffix or prefix.
         """
 
 
-class SylkField():
+class SylkField:
     """sylk field level object that defines the required meta data properties."""
 
-    def __init__(self, name, type: _FIELD_TYPES, label: _FIELD_LABELS, message_type=None, enum_type=None, extensions=None, description=None, key_type=None, value_type=None, oneof_fields=[]) -> None:
+    def __init__(
+        self,
+        name,
+        type: _FIELD_TYPES,
+        label: _FIELD_LABELS,
+        message_type=None,
+        enum_type=None,
+        extensions=None,
+        description=None,
+        key_type=None,
+        value_type=None,
+        oneof_fields=[],
+    ) -> None:
         """Parses a fields into a :module:`sylk.commons.protos.sylk.FieldDescriptor` representation.
 
         Parameters
         ----------
             name (str): A field name, `MUST` not include blank space and hyphens.
             type (:module:`sylk.commons.helpers._FIELD_TYPES`): One of the available field types.
             label (:module:`sylk.commons.helpers._FIELD_LABELS`): One of the available labels,
                 `LABEL_REPEATED` - will compile generated class field as array / list type
-            message_type (str): `MUST` be included when field type is `TYPE_MESSAGE` and should be 
+            message_type (str): `MUST` be included when field type is `TYPE_MESSAGE` and should be
                 passed as full name for the message the field represent.
             enum_type (str): Same as `message_type` field just with enums binding.
             extensions (dict): A dict value for extensions of field.
             description (str):  A field description.
         """
 
         self._name = name
@@ -166,15 +257,14 @@
         self._enum_type = enum_type
         self._extensions = extensions
         self._description = description
         self._key_type = key_type
         self._value_type = value_type
         self._oneof_fields = oneof_fields
 
-
     def setName(self, name):
         self._name = name
 
     def setType(self, type):
         self._field_type = type
 
     def setLabel(self, label):
@@ -183,46 +273,52 @@
     def setMessageType(self, message_type):
         self._message_type = message_type
 
     def to_dict(self):
         temp = {}
         self._validate()
         for k in dict(self.__dict__):
-            if k == '_extensions':
+            if k == "_extensions":
                 if dict(self.__dict__)[k] is not None:
                     temp[k[1:]] = {}
                     for j in dict(self.__dict__)[k]:
                         if isinstance(dict(self.__dict__)[k][j], str):
                             temp[k[1:]][j] = Value(
-                                string_value=dict(self.__dict__)[k][j])
-                        elif isinstance(dict(self.__dict__)[k][j], int) or isinstance(dict(self.__dict__)[k][j], float):
+                                string_value=dict(self.__dict__)[k][j]
+                            )
+                        elif isinstance(dict(self.__dict__)[k][j], int) or isinstance(
+                            dict(self.__dict__)[k][j], float
+                        ):
                             temp[k[1:]][j] = Value(
-                                number_value=dict(self.__dict__)[k][j])
+                                number_value=dict(self.__dict__)[k][j]
+                            )
                         elif isinstance(dict(self.__dict__)[k][j], bool):
-                            temp[k[1:]][j] = Value(
-                                bool_value=dict(self.__dict__)[k][j])
+                            temp[k[1:]][j] = Value(bool_value=dict(self.__dict__)[k][j])
                         else:
                             if isinstance(dict(self.__dict__)[k][j], Value):
                                 temp[k[1:]][j] = dict(self.__dict__)[k][j]
                             else:
                                 pretty.print_warning("Not supported extension type !")
             else:
                 temp[k[1:]] = dict(self.__dict__)[k]
 
-
         return temp
 
     def _validate(self):
-        if self._field_type == 'TYPE_ENUM':
+        if self._field_type == "TYPE_ENUM":
             if self._enum_type is None:
-                pretty.print_error(f"Field {self._name} missing enum type and is configured as 'TYPE_ENUM'")
+                pretty.print_error(
+                    f"Field {self._name} missing enum type and is configured as 'TYPE_ENUM'"
+                )
                 exit(1)
-        elif self._field_type == 'TYPE_MESSAGE':
-            if self._message_type is None:    
-                pretty.print_error(f"Field {self._name} missing enum type and is configured as 'TYPE_MESSAGE'")
+        elif self._field_type == "TYPE_MESSAGE":
+            if self._message_type is None:
+                pretty.print_error(
+                    f"Field {self._name} missing enum type and is configured as 'TYPE_MESSAGE'"
+                )
                 exit(1)
 
     @property
     def name(self):
         return self._name
 
     @property
@@ -234,18 +330,26 @@
         return self._label
 
     @property
     def message_type(self):
         return self._message_type
 
 
-class SylkRPC():
+class SylkRPC:
     """sylk RPC level object that defines the required meta data properties."""
 
-    def __init__(self, name, in_type, out_type, client_stream=False, server_stream=False, description=None) -> None:
+    def __init__(
+        self,
+        name,
+        in_type,
+        out_type,
+        client_stream=False,
+        server_stream=False,
+        description=None,
+    ) -> None:
         """Parses a fields into a :module:`sylk.commons.protos.sylk.MethodDescriptor` representation.
 
         Parameters
         ----------
             name (str): A RPC name, `MUST` not include blank space and hyphens.
             in_type (str): Full name for message to be used as input type for the new RPC.
             out_type (str):  Full name for message to be used as output type for the new RPC.
@@ -257,21 +361,35 @@
         self._input_type = in_type
         self._output_type = out_type
         self._client_stream = client_stream
         self._server_stream = server_stream
         self._description = description
 
     def to_tuple(self):
-        return self._name, [(self._client_stream, self._input_type), (self._server_stream, self._output_type)], self._description
+        return (
+            self._name,
+            [
+                (self._client_stream, self._input_type),
+                (self._server_stream, self._output_type),
+            ],
+            self._description,
+        )
 
 
-class SylkService():
+class SylkService:
     """sylk service level object that defines the required meta data properties."""
 
-    def __init__(self, name, methods: List[SylkRPC] = [], dependencies: List[str] = [], description=None,extensions=None) -> None:
+    def __init__(
+        self,
+        name,
+        methods: List[SylkRPC] = [],
+        dependencies: List[str] = [],
+        description=None,
+        extensions=None,
+    ) -> None:
         """Parses a fields into a :module:`sylk.commons.protos.sylk.ServiceDescriptor` representation.
 
         Parameters
         ----------
             name (str): A service name, `MUST` not include blank space and hyphens.
             methods (:module:`List[sylk.commons.helpers.SylkRPC]`): A list of RPC methods.
             dependencies (List[str]): List of service dependencies (Other packages).
@@ -290,18 +408,26 @@
         return self._name, rpcs, self._dependencies, self._description, self._extensions
 
     @property
     def name(self):
         return self._name
 
 
-class SylkMessage():
+class SylkMessage:
     """sylk message level object that defines the required meta data properties."""
 
-    def __init__(self, name, fields: List[SylkField] = None, description: str = None, extension_type: _EXTENSIONS_TYPE = None,extensions=None,domain=None) -> None:
+    def __init__(
+        self,
+        name,
+        fields: List[SylkField] = None,
+        description: str = None,
+        extension_type: _EXTENSIONS_TYPE = None,
+        extensions=None,
+        domain=None,
+    ) -> None:
         """Parses a fields into a :module:`sylk.commons.protos.sylk.Descriptor` representation.
 
         Parameters
         ----------
             name (str): A message name, `MUST` not include blank space and hyphens.
             fields (:module:`List[sylk.commons.helpers.SylkField]`): A list of message fields.
             description (str): A message description.
@@ -315,29 +441,35 @@
         self._domain = domain
 
     def setFields(self, fields: List[SylkField]):
         self._fields = fields
 
     def to_tuple(self):
         if self._fields is None:
-            raise SylkValidationError(
-                "Message", "Message must hold atleast 1 field !")
+            raise SylkValidationError("Message", "Message must hold atleast 1 field !")
 
         f_array = []
         for f in self._fields:
             f_array.append(f.to_dict())
 
-        return self._name, f_array, self._description, self._extension_type, self._extensions,  self._domain
+        return (
+            self._name,
+            f_array,
+            self._description,
+            self._extension_type,
+            self._extensions,
+            self._domain,
+        )
 
     @property
     def name(self):
         return self._name
 
 
-class SylkEnumValue():
+class SylkEnumValue:
     """sylk enum value level object that defines the required meta data properties."""
 
     def __init__(self, name: str, number: int, description: str = None) -> None:
         """Parses a fields into a :module:`sylk.commons.protos.sylk.EnumValue` representation.
 
         Parameters
         ----------
@@ -368,18 +500,24 @@
         return self._name
 
     @property
     def number(self):
         return self._number
 
 
-class SylkEnum():
+class SylkEnum:
     """sylk enum level object that defines the required meta data properties."""
 
-    def __init__(self, name, enum_values: List[SylkEnumValue] = [],description:str = '',domain=None) -> None:
+    def __init__(
+        self,
+        name,
+        enum_values: List[SylkEnumValue] = [],
+        description: str = "",
+        domain=None,
+    ) -> None:
         """Parses a fields into a :module:`sylk.commons.protos.sylk.Enum` representation.
 
         Parameters
         ----------
             name (str): A enum name.
             enum_values (:module:`List[sylk.commons.helpers.SylkEnumValue]`): A list of enum values.
         """
@@ -395,87 +533,110 @@
         return self._name, enums_values, self._description, self._domain
 
     @property
     def name(self):
         return self._name
 
 
-class SylkContext():
-
+class SylkContext:
     def __init__(self, sylk_context):
         self._sylk_context = sylk_context
         self._parse_context()
 
     def _parse_context(self):
-        self._files = self._sylk_context.get('files')
+        self._files = self._sylk_context.get("files")
 
     def get_rpc(self, service, name):
         svc = None
         if self._files is not None and len(self._files) > 0:
-            svc = next((svc for svc in self._files if svc['file'].split(
-                '/')[-1].split('.')[0] == service), None)
+            svc = next(
+                (
+                    svc
+                    for svc in self._files
+                    if svc["file"].split("/")[-1].split(".")[0] == service
+                ),
+                None,
+            )
             if svc is not None:
-                for rpc in svc['methods']:
-                    if rpc['name'] == name:
+                for rpc in svc["methods"]:
+                    if rpc["name"] == name:
                         return rpc
             else:
                 return svc
 
-    def new_rpc(self,service,context, suffix='py'):
-        file = next((file for file in self._files if file.get('file') == f'./services/{service}.{suffix}'),None)
+    def new_rpc(self, service, context, suffix="py"):
+        file = next(
+            (
+                file
+                for file in self._files
+                if file.get("file") == f"./services/{service}.{suffix}"
+            ),
+            None,
+        )
         if file is not None:
-            file.get('methods').append(context)
+            file.get("methods").append(context)
 
     def edit_rpc(self, service, name, new_context):
         rpc = self.get_rpc(service, name)
-        rpc['code'] = new_context['code']
-        rpc['type'] = new_context['type']
-        rpc['name'] = new_context['name']
+        rpc["code"] = new_context["code"]
+        rpc["type"] = new_context["type"]
+        rpc["name"] = new_context["name"]
 
     def set_rpc_code(self, service, name, code):
         rpc = self.get_rpc(service, name)
-        rpc['code'] = code
-        rpc['type'] = 'rpc'
+        rpc["code"] = code
+        rpc["type"] = "rpc"
 
     def get_functions(self, service):
         if self._files is not None:
-            svc = next((svc for svc in self._files if svc['file'].split(
-                '/')[-1].split('.')[0] == service), None)
+            svc = next(
+                (
+                    svc
+                    for svc in self._files
+                    if svc["file"].split("/")[-1].split(".")[0] == service
+                ),
+                None,
+            )
             funcs = []
             if svc is not None:
-                for func in svc['methods']:
-                    if func['type'] != 'rpc':
+                for func in svc["methods"]:
+                    if func["type"] != "rpc":
                         funcs.append(func)
                 return funcs
             else:
                 return svc
 
     def set_method_code(self, service, name, code):
-        file = next((f for f in self._files if service in f['file']), None)
+        file = next((f for f in self._files if service in f["file"]), None)
         if file is not None:
-            method = next(
-                (m for m in file['methods'] if m['name'] == name), None)
+            method = next((m for m in file["methods"] if m["name"] == name), None)
             if method is None:
-                file['methods'].insert(
-                    0, {'name': name, 'code': code, 'type': 'func'})
+                file["methods"].insert(0, {"name": name, "code": code, "type": "func"})
             else:
-                method['code'] = code
+                method["code"] = code
 
     def dump(self):
         return self._sylk_context
 
     @property
     def files(self):
         return self._files
 
 
-class SylkPackage():
+class SylkPackage:
     """sylk package level object that defines the required meta data properties."""
 
-    def __init__(self, name, messages: List[SylkMessage] = [], enums: List[SylkEnum] = [],extensions=None,domain=None):
+    def __init__(
+        self,
+        name,
+        messages: List[SylkMessage] = [],
+        enums: List[SylkEnum] = [],
+        extensions=None,
+        domain=None,
+    ):
         """Parses a fields into a :module:`sylk.commons.protos.sylk_pb2.PackageDescriptor` representation.
 
         Parameters
         ----------
             name (str): A package name.
             messages (List[:module:`sylk.commons.helpers.SylkMessage`]): A list of package messages.
             enums (List[:module:`sylk.commons.helpers.SylkEnum`]): A list of package enums.
@@ -496,217 +657,518 @@
         return self._name, messages, enums, self._extensions, self._domain
 
     @property
     def name(self):
         return self._name
 
 
-class SylkJson():
-
+class SylkJson:
     def __init__(self, sylk_json):
         self._sylk_json = sylk_json
         self._parse_json()
+        self._parse_proto_tree()
+
+    def _topological_sort(self,packages):
+        def dfs(package, visited, stack):
+            if self.packages.get(package) is not None:
+                visited.add(package)
+                for dependency in [dep for dep in self.packages.get(package,{}).get('dependencies',[]) if 'google.' not in dep]:
+                    if dependency not in visited and dependency not in self.packages[package].get('package'):
+                        dfs(dependency.replace('.','/'), visited, stack)
+                if package not in stack:
+                    stack.append(package)
+
+        visited = set()
+        stack = []
+
+        for package in packages:
+            if package not in visited:
+                dfs(package, visited, stack)
+        return stack
+
+    def _parse_proto_tree(self):
+        self._proto_tree = SylkTree(self.domain,self.project.get('name'))
+        self._proto_tree.load_module(google())
+
+        def _process_enum(self,enum,inline:str = None):
+            enm_name = enum.get('name')
+            inline = f'{inline}.' if inline is not None else ''
+            enm_path = pkg_path + '.' + inline + enm_name
+            self._proto_tree.add_node(enm_path,'enum',enum)
+            if enum.get('values') is not None:
+                for v in enum.get('values'):
+                    self._proto_tree.add_node(enm_path + '.' + v.get('name'),'value',v)
+
+        def _process_msg(self, msg, inline: str = None):
+            msg_name = msg.get('name')
+            inline = '' if inline is None else inline+'.'
+            msg_path = pkg_path + '.' + inline + msg_name
+            self._proto_tree.add_node(msg_path,'message',m)
+            if msg.get('inlines') is not None:
+                for inline in msg.get('inlines'):
+                    if inline.get('type') == 'enum':
+                        _process_enum(self,inline,msg.get('name'))
+                    else:
+                        _process_msg(self, inline, msg.get('name'))
+            if msg.get('fields') is not None:
+                for f in msg.get('fields'):
+                    self._proto_tree.add_node(msg_path + '.' + f.get('name'),'field',f)
+                    if f.get('fieldType') == "TYPE_ENUM":
+                        self._proto_tree.add_field_reference(msg_path, f.get('name'), f.get('enumType'))
+                    elif f.get('fieldType') == "TYPE_MESSAGE":
+                        self._proto_tree.add_field_reference(msg_path, f.get('name'), f.get('messageType'))
+                    elif f.get('fieldType') == "TYPE_MAP":
+                        if f.get('valueType') == "TYPE_ENUM":
+                            self._proto_tree.add_field_reference(msg_path, f.get('name'), f.get('enumType'))
+                        elif f.get('valueType') == "TYPE_MESSAGE":
+                            self._proto_tree.add_field_reference(msg_path, f.get('name'), f.get('messageType'))
+                    elif f.get('fieldType') == "TYPE_ONEOF":
+                        for oneof in f.get('oneofFields'):
+                            if oneof.get('fieldType') == "TYPE_ENUM":
+                                self._proto_tree.add_field_reference(msg_path+'.'+f.get('name'), oneof.get('name'), oneof.get('enumType'))
+                            elif oneof.get('fieldType') == "TYPE_MESSAGE":
+                                self._proto_tree.add_field_reference(msg_path+'.'+f.get('name'), oneof.get('name'), oneof.get('messageType'))
+
+        if self.packages is not None:
+            for pkg in self._topological_sort(self.packages):
+                p = self.packages[pkg]
+                pkg_path = p.get('package')
+                self._proto_tree.add_node(pkg_path,'package',p)
+
+                if p.get('enums') is not None:
+                    for e in p.get('enums'):
+                        _process_enum(self,e)
+                if p.get('messages') is not None:
+                    sorted = self._proto_tree.resolve_dependency_order(p.get('messages'))
+                    for m in sorted:
+                        _process_msg(self,m)
+                        
+                if p.get('services') is not None:
+                    for s in p.get('services'):
+                        svc_name = s.get('name')
+                        svc_path = pkg_path + '.' + svc_name
+                        self._proto_tree.add_node(svc_path,'service',s)
+                        if s.get('methods') is not None:
+                            for r in s.get('methods'):
+                                self._proto_tree.add_node(svc_path + '.' + r.get('name'),'method',r)
+                                self._proto_tree.add_method_reference(svc_path + '.' + r.get('name'), r.get('inputType'))
+                                self._proto_tree.add_method_reference(svc_path + '.' + r.get('name'), r.get('outputType'))
+
 
     def _parse_json(self):
-        self._organization = self._sylk_json.get('organization')
-        self._domain = self._organization.get('domain') if self._organization is not None and self._organization.get('domain') is not None else 'sylk'
-        self._config = self._sylk_json.get('configs')
-        self._project = self._sylk_json.get('project')
-        self._services = self._sylk_json.get('services')
-        self._packages = self._sylk_json.get('packages')
-        self._path = self._sylk_json.get('project').get('uri')
-        self._sylk_version = self._sylk_json.get('sylkVersion')
+        self._organization = self._sylk_json.get("organization")
+        self._domain = (
+            self._organization.get("domain")
+            if self._organization is not None
+            and self._organization.get("domain") is not None
+            else "sylk"
+        )
+        self._config = self._sylk_json.get("configs")
+        self._root_protos = self._config.get("protoBasePath")
+        self._project = self._sylk_json.get("project")
+        self._packages = self._sylk_json.get("packages")
+        self._services = self.flat_services()
+        self._path = self._sylk_json.get("project").get("uri")
+        self._sylk_version = self._sylk_json.get("sylkVersion")
+
+    def flat_services(self):
+        temp_services = []
+        if self.packages:
+            for p in self.packages:
+                pkg = self.packages[p]
+                if pkg.get("services"):
+                    for s in pkg.get("services"):
+                        temp_services.append(s)
+        return temp_services
 
-    def get_service(self, name, json=True,sylk_json=None,version:str='v1'):
+    def get_service(self, full_name, json=True):
+        name = full_name.split(".")[-1]
         if json:
             try:
-                return self._services[f'protos/{self.domain}/{name}/{version}/{name}.proto']
+                pkg = self.get_package(".".join(full_name.split(".")[:-1]), json)
+                filtered_svc = [s for s in pkg["services"] if s.get("name") == name]
+                return filtered_svc[0] if filtered_svc else None
             except Exception:
                 return None
         else:
-            depend = self._services[f'protos/{self.domain}/{name}/{version}/{name}.proto'].get('dependencies')
-            methods = self._services[f'protos/{self.domain}/{name}/{version}/{name}.proto'].get('methods')
-            extensions = self._services[f'protos/{self.domain}/{name}/{version}/{name}.proto'].get('extensions')
-            return generate_service(self.path,self.domain,name,self.get_server_language(),depend if depend is not None else [],self._services[f'protos/{self.domain}/{name}/{version}/{name}.proto'].get('description'),methods if methods is not None else [],extensions=extensions,sylk_json=sylk_json)
-
+            pkg = self.get_package(".".join(full_name.split(".")[:-1]))
+            filtered_svc = [s for s in pkg["services"] if s.get("name") == name]
+            if filtered_svc:
+                svc = filtered_svc[0]
+                depend = svc.get("dependencies")
+                description = svc.get("description")
+                methods = svc.get("methods")
+                extensions = svc.get("extensions")
+                return generate_service(
+                    self.path,
+                    full_name,
+                    self.get_server_language(),
+                    depend if depend is not None else [],
+                    description,
+                    methods if methods is not None else [],
+                    extensions=extensions,
+                    sylk_json=self._sylk_json,
+                )
+            else:
+                return None
 
-    def get_path(self, domain, name, version: str = 'v1'):
-        temp_path = f'protos/{domain}/{name}/{version}/{name}.proto'
-        if self._packages.get(temp_path) is not None or self._services.get(temp_path) is not None:
+    def get_path(self, full_name, tag: str = None):
+        paths = "/".join(full_name.split("."))
+        temp_path = f"{self._root_protos}/{paths}"
+        if (
+            self._packages.get(temp_path)
+            is not None
+            # or self.get_service().get(temp_path) is not None
+        ):
             return temp_path
         else:
-            raise SylkValidationError('Resource',"Sylk Resource Path {} not found.".format(f'protos/{domain}/{name}/{version}/{name}.proto',name))
-
-    def get_package(self, name,json=True,version:str='v1'):
+            raise SylkValidationError(
+                "Resource",
+                "Sylk Resource Path {} not found.".format(
+                    temp_path,
+                ),
+            )
+
+    def get_package(self, full_name, json=True):
+        ver = parse_version_component(full_name=full_name)
+        pkg_path = "/".join(full_name.split("."))
         if json:
-            if self._packages.get(f'protos/{self.domain}/{name}/{version}/{name}.proto') is None:
-                raise SylkValidationError('Package',"Sylk Package {} not found, if you trying to get import a package into Service try to run 'sylk package <some.package.v1> {}'".format(f'protos/{self.domain}/{name}/{version}/{name}.proto',name))
+            if self._packages.get(pkg_path) is None:
+                raise SylkValidationError(
+                    "Package", "Sylk Package {} not found".format(full_name)
+                )
             else:
-                return self._packages[f'protos/{self.domain}/{name}/{version}/{name}.proto']
+                return self._packages[pkg_path]
         else:
-            depend = self._packages[f'protos/{self.domain}/{name}/{version}/{name}.proto'].get('dependencies')
-            msgs = self._packages[f'protos/{self.domain}/{name}/{version}/{name}.proto'].get('messages')
-            enums = self._packages[f'protos/{self.domain}/{name}/{version}/{name}.proto'].get('enums')
-            return generate_package(self.path,self.domain,name,depend if depend is not None else [],msgs if msgs is not None else [],enums if enums is not None else [],sylk_json=self)
 
+            pkg = self._packages.get(pkg_path)
+            if pkg is not None:
+                depend = pkg.get("dependencies")
+                msgs = pkg.get("messages")
+                enums = pkg.get("enums")
+                services = pkg.get("services")
+                return generate_package(
+                    self.path,
+                    pkg.get("package"),
+                    dependencies=depend if depend is not None else [],
+                    messages=msgs if msgs is not None else [],
+                    enums=enums if enums is not None else [],
+                    services=services if services is not None else [],
+                    sylk_json=self,
+                    version=ver,
+                )
+            else:
+                raise SylkValidationError(
+                    "package",
+                    "package '{}' is not found under '{}' project".format(
+                        pkg_path, self.project.get("name")
+                    ),
+                )
 
     def get_enum(self, full_name):
-        version = full_name.split('.')[2]
-        pkg_name = full_name.split('.')[1]
-        enums = self._packages[f'protos/{self.domain}/{pkg_name}/{version}/{pkg_name}.proto'].get('enums')
-        if enums is not None:
-            return next((e for e in enums if e['name'] == full_name.split('.')[-1]), None)
+        parent = self._resolve_path_backwards(full_name)
+        enums = parent.get("enums") if parent.get("enums") is not None else []
+        if len(enums) > 0:
+            return next(
+                (m for m in enums if m["name"] == full_name.split(".")[-1]), None
+            )
         else:
             return None
 
+    def _resolve_path_backwards(self, path):
+        parts = path.split(".")
+        current_path = ""
+        for i in range(len(parts), 0, -1):
+            current_path = ".".join(parts[:i])
+            current_full_path = current_path.replace(".", "/")
+            if current_full_path in self._packages:
+                return self._packages[current_full_path]
+        return None
 
-    def get_message(self, full_name):
-        pkg_name = full_name.split('.')[1]
-        version = full_name.split('.')[0]
-        msgs = self._packages.get(f'protos/{self.domain}/{pkg_name}/{version}/{pkg_name}.proto',None)
-        msgs = msgs['messages'] if msgs is not None else []
-        if len(msgs) > 0:
-            return next((m for m in msgs if m['name'] == full_name.split('.')[-1]), None)
-        else:
+    def get_well_known_message(self, key):
+        if key == "google.protobuf.MessageOptions":
             return {
-                'fields': []
+                "fullName": key,
+                "name": key.split(".")[-1],
+                "fields": [
+                    {
+                        "name": "message_set_wire_format",
+                        "index": 1,
+                        "fieldType": "TYPE_BOOL",
+                        "label": "LABEL_OPTIONAL",
+                    },
+                    {
+                        "name": "no_standard_descriptor_accessor",
+                        "index": 2,
+                        "fieldType": "TYPE_BOOL",
+                        "label": "LABEL_OPTIONAL",
+                    },
+                    {
+                        "name": "deprecated",
+                        "index": 3,
+                        "fieldType": "TYPE_BOOL",
+                        "label": "LABEL_OPTIONAL",
+                    },
+                ],
             }
 
-    def get_rpc(self, full_name,version:str='v1'):
-        svc_name = full_name.split('.')[1]
-        svc_path = f'protos/{self.domain}/{svc_name}/{version}/{svc_name}.proto'
-        rpcs = self._services[svc_path].get('methods')
-        if rpcs is None:
-            return rpcs
-        else:
-            return next((r for r in rpcs if r['name'] == full_name.split('.')[-1]), None)
+    def get_message(self, full_name):
+        parent = self._resolve_path_backwards(full_name)
+        if parent is not None:
+            msgs = parent.get("messages") if parent.get("messages") is not None else []
+            if len(msgs) > 0:
+                return next(
+                    (m for m in msgs if m["name"] == full_name.split(".")[-1]), None
+                )
+        return None
+
+    def get_rpc(self, full_name):
+        svc = [s for s in self.services if s["fullName"] == full_name]
+        if svc:
+            rpcs = svc[0].get("methods")
+            if rpcs is not None:
+                return next(
+                    (r for r in rpcs if r["name"] == full_name.split(".")[-1]), None
+                )
+        return None
 
     def get_server_language(self):
-        return self.project.get('server').get('language').lower()
+        return self.project.get("server").get("language").lower()
 
-    
-    def get_extensions(self,extensions_type:Literal["FieldOptions","MessageOptions","ServiceOptions","FileOptions","MethodOptions"]=None):
+    def get_extensions(
+        self,
+        extensions_type: Literal[
+            "FieldOptions",
+            "MessageOptions",
+            "ServiceOptions",
+            "FileOptions",
+            "MethodOptions",
+        ] = None,
+    ):
         extensions = []
         if self.packages is not None:
             for p in self.packages:
                 pkg = self.packages[p]
-                msgs = pkg.get('messages')
+                msgs = pkg.get("messages")
                 if msgs is not None:
                     for m in msgs:
-                        ext_type = m.get('extensionType')
+                        ext_type = m.get("extensionType")
                         if ext_type is not None:
-                            if extensions_type is not None and extensions_type == ext_type:
+                            if (
+                                extensions_type is not None
+                                and extensions_type == ext_type
+                            ):
                                 extensions.append(m)
                             else:
                                 extensions.append(m)
         return extensions
 
-    
-    def get_extended_fields(self,message_full_name:str):
+    def get_extended_fields(self, message_full_name: str):
         """This function should be used when trying to iterate a specific message fields options
-        
+
         Args
         ----
             message_full_name - Full valid name for the message we want to get fields that are extended
 
         Returns
         -------
             A list of fields under passed message that holds an extension value
         """
         list_fields = None
         temp_msg = self.get_message(message_full_name)
 
         if temp_msg is not None:
-            list_fields = [f for f in temp_msg.get('fields') if f.get('extensions') is not None]
-            
+            list_fields = [
+                f for f in temp_msg.get("fields") if f.get("extensions") is not None
+            ]
+
         return list_fields
 
-    def get_extended_messages(self,package:str,extension:str=None):
+    def get_extended_messages(self, package: str, extension: str = None):
         """This function should be used when trying to iterate a specific package message options
-        
+
         Args
         ----
             package - valid name for the package we want to get fields that are extended
             extension - Optional full name that filter the message extension accordingly must be the extension message full name
 
         Returns
         -------
             A list of messages under passed package that holds an extension value
         """
         list_msgs = None
         temp_pkg = self.get_package(package)
 
         if temp_pkg is not None:
-            if temp_pkg.get('messages') is not None:
+            if temp_pkg.get("messages") is not None:
                 list_msgs = [
-                    m for m in temp_pkg.get('messages') if m.get('extensions') is not None 
-                    and (extension in m.get('extensions') if extension is not None else True)]
-            
+                    m
+                    for m in temp_pkg.get("messages")
+                    if m.get("extensions") is not None
+                    and (
+                        extension in m.get("extensions")
+                        if extension is not None
+                        else True
+                    )
+                ]
+
         return list_msgs
 
-    def get_extended_services(self,extension:str=None):
+    def get_extended_services(self, extension: str = None):
         """This function should be used when trying to iterate a specific service options
-        
+
         Args
         ----
             extension - Optional full name that filter the message extension accordingly must be the extension message full name
 
         Returns
         -------
             A list of services under the whole project that holds an extension value
         """
         list_pkgs = []
 
         for svc in self.services:
             temp_pkg = self.services[svc]
 
-            if temp_pkg.get('extensions') is not None:
+            if temp_pkg.get("extensions") is not None:
                 if extension is not None:
-                    if extension in temp_pkg.get('extensions'):
+                    if extension in temp_pkg.get("extensions"):
                         list_pkgs.append(temp_pkg)
                 else:
                     list_pkgs.append(temp_pkg)
-            
+
         return list_pkgs
 
-    def get_extended_packages(self,extension:str=None):
+    def get_extended_packages(self, extension: str = None):
         """This function should be used when trying to iterate a specific package message options
-        
+
         Args
         ----
             extension - Optional full name that filter the message extension accordingly must be the extension message full name
 
         Returns
         -------
             A list of packages under the whole project that holds an extension value
         """
         list_pkgs = []
 
         for p in self.packages:
             temp_pkg = self.packages[p]
 
-            if temp_pkg.get('extensions') is not None:
+            if temp_pkg.get("extensions") is not None:
                 if extension is not None:
-                    if extension in temp_pkg.get('extensions'):
+                    if extension in temp_pkg.get("extensions"):
                         list_pkgs.append(temp_pkg)
                 else:
                     list_pkgs.append(temp_pkg)
-            
+
         return list_pkgs
 
-    def is_language(self, language: str ):
-        if self.project.get('server').get('language') == language:
+    def is_language(self, language: str):
+        if self.project.get("server").get("language") == language:
             return True
         else:
-            for c in list(map(lambda c: c.get('language'), self.project.get('clients'))):
+            for c in list(
+                map(lambda c: c.get("language"), self.project.get("clients"))
+            ):
                 if c == language:
                     return True
-        
+
         return False
-        
+
+    def get_service_dependencies(self, service):
+        deps = []
+        service_node = self._proto_tree._find_node(service,self._proto_tree.root)
+        svc_deps = [ref for ref in self._proto_tree.get_references(service)]
+        files = self._proto_tree._get_file_paths(svc_deps)
+        for f in files:
+            if service_node.properties.get('tag') != f.split('/')[-1].split('.')[0]:
+                deps.append(f'import "{f}";')
+        return deps
+
+    def get_message_dependencies(self, message_name):
+        deps = []
+        if "google.protobuf." in message_name:
+            for t, msgs in _WellMap:
+                if message_name.split(".")[-1] in msgs:
+                    import_path = 'import "google/protobuf/{}.proto";'.format(t)
+                    deps.append(import_path)
+                    break
+        else:
+            refs = self._proto_tree.get_references(message_name)
+            files = self._proto_tree._get_file_paths(refs)
+            for f in files:
+                import_path = 'import "{}";'.format(
+                    f
+                )
+                deps.append(import_path)
+            # print(message_name,refs,'->',files)
+            # msg = self.get_message(message_name)
+            # pkg = self._resolve_path_backwards(message_name)
+            # for f in msg.get("fields"):
+            #     if f.get("fieldType") == "TYPE_MESSAGE":
+            #         dep_msg = self.get_message(f.get("messageType"))
+            #         if pkg.get("package") not in f.get("messageType"):
+            #             dep_pkg = self._resolve_path_backwards(f.get("messageType"))
+            #             if pkg.get("package") not in f.get("messageType") or (
+            #                 dep_msg.get("tag") is not None
+            #                 and dep_msg.get("tag") != msg.get("tag")
+            #             ):
+            #                 file_name = (
+            #                     dep_msg.get("tag")
+            #                     if dep_msg.get("tag") is not None
+            #                     else dep_pkg.get("name")
+            #                 )
+            #                 import_path = 'import "{}/{}.proto";'.format(
+            #                     dep_pkg.get("package").replace(".", "/"), file_name
+            #                 )
+            #                 if import_path not in deps:
+            #                     deps.append(import_path)
+            #         elif dep_msg.get("tag") != msg.get("tag"):
+            #             file_name = (
+            #                 dep_msg.get("tag")
+            #                 if dep_msg.get("tag") is not None
+            #                 else pkg.get("name")
+            #             )
+            #             import_path = 'import "{}/{}.proto";'.format(
+            #                 pkg.get("package").replace(".", "/"), file_name
+            #             )
+            #             if import_path not in deps:
+            #                 deps.append(import_path)
+            #     if f.get("fieldType") == "TYPE_ENUM":
+            #         dep_enm = self.get_enum(f.get("enumType"))
+            #         if pkg.get("package") not in f.get("enumType"):
+            #             dep_pkg = self._resolve_path_backwards(f.get("enumType"))
+            #             if pkg.get("package") not in f.get("enumType") or (
+            #                 dep_enm.get("tag") is not None
+            #                 and dep_enm.get("tag") != msg.get("tag")
+            #             ):
+            #                 file_name = (
+            #                     dep_enm.get("tag")
+            #                     if dep_enm.get("tag") is not None
+            #                     else dep_pkg.get("name")
+            #                 )
+            #                 import_path = 'import "{}/{}.proto";'.format(
+            #                     dep_pkg.get("package").replace(".", "/"), file_name
+            #                 )
+            #                 if import_path not in deps:
+            #                     deps.append(import_path)
+            #         elif dep_enm.get("tag") != msg.get("tag"):
+            #             file_name = (
+            #                 dep_enm.get("tag")
+            #                 if dep_enm.get("tag") is not None
+            #                 else pkg.get("name")
+            #             )
+            #             import_path = 'import "{}/{}.proto";'.format(
+            #                 pkg.get("package").replace(".", "/"), file_name
+            #             )
+            #             if import_path not in deps:
+            #                 deps.append(import_path)
+        return deps
+
     @property
     def domain(self):
         """str: Project domain."""
         return self._domain
 
     @property
     def project(self):
@@ -721,1595 +1183,3251 @@
     @property
     def packages(self):
         return self._packages
 
     @property
     def path(self):
         return self._path
-    
+
     @property
     def sylk_version(self):
         return self._sylk_version
 
 
-def load_sylk_json(path:str):
+def load_sylk_json(path: str):
     SYLK_JSON = file_system.rFile(path, json=True)
     SYLK_JSON = SylkJson(sylk_json=SYLK_JSON)
     return SYLK_JSON
 
-class SylkProto():
 
-    def __init__(self, name, imports=[], service=None, package=None, messages=[], enums=[], description=None,extensions=None,sylk_json:SylkJson=None):
+class SylkProtoFile:
+    def __init__(self, file_name, package, sylk_json: SylkJson = None, is_tag: bool = False) -> None:
+        self._file_name = file_name
+        self._package = package
+        self._is_tag = is_tag
+        self._sylk_json = sylk_json
+        self._file_path = self._set_file_path()
+
+    def _set_file_path(self):
+        pkg_path = self._package.package.replace(".", "/")
+        return f"{self._sylk_json.path}/{self._sylk_json._root_protos}/{pkg_path}/{self._file_name}.proto"
+
+    def get_metadata(self):
+        pkg_path = self._package.package.replace(".", "/")
+        base_protos = self._sylk_json._root_protos +'/' if self._sylk_json._root_protos is not None and self._sylk_json._root_protos != '' else ''
+        file_ver = parse_version_component(self._package.package.split('.')[-1])
+        if file_ver is not None:
+            file_ver = f";{self._package.name}v{file_ver.get('version')}{file_ver.get('channel') if file_ver.get('channel') is not None else ''}{file_ver.get('release') if file_ver.get('release') is not None else ''}"
+        else:
+            file_ver = ''
+        go_package = f'\noption go_package = "{self._sylk_json.project.get("goPackage")}/services/{base_protos}{pkg_path}{file_ver}";' if self._sylk_json.project.get("goPackage") is not None else ''
+        return "package {};{}".format(self._package.package,go_package)
+
+    def get_imports(self):
+        dependencies = []
+        current_file_path = self._file_path.split(self._sylk_json.path + '/' +self._sylk_json._root_protos + '/')[1]
+        if self._file_name != self._package.name or self._is_tag == True:
+            refs = []
+            msgs = [m.full_name for m in self._package.messages if m.tag == self._file_name]
+            enms = [e.full_name for e in self._package.enums if e.tag == self._file_name]
+            svcs = [s.full_name for s in self._package.services if s.tag == self._file_name]
+            refs = msgs + enms + svcs
+            file_refs = []
+            for m in msgs:
+                deps = self._sylk_json.get_message_dependencies(m)
+                for d in deps:
+                    if d not in dependencies and current_file_path not in d:
+                        dependencies.append(d)
+            for s in svcs:
+                deps = self._sylk_json.get_service_dependencies(s)
+                for d in deps:
+                    if d not in dependencies and  current_file_path not in d:
+                        dependencies.append(d)
+            # for i in refs:
+            #     references = self._sylk_json._proto_tree.get_references(i)
+            #     for r in references:
+            #         if r not in file_refs:
+            #             file_refs.append(r)
+            # files = self._sylk_json._proto_tree._get_file_paths(file_refs)
+            # for f in files:
+            #     # current_file = self._package.package.replace('.','/') + '/' + self._file_name + '.proto'
+            #     imp_path = f'import "{f}";'
+            #     if imp_path not in dependencies and f != current_file_path:
+            #         dependencies.append(imp_path)
+             
+            # for m in msgs:
+            #     deps = self._sylk_json.get_message_dependencies(m.full_name)
+            #     for d in deps:
+            #         if d not in dependencies:
+            #             dependencies.append(d)
+            # for s in svcs:
+            #     deps = self._sylk_json.get_service_dependencies(s)
+            #     for d in deps:
+            #         if d not in dependencies:
+            #             dependencies.append(d)
+
+        else:
+            msgs = [m.full_name for m in self._package.messages if m.tag == "" or m.tag == self._file_name]
+            enms = [e.full_name for e in self._package.enums if e.tag == "" or e.tag == self._file_name]
+            svcs = [s.full_name for s in self._package.services if s.tag == "" or s.tag == self._file_name]
+            
+            for m in msgs:
+                deps = self._sylk_json.get_message_dependencies(m)
+                for d in deps:
+                    if d not in dependencies and current_file_path not in d:
+                        dependencies.append(d)
+            for s in svcs:
+                deps = self._sylk_json.get_service_dependencies(s)
+                for d in deps:
+                    if d not in dependencies and  current_file_path not in d:
+                        dependencies.append(d)
+
+        return "\n\n" + "\n".join(dependencies) if len(dependencies) > 0 else ""
+
+    def get_services(self):
+        temp_svcs = []
+        if self._file_name != self._package.name:
+            svcs = [s for s in self._package.services if s.tag == self._file_name]
+        else:
+            svcs = [s for s in self._package.services if s.tag == "" or s.tag == self._file_name]
+        
+        for s in svcs:
+            methods = []
+            for rpc in s.methods:
+                in_stream = "stream " if rpc.client_streaming == True else ""
+                out_stream = "stream " if rpc.server_streaming == True else ""
+                methods.append("\t// [{}] - {}".format(rpc.full_name, rpc.description))
+                methods.append(
+                    "\trpc {} ({}{}) returns ({}{});".format(
+                        rpc.name, in_stream, rpc.input_type, out_stream, rpc.output_type
+                    )
+                )
+            methods = "\n".join(methods)
+
+            temp_svcs.append(
+                "service {0} {2}\n{1}\n{3}".format(
+                    s.name, methods, _OPEN_BRCK, _CLOSING_BRCK
+                )
+            )
+        return "\n\n" + "\n".join(temp_svcs) if len(temp_svcs) > 0 else ""
+
+    def get_messages(self):
+        temp_msgs = []
+
+        def _process_field(self,f,inline=False):
+            inline_fields = []
+
+            field_label = (
+                ""
+                if (
+                    f.label == SylkField_pb2.LABEL_OPTIONAL
+                    or f.label == SylkField_pb2.DEFAULT_SYLKFIELDLABELS
+                )
+                else "repeated "
+            )
+            field_type = (
+                SylkField_pb2.SylkFieldTypes.Name(f.field_type)
+                .split("_")[1]
+                .lower()
+                if f.field_type
+                not in [
+                    SylkField_pb2.TYPE_MESSAGE,
+                    SylkField_pb2.TYPE_ENUM,
+                    SylkField_pb2.TYPE_MAP,
+                    SylkField_pb2.TYPE_ONEOF,
+                ]
+                else f.message_type
+                if f.field_type == SylkField_pb2.TYPE_MESSAGE
+                else f.enum_type
+                if f.field_type == SylkField_pb2.TYPE_ENUM
+                else "map<{}, {}>".format(
+                    SylkField_pb2.SylkFieldTypes.Name(f.key_type)
+                    .split("_")[1]
+                    .lower(),
+                    SylkField_pb2.SylkFieldTypes.Name(f.value_type)
+                    .split("_")[1]
+                    .lower()
+                    if f.value_type
+                    not in [SylkField_pb2.TYPE_MESSAGE, SylkField_pb2.TYPE_ENUM]
+                    else f.message_type
+                    if f.value_type == SylkField_pb2.TYPE_MESSAGE
+                    else f.enum_type,
+                )
+                if f.field_type == SylkField_pb2.TYPE_MAP
+                else "oneof"
+            )
+
+            field_extensions = ""
+            format_desc =  f.description.split('\n') if f.description.split('\n')[-1]!='' else f.description.split('\n')[:-1]
+            if inline == False:
+                fields.append(
+                    "\t// [{}] - {}".format(
+                        f.full_name, '\n\t//'.join(format_desc)
+                    )
+                )
+            else:
+                inline_fields.append(
+                    "\t\t// [{}] - {}".format(
+                        f.full_name, '\n\t//'.join(format_desc)
+                    )
+                )
+
+            if f.field_type == SylkField_pb2.TYPE_ONEOF:
+                oneofs = []
+                for oneof in f.oneof_fields:
+
+                    oneof_field_type = (
+                        SylkField_pb2.SylkFieldTypes.Name(oneof.field_type)
+                        .split("_")[1]
+                        .lower()
+                        if oneof.field_type
+                        not in [
+                            SylkField_pb2.TYPE_MESSAGE,
+                            SylkField_pb2.TYPE_ENUM,
+                        ]
+                        else oneof.message_type
+                        if oneof.field_type == SylkField_pb2.TYPE_MESSAGE
+                        else oneof.enum_type
+                        if oneof.field_type == SylkField_pb2.TYPE_ENUM
+                        else "map<{}, {}>".format(
+                            SylkField_pb2.SylkFieldTypes.Name(oneof.key_type)
+                            .split("_")[1]
+                            .lower(),
+                            SylkField_pb2.SylkFieldTypes.Name(oneof.value_type)
+                            .split("_")[1]
+                            .lower()
+                            if oneof.value_type
+                            not in [SylkField_pb2.TYPE_MESSAGE, SylkField_pb2.TYPE_ENUM]
+                            else oneof.message_type
+                            if oneof.value_type == SylkField_pb2.TYPE_MESSAGE
+                            else oneof.enum_type,
+                        )
+                        if oneof.field_type == SylkField_pb2.TYPE_MAP
+                        else "NONE"
+                    )
+                    oneof_field_extensions = ""
+                    format_desc = oneof.description.split('\n') if oneof.description.split('\n')[-1]!='' else oneof.description.split('\n')[:-1]
+                    oneofs.append(
+                        "{}\t\t// [{}] - {}".format(
+                            '\t' if inline == True else '' ,oneof.full_name, '\n\t\t//'.join(format_desc)
+                        )
+                    )
+                    oneofs.append(
+                        "{}\t\t{} {} = {}{};".format(
+                           '\t' if inline == True else '' ,oneof_field_type, oneof.name, oneof.index, oneof_field_extensions
+                        )
+                    )
+                    field_extensions = '{\n'+'\n'.join(oneofs)+'\n\t}'
+                if inline == False:
+                    fields.append(
+                        "\t{} {} {};".format(
+                            field_type, f.name, field_extensions
+                        )
+                    )
+                else:
+                    inline_fields.append(
+                        "\t\t{} {} {};".format(
+                            field_type, f.name, field_extensions
+                        )
+                    )
+            else:
+                if inline == False:
+                    fields.append(
+                       "\t{}{} {} = {}{};".format(
+                        field_label, field_type, f.name, f.index, field_extensions
+                        )
+                    )
+                else:
+                    inline_fields.append(
+                        "\t\t{}{} {} = {}{};".format(
+                        field_label, field_type, f.name, f.index, field_extensions
+                        )
+                    )
+            return inline_fields
+
+        if self._file_name != self._package.name or self._is_tag == True:
+            msgs = [m for m in self._package.messages if m.tag == self._file_name]
+        else:
+            msgs = [m for m in self._package.messages if m.tag == "" or m.tag == self._file_name]
+        for m in msgs:
+            fields = []
+            temp_inlines = []
+            for inline in m.inlines:
+                if 'SylkMessage' in inline.type_url:
+                    msg = SylkMessage_pb2.SylkMessage()
+                    inline.Unpack(msg)
+                    inline_fields = []
+                    for f in msg.fields:
+                        inline_fields = inline_fields + _process_field(self,f,True)
+                    format_desc =  m.description.split('\n') if m.description.split('\n')[-1]!='' else m.description.split('\n')[:-1]
+                    temp_inlines.append(
+                        "\n\t// [{4}] - {5}\n\tmessage {0} {2}\n{1}\n\t{3}\n".format(
+                            msg.name, "\n".join(inline_fields), _OPEN_BRCK, _CLOSING_BRCK, msg.full_name, '\n//'.join(format_desc)
+                        )
+                    )
+                else:
+                    enm = SylkEnum_pb2.SylkEnum()
+                    inline.Unpack(enm)
+                    values = "\n\t".join(self._process_enum(enm))
+                    format_desc =  m.description.split('\n') if m.description.split('\n')[-1]!='' else m.description.split('\n')[:-1]
+                    temp_inlines.append(
+                        "\n\t// [{4}] - {5}\n\tenum {0} {2}\n{1}\n\t{3}\n".format(
+                            enm.name, values, _OPEN_BRCK, _CLOSING_BRCK, enm.full_name, '\n//'.join(format_desc)
+                        )
+                    )
+                        
+            for f in m.fields:
+                _process_field(self,f)
+            temp_inlines = "\n".join(temp_inlines)
+            fields = "\n".join(fields)
+            format_desc =  m.description.split('\n') if m.description.split('\n')[-1]!='' else m.description.split('\n')[:-1]
+            temp_msgs.append(
+                "\n// [{6}] - {5}\nmessage {0} {3}\n{1}{2}\n{4}".format(
+                    m.name, temp_inlines, fields, _OPEN_BRCK, _CLOSING_BRCK, '\n//'.join(format_desc),m.full_name
+                )
+            )
+        return "\n\n" + "\n".join(temp_msgs) if len(temp_msgs) > 0 else ""
+    
+    def _process_enum(self,e):
+        values = []
+        for v in sorted(e.values, key=lambda x: x.number):
+            format_desc =  v.description.split('\n') if v.description.split('\n')[-1]!='' else v.description.split('\n')[:-1]
+            values.append('\t// [{}] - {}'.format(v.full_name, '\n//'.join(format_desc)))
+            values.append('\t{} = {};'.format(v.name, v.number))
+        return values
+    
+    def get_enums(self):
+        temp_enums = []
+        if self._file_name != self._package.name or self._is_tag == True:
+            enums = [e for e in self._package.enums if e.tag == self._file_name]
+        else:
+            enums = [e for e in self._package.enums if e.tag == "" or e.tag == self._file_name]
+        for e in enums:
+            values = "\n".join(self._process_enum(e))
+            format_desc =  e.description.split('\n') if e.description.split('\n')[-1]!='' else e.description.split('\n')[:-1]
+            temp_enums.append(
+                "\n// [{4}] - {5}\nenum {0} {2}\n{1}\n{3}".format(
+                    e.name, values, _OPEN_BRCK, _CLOSING_BRCK, e.full_name, '\n//'.join(format_desc)
+                )
+            )
+        return "\n\n" + "\n".join(temp_enums) if len(temp_enums) > 0 else ""
+
+    def to_str(self):
+        return f'// Generated by sylk.build, DO NOT EDIT.\nsyntax = "proto3";\n{self.get_metadata()}{self.get_imports()}{self.get_services()}{self.get_messages()}{self.get_enums()}'
+
+
+class SylkProto:
+    def __init__(
+        self,
+        name,
+        imports=[],
+        package=None,
+        services=[],
+        messages=[],
+        enums=[],
+        description=None,
+        extensions=None,
+        sylk_json: SylkJson = None,
+        tags=None,
+    ):
         self._name = name
         self._imports = imports
-        self._service = service
         self._package = package
         self._messages = messages
         self._enums = enums
+        self._services = services
         self._description = description
         self._extensions = extensions
         self._sylk_json = sylk_json
+        self._tags = tags
+        self._files = []
 
-    def write_imports(self):
+    def write_files(self):
+        self.generate_files()
+        for path, content in self._files:
+            file_system.wFile(
+                file_system.join_path(
+                    self._sylk_json.path, self._sylk_json._root_protos, path
+                ),
+                content,
+                True,
+                False,
+                True,
+            )
+
+    def write_imports(self, tag=None):
         temp_imports = []
-       
+        if tag is None:
+            tag = ""
+        svcs = [s for s in self._services if s.tag == tag]
+        msgs = [m for m in self._messages if m.tag == tag]
+        enms = [e for e in self._enums if e.tag == tag]
+        for svc in svcs:
+            for rpc in svc.methods:
+                if self._package not in rpc.input_type or rpc.input_type in [
+                    m.full_name for m in self._messages if m.tag != tag
+                ]:
+                    msg = self._sylk_json.get_message(rpc.input_type)
+                    pkg = self._sylk_json._resolve_path_backwards(rpc.input_type)
+                    imp_path = "/".join(pkg.get("package").split("."))
+                    imp_file = (
+                        pkg.get("name") if msg.get("tag") is None else pkg.get("name")
+                    )
+                    temp_imports.append(f'\nimport "{imp_path}/{imp_file}.proto";')
+                if self._package not in rpc.output_type or rpc.output_type in [
+                    m.full_name for m in self._messages if m.tag != tag
+                ]:
+                    msg = self._sylk_json.get_message(rpc.output_type)
+                    pkg = self._sylk_json._resolve_path_backwards(rpc.output_type)
+                    imp_path = "/".join(pkg.get("package").split("."))
+                    imp_file = (
+                        pkg.get("name") if msg.get("tag") is None else pkg.get("name")
+                    )
+                    if f'\nimport "{imp_path}/{imp_file}.proto";' not in temp_imports:
+                        temp_imports.append(f'\nimport "{imp_path}/{imp_file}.proto";')
+        for msg in msgs:
+            # Message fields
+            for f in [
+                f
+                for f in msg.fields
+                if f.field_type == SylkField_pb2.SylkFieldTypes.TYPE_MESSAGE
+            ]:
+                if self._package not in f.message_type or f.message_type in [
+                    m.full_name for m in self._messages if m.tag != tag
+                ]:
+                    msg = self._sylk_json.get_message(rpc.input_type)
+                    pkg = self._sylk_json._resolve_path_backwards(rpc.input_type)
+                    imp_path = "/".join(pkg.get("package").split("."))
+                    imp_file = (
+                        pkg.get("name") if msg.get("tag") is None else pkg.get("name")
+                    )
+                    temp_imports.append(f'\nimport "{imp_path}/{imp_file}.proto";')
+                if self._package not in rpc.output_type or rpc.output_type in [
+                    m.full_name for m in self._messages if m.tag != tag
+                ]:
+                    msg = self._sylk_json.get_message(rpc.output_type)
+                    pkg = self._sylk_json._resolve_path_backwards(rpc.output_type)
+                    imp_path = "/".join(pkg.get("package").split("."))
+                    imp_file = (
+                        pkg.get("name") if msg.get("tag") is None else pkg.get("name")
+                    )
+                    if f'\nimport "{imp_path}/{imp_file}.proto";' not in temp_imports:
+                        temp_imports.append(f'\nimport "{imp_path}/{imp_file}.proto";')
+
         if self._imports is not None:
-                
             for imp in self._imports:
-                if 'google.protobuf.' in imp:
-                    if 'FieldMask' in imp:
-                        imp = f"google/protobuf/field_mask.proto"
-                        temp_imports.append(f'\nimport "{imp.lower()}";')
-                    else:
-                        imp = f"{imp.replace('.','/')}.proto"
-                        temp_imports.append(f'\nimport "{imp.lower()}";')
+                if "google.protobuf" in imp:
+                    for msgs in self._messages:
+                        for f in [
+                            f.message_type
+                            for f in msgs.fields
+                            if f.field_type == SylkField_pb2.TYPE_MESSAGE
+                        ]:
+                            for t, msgs in _WellMap:
+                                if f.split(".")[-1] in msgs:
+                                    well_known = imp.replace(".", "/")
+                                    temp_imports.append(f'\nimport "{well_known}/{t}";')
+                                    break
                 else:
-                    imp_file = imp.split('.')[1] + '.proto'
-                    imp_path = imp.replace('.','/')
                     try:
-                        # self._sylk_json.get_package(imp) 
-                        temp_imports.append(f'\nimport "{imp_path}/{imp_file}";')
-                    except SylkValidationError as e:
-                        
-                        pretty.print_warning(e)
-                        pretty.print_success('Importing {} Service into {} Service'.format(self._sylk_json.get_service(imp).get('name'),self._name))
+                        dep_pkg = self._sylk_json.get_package(imp, False)
+                        imp_path = imp.replace(".", "/")
+                        for msgs in self._messages:
+                            for f in [
+                                f.message_type
+                                for f in msgs.fields
+                                if f.field_type == SylkField_pb2.TYPE_MESSAGE
+                                and imp in f.message_type
+                            ]:
+                                tags = self._tags.get(imp)
+                                if tags is not None:
+                                    temp_imports.append(
+                                        f'\nimport "{imp_path}/{tags.get(f.message_type)}";'
+                                    )
+                                else:
+                                    temp_imports.append(
+                                        f'\nimport "{imp_path}/{dep_pkg.name}.proto";'
+                                    )
 
-            options = next((m for m in self._messages if m.get(
-                'extensionType') is not None), None)
-            if options is not None and 'google.protobuf.Descriptor' not in self._imports :
-                temp_imports.append(
-                    '\nimport "google/protobuf/descriptor.proto";')
-            return ''.join(temp_imports)
+                        # temp_imports.append(f'\nimport "imp/{imp_file}";')
+                    except SylkValidationError as e:
+                        print(e)
+                        # pretty.print_warning(e)
+                        # pretty.print_success(
+                        #     "Importing {} Service into {} Service".format(
+                        #         self._sylk_json.get_service(imp).get("name"), self._name
+                        #     )
+                        # )
+            options = next(
+                (
+                    m
+                    for m in self._messages
+                    if m.extension_type is not SylkCommons_pb2.DEFAULT_SYLKEXTENSIONS
+                ),
+                None,
+            )
+            if (
+                options is not None
+                and '\nimport "google/protobuf/descriptor.proto";' not in temp_imports
+            ):
+                temp_imports.append('\nimport "google/protobuf/descriptor.proto";')
+            return "".join(temp_imports)
         else:
-            return ''.join(temp_imports)
+            return "".join(temp_imports)
 
     def write_package(self):
         if self._package is not None:
             if self._extensions is not None:
                 temp_extensions = []
                 for ext_key in self._extensions:
-
                     ext_value = self._extensions[ext_key]
-                    extension_type = self._sylk_json.get_message('.'.join(ext_key.split('.')[:4]))
-                    extensions_package = parse_extension_to_proto('FileOptions',extension_type,ext_key,ext_value,self._sylk_json)
+                    extension_type = self._sylk_json.get_message(
+                        ".".join(ext_key.split(".")[:4])
+                    )
+                    extensions_package = parse_extension_to_proto(
+                        "FileOptions",
+                        extension_type,
+                        ext_key,
+                        ext_value,
+                        self._sylk_json,
+                    )
                     temp_extensions.append(extensions_package)
-                joined_extensions = '\n'.join(temp_extensions)
-                return f'\n\npackage {self._package};\n\n// Sylk.build Package Extensions\n{joined_extensions}'
+                joined_extensions = "\n".join(temp_extensions)
+                return f"\n\npackage {self._package};\n\n// Sylk.build Package Extensions\n{joined_extensions}"
             else:
-                return f'\n\npackage {self._package};'
+                return f"\n\npackage {self._package};"
         else:
-            return ''
+            svc_package = self._service.get("fullName")
+            return f"\n\npackage {svc_package};"
 
-    def write_service(self):
-        if self._service is not None:
+    def write_service(self, services):
+        tmp_services = []
+        for s in services:
             rpcs = []
 
-            if self._service.get('extensions') is not None:
-                for ext in self._service.get('extensions'):
-                    ext_msg = self._sylk_json.get_message('.'.join(ext.split('.')[:4]))
-                    
-                    temp_svc_ext = parse_extension_to_proto('ServiceOptions',ext_msg,ext,self._service.get('extensions')[ext],self._sylk_json)
-                    
+            if s.extensions is not None:
+                for ext in s.extensions:
+                    ext_msg = self._sylk_json.get_message(ext)
+
+                    temp_svc_ext = parse_extension_to_proto(
+                        "ServiceOptions",
+                        ext_msg,
+                        ext,
+                        s.extensions[ext],
+                        self._sylk_json,
+                    )
+
                     rpcs.append(temp_svc_ext)
 
-            for m in self._service.get('methods'):
-                rpc_name = m.get('name')
-                msg_name_in = m.get('inputType')
-                msg_name_out = m.get('outputType')
-
-                description = m.get('description')
-
-                stream_in = 'stream ' if m.get('clientStreaming') is not None and m.get(
-                    'clientStreaming') == True else ''
-                stream_out = 'stream ' if m.get('serverStreaming') is not None and m.get(
-                    'serverStreaming') == True else ''
-                
+            for m in s.methods:
+                rpc_name = m.name
+                msg_name_in = m.input_type
+                msg_name_out = m.output_type
+
+                description = m.description
+
+                stream_in = (
+                    "stream "
+                    if m.client_streaming is not None and m.client_streaming == True
+                    else ""
+                )
+                stream_out = (
+                    "stream "
+                    if m.server_streaming is not None and m.server_streaming == True
+                    else ""
+                )
+
                 rpcs.append(
-                    f'// [sylk] - {description}\n\trpc {rpc_name} ({stream_in}{msg_name_in}) returns ({stream_out}{msg_name_out});')
-            rpcs = '\n\t'.join(rpcs)
-            desc = f'// [sylk] {self._description}\n' if self._description is not None else ''
-            return f'{desc}service {self._name} {_OPEN_BRCK}\n\t{rpcs}\n{_CLOSING_BRCK}'
-        else:
-            return ''
+                    f"// [sylk] - {description}\n\trpc {rpc_name} ({stream_in}{msg_name_in}) returns ({stream_out}{msg_name_out});"
+                )
+            rpcs = "\n\t".join(rpcs)
+            desc = (
+                f"// [sylk] {self._description}\n"
+                if self._description is not None
+                else ""
+            )
+            tmp_services.append(
+                f"{desc}service {self._name} {_OPEN_BRCK}\n\t{rpcs}\n{_CLOSING_BRCK}"
+            )
 
-    def write_messages(self):
-        if len(self._messages) > 0:
+        return "".join(tmp_services)
+
+    def write_messages(self, messages):
+        if len(messages) > 0:
             msgs = []
-            for m in self._messages:
-                msg_name = m.get('name')
-                msgFullName = m.get('fullName')
+            for m in messages:
+                msg_name = m.name
+                msg_full_name = m.full_name
                 fields = []
                 # Adding MessageOptions
-                if m.get('extensions') is not None:
-                    for ext_key in m.get('extensions'):
-                        ext_msg = self._sylk_json.get_message('.'.join(ext_key.split('.')[:-1]))
-                        if ext_msg is None:
-                            raise SylkValidationError(
-                                'FieldOptions', f'Field Option [{ext}] specified for : "{fName}", is invalid !')
-                        fields.append('{}'.format(parse_extension_to_proto('MessageOptions',ext_msg,ext_key,m.get('extensions')[ext_key],self._sylk_json)))
-                m_desc = m.get('description')
-                ext_type = m.get('extensionType')
-                for f in m.get('fields'):
-                    fLabel = '' if f.get('label') == 'LABEL_OPTIONAL' or f.get('label') is None else '{0} '.format(
-                        f.get('label').split('_')[-1].lower())
-                    fType = f.get('fieldType').split('_')[-1].lower()
-                    if fType == 'message':
-                        fType = f.get('messageType')
-                    elif fType == 'enum':
-                        fType = f.get('enumType')
-                    elif fType == 'map':
-                        keyType = f.get('keyType').split('_')[-1].lower() if f.get('keyType') is not None and f.get('keyType') != -1 else None
-                        valueType = f.get('valueType').split('_')[-1].lower() if f.get('valueType') != 'TYPE_MESSAGE' and f.get('valueType') != 'TYPE_ENUM'  else f.get('messageType') if f.get('valueType') == 'TYPE_MESSAGE' else f.get('enumType') if f.get('valueType') == 'TYPE_ENUM' else None
-                        if valueType is None:
-                            pretty.print_error("Value type for 'map' is not valid ! {0}".format(f.get('valueType')))
+                if m.extensions is not None:
+                    for ext_key in m.extensions:
+                        if "google.protobuf" in ext_key:
+                            fields.append(
+                                "{}".format(
+                                    parse_extension_to_proto(
+                                        "MessageOptions",
+                                        self._sylk_json.get_well_known_message(ext_key),
+                                        ext_key,
+                                        m.extensions[ext_key],
+                                        self._sylk_json,
+                                    )
+                                )
+                            )
+                        else:
+                            ext_msg = self._sylk_json.get_message(ext_key)
+                            if ext_msg is None:
+                                raise SylkValidationError(
+                                    "FieldOptions",
+                                    f'Field Option [{ext}] specified for : "{ext_key}", is invalid !',
+                                )
+                            fields.append(
+                                "{}".format(
+                                    parse_extension_to_proto(
+                                        "MessageOptions",
+                                        ext_msg,
+                                        ext_key,
+                                        m.extensions[ext_key],
+                                        self._sylk_json,
+                                    )
+                                )
+                            )
+                m_desc = m.description
+                ext_type = m.extension_type
+                for f in m.fields:
+                    fLabel = (
+                        ""
+                        if f.label == SylkField_pb2.LABEL_OPTIONAL
+                        else "{0} ".format(
+                            SylkField_pb2.SylkFieldLabels.Name(f.label)
+                            .split("_")[-1]
+                            .lower()
+                        )
+                    )
+                    f_type = (
+                        SylkField_pb2.SylkFieldTypes.Name(f.field_type)
+                        .split("_")[-1]
+                        .lower()
+                    )
+                    if f_type == "message":
+                        f_type = f.message_type
+                    elif f_type == "enum":
+                        f_type = f.enum_type
+                    elif f_type == "map":
+                        key_type = (
+                            SylkField_pb2.SylkFieldTypes.Name(f.key_type)
+                            .split("_")[-1]
+                            .lower()
+                            if f.key_type is not None and f.key_type != -1
+                            else None
+                        )
+                        value_type = (
+                            SylkField_pb2.SylkFieldTypes.Name(f.value_type)
+                            .split("_")[-1]
+                            .lower()
+                            if f.value_type != "TYPE_MESSAGE"
+                            and f.value_type != "TYPE_ENUM"
+                            else f.message_type
+                            if f.value_type == "TYPE_MESSAGE"
+                            else f.enum_type
+                            if f.value_type == "TYPE_ENUM"
+                            else None
+                        )
+                        if value_type is None:
+                            pretty.print_error(
+                                "Value type for 'map' is not valid ! {0}".format(
+                                    f.value_type
+                                )
+                            )
                         else:
-                            fType = 'map<{0}, {1}>'.format(keyType,valueType)
-                    elif fType == 'oneof':
-                        field_name = f.get('name')
+                            f_type = "map<{0}, {1}>".format(key_type, value_type)
+                    elif f_type == "oneof":
+                        field_name = f.name
                         oneof_fields = []
-                        
-                        for oneof_field in f.get('oneofFields'):
-                            if oneof_field.get('fieldType') == 'TYPE_MESSAGE':
-                                oneof_field_type = oneof_field.get('messageType')
-                            elif oneof_field.get('fieldType') == 'TYPE_ENUM':
-                                oneof_field_type = oneof_field.get('enumType')
+
+                        for oneof_field in f.oneof_fields:
+                            if oneof_field.field_type == "TYPE_MESSAGE":
+                                oneof_field_type = oneof_field.message_type
+                            elif oneof_field.field_type == "TYPE_ENUM":
+                                oneof_field_type = oneof_field.enum_type
                             else:
-                                oneof_field_type = oneof_field.get('fieldType').split('_')[-1].lower()
-                            
-                            oneof_field_name = oneof_field.get('name')
-                            oneof_field_index = oneof_field.get('index') if oneof_field.get('index') is not None else 1
-                            oneof_fields.append(f'\n\t\t{oneof_field_type} {oneof_field_name} = {oneof_field_index};')
-                        oneof_fields = ''.join(oneof_fields)
-                        fType = f'oneof {field_name} {_OPEN_BRCK}\n{oneof_fields}\n\t{_CLOSING_BRCK}'
-                    
-                    fName = f.get('name')
-                    fIndex = int(f.get('index'))
+                                oneof_field_type = (
+                                    SylkField_pb2.SylkFieldTypes.Name(
+                                        oneof_field.field_type
+                                    )
+                                    .split("_")[-1]
+                                    .lower()
+                                )
+
+                            oneof_field_name = oneof_field.name
+                            oneof_field_index = (
+                                oneof_field.index
+                                if oneof_field.index is not None
+                                else 1
+                            )
+                            oneof_fields.append(
+                                f"\n\t\t{oneof_field_type} {oneof_field_name} = {oneof_field_index};"
+                            )
+                        oneof_fields = "".join(oneof_fields)
+                        f_type = f"oneof {field_name} {_OPEN_BRCK}\n{oneof_fields}\n\t{_CLOSING_BRCK}"
+
+                    f_name = f.name
+                    f_index = int(f.index)
                     fOptions = []
-                    if f.get('extensions') is not None:
-                        for ext in f.get('extensions'):
-                            list_names = ext.split('.')
+                    if f.extensions is not None:
+                        for ext in f.extensions:
+                            list_names = ext.split(".")
                             ext_msg = None
 
                             if len(list_names) > 2:
-                                if '.'.join(list_names[:3]) == self._package:
-                                    ext_msg = next((m for m in self._messages if m.get('name') == list_names[3]),None)
+                                if ".".join(list_names[:3]) == self._package:
+                                    ext_msg = next(
+                                        (
+                                            m
+                                            for m in self._messages
+                                            if m.name == list_names[3]
+                                        ),
+                                        None,
+                                    )
                             else:
-                                ext_msg = next((m for m in self._messages if m.get(
-                                    'name') == ext.split('.')[0]), None)
+                                ext_msg = next(
+                                    (
+                                        m
+                                        for m in self._messages
+                                        if m.name == ext.split(".")[0]
+                                    ),
+                                    None,
+                                )
                             if ext_msg is None:
-                                ext_msg = self._sylk_json.get_message('.'.join(ext.split('.')[:-1]))
+                                ext_msg = self._sylk_json.get_message(
+                                    ".".join(ext.split(".")[:-1])
+                                )
                                 if ext_msg is None:
                                     raise SylkValidationError(
-                                        'FieldOptions', f'Field Option [{ext}] specified for : "{fName}", is invalid !')
-                            
-                            temp_field_extension_test = parse_extension_to_proto('FieldOptions',ext_msg,ext,f.get('extensions')[ext],self._sylk_json)
+                                        "FieldOptions",
+                                        f'Field Option [{ext}] specified for : "{f_name}", is invalid !',
+                                    )
+
+                            temp_field_extension_test = parse_extension_to_proto(
+                                "FieldOptions",
+                                ext_msg,
+                                ext,
+                                f.extensions[ext],
+                                self._sylk_json,
+                            )
                             fOptions.append(temp_field_extension_test)
 
-                        fOptions = ',\n\t\t'.join(fOptions)
-                    fOptions = f' [\n\t\t{fOptions}\n\t]' if len(fOptions) > 1 else f'[{fOptions}]' if len(fOptions) == 1 else ''
-                    fDesc = f.get('description')
-                    fFullName = f.get('fullName')
-                    if ext_type == 'FieldOptions' or ext_type == 'FileOptions' or ext_type == 'MessageOptions' or ext_type == 'ServiceOptions' or ext_type == 'MethodOptions':
-                        fDesc = f'// [{fFullName}] - {fDesc}\n\t\t' if fDesc is not None else ''
+                        fOptions = ",\n\t\t".join(fOptions)
+                    fOptions = (
+                        f" [\n\t\t{fOptions}\n\t]"
+                        if len(fOptions) > 1
+                        else f"[{fOptions}]"
+                        if len(fOptions) == 1
+                        else ""
+                    )
+                    f_desc = f.description
+                    f_fullname = f.full_name
+                    if (
+                        ext_type == "FieldOptions"
+                        or ext_type == "FileOptions"
+                        or ext_type == "MessageOptions"
+                        or ext_type == "ServiceOptions"
+                        or ext_type == "MethodOptions"
+                    ):
+                        f_desc = (
+                            f"// [{f_fullname}] - {f_desc}\n\t\t"
+                            if f_desc is not None
+                            else ""
+                        )
                     else:
-                        fDesc = f'// [{fFullName}] - {fDesc}\n\t' if fDesc is not None else ''
-                    if f.get('fieldType') == 'TYPE_ONEOF':
-                        fields.append(
-                            f'{fDesc}{fType}')
+                        f_desc = (
+                            f"// [{f_fullname}] - {f_desc}\n\t"
+                            if f_desc is not None
+                            else ""
+                        )
+                    if f.field_type == "TYPE_ONEOF":
+                        fields.append(f"{f_desc}{f_type}")
                     else:
                         fields.append(
-                            f'{fDesc}{fLabel}{fType} {fName} = {fIndex}{fOptions};')
+                            f"{f_desc}{fLabel}{f_type} {f_name} = {f_index}{fOptions};"
+                        )
 
-                if ext_type == 'FieldOptions':
-                    fields = '\n\t\t'.join(fields)
+                if ext_type == "FieldOptions":
+                    fields = "\n\t\t".join(fields)
                     msgs.append(
-                        f'\n// [{msgFullName}] - {m_desc}\nmessage {msg_name} {_OPEN_BRCK}\n\textend google.protobuf.FieldOptions {_OPEN_BRCK}\n\t\t{fields}\n\t{_CLOSING_BRCK}\n{_CLOSING_BRCK}\n')
-                elif ext_type == 'MessageOptions':
-                    fields = '\n\t\t'.join(fields)
+                        f"\n// [{msg_full_name}] - {m_desc}\nmessage {msg_name} {_OPEN_BRCK}\n\textend google.protobuf.FieldOptions {_OPEN_BRCK}\n\t\t{fields}\n\t{_CLOSING_BRCK}\n{_CLOSING_BRCK}\n"
+                    )
+                elif ext_type == "MessageOptions":
+                    fields = "\n\t\t".join(fields)
                     msgs.append(
-                        f'\n// [{msgFullName}] - {m_desc}\nmessage {msg_name} {_OPEN_BRCK}\n\textend google.protobuf.MessageOptions {_OPEN_BRCK}\n\t\t{fields}\n\t{_CLOSING_BRCK}\n{_CLOSING_BRCK}\n')
-                elif ext_type == 'FileOptions':
-                    fields = '\n\t\t'.join(fields)
+                        f"\n// [{msg_full_name}] - {m_desc}\nmessage {msg_name} {_OPEN_BRCK}\n\textend google.protobuf.MessageOptions {_OPEN_BRCK}\n\t\t{fields}\n\t{_CLOSING_BRCK}\n{_CLOSING_BRCK}\n"
+                    )
+                elif ext_type == "FileOptions":
+                    fields = "\n\t\t".join(fields)
                     msgs.append(
-                        f'\n// [{msgFullName}] - {m_desc}\nmessage {msg_name} {_OPEN_BRCK}\n\textend google.protobuf.FileOptions {_OPEN_BRCK}\n\t\t{fields}\n\t{_CLOSING_BRCK}\n{_CLOSING_BRCK}\n')
-                elif ext_type == 'ServiceOptions':
-                    fields = '\n\t\t'.join(fields)
+                        f"\n// [{msg_full_name}] - {m_desc}\nmessage {msg_name} {_OPEN_BRCK}\n\textend google.protobuf.FileOptions {_OPEN_BRCK}\n\t\t{fields}\n\t{_CLOSING_BRCK}\n{_CLOSING_BRCK}\n"
+                    )
+                elif ext_type == "ServiceOptions":
+                    fields = "\n\t\t".join(fields)
                     msgs.append(
-                        f'\n// [{msgFullName}] - {m_desc}\nmessage {msg_name} {_OPEN_BRCK}\n\textend google.protobuf.ServiceOptions {_OPEN_BRCK}\n\t\t{fields}\n\t{_CLOSING_BRCK}\n{_CLOSING_BRCK}\n')
-                elif ext_type == 'MethodOptions':
-                    fields = '\n\t\t'.join(fields)
+                        f"\n// [{msg_full_name}] - {m_desc}\nmessage {msg_name} {_OPEN_BRCK}\n\textend google.protobuf.ServiceOptions {_OPEN_BRCK}\n\t\t{fields}\n\t{_CLOSING_BRCK}\n{_CLOSING_BRCK}\n"
+                    )
+                elif ext_type == "MethodOptions":
+                    fields = "\n\t\t".join(fields)
                     msgs.append(
-                        f'\n// [{msgFullName}] - {m_desc}\nmessage {msg_name} {_OPEN_BRCK}\n\textend google.protobuf.MethodOptions {_OPEN_BRCK}\n\t\t{fields}\n\t{_CLOSING_BRCK}\n{_CLOSING_BRCK}\n')
+                        f"\n// [{msg_full_name}] - {m_desc}\nmessage {msg_name} {_OPEN_BRCK}\n\textend google.protobuf.MethodOptions {_OPEN_BRCK}\n\t\t{fields}\n\t{_CLOSING_BRCK}\n{_CLOSING_BRCK}\n"
+                    )
                 else:
-                    fields = '\n\t'.join(fields)
+                    fields = "\n\t".join(fields)
                     msgs.append(
-                        f'\n// [{msgFullName}] - {m_desc}\nmessage {msg_name} {_OPEN_BRCK}\n\t{fields}\n{_CLOSING_BRCK}\n')
+                        f"\n// [{msg_full_name}] - {m_desc}\nmessage {msg_name} {_OPEN_BRCK}\n\t{fields}\n{_CLOSING_BRCK}\n"
+                    )
 
-            msgs = '\n'.join(msgs)
+            msgs = "\n".join(msgs)
             return msgs
         else:
-            return ''
+            return ""
 
-    def write_enums(self):
-        if self._enums is not None:
-            enums = []
-            for e in self._enums:
-                enum_name = e.get('name')
-                enum_full_name = e.get('fullName')
+    def write_enums(self, enums):
+        if enums is not None:
+            tmp_enums = []
+            for e in enums:
+                enum_name = e.name
+                enum_full_name = e.full_name
                 values = []
-                for v in e.get('values'):
-                    value_name = v.get('name')
-                    value_number = 0 if v.get(
-                        'number') is None else v.get('number')
-                    v_desc = v.get('description')
-                    values.append(f'// [{enum_full_name}] - {v_desc}\n\t{value_name} = {int(value_number)};')
-                values = '\n\t'.join(values)
-                e_desc = e.get('description')
-                enums.append(
-                    f'// [{enum_full_name}] - {e_desc}\nenum {enum_name} {_OPEN_BRCK}\n\t{values}\n{_CLOSING_BRCK}\n')
-            return '\n'.join(enums)
+                for v in e.values:
+                    value_name = v.name
+                    value_number = 0 if v.number is None else v.number
+                    v_desc = v.description
+                    values.append(
+                        f"// [{enum_full_name}] - {v_desc}\n\t{value_name} = {int(value_number)};"
+                    )
+                values = "\n\t".join(values)
+                e_desc = e.description
+                tmp_enums.append(
+                    f"// [{enum_full_name}] - {e_desc}\nenum {enum_name} {_OPEN_BRCK}\n\t{values}\n{_CLOSING_BRCK}\n"
+                )
+            return "\n".join(tmp_enums)
 
         else:
-            return ''
+            return ""
 
     def to_str(self):
         return self.__str__()
 
-    def __str__(self):
+    def generate_files(self):
         options = []
-        if self._sylk_json.project.get('goPackage') is not None:
-            if self._service is not None:
-                domain = self._service.get('fullName').split('.')[0]
-                name = self._service.get('fullName').split('.')[1]
-                ver = self._service.get('fullName').split('.')[2]
-            if self._package is not None:
-                domain = self._package.split('.')[0]
-                name = self._package.split('.')[1]
-                ver = self._package.split('.')[2]
-            options.append('// Go package name\noption go_package = "{}{}";\n'.format(self._sylk_json.project.get('goPackage'),'/services/protos/{0}/{1}/{2}'.format(domain,name,ver)))
-        options = '\n'.join(options)
-        return f'// sylk.build Generated proto DO NOT EDIT\nsyntax = "proto3";{self.write_package()}{self.write_imports()}\n\n{options}{self.write_service()}{self.write_messages()}{self.write_enums()}'
+        options = "\n".join(options)
+        # if self._sylk_json.project.get("goPackage") is not None:
+        #     options.append(
+        #         '// Go package name\noption go_package = "{}{}";\n'.format(
+        #             self._sylk_json.project.get("goPackage"),
+        #             "/services/protos/{0}/{1}/{2};{3}".format(
+        #                 domain, name, ver, name + ver
+        #             ),
+        #         )
+        #     )
+
+        for t in self._tags:
+            svcs = [s for s in self._services if s.tag == t]
+            msgs = [m for m in self._messages if m.tag == t]
+            enms = [e for e in self._enums if e.tag == t]
+            self._files.append(
+                (
+                    self._package.replace(".", "/") + "/" + t + ".proto",
+                    f'// sylk.build Generated proto DO NOT EDIT\nsyntax = "proto3";{self.write_package()}{self.write_imports(t)}\n\n{options}{self.write_service(svcs)}{self.write_messages(msgs)}{self.write_enums(enms)}',
+                )
+            )
+        svcs = [s for s in self._services if s.tag == "" or s.tag == pkg_name]
+        msgs = [m for m in self._messages if m.tag == ""  or m.tag == pkg_name]
+        enms = [e for e in self._enums if e.tag == "" or e.tag == pkg_name]
+
+        if len(enms) > 0 or len(msgs) > 0 or len(svcs) > 0:
+            ver = parse_version_component(self._package)
+            if ver:
+                pkg_name = self._package.split(".")[-2].lower()
+            else:
+                pkg_name = self._package.split(".")[-1].lower()
 
+            self._files.append(
+                (
+                    self._package.replace(".", "/") + "/" + pkg_name + ".proto",
+                    f'// sylk.build Generated proto DO NOT EDIT\nsyntax = "proto3";{self.write_package()}{self.write_imports()}\n\n{options}{self.write_service(svcs)}{self.write_messages(msgs)}{self.write_enums(enms)}',
+                )
+            )
 
-class SylkClientPy():
-    """A helper class to write 'Python' language clients for sylk.build project services"""
 
-    def __init__(self, project_package, services=None, packages=None, context: SylkContext = None, config = None, pre_data = None):
+class SylkClientPy:
+    """A helper class to write 'Python' language clients for sylk.build project services"""
 
+    def __init__(
+        self,
+        project_package,
+        services=None,
+        packages=None,
+        context: SylkContext = None,
+        config=None,
+        pre_data=None,
+        sylk_json: SylkJson = None
+    ):
         self._services = services
         self._project_package = project_package
         self._context = context
         self._packages = packages
         self._config = config
         self._pre_data = pre_data
+        self._sylk_json = sylk_json
 
     def __str__(self):
-
-        return f'{self.write_imports()}\n{self.write_client_wrapper()}\n\n\t{self.write_services_classes()}'
+        return f"{self.write_imports()}\n{self.write_client_wrapper()}\n\n{self.write_services_classes()}"
 
     def write_client_wrapper(self):
         if self._pre_data is not None:
-            client_options = self._pre_data.get('client_options')
-            client_options = '\n\t'.join(list(map(lambda opt: '("{}", {}),'.format(opt[0],opt[1]),client_options)))
+            client_options = self._pre_data.get("client_options")
+            client_options = "\n\t".join(
+                list(
+                    map(
+                        lambda opt: '("{}", {}),'.format(opt[0], opt[1]), client_options
+                    )
+                )
+            )
         sylk_version = __version__.__version__
         sylk_global_auth_key = None
-        return f'\n# For available channel options in python visit https://github.com/grpc/grpc/blob/v1.46.x/include/grpc/impl/codegen/grpc_types.h\n_CHANNEL_OPTIONS = ({client_options})\n\n# Global metadata\n_METADATA = ((\'sylk-version\',\'{sylk_version}\'),)\n\n# Global auth key that will be verified by sylk client\n_GLOBAL_AUTH_KEY = {sylk_global_auth_key}\n\n# Generated thanks to [sylk.build](https://www.sylk.build)\nclass {self._project_package}:\n\n\t{self.init_wrapper()}'
+        return f"\n# For available channel options in python visit https://github.com/grpc/grpc/blob/v1.46.x/include/grpc/impl/codegen/grpc_types.h\n_CHANNEL_OPTIONS = ({client_options})\n\n# Global metadata\n_METADATA = (('sylk-version','{sylk_version}'),)\n\n# Global auth key that will be verified by sylk client\n_GLOBAL_AUTH_KEY = {sylk_global_auth_key}\n\n# Generated thanks to [sylk.build](https://www.sylk.build)\n"
 
     def init_stubs(self):
         stubs = []
         for svc in self._services:
-            svc_name = svc.split('/')[-1].split('.')[0]
-            stubs.append(f'self.{svc_name}Stub = {svc_name}Service.{svc_name}Stub(channel)')
+            svc_name = svc.split("/")[-1].split(".")[0]
+            svc_ver = svc.split("/")[-2]
+            stubs.append(
+                f"self.{svc_name}{svc_ver}Stub = {svc_name}{svc_ver}Service.{svc_name}Stub(channel)"
+            )
 
-        return '\n\t\t'.join(stubs)
+        return "\n\t\t".join(stubs)
 
     def init_wrapper(self):
         if self._config is not None:
-            host = self._config.get('host')
-            port = self._config.get('port')
+            host = self._config.get("host")
+            port = self._config.get("port")
 
         else:
-            host = 'localhost'
+            host = "localhost"
             port = 44880
-        init_func = f'def __init__(self, host="{host}", port={port}, timeout=10, log_level=\'ERROR\'):\n\t\tlogging.root.setLevel(log_level)\n\t\tself._sylk_global_auth_key = _GLOBAL_AUTH_KEY\n\t\tchannel = grpc.insecure_channel(\'{_OPEN_BRCK}0{_CLOSING_BRCK}:{_OPEN_BRCK}1{_CLOSING_BRCK}\'.format(host, port),_CHANNEL_OPTIONS)\n\t\ttry:\n\t\t\tgrpc.channel_ready_future(channel).result(timeout=timeout)\n\t\texcept grpc.FutureTimeoutError:\n\t\t\tlogging.error(\'Timed out: Server seems to be offline. Verify your connection configs.\')\n\t\t\tsys.exit(1)\n\t\t{self.init_stubs()}'
+        init_func = f"def __init__(self, host=\"{host}\", port={port}, timeout=10, log_level='ERROR'):\n\t\tlogging.root.setLevel(log_level)\n\t\tself._sylk_global_auth_key = _GLOBAL_AUTH_KEY\n\t\tchannel = grpc.insecure_channel('{_OPEN_BRCK}0{_CLOSING_BRCK}:{_OPEN_BRCK}1{_CLOSING_BRCK}'.format(host, port),_CHANNEL_OPTIONS)\n\t\ttry:\n\t\t\tgrpc.channel_ready_future(channel).result(timeout=timeout)\n\t\texcept grpc.FutureTimeoutError:\n\t\t\tlogging.error('Timed out: Server seems to be offline. Verify your connection configs.')\n\t\t\tsys.exit(1)\n\t\t{self.init_stubs()}"
         return init_func
 
+    
     def write_imports(self):
-        imports = ['from typing import Tuple, Iterator, Any', 'import grpc',
-                   'import sys', 'from functools import partial',
-                   'from sylk.commons.interceptors import sylk_client_pre_rpc','import logging']
-        for svc in self._services:
-            for dep in self._services[svc].get('dependencies'):
-                if 'google.protobuf.' in dep:
-                    wellknown_message = dep.split('.')[-1]
-                    imports.append(f'from google.protobuf import {wellknown_message.lower()}_pb2')
-            svc_name = svc.split('/')[-1].split('.')[0]
-            svc_path = '.'.join(svc.split('/')[:-1])
-            imports.append(f'from .{svc_path} import {svc_name}_pb2_grpc as {svc_name}Service')
-        for pkg in self._packages:
-            pkg_name = pkg.split('/')[-1].split('.')[0]
-            pkg_path = '.'.join(pkg.split('/')[:-1])
-            imports.append(f'from .{pkg_path} import {pkg_name}_pb2 as {pkg_name}')
+        adding_protos_module_path = f'# Adding protos module path if needed\n\
+script_dir = os.path.dirname(os.path.abspath(__file__))\n\
+proto_module = os.path.join(script_dir, "{self._sylk_json._root_protos}")\n\
+if proto_module not in sys.path:\n\
+    # Insert the protos modules path at the beginning of sys.path (to give it higher priority)\n\
+    sys.path.insert(0, proto_module)'
+        imports = [
+            "from typing import Tuple, Iterator, Any",
+            "import grpc",
+            "import os",
+            "import sys",
+            adding_protos_module_path,
+            "from functools import partial",
+            "from sylk.commons.interceptors import sylk_client_pre_rpc, SylkSimpleAuth",
+            "import logging",
+        ]
+
+        files =  self._sylk_json._proto_tree.get_all_file_paths()
+        for mod in files:
+            mod_path = '.'.join(mod.split('/')[:-1])
+            mod_name = mod.split('/')[-1].split('.')[0]
+            ver = self._sylk_json._proto_tree._parse_version_component(mod_path)
+            if ver is not None:
+                version = mod_path.split('.')[-1]
+            else:
+                version = ''
+            if mod_path.split('.')[0] != self._sylk_json._proto_tree.root.name:
+                base_protos = ''
+                imports.append(f"from {base_protos}{mod_path} import {mod_name}_pb2" )
+            else:
+                base_protos = f'.{self._sylk_json._root_protos}.' if self._sylk_json._root_protos is not None and self._sylk_json._root_protos != '' else '.'
+                imports.append(f"from {base_protos}{mod_path} import {mod_name}_pb2 as {mod_name}_{version}, {mod_name}_pb2_grpc as {mod_name}_{version}_grpc" )
 
         # Pre data parsing
         if self._pre_data is not None:
-            if self._pre_data.get('imports') is not None:
-                for imp in self._pre_data.get('imports'):
+            if self._pre_data.get("imports") is not None:
+                for imp in self._pre_data.get("imports"):
                     if imp not in imports:
                         imports.append(imp)
 
-        return '\n'.join(imports)
+        return "\n".join(imports)
 
     def write_services_classes(self):
+        defualt_port = self._sylk_json._config.get('port')
         if self._services is not None:
-            rpcs = []
+            svcs = []
             for svc in self._services:
-                for rpc in self._services[svc]['methods']:
-                    rpc_name = rpc['name']
-                    description = rpc.get('description') if rpc.get('description') is not None else ''
-                    rpc_in_type_pkg = rpc['inputType'].split('.')[1]
-                    rpc_in_type = rpc['inputType'].split('.')[-1]
-                    if 'protobuf' in rpc_in_type_pkg:
-                        rpc_in_type = f'{rpc_in_type.lower()}_pb2.{rpc_in_type}'
+                rpcs = []
+                svc_pkg = self._sylk_json._proto_tree.get_parent(svc.get('fullName'))
+                
+                svc_ver = parse_version_component(svc.get("fullName"))
+                svc_name = svc.get("name")
+                if svc_ver is not None:
+                    svc_pkg_name = svc_pkg.full_path.split('.')[-2] if svc.get('tag') is None else svc.get('tag')
+                    formatted_version = "v{}".format(svc_ver.get("version"))
+                    if svc_ver.get("channel") is not None:
+                        formatted_version += svc_ver.get("channel")
+                        if svc_ver.get("release") is not None:
+                            formatted_version += svc_ver.get("release")
+                else:
+                    svc_pkg_name = svc_pkg.full_path.split('.')[-1] if svc.get('tag') is None else svc.get('tag')
+                for rpc in svc.get("methods"):
+                    rpc_name = rpc["name"]
+                    description = (
+                        rpc.get("description")
+                        if rpc.get("description") is not None
+                        else ""
+                    )
+                    rpc_in_type = rpc["inputType"].split(".")[-1]
+                    if "google.protobuf" in rpc["inputType"]:
+                        pb_pkg = rpc["inputType"].split(".")[-1].lower()
+                        rpc_in_type = f"{pb_pkg}_pb2.{rpc_in_type}"
                     else:
-                        rpc_in_type = f'{rpc_in_type_pkg}.{rpc_in_type}'
-                    rpc_out_type_pkg = rpc['outputType'].split('.')[1]
-                    rpc_out_type = rpc['outputType'].split('.')[-1]
-                    if 'protobuf' in rpc_out_type_pkg:
-                        rpc_out_type = f'{rpc_out_type.lower()}_pb2.{rpc_out_type}'
+                        rpc_in_pkg = self._sylk_json._proto_tree.get_parent(rpc["inputType"])
+                        rpc_in_type_pkg = self._sylk_json._proto_tree._get_file_paths([rpc["inputType"]])
+                        rpc_in_type_pkg = rpc_in_type_pkg[0].split('/')[-1].split('.')[0]
+                        ver = self._sylk_json._proto_tree._parse_version_component(rpc["inputType"])
+                        if ver is not None:
+                            rpc_in_type_over = rpc_in_pkg.full_path.split(".")[-1]
+                        else:
+                            rpc_in_type_over = ""
+                        rpc_in_type = (
+                            f"{rpc_in_type_pkg}_{rpc_in_type_over}.{rpc_in_type}"
+                        )
+                   
+                    rpc_out_type = rpc["outputType"].split(".")[-1]
+                    if "google.protobuf" in rpc["outputType"]:
+                        pb_pkg = rpc["outputType"].split(".")[-1].lower()
+                        rpc_out_type = f"{pb_pkg}_pb2.{rpc_out_type}"
                     else:
-                        rpc_out_type = f'{rpc_out_type_pkg}.{rpc_out_type}'
-                    in_open_type = 'Iterator[' if rpc.get(
-                        'clientStreaming') is not None and rpc.get('clientStreaming') == True else ''
-                    in_close_type = ']' if rpc.get('clientStreaming') is not None and rpc.get(
-                        'clientStreaming') == True else ''
-                    out_open_type = 'Iterator[' if rpc.get(
-                        'serverStreaming') is not None and rpc.get('serverStreaming') == True else ''
-                    out_close_type = ']' if rpc.get('serverStreaming') is not None and rpc.get(
-                        'serverStreaming') == True else ''
-                    svc_name = svc.split('/')[-1].split('.')[0]
-                    rpcs.append(
-                        f'\n\tdef {rpc_name}_WithCall(self, request: {in_open_type}{rpc_in_type}{in_close_type}, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[{out_open_type}{rpc_out_type}{out_close_type}, Any]:\n\t\t"""sylk - {description} Returns: RPC output and a call object"""\n\n\t\treturn self.{svc_name}Stub.{rpc_name}.with_call(request,metadata=metadata)')
-                    rpcs.append(
-                        f'\n\tdef {rpc_name}(self, request: {in_open_type}{rpc_in_type}{in_close_type}, metadata: Tuple[Tuple[str,str]] = _METADATA) -> {out_open_type}{rpc_out_type}{out_close_type}:\n\t\t"""sylk - {description}"""\n\n\t\treturn self.{svc_name}Stub.{rpc_name}(request,metadata=metadata)')
-
-            rpcs = '\n\n\t'.join(rpcs)
-        return ''.join(rpcs)
+                        rpc_out_pkg = self._sylk_json._proto_tree.get_parent(rpc["outputType"])
+                        rpc_out_type_pkg = self._sylk_json._proto_tree._get_file_paths([rpc["outputType"]])
+                        rpc_out_type_pkg = rpc_out_type_pkg[0].split('/')[-1].split('.')[0]
+                        ver = self._sylk_json._proto_tree._parse_version_component(rpc["outputType"])
+                        if ver is not None:
+                            rpc_out_type_over = rpc_out_pkg.full_path.split(".")[-1]
+                        else:
+                            rpc_out_type_over = ""
+                        rpc_out_type = (
+                            f"{rpc_out_type_pkg}_{rpc_out_type_over}.{rpc_out_type}"
+                        )
+                    in_open_type = (
+                        "Iterator["
+                        if rpc.get("clientStreaming") is not None
+                        and rpc.get("clientStreaming") == True
+                        else ""
+                    )
+                    in_close_type = (
+                        "]"
+                        if rpc.get("clientStreaming") is not None
+                        and rpc.get("clientStreaming") == True
+                        else ""
+                    )
+                    out_open_type = (
+                        "Iterator["
+                        if rpc.get("serverStreaming") is not None
+                        and rpc.get("serverStreaming") == True
+                        else ""
+                    )
+                    out_close_type = (
+                        "]"
+                        if rpc.get("serverStreaming") is not None
+                        and rpc.get("serverStreaming") == True
+                        else ""
+                    )
+                    if svc_ver is not None:
+                        rpcs.append(
+                            f'\n\tdef {rpc_name}_WithCall(self, request: {in_open_type}{rpc_in_type}{in_close_type}, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[{out_open_type}{rpc_out_type}{out_close_type}, Any]:\n\t\t"""sylk - {description} Returns: RPC output and a call object"""\n\n\t\treturn self.{svc_name}_{formatted_version}_stub.{rpc_name}.with_call(request,metadata=metadata)'
+                        )
+                        rpcs.append(
+                            f'\n\tdef {rpc_name}(self, request: {in_open_type}{rpc_in_type}{in_close_type}, metadata: Tuple[Tuple[str,str]] = _METADATA) -> {out_open_type}{rpc_out_type}{out_close_type}:\n\t\t"""sylk - {description}"""\n\n\t\treturn self.{svc_name}_{formatted_version}_stub.{rpc_name}(request,metadata=metadata)'
+                        )
+                    else:
+                        rpcs.append(
+                            f'\n\tdef {rpc_name}_WithCall(self, request: {in_open_type}{rpc_in_type}{in_close_type}, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[{out_open_type}{rpc_out_type}{out_close_type}, Any]:\n\t\t"""sylk - {description} Returns: RPC output and a call object"""\n\n\t\treturn self.{svc_name}_{formatted_version}_stub.{rpc_name}.with_call(request,metadata=metadata)'
+                        )
+                        rpcs.append(
+                            f'\n\tdef {rpc_name}(self, request: {in_open_type}{rpc_in_type}{in_close_type}, metadata: Tuple[Tuple[str,str]] = _METADATA) -> {out_open_type}{rpc_out_type}{out_close_type}:\n\t\t"""sylk - {description}"""\n\n\t\treturn self.{svc_name}_{formatted_version}_stub.{rpc_name}(request,metadata=metadata)'
+                        )
+                rpcs = "\n\n\t".join(rpcs)
+                if svc_ver is not None:
+                    svcs.append(
+                        f"\nclass {svc_name}_{formatted_version}:\n\t\"\"\"\n\tservice class generated by sylk.build\n\n\tFile: {svc.get('fullName')}\n\tService: {svc_name}\n\tVersion: {formatted_version}\n\t\"\"\"\n\n\tdef __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {_OPEN_BRCK}{_CLOSING_BRCK}):\n\t\tlogging.root.setLevel(client_opt.get('log_level','ERROR'))\n\t\tif channel is None:\n\t\t\tself.channel = grpc.insecure_channel('{_OPEN_BRCK}0{_CLOSING_BRCK}:{_OPEN_BRCK}1{_CLOSING_BRCK}'.format(client_opt.get('host','localhost'), client_opt.get('port',{defualt_port})),_CHANNEL_OPTIONS)\n\t\t\ttry:\n\t\t\t\tgrpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))\n\t\t\texcept grpc.FutureTimeoutError:\n\t\t\t\tlogging.error('Timedout: server seems to be offline. verify your connection configs.')\n\t\t\t\tsys.exit(1)\n\t\telse:\n\t\t\tself.channel = channel\n\t\tself.{svc_name}_{formatted_version}_stub = {svc_pkg_name}_{formatted_version}_grpc.{svc_name}Stub(self.channel)\n{rpcs}"
+                    )
+                else:
+                    svcs.append(
+                        f"\nclass {svc_name}:\n\t\"\"\"\n\tservice class generated by sylk.build\n\n\tFile: {svc}\n\tService: {svc_name}\n\tVersion: {formatted_version}\n\t\"\"\"\n\n\tdef __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {_OPEN_BRCK}{_CLOSING_BRCK}):\n\t\tlogging.root.setLevel(client_opt.get('log_level','ERROR'))\n\t\tif channel is None:\n\t\t\tself.channel = grpc.insecure_channel('{_OPEN_BRCK}0{_CLOSING_BRCK}:{_OPEN_BRCK}1{_CLOSING_BRCK}'.format(client_opt.get('host','localhost'), client_opt.get('port',{defualt_port})),_CHANNEL_OPTIONS)\n\t\t\ttry:\n\t\t\t\tgrpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))\n\t\t\texcept grpc.FutureTimeoutError:\n\t\t\t\tlogging.error('Timedout: server seems to be offline. verify your connection configs.')\n\t\t\t\tsys.exit(1)\n\t\telse:\n\t\t\tself.channel = channel\n\t\tself.{svc_name}_{formatted_version}_stub = {svc_pkg_name}_{formatted_version}_grpc.{svc_name}Stub(self.channel)\n{rpcs}"
+                    )
+            svcs = "\n\n".join(svcs)
+        return "".join(svcs)
 
 
-class SylkServicePy():
+class SylkServicePy:
     """A helper class to write 'Python' language services for sylk.build project services"""
 
-    def __init__(self, project_package, name, imports=[], service=None, package=None, messages=[], enums=[], context: SylkContext = None,sylk_json: SylkJson= None):
+    def __init__(
+        self,
+        project_package,
+        name,
+        imports=[],
+        service=None,
+        package=None,
+        messages=[],
+        enums=[],
+        context: SylkContext = None,
+        sylk_json: SylkJson = None,
+    ):
         self._name = name
         self._imports = imports
         self._service = service
         self._project_package = project_package
         self._context = context
         self._sylk_json = sylk_json
-        self._service_name = self._name.split('/')[-1].split('.')[0]
-        self._service_path = '.'.join(self._name.split('/')[:-1])
+        self._service_name = self._name.split("/")[-1].split(".")[0]
+        self._service_path = ".".join(self._name.split("/")[:-1])
 
     def write_imports(self):
-        if self._imports is not None:
-            list_d = list(map(lambda i: i, _WELL_KNOWN_PY_IMPORTS))
-            list_d.append(f'from {self._service_path} import {self._service_name}_pb2_grpc')
-            for d in self._imports:
-                domain = d.split('.')[0]
-                name = d.split('.')[1]
-                ver = d.split('.')[2]
-                path = '.'.join(self._sylk_json.get_path(domain,name,ver).split('/')[:-1])
-                d_name = '{0}_pb2'.format(name)
-                list_d.append(f'from {path} import {d_name}')
+        list_d = list(map(lambda i: i, _WELL_KNOWN_PY_IMPORTS))
 
-            list_d = '\n'.join(list_d)
-            return f'{list_d}'
+        parent = self._sylk_json._proto_tree.get_parent(self._service.get('fullName'))
+        refs = self._sylk_json._proto_tree.get_parents_refs([self._service.get('fullName')])
+        
+        deps = self._sylk_json._proto_tree.get_references(self._service.get('fullName'))
+       
+        pkg_ver = self._sylk_json._proto_tree._parse_version_component(parent.full_path)
+        if pkg_ver is not None:
+            pkg_name = parent.full_path.split('.')[-2]
         else:
-            return ''
+            pkg_name = parent.name
+        module_name = pkg_name if self._service.get('tag') is None and self._service.get('tag') != '' else self._service.get('tag')
+        base_protos = self._sylk_json._root_protos.replace('/','.')
+        for d in deps:
+            if d.split('.')[0] == self._sylk_json._proto_tree.root.name:
+                root = self._sylk_json._proto_tree.root
+                dep_parent = self._sylk_json._proto_tree.get_parent(d)
+                base_path = 'services.' if self._sylk_json._root_protos is None or self._sylk_json._root_protos == '' else f'services.{base_protos}.'
+                msg_dep =self._sylk_json._proto_tree._find_node(d,root) 
+                if parse_version_component(dep_parent.full_path) is not None:
+                    temp_name = dep_parent.full_path.split('.')[-2]
+                else:
+                    temp_name = dep_parent.name
+                dep_mod_name = temp_name if msg_dep.properties.get('tag') is None or msg_dep.properties.get('tag') == '' else msg_dep.properties.get('tag')
+                imp_path = f"from {base_path}{dep_parent.full_path} import {dep_mod_name}_pb2_grpc, {dep_mod_name}_pb2"
+            else:
+                root = self._sylk_json._proto_tree.proto_modules[d.split('.')[0]].root
+                dep_parent = self._sylk_json._proto_tree.proto_modules[d.split('.')[0]].get_parent(d)
+                msg_dep =self._sylk_json._proto_tree._find_node(d,root) 
+                if parse_version_component(dep_parent.full_path) is not None:
+                    temp_name = dep_parent.full_path.split('.')[-2]
+                else:
+                    temp_name = dep_parent.name
+                dep_mod_name = temp_name if msg_dep.properties.get('tag') is None or msg_dep.properties.get('tag') == '' else msg_dep.properties.get('tag')
+                imp_path = f"from {dep_parent.full_path} import {dep_mod_name}_pb2"
+            if imp_path not in list_d:
+                list_d.append(
+                    imp_path
+                )
+        base_path = 'services.' if self._sylk_json._root_protos is None or self._sylk_json._root_protos == '' else f'services.{base_protos}.'
+        imp_path = f"from {base_path}{parent.full_path} import {module_name}_pb2_grpc, {module_name}_pb2"
+        if imp_path not in list_d:
+            list_d.append(
+                    f"from {base_path}{parent.full_path} import {module_name}_pb2_grpc, {module_name}_pb2"
+                )
+        list_d = "\n".join(list_d)
+        return f"{list_d}"
+        
 
     def write_class(self):
         rpcs = []
+        svc_node = self._sylk_json._proto_tree.get_parent(self._service.get('fullName'))
+        ver = self._sylk_json._proto_tree._parse_version_component(self._service.get('fullName'))
+        if ver is not None:
+            pkg_name = svc_node.full_path.split('.')[-2]
+        else:
+            pkg_name = svc_node.full_path.split('.')[-1]
+        mod_name = self._service.get('tag') if self._service.get('tag') is not None else pkg_name
+
         if self._context is not None:
             functions = self._context.get_functions(self._name)
             if functions is not None:
                 for func in functions:
-                    func_code = func['code']
-                    rpcs.append(
-                        f'\t# @skip @@sylk - DO NOT REMOVE\n{func_code}')
-
-        for rpc in self._service.get('methods'):
-            rpc_name = rpc.get('name')
-            rpc_in_pkg = rpc.get('inputType').split('.')[1]
-            rpc_in_name = rpc.get('inputType').split('.')[-1]
-            rpc_out_pkg = rpc.get('outputType').split('.')[1]
-            rpc_out_name = rpc.get('outputType').split('.')[-1]
-            rpc_type_in = rpc.get('clientStreaming')
-            rpc_type_out = rpc.get('serverStreaming')
-
-            open_in_type = 'Iterator[' if rpc_type_in is not None and rpc_type_in == True else ''
-            closing_in_type = ']' if rpc_type_in is not None and rpc_type_in == True else ''
-
-            open_out_type = 'Iterator[' if rpc_type_out is not None and rpc_type_out == True else ''
-            close_out_type = ']' if rpc_type_out is not None and rpc_type_out == True else ''
-            code = ''
+                    func_code = func["code"]
+                    rpcs.append(f"\t# @skip @@sylk - DO NOT REMOVE\n{func_code}")
+
+        for rpc in self._service.get("methods"):
+            rpc_name = rpc.get("name")
+            if "google.protobuf." in rpc.get("inputType"):
+                in_mod_name = rpc.get("inputType").split(".")[-1].lower()
+            else:
+                files = self._sylk_json._proto_tree._get_file_paths([rpc.get("inputType")])
+                in_mod_name = files[0].split('/')[-1].split('.')[0]
+            rpc_in_name = rpc.get("inputType").split(".")[-1]
+            if "google.protobuf." in rpc.get("outputType"):
+                out_mod_name = rpc.get("outputType").split(".")[-1].lower()
+            else:
+                files = self._sylk_json._proto_tree._get_file_paths([rpc.get("outputType")])
+                out_mod_name = files[0].split('/')[-1].split('.')[0]
+            rpc_out_name = rpc.get("outputType").split(".")[-1]
+            rpc_type_in = rpc.get("clientStreaming")
+            rpc_type_out = rpc.get("serverStreaming")
+
+            open_in_type = (
+                "Iterator[" if rpc_type_in is not None and rpc_type_in == True else ""
+            )
+            closing_in_type = (
+                "]" if rpc_type_in is not None and rpc_type_in == True else ""
+            )
+
+            open_out_type = (
+                "Iterator[" if rpc_type_out is not None and rpc_type_out == True else ""
+            )
+            close_out_type = (
+                "]" if rpc_type_out is not None and rpc_type_out == True else ""
+            )
+            code = ""
             if self._context is not None:
                 code = self._context.get_rpc(self._name, rpc_name)
                 if code is not None:
-                    code =code.get('code')
+                    code = code.get("code")
                 else:
                     if self._sylk_json is not None:
                         fields = []
-                        msg = self._sylk_json.get_message(rpc.get('outputType'))
-                        for f in msg.get('fields'):
-                            fields.append('{0}=None'.format(f.get('name')))
-                    fields = ','.join(fields)
+                        msg = self._sylk_json.get_message(rpc.get("outputType"))
+                        for f in msg.get("fields"):
+                            fields.append("{0}=None".format(f.get("name")))
+                    fields = ",".join(fields)
                     if rpc_type_out:
-                        out_prototype = f'\t\t# responses = [{rpc_out_pkg}_pb2.{rpc_out_name}({fields})]\n\t\t# for res in responses:\n\t\t#    yield res\n'
+                        out_prototype = f"\t\t# responses = [{out_mod_name}_pb2.{rpc_out_name}({fields})]\n\t\t# for res in responses:\n\t\t#    yield res\n"
                     else:
-                        out_prototype = f'\t\t# response = {rpc_out_pkg}_pb2.{rpc_out_name}({fields})\n\t\t# return response\n'
-                    code = f'{out_prototype}\n\t\tsuper().{rpc_name}(request, context)\n\n'
+                        out_prototype = f"\t\t# response = {out_mod_name}_pb2.{rpc_out_name}({fields})\n\t\t# return response\n"
+                    code = (
+                        f"{out_prototype}\n\t\tsuper().{rpc_name}(request, context)\n\n"
+                    )
             else:
                 if self._sylk_json is not None:
                     fields = []
-                    msg = self._sylk_json.get_message(rpc.get('outputType'))
-                    for f in msg.get('fields'):
-                        fields.append('{0}=None'.format(f.get('name')))
-                fields = ','.join(fields)
+                    msg = self._sylk_json.get_message(rpc.get("outputType"))
+                    if msg is not None:
+                        for f in msg.get("fields"):
+                            fields.append("{0}=None".format(f.get("name")))
+                fields = ",".join(fields)
                 if rpc_type_out:
-                    out_prototype = f'\t\t# responses = [{rpc_out_pkg}_pb2.{rpc_out_name}({fields})]\n\t\t# for res in responses:\n\t\t#    yield res\n'
+                    out_prototype = f"\t\t# responses = [{out_mod_name}_pb2.{rpc_out_name}({fields})]\n\t\t# for res in responses:\n\t\t#    yield res\n"
                 else:
-                    out_prototype = f'\t\t# response = {rpc_out_pkg}_pb2.{rpc_out_name}({fields})\n\t\t# return response\n'
-                code = f'{out_prototype}\n\t\tsuper().{rpc_name}(request, context)\n\n'
+                    out_prototype = f"\t\t# response = {out_mod_name}_pb2.{rpc_out_name}({fields})\n\t\t# return response\n"
+                code = f"{out_prototype}\n\t\tsuper().{rpc_name}(request, context)\n\n"
             rpcs.append(
-                f'\t# @rpc @@sylk - DO NOT REMOVE\n\tdef {rpc_name}(self, request: {open_in_type}{rpc_in_pkg}_pb2.{rpc_in_name}{closing_in_type}, context) -> {open_out_type}{rpc_out_pkg}_pb2.{rpc_out_name}{close_out_type}:\n{code}')
-        rpcs = ''.join(rpcs)
-        return f'class {self._service_name}({self._service_name}_pb2_grpc.{self._service_name}Servicer):\n\n{rpcs}'
+                f"\t# @rpc @@sylk - DO NOT REMOVE\n\tdef {rpc_name}(self, request: {open_in_type}{in_mod_name}_pb2.{rpc_in_name}{closing_in_type}, context: grpc.ServicerContext) -> {open_out_type}{out_mod_name}_pb2.{rpc_out_name}{close_out_type}:\n{code}"
+            )
+        rpcs = "".join(rpcs)
+        return f"class {self._service_name}({mod_name}_pb2_grpc.{self._service_name}Servicer):\n\n{rpcs}"
 
     def to_str(self):
         return self.__str__()
 
     def __str__(self):
         return f'"""sylk.build service implemantation for -> {self._name}"""\nimport grpc\n{self.write_imports()}\n\n{self.write_class()}'
 
-class SylkServiceTs():
+
+class SylkServiceTs:
     """A helper class to write 'Typescript' language services for sylk.build project services"""
-    
-    def __init__(self, project_package, name, imports=[], service=None, package=None, messages=[], enums=[], context: SylkContext = None,sylk_json: SylkJson= None):
+
+    def __init__(
+        self,
+        project_package,
+        name,
+        imports=[],
+        service=None,
+        package=None,
+        messages=[],
+        enums=[],
+        context: SylkContext = None,
+        sylk_json: SylkJson = None,
+    ):
         self._name = name
         self._imports = imports
         self._service = service
         self._project_package = project_package
         self._context = context
         self._sylk_json = sylk_json
-        self._import_name = self._name.split('/')[-1].split('.')[0]
-        self._import_path = '/'.join(self._name.split('/')[:-1]) + '/' + self._import_name
+        self._import_name = self._name.split("/")[-1].split(".")[0]
+        self._import_path = (
+            "/".join(self._name.split("/")[:-1]) + "/" + self._import_name
+        )
 
     def write_imports(self):
-        if self._imports is not None:
-            list_d = list(map(lambda i: i, _WELL_KNOWN_TS_IMPORTS))
-            list_d.append(f'import {_OPEN_BRCK} {self._import_name}Server, {self._import_name}Service {_CLOSING_BRCK} from \'./{self._import_path}\';')
-            for d in self._imports:
-                name = d.split('.')[1]
-                d_name = '{0}'.format(name)
-                pkg = '/'.join(self._sylk_json.get_path(d.split('.')[0],d.split('.')[1],d.split('.')[2]).split('/')[:-1])
-                list_d.append(f'import * as {d_name} from \'./{pkg}/{d_name}\';')
-
-            list_d = '\n'.join(list_d)
-            return f'{list_d}'
+        list_d = list(map(lambda i: i, _WELL_KNOWN_TS_IMPORTS))
+        parent = self._sylk_json._proto_tree.get_parent(self._service.get('fullName'))
+        refs = self._sylk_json._proto_tree.get_parents_refs([self._service.get('fullName')])
+        
+        deps = self._sylk_json._proto_tree.get_references(self._service.get('fullName'))
+       
+        pkg_ver = self._sylk_json._proto_tree._parse_version_component(parent.full_path)
+        if pkg_ver is not None:
+            pkg_name = parent.full_path.split('.')[-2]
         else:
-            return ''
+            pkg_name = parent.name
+        module_name = pkg_name if self._service.get('tag') is None and self._service.get('tag') != '' else self._service.get('tag')
+        base_protos = self._sylk_json._root_protos.replace('/','.')
+        for d in list(set(deps)):
+
+            if d.split('.')[0] == self._sylk_json._proto_tree.root.name:
+                root = self._sylk_json._proto_tree.root
+                dep_parent = self._sylk_json._proto_tree.get_parent(d)
+                
+                base_path = '../../' if self._sylk_json._root_protos is None or self._sylk_json._root_protos == '' else f'../../{base_protos}/'
+                msg_dep =self._sylk_json._proto_tree._find_node(d,root) 
+                if parse_version_component(dep_parent.full_path) is not None:
+                    temp_name = dep_parent.full_path.split('.')[-2]
+                else:
+                    temp_name = dep_parent.name
+                dep_mod_name = temp_name if msg_dep.properties.get('tag') is None or msg_dep.properties.get('tag') == '' else msg_dep.properties.get('tag')
+                imp_path = f"import * as {dep_mod_name} from '{base_path}{dep_parent.full_path.replace('.','/')}/{dep_mod_name}';"
+                # f"from {base_path}{dep_parent.full_path} import {dep_mod_name}_pb2_grpc, {dep_mod_name}_pb2"
+            else:
+                root = self._sylk_json._proto_tree.proto_modules[d.split('.')[0]].root
+                dep_parent = self._sylk_json._proto_tree.proto_modules[d.split('.')[0]].get_parent(d)
+                msg_dep =self._sylk_json._proto_tree._find_node(d,root) 
+                base_path = '../../' if self._sylk_json._root_protos is None or self._sylk_json._root_protos == '' else f'../../{base_protos}/'
+                if parse_version_component(dep_parent.full_path) is not None:
+                    temp_name = dep_parent.full_path.split('.')[-2]
+                else:
+                    temp_name = dep_parent.name
+                dep_mod_name = temp_name if msg_dep.properties.get('tag') is None or msg_dep.properties.get('tag') == '' else msg_dep.properties.get('tag')
+                imp_path = f"import * as {dep_mod_name} from '{base_path}{dep_parent.full_path.replace('.','/')}/{dep_mod_name}';"
+            if imp_path not in list_d:
+                list_d.append(
+                    imp_path
+                )
+        base_path = '../../' if self._sylk_json._root_protos is None or self._sylk_json._root_protos == '' else f'../../{base_protos}/'
+        imp_path = f"import {_OPEN_BRCK} {self._service.get('name')}Service {_CLOSING_BRCK} from '{base_path}{parent.full_path.replace('.','/')}/{module_name}';"
+        if imp_path not in list_d:
+            list_d.append(
+                    imp_path
+                )
+        list_d = "\n".join(list_d)
+        return f"{list_d}"
+
+        # if self._imports is not None:
+        #     pkg = self._sylk_json.get_package(
+        #         self._service.get("name"),
+        #         version=self._service.get("fullName").split(".")[-1],
+        #         json=False,
+        #     )
+        #     list_d.append(
+        #         f"import {_OPEN_BRCK} {self._import_name}Server, {self._import_name}Service {_CLOSING_BRCK} from '../../{self._import_path}';"
+        #     )
+        #     for d in self._imports:
+        #         if "google.protobuf." in d:
+        #             pass
+        #             # wellknown_message = d.split('.')[-1]
+        #             # list_d.append(f'from google.protobuf import {wellknown_message.lower()}_pb2')
+        #         else:
+        #             name = d.split(".")[1]
+        #             d_name = "{0}".format(name)
+        #             d_ver = d.split(".")[-1]
+        #             pkg = "/".join(
+        #                 self._sylk_json.get_path(
+        #                     d.split(".")[0], d.split(".")[1], d.split(".")[2]
+        #                 ).split("/")[:-1]
+        #             )
+        #             list_d.append(
+        #                 f"import * as {d_name}{d_ver} from '../../{pkg}/{d_name}';"
+        #             )
+
+        #     list_d = "\n".join(list_d)
+        #     return f"{list_d}"
+        # else:
+        #     pkg = self._sylk_json.get_package(
+        #         self._service.get("name"),
+        #         version=self._service.get("fullName").split(".")[-1],
+        #         json=False,
+        #     )
+        #     msgs = []
+        #     for m in pkg.messages:
+        #         msgs.append(m.name)
+        #     msgs = ", ".join(msgs)
+        #     list_d.append(
+        #         f"import {_OPEN_BRCK} {self._import_name}Server, {self._import_name}Service, {msgs} {_CLOSING_BRCK} from '../../{self._import_path}';"
+        #     )
+        #     list_d = "\n".join(list_d)
+        #     return f"{list_d}"
 
     def write_class(self):
         rpcs = []
+        svc_node = self._sylk_json._proto_tree.get_parent(self._service.get('fullName'))
+        ver = self._sylk_json._proto_tree._parse_version_component(self._service.get('fullName'))
+        if ver is not None:
+            pkg_name = svc_node.full_path.split('.')[-2]
+        else:
+            pkg_name = svc_node.full_path.split('.')[-1]
+        mod_name = self._service.get('tag') if self._service.get('tag') is not None else pkg_name
         if self._context is not None:
             functions = self._context.get_functions(self._name)
             if functions is not None:
                 for func in functions:
-                    func_code = func['code']
-                    rpcs.append(
-                        f'\t// @skip @@sylk - DO NOT REMOVE\n{func_code}')
-
-        for rpc in self._service.get('methods'):
-            rpc_name = rpc.get('name')
-            rpc_in_pkg = rpc.get('inputType').split('.')[1]
-            rpc_in_name = rpc.get('inputType').split('.')[-1]
-            rpc_out_pkg = rpc.get('outputType').split('.')[1]
-            rpc_out_name = rpc.get('outputType').split('.')[-1]
-            rpc_type_in = rpc.get('clientStreaming') if rpc.get('clientStreaming') is not None else False
-            rpc_type_out = rpc.get('serverStreaming') if rpc.get('serverStreaming') is not None else False
-            
-            handleType = 'handleUnaryCall'
-            args = f'call: ServerUnaryCall<{rpc_in_pkg}.{rpc_in_name}, {rpc_out_pkg}.{rpc_out_name}>,\n\t\tcallback: sendUnaryData<{rpc_out_pkg}.{rpc_out_name}>'
+                    func_code = func["code"]
+                    rpcs.append(f"\t// @skip @@sylk - DO NOT REMOVE\n{func_code}")
+
+        for rpc in self._service.get("methods"):
+            rpc_name = rpc.get("name")
+            # rpc_in_pkg = rpc.get("inputType").split(".")[1]
+            # rpc_in_pkg_ver = rpc.get("inputType").split(".")[2]
+            # Case the service holds the messages we remove the prefix of package
+            # since the service imports pb generated classes and grpc classes from single a file
+            if "google.protobuf." in rpc.get("inputType"):
+                in_mod_name = rpc.get("inputType").split(".")[-1].lower()
+            else:
+                files = self._sylk_json._proto_tree._get_file_paths([rpc.get("inputType")])
+                in_mod_name = files[0].split('/')[-1].split('.')[0]
             
+            rpc_in_name = rpc.get("inputType").split(".")[-1]
+            # Same as we done for inputs prefixes we do for output prefixes
+            if "google.protobuf." in rpc.get("outputType"):
+                out_mod_name = rpc.get("outputType").split(".")[-1].lower()
+            else:
+                files = self._sylk_json._proto_tree._get_file_paths([rpc.get("outputType")])
+                out_mod_name = files[0].split('/')[-1].split('.')[0]
+            rpc_out_name = rpc.get("outputType").split(".")[-1]
+            rpc_type_in = (
+                rpc.get("clientStreaming")
+                if rpc.get("clientStreaming") is not None
+                else False
+            )
+            rpc_type_out = (
+                rpc.get("serverStreaming")
+                if rpc.get("serverStreaming") is not None
+                else False
+            )
+
+            handleType = "handleUnaryCall"
+            args = f"call: ServerUnaryCall<{in_mod_name}.{rpc_in_name}, {out_mod_name}.{rpc_out_name}>,\n\t\tcallback: sendUnaryData<{out_mod_name}.{rpc_out_name}>"
+
             if rpc_type_in and rpc_type_out:
-                handleType = 'handleBidiStreamingCall'
-                args = f'call: ServerDuplexStream<{rpc_in_pkg}.{rpc_in_name}, {rpc_out_pkg}.{rpc_out_name}>'
+                handleType = "handleBidiStreamingCall"
+                args = f"call: ServerDuplexStream<{in_mod_name}.{rpc_in_name}, {out_mod_name}.{rpc_out_name}>"
             elif rpc_type_in and rpc_type_out == False:
-                handleType = 'handleClientStreamingCall'
-                args = f'call: ServerReadableStream<{rpc_in_pkg}.{rpc_in_name}, {rpc_out_pkg}.{rpc_out_name}>,\n\t\tcallback: sendUnaryData<{rpc_out_pkg}.{rpc_out_name}>'
+                handleType = "handleClientStreamingCall"
+                args = f"call: ServerReadableStream<{in_mod_name}.{rpc_in_name}, {out_mod_name}.{rpc_out_name}>,\n\t\tcallback: sendUnaryData<{out_mod_name}.{rpc_out_name}>"
             elif rpc_type_in == False and rpc_type_out:
-                handleType = 'handleServerStreamingCall'
-                args = f'call: ServerWritableStream<{rpc_in_pkg}.{rpc_in_name}, {rpc_out_pkg}.{rpc_out_name}>'
-            code = ''
+                handleType = "handleServerStreamingCall"
+                args = f"call: ServerWritableStream<{in_mod_name}.{rpc_in_name}, {out_mod_name}.{rpc_out_name}>"
+            code = ""
             if self._context is not None:
                 code = self._context.get_rpc(self._name, rpc_name)
                 if code is not None:
-                    code =code.get('code')
+                    code = code.get("code")
             temp_name = rpc_name[0].lower() + rpc_name[1:]
             rpcs.append(
-                f'\t// @rpc @@sylk - DO NOT REMOVE\n\tpublic {temp_name}: {handleType}<{rpc_in_pkg}.{rpc_in_name}, {rpc_out_pkg}.{rpc_out_name}> = (\n\t\t{args}\n\t) => {_OPEN_BRCK}\n{code}\n\t{_CLOSING_BRCK}\n')
-        rpcs = ''.join(rpcs)
-        return f'\nclass {self._import_name} implements {self._import_name}Server, ApiType<UntypedHandleCall> {_OPEN_BRCK}\n\t[method: string]: any;\n\n{rpcs}\n\n{_CLOSING_BRCK}\n\nexport {_OPEN_BRCK}\n\t{self._import_name},\n\t{self._import_name}Service\n{_CLOSING_BRCK};'
+                f"\t// @rpc @@sylk - DO NOT REMOVE\n\tpublic {temp_name}: {handleType}<{in_mod_name}.{rpc_in_name}, {out_mod_name}.{rpc_out_name}> = (\n\t\t{args}\n\t) => {_OPEN_BRCK}\n{code}\n\t{_CLOSING_BRCK}\n"
+            )
+        rpcs = "".join(rpcs)
+        return f"\nclass {self._import_name} implements {mod_name}.{self._import_name}Server, ApiType<UntypedHandleCall> {_OPEN_BRCK}\n\t[method: string]: any;\n\n{rpcs}\n\n{_CLOSING_BRCK}\n\nexport {_OPEN_BRCK}\n\t{self._import_name},\n\t{self._import_name}Service\n{_CLOSING_BRCK};"
 
     def to_str(self):
         return self.__str__()
 
     def __str__(self):
-        return f'{self.write_imports()}\n{self.write_class()}'
+        return f"{self.write_imports()}\n{self.write_class()}"
 
 
-class SylkClientTs():
+class SylkClientTs:
     """A helper class to write 'Typescript' language clients for sylk.build project services"""
 
-    def __init__(self, project_package, services=None, packages=None, context: SylkContext = None, config = None,pre_data=None):
+    def __init__(
+        self,
+        project_package,
+        services=None,
+        packages=None,
+        context: SylkContext = None,
+        config=None,
+        pre_data=None,
+        sylk_json: SylkJson = None
+    ):
         self._services = services
         self._project_package = project_package
         self._context = context
         self._packages = packages
         self._config = config
         self._pre_data = pre_data
+        self._sylk_json = sylk_json
 
     def __str__(self):
-        return f'{self.write_imports()}\n{self.write_client_wrapper()}\n\n\t{self.write_services_classes()}\n{_CLOSING_BRCK}\n{self.write_client_exports()}'
+        return f"{self.write_imports()}\n{self.write_client_wrapper()}\n\n{self.write_services_classes()}"
 
     def write_client_exports(self):
         pkgs_list = []
         clients_list = []
         for key in self._packages:
-            pkg = self._packages[key].get('name')
+            pkg = self._packages[key].get("name")
             pkgs_list.append(pkg)
-        pkgs_list = ',\n\t'.join(pkgs_list)
+        pkgs_list = ",\n\t".join(pkgs_list)
         for key in self._services:
-            svc_name = key.split('/')[-1].split('.')[0]
-            clients_list.append(f'{svc_name}Client')
-        
+            svc_name = key.split("/")[-1].split(".")[0]
+            clients_list.append(f"{svc_name}Client")
+
         # Pre data parsing
         if self._pre_data is not None:
-            if self._pre_data.get('exports') is not None:
-                for exp in self._pre_data.get('exports'):
+            if self._pre_data.get("exports") is not None:
+                for exp in self._pre_data.get("exports"):
                     if exp not in clients_list:
                         clients_list.append(exp)
 
-        clients_list = ',\n\t'.join(clients_list)
-        return f'export {_OPEN_BRCK}\n\t{pkgs_list},\n\t{clients_list}\n{_CLOSING_BRCK}' 
+        clients_list = ",\n\t".join(clients_list)
+        return f"export {_OPEN_BRCK}\n\t{pkgs_list},\n\t{clients_list}\n{_CLOSING_BRCK}"
 
     def write_client_wrapper(self):
-        client_options = self._pre_data.get('client_options')
-        client_options = '\n\t'.join(list(map(lambda opt: '"{}": {},'.format(opt[0],opt[1]),client_options)))
-        
+        client_options = self._pre_data.get("client_options")
+        client_options = "\n\t".join(
+            list(map(lambda opt: '"{}": {},'.format(opt[0], opt[1]), client_options))
+        )
+
         # Parsing pre data
-        before_init = ''
+        before_init = ""
         interceptors = []
 
         if self._pre_data:
-            if self._pre_data.get('before_init') is not None:
-                before_init = self._pre_data.get('before_init')
-            if self._pre_data.get('interceptors') is not None:
-                interceptors = self._pre_data.get('interceptors')
+            if self._pre_data.get("before_init") is not None:
+                before_init = self._pre_data.get("before_init")
+            if self._pre_data.get("interceptors") is not None:
+                interceptors = self._pre_data.get("interceptors")
 
-        interceptors = ', '.join(interceptors)
-        return f'\n{before_init}\nconst interceptorsProviders: Interceptor[] = [{interceptors}]\nconst _DEFAULT_OPTION = {_OPEN_BRCK}\n\t{client_options}\n{_CLOSING_BRCK}\n\n/**\n * Generated thanks to [sylk.build](https://www.sylk.build)\n */\nexport class {self._project_package} {_OPEN_BRCK}\n\n\t{self.init_wrapper()}'
+        interceptors = ", ".join(interceptors)
+        return f'\n{before_init}\nconst interceptorsProviders: Interceptor[] = [{interceptors}]\nconst _DEFAULT_OPTION = {_OPEN_BRCK}\n\t{client_options}\n{_CLOSING_BRCK}\n\n/**\n * Generated thanks to [sylk.build](https://www.sylk.build)\n */\nexport interface SylkClientOpts {_OPEN_BRCK}\n\thost: string;\n\tport: number;\n\tmetadata: Metadata;\n\tchannelCreds: ChannelCredentials\n{_CLOSING_BRCK}\nconst DEFAULT_CLIENT_OPTS: SylkClientOpts = {_OPEN_BRCK}\n\thost: "localhost",\n\tport: 44880,\n\tmetadata: new Metadata(),\n\tchannelCreds: credentials.createInsecure()\n{_CLOSING_BRCK}\n'
 
-    def init_stubs(self):
+    def init_stubs(self, svc):
         stubs = []
         temp_stubs = {}
         if self._pre_data is not None:
-            if self._pre_data.get('stubs') is not None:
-                temp_stubs = self._pre_data.get('stubs')
-
-        for svc in self._services:
-            svc_name = svc.split('/')[-1].split('.')[0]
-            if svc in temp_stubs:
-                stub = temp_stubs[svc]
-                stub_target = stub.get('target') if stub.get('target') is not None else '${_OPEN_BRCK}this.host{_CLOSING_BRCK}:${_OPEN_BRCK}this.port{_CLOSING_BRCK}'
-                stub_creds = stub.get('creds') if stub.get('creds') is not None else 'credentials.createInsecure()'
-                stub_opts =  stub.get('opts') if stub.get('opts') is not None else '_DEFAULT_OPTION'
-                stubs.append(f'this.{svc_name}_client = new {svc_name}Client(`{stub_target}`, {stub_creds}, {stub_opts});')
-            else:
-                stubs.append(f'this.{svc_name}_client = new {svc_name}Client(`${_OPEN_BRCK}this.host{_CLOSING_BRCK}:${_OPEN_BRCK}this.port{_CLOSING_BRCK}`, credentials.createInsecure(),_DEFAULT_OPTION);')
-
-        return '\n\t\t'.join(stubs)
+            if self._pre_data.get("stubs") is not None:
+                temp_stubs = self._pre_data.get("stubs")
 
-    def args_stubs(self):
-        stubs = []
-        for svc in self._services:
-            svc_name = svc.split('/')[-1].split('.')[0]
-            stubs.append(f'private readonly {svc_name}_client: {svc_name}Client;')
-
-        return '\n\t'.join(stubs)
+        svc_name = svc.get("name")
+        svc_ver = parse_version_component(svc.get('fullName'))
+        if svc_ver is not None:
+            svc_ver = f"v{svc_ver.get('version')}{svc_ver.get('channel') if svc_ver.get('channel') is not None else ''}{svc_ver.get('release') if svc_ver.get('release') is not None else ''}"
+        else:
+            svc_ver = ""
+        if svc.get('name') in temp_stubs:
+            stub = temp_stubs[svc.get('name')]
+            stub_target = (
+                stub.get("target")
+                if stub.get("target") is not None
+                else "${_OPEN_BRCK}this.host{_CLOSING_BRCK}:${_OPEN_BRCK}this.port{_CLOSING_BRCK}"
+            )
+            stub_creds = (
+                stub.get("creds")
+                if stub.get("creds") is not None
+                else "credentials.createInsecure()"
+            )
+            stub_opts = (
+                stub.get("opts") if stub.get("opts") is not None else "_DEFAULT_OPTION"
+            )
+            stubs.append(
+                f"this.{svc_name}{svc_ver}Client = new {svc_name}{svc_ver}Client(`{stub_target}`, {stub_creds}, {stub_opts});"
+            )
+        else:
+            stubs.append(
+                f"this.{svc_name}{svc_ver}Client = new {svc_name}{svc_ver}Client(`${_OPEN_BRCK}this.host{_CLOSING_BRCK}:${_OPEN_BRCK}this.port{_CLOSING_BRCK}`, <ChannelCredentials>channelCreds,_DEFAULT_OPTION);"
+            )
+
+        return "\n\t\t".join(stubs)
+
+    def args_stubs(self, svc):
+        svc_name = svc.get('name')
+        svc_ver = parse_version_component(svc.get('fullName'))
+        if svc_ver is not None:
+            svc_ver = f"v{svc_ver.get('version')}{svc_ver.get('channel') if svc_ver.get('channel') is not None else ''}{svc_ver.get('release') if svc_ver.get('release') is not None else ''}"
+        else:
+            svc_ver = ""
+        return f"private readonly {svc_name}{svc_ver}Client: {svc_name}{svc_ver}Client;"
 
-    def init_wrapper(self):
+    def init_wrapper(self, svc):
         if self._config is not None:
-            host = self._config.get('host')
-            port = self._config.get('port')
+            host = self._config.get("host")
+            port = self._config.get("port")
 
         else:
-            host = 'localhost'
+            host = "localhost"
             port = 44880
         sylk_version = __version__.__version__
-        init_func = f'constructor(host: string = "{host}", port: number = {port}, metadata: Metadata = new Metadata()) {_OPEN_BRCK}\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t\tthis.metadata = metadata;\n\t\tthis.metadata.add(\'sylk-version\',\'{sylk_version}\');\n\t\t{self.init_stubs()}\n\t{_CLOSING_BRCK}\n\n\tprivate readonly metadata: Metadata;\n\tprivate readonly host: string;\n\tprivate readonly port: number;\n\t{self.args_stubs()}'
+        init_func = f"constructor(opts: SylkClientOpts) {_OPEN_BRCK}\n\t\tconst {_OPEN_BRCK} host, metadata, port, channelCreds {_CLOSING_BRCK} = {_OPEN_BRCK}...DEFAULT_CLIENT_OPTS, ...opts{_CLOSING_BRCK}\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t\tthis.metadata = metadata;\n\t\tthis.metadata.add('sylk-version','{sylk_version}');\n\t\t{self.init_stubs(svc)}\n\t{_CLOSING_BRCK}\n\n\tprivate readonly metadata: Metadata;\n\tprivate readonly host: string;\n\tprivate readonly port: number;\n\t{self.args_stubs(svc)}"
         return init_func
 
     def write_imports(self):
-        imports = ['import { credentials, Metadata, ServiceError as _service_error, ClientUnaryCall, ClientDuplexStream, ClientReadableStream, ClientWritableStream, InterceptingCall, Interceptor } from \'@grpc/grpc-js\';',
-                   'import { promisify } from \'util\';','import { Observable } from \'rxjs\';']
+
         for svc in self._services:
-            for dep in self._services[svc].get('dependencies'):
-                if 'google.protobuf.' in dep:
-                    wellknown_message = dep.split('.')[-1]
-                    imports.append(f'import {_OPEN_BRCK} {wellknown_message} {_CLOSING_BRCK} from \'./protos/google/protobuf/{wellknown_message.lower()}\';')
-            svc_path = svc.split('.')[0]
-            svc_name = svc.split('/')[-1].split('.')[0]
-            imports.append(f'import {_OPEN_BRCK} {svc_name}Client {_CLOSING_BRCK} from \'./{svc_path}\';')
-        for pkg in self._packages:
-            pkg_name = pkg.split('/')[-1].split('.')[0]
-            pkg_path = pkg.split('.')[0]
-            imports.append(f'import * as {pkg_name} from \'./{pkg_path}\';')
+            list_d = list(map(lambda i: i, _WELL_KNOWN_TS_CLIENT_IMPORTS))
+            parent = self._sylk_json._proto_tree.get_parent(svc.get('fullName'))
+            refs = self._sylk_json._proto_tree.get_parents_refs([svc.get('fullName')])
+            
+            deps = self._sylk_json._proto_tree.get_references(svc.get('fullName'))
         
+            pkg_ver = self._sylk_json._proto_tree._parse_version_component(parent.full_path)
+            if pkg_ver is not None:
+                pkg_ver = f'v{pkg_ver.get("version")}{pkg_ver.get("channel") if pkg_ver.get("channel") is not None else ""}{pkg_ver.get("release") if pkg_ver.get("release") is not None else ""}'
+                pkg_name = parent.full_path.split('.')[-2]
+            else:
+                pkg_name = parent.name
+            module_name = pkg_name if svc.get('tag') is None and svc.get('tag') != '' else svc.get('tag')
+            base_protos = self._sylk_json._root_protos.replace('/','.')
+            for d in list(set(deps)):
+
+                if d.split('.')[0] == self._sylk_json._proto_tree.root.name:
+                    root = self._sylk_json._proto_tree.root
+                    dep_parent = self._sylk_json._proto_tree.get_parent(d)
+                    
+                    base_path = './' if self._sylk_json._root_protos is None or self._sylk_json._root_protos == '' else f'./{base_protos}/'
+                    msg_dep =self._sylk_json._proto_tree._find_node(d,root) 
+                    dep_mode_ver = parse_version_component(dep_parent.full_path)
+                    if dep_mode_ver is not None:
+                        dep_mode_ver = f'v{dep_mode_ver.get("version")}{dep_mode_ver.get("channel") if dep_mode_ver.get("channel") is not None else ""}{dep_mode_ver.get("release") if dep_mode_ver.get("release") is not None else ""}'
+                        temp_name = dep_parent.full_path.split('.')[-2]
+                    else:
+                        dep_mode_ver = ''
+                        temp_name = dep_parent.name
+                    dep_mod_name = temp_name if msg_dep.properties.get('tag') is None or msg_dep.properties.get('tag') == '' else msg_dep.properties.get('tag')
+                    imp_path = f"import * as {dep_mod_name}{dep_mode_ver} from '{base_path}{dep_parent.full_path.replace('.','/')}/{dep_mod_name}';"
+                    # f"from {base_path}{dep_parent.full_path} import {dep_mod_name}_pb2_grpc, {dep_mod_name}_pb2"
+                else:
+                    root = self._sylk_json._proto_tree.proto_modules[d.split('.')[0]].root
+                    dep_parent = self._sylk_json._proto_tree.proto_modules[d.split('.')[0]].get_parent(d)
+                    msg_dep =self._sylk_json._proto_tree._find_node(d,root) 
+                    base_path = './' if self._sylk_json._root_protos is None or self._sylk_json._root_protos == '' else f'./{base_protos}/'
+                    dep_mode_ver = parse_version_component(dep_parent.full_path)
+                    if dep_mode_ver is not None:
+                        dep_mode_ver = f'v{dep_mode_ver.get("version")}{dep_mode_ver.get("channel") if dep_mode_ver.get("channel") is not None else ""}{dep_mode_ver.get("release") if dep_mode_ver.get("release") is not None else ""}'
+                        temp_name = dep_parent.full_path.split('.')[-2]
+                    else:
+                        dep_mode_ver = ''
+                        temp_name = dep_parent.name
+                    dep_mod_name = temp_name if msg_dep.properties.get('tag') is None or msg_dep.properties.get('tag') == '' else msg_dep.properties.get('tag')
+                    imp_path = f"import * as {dep_mod_name}{dep_mode_ver} from '{base_path}{dep_parent.full_path.replace('.','/')}/{dep_mod_name}';"
+                if imp_path not in list_d:
+                    list_d.append(
+                        imp_path
+                    )
+            base_path = './' if self._sylk_json._root_protos is None or self._sylk_json._root_protos == '' else f'./{base_protos}/'
+            imp_path = f"import {_OPEN_BRCK} {svc.get('name')}Service, {svc.get('name')}Client as {svc.get('name')}{pkg_ver}Client  {_CLOSING_BRCK} from '{base_path}{parent.full_path.replace('.','/')}/{module_name}';"
+            if imp_path not in list_d:
+                list_d.append(
+                        imp_path
+                    )
+
         # Pre data parsing
         if self._pre_data is not None:
-            if self._pre_data.get('imports') is not None:
-                for imp in self._pre_data.get('imports'):
-                    if imp not in imports:
-                        imports.append(imp)
-
-        return '\n'.join(imports)
+            if self._pre_data.get("imports") is not None:
+                for imp in self._pre_data.get("imports"):
+                    if imp not in list_d:
+                        list_d.append(imp)
+        
+        list_d = "\n".join(list_d)
+        return list_d
 
     def write_services_classes(self):
         if self._services is not None:
-            rpcs = []
+            svcs = []
             for svc in self._services:
-                svc_name = svc.split('/')[-1].split('.')[0]
-                for rpc in self._services[svc]['methods']:
-                    rpc_name = rpc['name']
-                    rpc_in_type_pkg = rpc['inputType'].split('.')[1]
-                    rpc_in_type = rpc['inputType'].split('.')[-1]
-                    if rpc_in_type_pkg == 'protobuf':
-                        rpc_in_type = rpc_in_type
-                    else:
-                        rpc_in_type = f'{rpc_in_type_pkg}.{rpc_in_type}'
-                    rpc_out_type_pkg = rpc['outputType'].split('.')[1]
-                    rpc_out_type = rpc['outputType'].split('.')[-1]
-                    if rpc_out_type_pkg == 'protobuf':
-                        rpc_out_type = rpc_out_type
-                    else:
-                        rpc_out_type = f'{rpc_out_type_pkg}.{rpc_out_type}'
-                    rpc_output_type = rpc.get('serverStreaming') if rpc.get('serverStreaming') is not None else False
-                    rpc_input_type = rpc.get('clientStreaming') if rpc.get('clientStreaming') is not None else False
-                    
-                    rpc_type = 'Unary' if rpc_output_type == False and rpc_input_type == False else 'Client Stream' if rpc_input_type == True and rpc_output_type == False  else 'Server Stream' if rpc_input_type == False and rpc_output_type == True else 'Bidi Stream' 
-                    
-                    rpc_description = rpc.get('description')
-                    return_type_overload = 'ClientUnaryCall' if rpc_output_type == False and rpc_input_type == False else f'ClientDuplexStream<{rpc_in_type}, {rpc_out_type}>' if rpc_output_type == True and rpc_input_type == True else f'ClientReadableStream<{rpc_out_type}>' if rpc_output_type == True and rpc_input_type == False else f'ClientWritableStream<{rpc_in_type}>' if rpc_output_type == False and rpc_input_type == True else 'any'
-                    return_type = f'Promise<{rpc_out_type}>' if rpc_output_type == False else f'Observable<{rpc_out_type}>'
+                svc_name = svc.get("name")
+                svc_ver = parse_version_component(svc.get('fullName'))
+                if svc_ver is not None:
+                    svc_ver = f"v{svc_ver.get('version')}{svc_ver.get('channel') if svc_ver.get('channel') is not None else ''}{svc_ver.get('release') if svc_ver.get('release') is not None else ''}"
+                else:
+                    svc_ver = ""
+                rpcs = []
+                for rpc in svc.get("methods",[]):
+                    rpc_name = rpc["name"]
+                    rpc_in_pkg = self._sylk_json._proto_tree.get_parent(rpc["inputType"])
+                    rpc_in_type_pkg = self._sylk_json._proto_tree._get_file_paths([rpc["inputType"]])
+                    rpc_in_type_pkg = rpc_in_type_pkg[0].split('/')[-1].split('.')[0]
+                    rpc_in_type = rpc["inputType"].split(".")[-1]
+                    if rpc_in_type_pkg != "protobuf":
+                        rpc_in_ver = self._sylk_json._proto_tree._parse_version_component(rpc["inputType"])
+                        if rpc_in_ver is not None:
+                            rpc_in_type_pkg_ver = rpc_in_pkg.full_path.split(".")[-1]
+                        else:
+                            rpc_in_type_pkg_ver = ""
+                        rpc_in_type = (
+                            f"{rpc_in_type_pkg}{rpc_in_type_pkg_ver}.{rpc_in_type}"
+                        )
+                    rpc_out_pkg = self._sylk_json._proto_tree.get_parent(rpc["outputType"])
+                    rpc_out_type_pkg = self._sylk_json._proto_tree._get_file_paths([rpc["outputType"]])
+                    rpc_out_type_pkg = rpc_out_type_pkg[0].split('/')[-1].split('.')[0]
+                    rpc_out_type = rpc["outputType"].split(".")[-1]
+                    rpc_out_ver = self._sylk_json._proto_tree._parse_version_component(rpc["outputType"])
+                    if rpc_out_type_pkg != "protobuf":
+                        rpc_out_ver = self._sylk_json._proto_tree._parse_version_component(rpc["outputType"])
+                        if rpc_out_ver is not None:
+                            rpc_out_type_pkg_ver = rpc_out_pkg.full_path.split(".")[-1]
+                        else:
+                            rpc_out_type_pkg_ver = ""
+                        rpc_out_type = (
+                            f"{rpc_out_type_pkg}{rpc_out_type_pkg_ver}.{rpc_out_type}"
+                        )
+                    rpc_output_type = (
+                        rpc.get("serverStreaming")
+                        if rpc.get("serverStreaming") is not None
+                        else False
+                    )
+                    rpc_input_type = (
+                        rpc.get("clientStreaming")
+                        if rpc.get("clientStreaming") is not None
+                        else False
+                    )
+
+                    rpc_type = (
+                        "Unary"
+                        if rpc_output_type == False and rpc_input_type == False
+                        else "Client Stream"
+                        if rpc_input_type == True and rpc_output_type == False
+                        else "Server Stream"
+                        if rpc_input_type == False and rpc_output_type == True
+                        else "Bidi Stream"
+                    )
+
+                    rpc_description = rpc.get("description")
+                    return_type_overload = (
+                        "ClientUnaryCall"
+                        if rpc_output_type == False and rpc_input_type == False
+                        else f"ClientDuplexStream<{rpc_in_type}, {rpc_out_type}>"
+                        if rpc_output_type == True and rpc_input_type == True
+                        else f"ClientReadableStream<{rpc_out_type}>"
+                        if rpc_output_type == True and rpc_input_type == False
+                        else f"ClientWritableStream<{rpc_in_type}>"
+                        if rpc_output_type == False and rpc_input_type == True
+                        else "any"
+                    )
+                    return_type = (
+                        f"Promise<{rpc_out_type}>"
+                        if rpc_output_type == False
+                        else f"Observable<{rpc_out_type}>"
+                    )
                     temp_rpc_name = rpc_name[0].lower() + rpc_name[1:]
                     temp_rpc_name = to_camel_case(temp_rpc_name)
-                    rpc_impl = f'if (callback === undefined) {_OPEN_BRCK}\n\t\t\treturn promisify<{rpc_in_type}, Metadata, {rpc_out_type}>(this.{svc_name}_client.{temp_rpc_name}.bind(this.{svc_name}_client))({rpc_in_type}.fromJSON(request), metadata);\n\t\t{_CLOSING_BRCK} else {_OPEN_BRCK}\n\t\t return this.{svc_name}_client.{temp_rpc_name}({rpc_in_type}.fromJSON(request), metadata, callback);\n\t\t{_CLOSING_BRCK}' if rpc_output_type == False and rpc_input_type == False else f'return this.{svc_name}_client.{temp_rpc_name}(metadata);' if rpc_output_type == True and rpc_input_type == True  else f'if (callback === undefined) {_OPEN_BRCK}\n\t\t\tcallback = (_error:_service_error | null , _response:{rpc_out_type}) => {_OPEN_BRCK}if (_error) throw _error; return _response{_CLOSING_BRCK}\n\t\t{_CLOSING_BRCK}\n\t\treturn this.{svc_name}_client.{temp_rpc_name}(metadata, callback);' if rpc_output_type == False and rpc_input_type == True else f'return new Observable(subscriber => {_OPEN_BRCK}\n\t\tconst stream = this.{svc_name}_client.{temp_rpc_name}({rpc_in_type}.fromJSON(request), metadata);\n\t\t\tstream.on(\'data\', (res: {rpc_out_type}) => {_OPEN_BRCK}\n\t\t\t\tsubscriber.next(res)\n\t\t\t{_CLOSING_BRCK}).on(\'end\', () => {_OPEN_BRCK}\n\t\t\t\tsubscriber.complete()\n\t\t\t{_CLOSING_BRCK}).on(\'error\', (err: any) => {_OPEN_BRCK}\n\t\t\t\tsubscriber.error(err)\n\t\t\t\tsubscriber.complete()\n\t\t\t{_CLOSING_BRCK});\n\t\t{_CLOSING_BRCK})'
+                    rpc_impl = (
+                        f"if (callback === undefined) {_OPEN_BRCK}\n\t\t\treturn promisify<{rpc_in_type}, Metadata, {rpc_out_type}>(this.{svc_name}{svc_ver}Client.{temp_rpc_name}.bind(this.{svc_name}{svc_ver}Client))({rpc_in_type}.fromJSON(request), metadata);\n\t\t{_CLOSING_BRCK} else {_OPEN_BRCK}\n\t\t return this.{svc_name}{svc_ver}Client.{temp_rpc_name}({rpc_in_type}.fromJSON(request), metadata, callback);\n\t\t{_CLOSING_BRCK}"
+                        if rpc_output_type == False and rpc_input_type == False
+                        else f"return this.{svc_name}{svc_ver}Client.{temp_rpc_name}(metadata);"
+                        if rpc_output_type == True and rpc_input_type == True
+                        else f"if (callback === undefined) {_OPEN_BRCK}\n\t\t\tcallback = (_error:_service_error | null , _response:{rpc_out_type}) => {_OPEN_BRCK}if (_error) throw _error; return _response{_CLOSING_BRCK}\n\t\t{_CLOSING_BRCK}\n\t\treturn this.{svc_name}{svc_ver}Client.{temp_rpc_name}(metadata, callback);"
+                        if rpc_output_type == False and rpc_input_type == True
+                        else f"return new Observable(subscriber => {_OPEN_BRCK}\n\t\tconst stream = this.{svc_name}{svc_ver}Client.{temp_rpc_name}({rpc_in_type}.fromJSON(request), metadata);\n\t\t\tstream.on('data', (res: {rpc_out_type}) => {_OPEN_BRCK}\n\t\t\t\tsubscriber.next(res)\n\t\t\t{_CLOSING_BRCK}).on('end', () => {_OPEN_BRCK}\n\t\t\t\tsubscriber.complete()\n\t\t\t{_CLOSING_BRCK}).on('error', (err: any) => {_OPEN_BRCK}\n\t\t\t\tsubscriber.error(err)\n\t\t\t\tsubscriber.complete()\n\t\t\t{_CLOSING_BRCK});\n\t\t{_CLOSING_BRCK})"
+                    )
                     # Client streaming
                     if rpc_output_type == False and rpc_input_type == True:
-                        description = f'/**\n\t* @method {svc_name}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param metadata Metadata\n\t*/'
+                        description = f"/**\n\t* @method {svc_name}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param metadata Metadata\n\t*/"
                         rpcs.append(
-                            f'\n\t{description}\n\tpublic {rpc_name}(metadata?: Metadata): {return_type};\n\tpublic {rpc_name}(metadata: Metadata, callback: (error: _service_error | null, response: {rpc_out_type}) => void): {return_type_overload};\n\tpublic {rpc_name}(metadata: Metadata = this.metadata, callback?: (error: _service_error | null, response: {rpc_out_type}) => void): {return_type_overload} | {return_type} {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}')
+                            f"\n\t{description}\n\tpublic {rpc_name}(metadata?: Metadata): {return_type};\n\tpublic {rpc_name}(metadata: Metadata, callback: (error: _service_error | null, response: {rpc_out_type}) => void): {return_type_overload};\n\tpublic {rpc_name}(metadata: Metadata = this.metadata, callback?: (error: _service_error | null, response: {rpc_out_type}) => void): {return_type_overload} | {return_type} {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}"
+                        )
                     # Bidi stream
                     elif rpc_output_type == True and rpc_input_type == True:
-                        description = f'/**\n\t* @method {svc_name}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param request {rpc_in_type}\n\t* @param metadata Metadata\n\t*/'
+                        description = f"/**\n\t* @method {svc_name}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param request {rpc_in_type}\n\t* @param metadata Metadata\n\t*/"
                         rpcs.append(
-                            f'\n\t{description}\n\tpublic {rpc_name}(metadata: Metadata = this.metadata): {return_type_overload} {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}')
+                            f"\n\t{description}\n\tpublic {rpc_name}(metadata: Metadata = this.metadata): {return_type_overload} {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}"
+                        )
                     # Unary
                     else:
-                        description_0 = f'/**\n\t* @method {svc_name}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param request {rpc_in_type}\n\t* @param metadata Metadata\n\t* @returns {return_type}\n\t*/'
-                        description_1 = f'/**\n\t* @method {svc_name}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param request {rpc_in_type}\n\t* @param metadata Metadata\n\t* @param callback A callback function to be excuted once the server responds with {rpc_out_type}\n\t* @returns {return_type_overload}\n\t*/'
-                        
+                        description_0 = f"/**\n\t* @method {svc_name}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param request {rpc_in_type}\n\t* @param metadata Metadata\n\t* @returns {return_type}\n\t*/"
+                        description_1 = f"/**\n\t* @method {svc_name}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param request {rpc_in_type}\n\t* @param metadata Metadata\n\t* @param callback A callback function to be excuted once the server responds with {rpc_out_type}\n\t* @returns {return_type_overload}\n\t*/"
+
                         rpcs.append(
-                            f'\n\t{description_0}\n\tpublic {rpc_name}(request: {rpc_in_type}, metadata?: Metadata): {return_type};\n\t{description_1}\n\tpublic {rpc_name}(request: {rpc_in_type}, metadata: Metadata, callback: (error: _service_error | null, response: {rpc_out_type}) => void): {return_type_overload};\n\tpublic {rpc_name}(request: {rpc_in_type}, metadata: Metadata = this.metadata, callback?: (error: _service_error | null, response: {rpc_out_type}) => void): {return_type_overload} | {return_type} {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}')
+                            f"\n\t{description_0}\n\tpublic {rpc_name}(request: {rpc_in_type}, metadata?: Metadata): {return_type};\n\t{description_1}\n\tpublic {rpc_name}(request: {rpc_in_type}, metadata: Metadata, callback: (error: _service_error | null, response: {rpc_out_type}) => void): {return_type_overload};\n\tpublic {rpc_name}(request: {rpc_in_type}, metadata: Metadata = this.metadata, callback?: (error: _service_error | null, response: {rpc_out_type}) => void): {return_type_overload} | {return_type} {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}"
+                        )
 
-            rpcs = '\n\n\t'.join(rpcs)
-        return ''.join(rpcs)
+                rpcs = "\n\n\t".join(rpcs)
+                svcs.append(
+                    f"export class {svc_name}{svc_ver.upper()} {_OPEN_BRCK}\n\t{self.init_wrapper(svc)}\n{rpcs}\n{_CLOSING_BRCK}"
+                )
+            svcs = "\n".join(svcs)
+        return "".join(svcs)
 
-class SylkClientJs():
+
+class SylkClientJs:
     """A helper class to write 'Javascript' language clients for sylk.build project services"""
 
-    def __init__(self, project_package, services=None, packages=None, context: SylkContext = None, config = None,pre_data=None):
+    def __init__(
+        self,
+        project_package,
+        services=None,
+        packages=None,
+        context: SylkContext = None,
+        config=None,
+        pre_data=None,
+    ):
         self._services = services
         self._project_package = project_package
         self._context = context
         self._packages = packages
         self._config = config
         self._pre_data = pre_data
         self._proto_paths = []
-        
+
     def __str__(self):
-        return f'{self.write_imports()}\n{self.write_services_namespaces()}\n{self.write_client_wrapper()}\n\n\t{self.write_services_classes()}\n{_CLOSING_BRCK}\n{self.write_client_exports()}'
+        return f"{self.write_imports()}\n{self.write_services_namespaces()}\n{self.write_client_wrapper()}\n\n\t{self.write_services_classes()}\n{_CLOSING_BRCK}\n{self.write_client_exports()}"
 
     def write_client_exports(self):
         pkgs_list = []
         clients_list = []
         # for key in self._packages:
         #     pkg = self._packages[key].get('name')
         #     pkgs_list.append(pkg)
         # pkgs_list = ',\n\t'.join(pkgs_list)
         # for key in self._services:
         #     clients_list.append(key+'Client')
-        
+
         # Pre data parsing
         if self._pre_data is not None:
-            if self._pre_data.get('exports') is not None:
-                for exp in self._pre_data.get('exports'):
+            if self._pre_data.get("exports") is not None:
+                for exp in self._pre_data.get("exports"):
                     if exp not in clients_list:
                         clients_list.append(exp)
 
-        clients_list = ',\n\t'.join(clients_list)
-        return f'module.exports = {_OPEN_BRCK}\n\t{self._project_package}\n{_CLOSING_BRCK}' 
+        clients_list = ",\n\t".join(clients_list)
+        return (
+            f"module.exports = {_OPEN_BRCK}\n\t{self._project_package}\n{_CLOSING_BRCK}"
+        )
 
     def write_services_namespaces(self):
         svcs = []
         for svc in self._services:
-
             svc_methods = []
-            for method in self._services[svc]['methods']:
-                rpc_name = method['name']
-                rpc_in_type_pkg = method['inputType'].split('.')[1]
-                rpc_in_type = method['inputType'].split('.')[-1]
-                rpc_in_type = f'{rpc_in_type_pkg}.{rpc_in_type}'
-                rpc_out_type_pkg = method['outputType'].split('.')[1]
-                rpc_out_type = method['outputType'].split('.')[-1]
-                rpc_out_type = f'{rpc_out_type_pkg}.{rpc_out_type}'
-                rpc_output_type = method.get('serverStreaming') if method.get('serverStreaming') is not None else False
-                rpc_input_type = method.get('clientStreaming') if method.get('clientStreaming') is not None else False
-                
-                rpc_type = 'Unary' if rpc_output_type == False and rpc_input_type == False else 'Client Stream' if rpc_input_type == True and rpc_output_type == False  else 'Server Stream' if rpc_input_type == False and rpc_output_type == True else 'Bidi Stream' 
-                return_type_overload = 'ClientUnaryCall' if rpc_output_type == False and rpc_input_type == False else f'ClientDuplexStream<{rpc_in_type}, {rpc_out_type}>' if rpc_output_type == True and rpc_input_type == True else f'ClientReadableStream<{rpc_out_type}>' if rpc_output_type == True and rpc_input_type == False else f'ClientWritableStream<{rpc_in_type}>' if rpc_output_type == False and rpc_input_type == True else 'any'
+            for method in self._services[svc]["methods"]:
+                rpc_name = method["name"]
+                rpc_in_type_pkg = method["inputType"].split(".")[1]
+                rpc_in_type = method["inputType"].split(".")[-1]
+                rpc_in_type = f"{rpc_in_type_pkg}.{rpc_in_type}"
+                rpc_out_type_pkg = method["outputType"].split(".")[1]
+                rpc_out_type = method["outputType"].split(".")[-1]
+                rpc_out_type = f"{rpc_out_type_pkg}.{rpc_out_type}"
+                rpc_output_type = (
+                    method.get("serverStreaming")
+                    if method.get("serverStreaming") is not None
+                    else False
+                )
+                rpc_input_type = (
+                    method.get("clientStreaming")
+                    if method.get("clientStreaming") is not None
+                    else False
+                )
+
+                rpc_type = (
+                    "Unary"
+                    if rpc_output_type == False and rpc_input_type == False
+                    else "Client Stream"
+                    if rpc_input_type == True and rpc_output_type == False
+                    else "Server Stream"
+                    if rpc_input_type == False and rpc_output_type == True
+                    else "Bidi Stream"
+                )
+                return_type_overload = (
+                    "ClientUnaryCall"
+                    if rpc_output_type == False and rpc_input_type == False
+                    else f"ClientDuplexStream<{rpc_in_type}, {rpc_out_type}>"
+                    if rpc_output_type == True and rpc_input_type == True
+                    else f"ClientReadableStream<{rpc_out_type}>"
+                    if rpc_output_type == True and rpc_input_type == False
+                    else f"ClientWritableStream<{rpc_in_type}>"
+                    if rpc_output_type == False and rpc_input_type == True
+                    else "any"
+                )
                 temp_rpc_name = rpc_name[0].lower() + rpc_name[1:]
-                rpc_impl = f'if (callback === undefined) {_OPEN_BRCK}\n\t\t\treturn new Promise((resolve,reject) => {_OPEN_BRCK}\n\t\t\tclient.{temp_rpc_name}.bind(client)(request, metadata, (err,res) => {_OPEN_BRCK}\n\t\t\t\tif(err) reject(err);\n\t\t\t\telse {_OPEN_BRCK}\n\t\t\t\t\tresolve(res);\n\t\t\t\t\t{_CLOSING_BRCK}\n\t\t\t\t{_CLOSING_BRCK});\n\t\t\t\t{_CLOSING_BRCK})\n\t\t{_CLOSING_BRCK} else {_OPEN_BRCK}\n\t\t return client.{temp_rpc_name}(request, metadata, callback);\n\t\t{_CLOSING_BRCK}' if rpc_output_type == False and rpc_input_type == False else f'return client.{temp_rpc_name}(metadata);' if rpc_output_type == True and rpc_input_type == True  else f'if (callback === undefined) {_OPEN_BRCK}\n\t\t\tcallback = (_error, _response) => {_OPEN_BRCK}if (_error) throw _error; return _response{_CLOSING_BRCK}\n\t\t{_CLOSING_BRCK}\n\t\treturn client.{temp_rpc_name}(metadata, callback);' if rpc_output_type == False and rpc_input_type == True else f'return new Observable(subscriber => {_OPEN_BRCK}\n\t\tconst stream = client.{temp_rpc_name}({rpc_in_type}.fromJSON(request), metadata);\n\t\t\tstream.on(\'data\', (res) => {_OPEN_BRCK}\n\t\t\t\tsubscriber.next(res)\n\t\t\t{_CLOSING_BRCK}).on(\'end\', () => {_OPEN_BRCK}\n\t\t\t\tsubscriber.complete()\n\t\t\t{_CLOSING_BRCK}).on(\'error\', (err) => {_OPEN_BRCK}\n\t\t\t\tsubscriber.error(err)\n\t\t\t\tsubscriber.complete()\n\t\t\t{_CLOSING_BRCK});\n\t\t{_CLOSING_BRCK})'
+                rpc_impl = (
+                    f"if (callback === undefined) {_OPEN_BRCK}\n\t\t\treturn new Promise((resolve,reject) => {_OPEN_BRCK}\n\t\t\tclient.{temp_rpc_name}.bind(client)(request, metadata, (err,res) => {_OPEN_BRCK}\n\t\t\t\tif(err) reject(err);\n\t\t\t\telse {_OPEN_BRCK}\n\t\t\t\t\tresolve(res);\n\t\t\t\t\t{_CLOSING_BRCK}\n\t\t\t\t{_CLOSING_BRCK});\n\t\t\t\t{_CLOSING_BRCK})\n\t\t{_CLOSING_BRCK} else {_OPEN_BRCK}\n\t\t return client.{temp_rpc_name}(request, metadata, callback);\n\t\t{_CLOSING_BRCK}"
+                    if rpc_output_type == False and rpc_input_type == False
+                    else f"return client.{temp_rpc_name}(metadata);"
+                    if rpc_output_type == True and rpc_input_type == True
+                    else f"if (callback === undefined) {_OPEN_BRCK}\n\t\t\tcallback = (_error, _response) => {_OPEN_BRCK}if (_error) throw _error; return _response{_CLOSING_BRCK}\n\t\t{_CLOSING_BRCK}\n\t\treturn client.{temp_rpc_name}(metadata, callback);"
+                    if rpc_output_type == False and rpc_input_type == True
+                    else f"return new Observable(subscriber => {_OPEN_BRCK}\n\t\tconst stream = client.{temp_rpc_name}({rpc_in_type}.fromJSON(request), metadata);\n\t\t\tstream.on('data', (res) => {_OPEN_BRCK}\n\t\t\t\tsubscriber.next(res)\n\t\t\t{_CLOSING_BRCK}).on('end', () => {_OPEN_BRCK}\n\t\t\t\tsubscriber.complete()\n\t\t\t{_CLOSING_BRCK}).on('error', (err) => {_OPEN_BRCK}\n\t\t\t\tsubscriber.error(err)\n\t\t\t\tsubscriber.complete()\n\t\t\t{_CLOSING_BRCK});\n\t\t{_CLOSING_BRCK})"
+                )
                 # Client streaming
                 if rpc_output_type == False and rpc_input_type == True:
                     svc_methods.append(
-                        f'{rpc_name}: (client, metadata = this.metadata, callback = undefined) => {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}')
+                        f"{rpc_name}: (client, metadata = this.metadata, callback = undefined) => {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}"
+                    )
                 # Bidi stream
                 elif rpc_output_type == True and rpc_input_type == True:
                     svc_methods.append(
-                        f'{rpc_name}: (client, metadata = this.metadata) => {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}')
+                        f"{rpc_name}: (client, metadata = this.metadata) => {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}"
+                    )
                 # Unary
                 else:
                     svc_methods.append(
-                        f'{rpc_name}: (client, request, metadata = this.metadata, callback = undefined) => {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}')
+                        f"{rpc_name}: (client, request, metadata = this.metadata, callback = undefined) => {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}"
+                    )
 
-            svc_methods = ',\n\t'.join(svc_methods)
-            svcs.append(f'const {svc}Service = {_OPEN_BRCK}\n\t{svc_methods}\n{_CLOSING_BRCK}')
-            return '\n\n'.join(svcs)
+            svc_methods = ",\n\t".join(svc_methods)
+            svcs.append(
+                f"const {svc}Service = {_OPEN_BRCK}\n\t{svc_methods}\n{_CLOSING_BRCK}"
+            )
+            return "\n\n".join(svcs)
 
     def write_client_wrapper(self):
-        client_options = self._pre_data.get('client_options')
-        client_options = '\n\t'.join(list(map(lambda opt: '"{}": {},'.format(opt[0],opt[1]),client_options)))
-        
+        client_options = self._pre_data.get("client_options")
+        client_options = "\n\t".join(
+            list(map(lambda opt: '"{}": {},'.format(opt[0], opt[1]), client_options))
+        )
+
         # Parsing pre data
-        before_init = ''
+        before_init = ""
         interceptors = []
 
         if self._pre_data:
-            if self._pre_data.get('before_init') is not None:
-                before_init = self._pre_data.get('before_init')
-            if self._pre_data.get('interceptors') is not None:
-                interceptors = self._pre_data.get('interceptors')
+            if self._pre_data.get("before_init") is not None:
+                before_init = self._pre_data.get("before_init")
+            if self._pre_data.get("interceptors") is not None:
+                interceptors = self._pre_data.get("interceptors")
         # proto_paths = ','.join(self._proto_paths)
-        interceptors = ', '.join(interceptors)
+        interceptors = ", ".join(interceptors)
         if self._config is not None:
-            host = self._config.get('host')
-            port = self._config.get('port')
+            host = self._config.get("host")
+            port = self._config.get("port")
 
         else:
-            host = 'localhost'
+            host = "localhost"
             port = 44880
         return f'\n{before_init}\nconst interceptorsProviders = [{interceptors}]\nconst _DEFAULT_OPTION = {_OPEN_BRCK}\n\t{client_options}\n{_CLOSING_BRCK}\n\nconst protoDefinitions = protoLoader.loadSync(\n\t[...PROTO_PATHS],\n\t{_OPEN_BRCK}\n\t\tincluderDirs: [`${_OPEN_BRCK}__dirname{_CLOSING_BRCK}`],\n\t\tkeepCase:true,\n\t\tlongs: String,\n\t\tenums: String,\n\t\tdefaults: true,\n\t\toneofs: true,\n\t{_CLOSING_BRCK}\n);\nconst protos = grpc.loadPackageDefinition(protoDefinitions);\nconst defaultClientOptions = {_OPEN_BRCK}\n\thost: "{host}",\n\tport: {port},\n\tmetadata: new grpc.Metadata(),\n\tglobalInterceptors: []\n{_CLOSING_BRCK};\n\n/**\n * Generated thanks to [sylk.build](https://www.sylk.build)\n */\nclass {self._project_package} {_OPEN_BRCK}\n\n\t{self.init_wrapper()}'
 
     def init_stubs(self):
         stubs = []
         temp_stubs = {}
         if self._pre_data is not None:
-            if self._pre_data.get('stubs') is not None:
-                temp_stubs = self._pre_data.get('stubs')
+            if self._pre_data.get("stubs") is not None:
+                temp_stubs = self._pre_data.get("stubs")
 
         for svc in self._services:
             if svc in temp_stubs:
                 stub = temp_stubs[svc]
-                stub_target = stub.get('target') if stub.get('target') is not None else '${_OPEN_BRCK}this.host{_CLOSING_BRCK}:${_OPEN_BRCK}this.port{_CLOSING_BRCK}'
-                stub_creds = stub.get('creds') if stub.get('creds') is not None else 'credentials.createInsecure()'
-                stub_opts =  stub.get('opts') if stub.get('opts') is not None else '_DEFAULT_OPTION'
-                stubs.append(f'this._{svc}Client = new {svc}Client(`{stub_target}`, {stub_creds}, {stub_opts});')
+                stub_target = (
+                    stub.get("target")
+                    if stub.get("target") is not None
+                    else "${_OPEN_BRCK}this.host{_CLOSING_BRCK}:${_OPEN_BRCK}this.port{_CLOSING_BRCK}"
+                )
+                stub_creds = (
+                    stub.get("creds")
+                    if stub.get("creds") is not None
+                    else "credentials.createInsecure()"
+                )
+                stub_opts = (
+                    stub.get("opts")
+                    if stub.get("opts") is not None
+                    else "_DEFAULT_OPTION"
+                )
+                stubs.append(
+                    f"this._{svc}Client = new {svc}Client(`{stub_target}`, {stub_creds}, {stub_opts});"
+                )
             else:
-                stubs.append(f'this._{svc}Client = new protos.{svc}(`${_OPEN_BRCK}this.host{_CLOSING_BRCK}:${_OPEN_BRCK}this.port{_CLOSING_BRCK}`, grpc.credentials.createInsecure());')
+                stubs.append(
+                    f"this._{svc}Client = new protos.{svc}(`${_OPEN_BRCK}this.host{_CLOSING_BRCK}:${_OPEN_BRCK}this.port{_CLOSING_BRCK}`, grpc.credentials.createInsecure());"
+                )
 
-        return '\n\t\t'.join(stubs)
+        return "\n\t\t".join(stubs)
 
     def args_stubs(self):
         stubs = []
         for svc in self._services:
-            stubs.append(f'_{svc}Client;')
+            stubs.append(f"_{svc}Client;")
 
-        return '\n\t'.join(stubs)
+        return "\n\t".join(stubs)
 
     def init_wrapper(self):
-        
         sylk_version = __version__.__version__
-        init_func = f'constructor(options = {_OPEN_BRCK}{_CLOSING_BRCK}) {_OPEN_BRCK}\n\t\tconst {_OPEN_BRCK} host, port, metadata, globalInterceptors {_CLOSING_BRCK} = {_OPEN_BRCK} ...defaultClientOptions, ...options {_CLOSING_BRCK};\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t\tthis.metadata = metadata;\n\t\tthis.metadata.add(\'sylk-version\',\'{sylk_version}\');\n\t\tthis.globalInterceptors = globalInterceptors;\n\t\t{self.init_stubs()}\n\t{_CLOSING_BRCK}\n\n\tmetadata;\n\thost;\n\tport;\n\t{self.args_stubs()}'
+        init_func = f"constructor(options = {_OPEN_BRCK}{_CLOSING_BRCK}) {_OPEN_BRCK}\n\t\tconst {_OPEN_BRCK} host, port, metadata, globalInterceptors {_CLOSING_BRCK} = {_OPEN_BRCK} ...defaultClientOptions, ...options {_CLOSING_BRCK};\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t\tthis.metadata = metadata;\n\t\tthis.metadata.add('sylk-version','{sylk_version}');\n\t\tthis.globalInterceptors = globalInterceptors;\n\t\t{self.init_stubs()}\n\t{_CLOSING_BRCK}\n\n\tmetadata;\n\thost;\n\tport;\n\t{self.args_stubs()}"
         return init_func
 
     def write_imports(self):
-        imports = ['let grpc = require(\'@grpc/grpc-js\');',
-                   'let protoLoader = require(\'@grpc/proto-loader\');',
-                   'const { compose } = require(\'lodash/fp\');',
-                   'const { clientMethodWrapper, clientRetries } = require(\'./utils/interceptors\');']
+        imports = [
+            "let grpc = require('@grpc/grpc-js');",
+            "let protoLoader = require('@grpc/proto-loader');",
+            "const { compose } = require('lodash/fp');",
+            "const { clientMethodWrapper, clientRetries } = require('./utils/interceptors');",
+        ]
         proto_paths = []
         for svc in self._services:
-            proto_paths.append(f'`${_OPEN_BRCK}__dirname{_CLOSING_BRCK}/protos/{svc}/v1/{svc}.proto`')
+            proto_paths.append(
+                f"`${_OPEN_BRCK}__dirname{_CLOSING_BRCK}/protos/{svc}/v1/{svc}.proto`"
+            )
         for pkg in self._packages:
-            pkg_name = pkg.split('/')[-1].split('.')[0]
-            pkg_version = pkg.split('/')[1]
-            proto_paths.append(f'`${_OPEN_BRCK}__dirname{_CLOSING_BRCK}/protos/{pkg_name}/{pkg_version}/{pkg_name}.proto`')
-        proto_paths = ',\n\t'.join(proto_paths)
-        imports.append(f'const PROTO_PATHS = [{proto_paths}\n];')
+            pkg_name = pkg.split("/")[-1].split(".")[0]
+            pkg_version = pkg.split("/")[1]
+            proto_paths.append(
+                f"`${_OPEN_BRCK}__dirname{_CLOSING_BRCK}/protos/{pkg_name}/{pkg_version}/{pkg_name}.proto`"
+            )
+        proto_paths = ",\n\t".join(proto_paths)
+        imports.append(f"const PROTO_PATHS = [{proto_paths}\n];")
 
         # Pre data parsing
         if self._pre_data is not None:
-            if self._pre_data.get('imports') is not None:
-                for imp in self._pre_data.get('imports'):
+            if self._pre_data.get("imports") is not None:
+                for imp in self._pre_data.get("imports"):
                     if imp not in imports:
                         imports.append(imp)
 
-        return '\n'.join(imports)
+        return "\n".join(imports)
 
     def write_services_classes(self):
         if self._services is not None:
             rpcs = []
             for svc in self._services:
-                for rpc in self._services[svc]['methods']:
-                    rpc_name = rpc['name']
-                    rpc_in_type_pkg = rpc['inputType'].split('.')[1]
-                    rpc_in_type = rpc['inputType'].split('.')[-1]
-                    rpc_in_type = f'{rpc_in_type_pkg}.{rpc_in_type}'
-                    rpc_out_type_pkg = rpc['outputType'].split('.')[1]
-                    rpc_out_type = rpc['outputType'].split('.')[-1]
-                    rpc_out_type = f'{rpc_out_type_pkg}.{rpc_out_type}'
-                    rpc_output_type = rpc.get('serverStreaming') if rpc.get('serverStreaming') is not None else False
-                    rpc_input_type = rpc.get('clientStreaming') if rpc.get('clientStreaming') is not None else False
-                    
-                    rpc_type = 'Unary' if rpc_output_type == False and rpc_input_type == False else 'Client Stream' if rpc_input_type == True and rpc_output_type == False  else 'Server Stream' if rpc_input_type == False and rpc_output_type == True else 'Bidi Stream' 
-                    
-                    rpc_description = rpc.get('description')
-                    return_type_overload = 'ClientUnaryCall' if rpc_output_type == False and rpc_input_type == False else f'ClientDuplexStream<{rpc_in_type}, {rpc_out_type}>' if rpc_output_type == True and rpc_input_type == True else f'ClientReadableStream<{rpc_out_type}>' if rpc_output_type == True and rpc_input_type == False else f'ClientWritableStream<{rpc_in_type}>' if rpc_output_type == False and rpc_input_type == True else 'any'
-                    return_type = f'Promise' if rpc_output_type == False else f'Observable'
+                for rpc in self._services[svc]["methods"]:
+                    rpc_name = rpc["name"]
+                    rpc_in_type_pkg = rpc["inputType"].split(".")[1]
+                    rpc_in_type = rpc["inputType"].split(".")[-1]
+                    rpc_in_type = f"{rpc_in_type_pkg}.{rpc_in_type}"
+                    rpc_out_type_pkg = rpc["outputType"].split(".")[1]
+                    rpc_out_type = rpc["outputType"].split(".")[-1]
+                    rpc_out_type = f"{rpc_out_type_pkg}.{rpc_out_type}"
+                    rpc_output_type = (
+                        rpc.get("serverStreaming")
+                        if rpc.get("serverStreaming") is not None
+                        else False
+                    )
+                    rpc_input_type = (
+                        rpc.get("clientStreaming")
+                        if rpc.get("clientStreaming") is not None
+                        else False
+                    )
+
+                    rpc_type = (
+                        "Unary"
+                        if rpc_output_type == False and rpc_input_type == False
+                        else "Client Stream"
+                        if rpc_input_type == True and rpc_output_type == False
+                        else "Server Stream"
+                        if rpc_input_type == False and rpc_output_type == True
+                        else "Bidi Stream"
+                    )
+
+                    rpc_description = rpc.get("description")
+                    return_type_overload = (
+                        "ClientUnaryCall"
+                        if rpc_output_type == False and rpc_input_type == False
+                        else f"ClientDuplexStream<{rpc_in_type}, {rpc_out_type}>"
+                        if rpc_output_type == True and rpc_input_type == True
+                        else f"ClientReadableStream<{rpc_out_type}>"
+                        if rpc_output_type == True and rpc_input_type == False
+                        else f"ClientWritableStream<{rpc_in_type}>"
+                        if rpc_output_type == False and rpc_input_type == True
+                        else "any"
+                    )
+                    return_type = (
+                        f"Promise" if rpc_output_type == False else f"Observable"
+                    )
                     temp_rpc_name = rpc_name[0].lower() + rpc_name[1:]
-                    rpc_impl = f'return compose(\n\t\t\tclientMethodWrapper, clientRetries, ...this.globalInterceptors\n\t\t)({svc}Service.{rpc_name})(this._{svc}Client,request,metadata,callback)'
+                    rpc_impl = f"return compose(\n\t\t\tclientMethodWrapper, clientRetries, ...this.globalInterceptors\n\t\t)({svc}Service.{rpc_name})(this._{svc}Client,request,metadata,callback)"
                     # Client streaming
                     if rpc_output_type == False and rpc_input_type == True:
-                        description = f'/**\n\t* @method {svc}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param metadata Metadata\n\t*/'
+                        description = f"/**\n\t* @method {svc}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param metadata Metadata\n\t*/"
                         rpcs.append(
-                            f'\n\t{description}\n\t{rpc_name}(metadata = this.metadata, callback = undefined) {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}')
+                            f"\n\t{description}\n\t{rpc_name}(metadata = this.metadata, callback = undefined) {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}"
+                        )
                     # Bidi stream
                     elif rpc_output_type == True and rpc_input_type == True:
-                        description = f'/**\n\t* @method {svc}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param request {rpc_in_type}\n\t* @param metadata Metadata\n\t*/'
+                        description = f"/**\n\t* @method {svc}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param request {rpc_in_type}\n\t* @param metadata Metadata\n\t*/"
                         rpcs.append(
-                            f'\n\t{description}\n\t{rpc_name}(metadata = this.metadata) {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}')
+                            f"\n\t{description}\n\t{rpc_name}(metadata = this.metadata) {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}"
+                        )
                     # Unary
                     else:
                         # description_0 = f'/**\n\t* @method {svc}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param request {rpc_in_type}\n\t* @param metadata Metadata\n\t* @returns {return_type}\n\t*/'
-                        description_1 = f'/**\n\t* @method {svc}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param request {rpc_in_type}\n\t* @param metadata Metadata\n\t* @param callback A callback function to be excuted once the server responds with {rpc_out_type}\n\t* @returns {return_type_overload}\n\t*/'
-                        
+                        description_1 = f"/**\n\t* @method {svc}.{rpc_name}\n\t* @description {rpc_description}\n\t* @kind {rpc_type}\n\t* @param request {rpc_in_type}\n\t* @param metadata Metadata\n\t* @param callback A callback function to be excuted once the server responds with {rpc_out_type}\n\t* @returns {return_type_overload}\n\t*/"
+
                         rpcs.append(
-                            f'\n\t{description_1}\n\t{rpc_name}(request, metadata = this.metadata, callback = undefined) {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}')
+                            f"\n\t{description_1}\n\t{rpc_name}(request, metadata = this.metadata, callback = undefined) {_OPEN_BRCK}\n\t\t{rpc_impl}\n\t{_CLOSING_BRCK}"
+                        )
+
+            rpcs = "\n\n\t".join(rpcs)
+        return "".join(rpcs)
 
-            rpcs = '\n\n\t'.join(rpcs)
-        return ''.join(rpcs)
 
 class SylkClientGo:
     """A helper class to write 'Go' language clients for sylk.build project services"""
 
-    def __init__(self, project_package, services=None, packages=None, context: SylkContext = None, config = None,sylk_json:SylkJson=None):
+    def __init__(
+        self,
+        project_package,
+        services=None,
+        packages=None,
+        context: SylkContext = None,
+        config=None,
+        sylk_json: SylkJson = None,
+        pre_data=None
+    ):
         self._services = services
         self._project_package = project_package
         self._context = context
         self._packages = packages
         self._config = config
         self._sylk_json = sylk_json
-
-    def __str__(self):
-        return f'{self.write_imports()}{self.write_struct()}{self.write_new()}{self.write_methods()}'
-
-    def write_imports(self):
-        list_of_services = ['// Importing services']
-        list_of_packages = ['// Importing packages']
         for s in self._services:
-            svc_domain = self._services[s].get('fullName').split('.')[0]
-            svc_name = self._services[s].get('fullName').split('.')[1]
-            svc_ver = self._services[s].get('fullName').split('.')[2]
-            list_of_services.append('{2} "{0}/services/protos/{1}/{2}/{3}"'.format(self._sylk_json.project.get('goPackage'),svc_domain,svc_name,svc_ver))
-            if self._services[s].get('dependencies') is not None:
-                for dep in self._services[s].get('dependencies'):
-                    if 'google.protobuf' in dep:
-                        dep_name = dep.split('.')[-1].lower()
-                        list_of_services.append(f'{dep_name}pb "google.golang.org/protobuf/types/known/{dep_name}pb"')
-            	
-        for p in self._packages:
-            pkg_domain = self._packages[p].get('package').split('.')[0]
-            pkg_name = self._packages[p].get('package').split('.')[1]
-            pkg_ver = self._packages[p].get('package').split('.')[2]
-            list_of_packages.append('{2} "{0}/services/protos/{1}/{2}/{3}"'.format(self._sylk_json.project.get('goPackage'),pkg_domain,pkg_name,pkg_ver))
-            if self._packages[p].get('dependencies') is not None:
-                for dep in self._packages[p].get('dependencies'):
-                    if 'google.protobuf' in dep:
-                        dep_name = dep.split('.')[-1].lower()
-                        list_of_packages.append(f'{dep_name}pb "google.golang.org/protobuf/types/known/{dep_name}pb"')
-                    
-
-
-
-
-        _sylk_conn_builder = '\tsylkChannel "{}/clients/go/utils"'.format(self._sylk_json.project.get('goPackage'))
-
-        _default_imports = ['"fmt"','"io"','"context"','"log"','"time"','"google.golang.org/grpc"','"google.golang.org/grpc/credentials/insecure"','"google.golang.org/grpc/metadata"','\n',_sylk_conn_builder,'\n\t'.join(list_of_services),'\n\t'.join(list_of_packages)]
-
-        return 'package {}\n\nimport (\n\t{}\n)'.format(self._project_package,'\n\t'.join(_default_imports))
+            svc_name = s.get('name')
+            svc_code = f"{self.write_imports(s)}{self.write_struct(s)}{self.write_new(s)}{self.write_methods(s)}"
+            svc_ver = parse_version_component(s.get('fullName'))
+            if svc_ver is not None:
+                svc_ver = f"v{svc_ver.get('version')}{svc_ver.get('channel') if svc_ver.get('channel') is not None else ''}{svc_ver.get('release') if svc_ver.get('release') is not None else ''}"
+                file_system.wFile(
+                    file_system.join_path(
+                        sylk_json.path,
+                        "clients",
+                        "go",
+                        svc_name,
+                        svc_ver,
+                        f"{svc_name}.go",
+                    ),
+                    svc_code,
+                    overwrite=True,
+                    force=True,
+                )
+            else:
+                file_system.wFile(
+                    file_system.join_path(
+                        self._sylk_json.path,
+                        "clients",
+                        "go",
+                        svc_name,
+                        f"{svc_name}.go",
+                    ),
+                    svc_code,
+                    overwrite=True,
+                    force=True,
+                )
+
+    def write_imports(self, s):
+        list_of_services = ["// Importing services"]
+        list_of_packages = ["// Importing packages"]
+
+        files = self._sylk_json._proto_tree.get_all_file_paths()
+        imports = []
+        go_package_path = self._sylk_json.project.get("goPackage")
+        for mod in files:
+            mod_path = '.'.join(mod.split('/')[:-1])
+            mod_name = mod.split('/')[-1].split('.')[0]
+            ver = self._sylk_json._proto_tree._parse_version_component(mod_path)
+            if ver is not None:
+                version = mod_path.split('.')[-1]
+            else:
+                version = ''
+            if mod_path.split('.')[0] != self._sylk_json._proto_tree.root.name:
+                base_protos = ''
+                root = self._sylk_json._proto_tree.proto_modules[mod_path.split('.')[0]].root
+                dep_parent = self._sylk_json._proto_tree.proto_modules[mod_path.split('.')[0]].get_parent(mod_path)
+                msg_dep =self._sylk_json._proto_tree._find_node(mod_path,root) 
+                if parse_version_component(dep_parent.full_path) is not None:
+                    temp_name = dep_parent.full_path.split('.')[-2]
+                else:
+                    temp_name = dep_parent.name
+                dep_mod_name = temp_name if msg_dep.properties.get('tag') is None or msg_dep.properties.get('tag') == '' else msg_dep.properties.get('tag')
+                if "google.protobuf" in mod_path:
+                    imp_path = f'{dep_mod_name}pb "google.golang.org/protobuf/types/known/{dep_mod_name}pb"'
+                    if imp_path not in imports:
+                        imports.append(imp_path)
+                else:
+                    imp_path = f'"{base_protos}{mod_path.replace(".","/")}"' 
+                    if imp_path not in imports:
+                        imports.append(imp_path)
+            else:
+                base_protos = f'{self._sylk_json._root_protos}/' if self._sylk_json._root_protos is not None and self._sylk_json._root_protos != '' else ''
+                imp_path = f'"{go_package_path}/services/{base_protos}{mod_path.replace(".","/")}"' 
+                if imp_path not in imports:
+                    imports.append(imp_path)
+
+        # svc_domain = self._services[s].get("fullName").split(".")[0]
+        svc_name = s.get("name")
+        svc_ver = parse_version_component(s.get("fullName"))
+        if svc_ver is not None:
+            svc_ver = f'v{svc_ver.get("version")}{svc_ver.get("channel") if svc_ver.get("channel") is not None else ""}{svc_ver.get("release") if svc_ver.get("release") is not None else ""}'
+        else:
+            svc_ver = ''
+        # svc_path = '{4} "{0}/services/protos/{1}/{2}/{3}"'.format(
+        #     self._sylk_json.project.get("goPackage"),
+        #     svc_domain,
+        #     svc_name,
+        #     svc_ver,
+        #     svc_name + svc_ver,
+        # )
+        # list_of_services.append(svc_path)
+        # if s.get("dependencies") is not None:
+        #     for dep in s.get("dependencies"):
+        #         if "google.protobuf" in dep:
+        #             dep_name = dep.split(".")[-1].lower()
+        #             list_of_services.append(
+        #                 f'{dep_name}pb "google.golang.org/protobuf/types/known/{dep_name}pb"'
+        #             )
+
+        # for p in self._packages:
+        #     pkg_domain = self._packages[p].get("package").split(".")[0]
+        #     pkg_name = self._packages[p].get("package").split(".")[1]
+        #     pkg_ver = self._packages[p].get("package").split(".")[2]
+        #     pkg_path = '{4} "{0}/services/protos/{1}/{2}/{3}"'.format(
+        #         self._sylk_json.project.get("goPackage"),
+        #         pkg_domain,
+        #         pkg_name,
+        #         pkg_ver,
+        #         pkg_name + pkg_ver,
+        #     )
+        #     if pkg_path not in list_of_services:
+        #         list_of_packages.append(pkg_path)
+        #     if self._packages[p].get("dependencies") is not None:
+        #         for dep in self._packages[p].get("dependencies"):
+        #             if "google.protobuf" in dep:
+        #                 dep_name = dep.split(".")[-1].lower()
+        #                 list_of_packages.append(
+        #                     f'{dep_name}pb "google.golang.org/protobuf/types/known/{dep_name}pb"'
+        #                 )
+
+        _sylk_conn_builder = '\tsylkChannel "{}/clients/go/utils"'.format(
+            self._sylk_json.project.get("goPackage")
+        )
+        _default_imports = [
+            '"fmt"',
+            '"io"',
+            '"context"',
+            '"log"',
+            '"time"',
+            '"google.golang.org/grpc"',
+            '"google.golang.org/grpc/credentials/insecure"',
+            '"google.golang.org/grpc/metadata"',
+            "\n",
+            _sylk_conn_builder,
+            "\n\t".join(list_of_services),
+            "\n\t".join(list_of_packages),
+            "\n\t".join(imports)
+        ]
+
+        return "package {}\n\nimport (\n\t{}\n)".format(
+            svc_name + svc_ver, "\n\t".join(_default_imports)
+        )
 
-    
     # def write_types(self):
     #     struct_values = []
     #     for p in self._sylk_json.packages:
     #         temp_pkg = self._sylk_json.packages[p]
 
     #         if temp_pkg.get('messages'):
     #             for m in temp_pkg.get('messages'):
     #                 msg_name = m.get('name')
     #                 msg_go_name = msg_name[0].upper() + msg_name[1:]
     #                 struct_values.append('{} {}.{}'.format(msg_go_name,m.get('fullName').split('.')[1],msg_go_name))
-            
+
     #         if temp_pkg.get('enums'):
     #             for e in temp_pkg.get('enums'):
     #                 enm_name = e.get('name')
     #                 enm_go_name = enm_name[0].upper() + enm_name[1:]
     #                 struct_values.append('{} {}.{}'.format(enm_go_name,m.get('fullName').split('.')[1],enm_go_name))
-            
+
     #     struct_values = '\n\t'.join(struct_values)
     #     return '\n\ntype (\n\t{2}\n{1}\n'.format(_OPEN_BRCK,_CLOSING_BRCK,struct_values)
-    
-    def write_struct(self):
-        client_options = ['host string // Host name should be a valid ip or domain',
-                          'port int // Port that been served by the host',
-                          'dialOpts []grpc.DialOption // Connection dial options',
-                          'callOpts []grpc.CallOption // Connection call options',
-                          'md metadata.MD // Global metadata',
-                          'ctx context.Context // Global context',
-                          'conn *grpc.ClientConn // A client connection object']
-        for s in self._services:
-            temp_svc = s.split('/')[-1].split('.')[0][0].upper() + s.split('/')[-1].split('.')[0][1:]
-            temp_lower_svc = s.split('/')[-1].split('.')[0].lower()
-            svc_name = s.split('/')[-1].split('.')[0]
-            client_options.append(f'{temp_lower_svc} {svc_name}.{temp_svc}Client')
-        return '\n\n// \'{0}\' represents the project services facing client side\ntype {0} struct {1}\n\t{2}\n{3}\n\n'.format(self._sylk_json.project.get('packageName'),_OPEN_BRCK,'\n\t'.join(client_options),_CLOSING_BRCK)
-    
-    def write_new(self):
+
+    def write_struct(self, s):
+        client_options = [
+            "host string // Host name should be a valid ip or domain",
+            "port int // Port that been served by the host",
+            "dialOpts []grpc.DialOption // Connection dial options",
+            "callOpts []grpc.CallOption // Connection call options",
+            "md metadata.MD // Global metadata",
+            "ctx context.Context // Global context",
+            "conn *grpc.ClientConn // A client connection object",
+        ]
+        s_name = s.get('name')
+        temp_svc = (
+            s_name[0].upper()
+            + s_name[1:]
+        )
+        temp_lower_svc = s_name.lower()
+        svc_name = s_name
+        svc_ver = parse_version_component(s.get('fullName'))
+        if svc_ver is not None: 
+            svc_ver = f"v{svc_ver.get('version')}{svc_ver.get('channel') if svc_ver.get('channel') is not None else ''}{svc_ver.get('release') if svc_ver.get('release') is not None else ''}"
+            pkg_name = s.get('fullName').split('.')[-3]
+        else:
+            pkg_name = s.get('fullName').split('.')[-2]
+            svc_ver = ''
+        client_options.append(f"{temp_lower_svc} {pkg_name}{svc_ver}.{temp_svc}Client")
+        return "\n\n// '{0}' represents the project services facing client side\ntype {0} struct {1}\n\t{2}\n{3}\n\n".format(
+            svc_name, _OPEN_BRCK, "\n\t".join(client_options), _CLOSING_BRCK
+        )
+
+    def write_new(self, s):
         _list_of_services_clients = []
         _temp_svc_list = []
-        _list_of_client_opts = ['host string','port int','dialOpts []grpc.DialOption','callOpts []grpc.CallOption','md metadata.MD','ctx context.Context']
+        _list_of_client_opts = [
+            "host string",
+            "port int",
+            "dialOpts []grpc.DialOption",
+            "callOpts []grpc.CallOption",
+            "md metadata.MD",
+            "ctx context.Context",
+        ]
         _list_of_client_opts_none_types = []
 
         for i in _list_of_client_opts:
             _list_of_client_opts_none_types.append(i.split()[0])
 
-        for s in self._services:
-            svc_name = s.split('/')[-1].split('.')[0]
-            temp_service = svc_name[0].upper() + svc_name[1:]
-            _list_of_services_clients.append('{0}Client := {1}.New{2}Client(conn)'.format(svc_name.lower(),svc_name,temp_service))
-            _temp_svc_list.append('{0}Client'.format(svc_name.lower()))
-        
-        _new_client_init = ['\n\n\tif len(dialOpts) == 0 {\n\t\tdialOpts = defaultDialOpts\n\t}',
-                            '\n\n\tif host == "" {}\n\t\thost = defaultHost\n\t{}'.format(_OPEN_BRCK,_CLOSING_BRCK),
-                            '\n\n\tif port == 0 {}\n\t\tport = defaultPort\n\t{}'.format(_OPEN_BRCK,_CLOSING_BRCK),
-                            '\n\n\tif md == nil {0}\n\t\tmd = defaultMetadata\n\t{1} else {0}\n\t\tmd = metadata.Join(md, defaultMetadata)\n\t{1}'.format(_OPEN_BRCK,_CLOSING_BRCK),
-                            '\n\n\tif ctx == nil {}\n\t\tctx = defaultCtx\n\t{}'.format(_OPEN_BRCK,_CLOSING_BRCK),
-                            '\n\tctx = metadata.NewOutgoingContext(ctx, md)',
-                            '\n\n\tlog.SetFlags(log.Lshortfile + log.Ltime)',
-                            '\n\n\tconnBuilder := sylkChannel.GrpcConnBuilder{}{}'.format(_OPEN_BRCK,_CLOSING_BRCK),
-                            '\n\n\tconnBuilder.WithContext(ctx)',
-	                        '\n\tconnBuilder.WithOptions(dialOpts...)',
-                            '\n\t// Dailing to client target\n\tconn, err := connBuilder.GetConn(fmt.Sprintf("%s:%d", host, port))',
-                            '\n\tif err != nil {}\n\t\tlog.Fatalf("fail to dial: %v", err)\n\t{}'.format(_OPEN_BRCK,_CLOSING_BRCK),
-                            '\n',
-                            '\n\t'.join(_list_of_services_clients),
-                            '\n\tc := &{0}{1}{2}, conn, {3}{4}'.format(self._project_package,_OPEN_BRCK,', '.join(_list_of_client_opts_none_types),', '.join(_temp_svc_list),_CLOSING_BRCK),
-                            '\n\treturn c']
-        default_client = '// Default returns the standard client used by the project-level services RPC\'s.\nfunc Defualt() *{} {} return std {}'.format(self._project_package,_OPEN_BRCK,_CLOSING_BRCK)
-        return '// Initalize default constants\n\nvar (\n\tdefaultMsgSize  = 1024 * 1024 * 50 // Max Recv / Send message 50MB as default\n\tdefaultHost = "localhost"\n\tdefaultPort = 44880\n\tdefaultDialOpts = []grpc.DialOption{2}\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t\tgrpc.WithDefaultCallOptions(\n\t\t\tgrpc.MaxCallRecvMsgSize(defaultMsgSize),\n\t\t\tgrpc.MaxCallSendMsgSize(defaultMsgSize)),\n\t{4}\n\tdefaultCallOpts = []grpc.CallOption{2}{4}\n\tdefaultMetadata = metadata.Pairs("sylk-project-version","{6}",)\n\tdefaultCtx = context.Background()\n\tstd = New(defaultHost, defaultPort, defaultDialOpts, defaultCallOpts, defaultMetadata, defaultCtx)\n)\n\n{5}\n// Create new client stub\nfunc New({0}) *{1} {2}\n{3}\n{4}'.format(', '.join(_list_of_client_opts),self._project_package,_OPEN_BRCK,''.join(_new_client_init),_CLOSING_BRCK,default_client,self._sylk_json.project.get('version'))
-    
-    def write_methods(self):
+        svc_name = s.get('name')
+        temp_service = svc_name[0].upper() + svc_name[1:]
+        svc_ver = parse_version_component(s.get('fullName'))
+        if svc_ver is not None: 
+            pkg_name = s.get('fullName').split('.')[-3]
+            svc_ver = f"v{svc_ver.get('version')}{svc_ver.get('channel') if svc_ver.get('channel') is not None else ''}{svc_ver.get('release') if svc_ver.get('release') is not None else ''}"
+        else:
+            pkg_name = s.get('fullName').split('.')[-2]
+            svc_ver = ''
+        _list_of_services_clients.append(
+            "{0}Client := {1}{3}.New{2}Client(conn)".format(
+                svc_name.lower(), pkg_name, temp_service, svc_ver
+            )
+        )
+        _temp_svc_list.append("{0}Client".format(svc_name.lower()))
+
+        _new_client_init = [
+            "\n\n\tif len(dialOpts) == 0 {\n\t\tdialOpts = DefaultDialOpts\n\t}",
+            '\n\n\tif host == "" {}\n\t\thost = DefaultHost\n\t{}'.format(
+                _OPEN_BRCK, _CLOSING_BRCK
+            ),
+            "\n\n\tif port == 0 {}\n\t\tport = DefaultPort\n\t{}".format(
+                _OPEN_BRCK, _CLOSING_BRCK
+            ),
+            "\n\n\tif md == nil {0}\n\t\tmd = DefaultMetadata\n\t{1} else {0}\n\t\tmd = metadata.Join(md, DefaultMetadata)\n\t{1}".format(
+                _OPEN_BRCK, _CLOSING_BRCK
+            ),
+            "\n\n\tif ctx == nil {}\n\t\tctx = DefaultCtx\n\t{}".format(
+                _OPEN_BRCK, _CLOSING_BRCK
+            ),
+            "\n\tctx = metadata.NewOutgoingContext(ctx, md)",
+            "\n\n\tlog.SetFlags(log.Lshortfile + log.Ltime)",
+            "\n\n\tconnBuilder := sylkChannel.GrpcConnBuilder{}{}".format(
+                _OPEN_BRCK, _CLOSING_BRCK
+            ),
+            "\n\n\tconnBuilder.WithContext(ctx)",
+            "\n\tconnBuilder.WithOptions(dialOpts...)",
+            '\n\t// Dailing to client target\n\tconn, err := connBuilder.GetConn(fmt.Sprintf("%s:%d", host, port))',
+            '\n\tif err != nil {}\n\t\tlog.Fatalf("fail to dial: %v", err)\n\t{}'.format(
+                _OPEN_BRCK, _CLOSING_BRCK
+            ),
+            "\n",
+            "\n\t".join(_list_of_services_clients),
+            "\n\tc := &{0}{1}{2}, conn, {3}{4}".format(
+                svc_name,
+                _OPEN_BRCK,
+                ", ".join(_list_of_client_opts_none_types),
+                ", ".join(_temp_svc_list),
+                _CLOSING_BRCK,
+            ),
+            "\n\treturn c",
+        ]
+        default_client = "// Default returns the standard client used by the project-level services RPC's.\nfunc Defualt() *{} {} return std {}".format(
+            svc_name, _OPEN_BRCK, _CLOSING_BRCK
+        )
+        return '// Initalize default constants\n\nvar (\n\tDefaultMsgSize  = 1024 * 1024 * 50 // Max Recv / Send message 50MB as default\n\tDefaultHost = "localhost"\n\tDefaultPort = 44880\n\tDefaultDialOpts = []grpc.DialOption{2}\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t\tgrpc.WithDefaultCallOptions(\n\t\t\tgrpc.MaxCallRecvMsgSize(DefaultMsgSize),\n\t\t\tgrpc.MaxCallSendMsgSize(DefaultMsgSize)),\n\t{4}\n\tDefaultCallOpts = []grpc.CallOption{2}{4}\n\tDefaultMetadata = metadata.Pairs("sylk-version","{6}",)\n\tDefaultCtx = context.Background()\n\tstd = New(DefaultHost, DefaultPort, DefaultDialOpts, DefaultCallOpts, DefaultMetadata, DefaultCtx)\n)\n\n{5}\n// Create new client stub\nfunc New({0}) *{1} {2}\n{3}\n{4}'.format(
+            ", ".join(_list_of_client_opts),
+            svc_name,
+            _OPEN_BRCK,
+            "".join(_new_client_init),
+            _CLOSING_BRCK,
+            default_client,
+            __version__.__version__,
+        )
+
+    def write_methods(self, s):
         list_of_rpcs = []
-        for s in self._services:
-            svc = self._services[s]
-            svc_name = s.split('/')[-1].split('.')[0]
-            for r in svc.get('methods'):
-                rpc_msg_in_pkg = r.get('inputType').split('.')[1]
-                rpc_msg_input_type = r.get('inputType').split('.')[-1][0].upper() + r.get('inputType').split('.')[-1][1:]
-                if 'google.protobuf' in r.get('inputType'):
-                    well_known = r.get('inputType').split('.')[-1].lower()
-                    rpc_msg_in_pkg = f'{well_known}pb'
-                rpc_msg_out_pkg = r.get('outputType').split('.')[1]
-                rpc_msg_output_type = r.get('outputType').split('.')[-1][0].upper() + r.get('outputType').split('.')[-1][1:]
-                if  'google.protobuf' in r.get('outputType'):
-                    well_known = r.get('outputType').split('.')[-1].lower()
-                    rpc_msg_out_pkg = f'{well_known}pb'
-                rpc_client_stream = r.get('clientStreaming') if r.get('clientStreaming') is not None else False
-                rpc_server_stream = r.get('serverStreaming') if r.get('serverStreaming') is not None else False
-                rpc_name = r.get('name')[0].upper() + r.get('name')[1:]
-                # Unary
-                if rpc_server_stream == False and rpc_client_stream == False:
-                    list_of_rpcs.append('\n\n// [sylk.build] - {10}.{1}\n// Description: {9}\n// Read: https://www.sylk.build/docs/go/unary-call\nfunc (c *{0}) {1}(message *{2}.{3}) (*{7}.{8}, metadata.MD, metadata.MD) {4}\n\tlog.Printf("Calling {1} %v", message)\n\n\tctx, cancel := context.WithTimeout(c.ctx, 10*time.Second)\n\n\tdefer cancel()\n\n\tvar header, trailer metadata.MD\n\n\tresponse, err := c.{5}.{1}(ctx, message, grpc.Header(&header), grpc.Trailer(&trailer))\n\n\tif err != nil {4}\n\t\tlog.Fatalf("Client call {1} failed: %v", err)\n\t{6}\n\n\treturn response, header, trailer\n{6}'.format(self._project_package,rpc_name,rpc_msg_in_pkg,rpc_msg_input_type,_OPEN_BRCK,svc_name.lower(),_CLOSING_BRCK,rpc_msg_out_pkg,rpc_msg_output_type,r.get('description'),s))
-                # Client stream
-                elif rpc_client_stream == True and rpc_server_stream == False:
-                    list_of_rpcs.append('\n\n// [sylk.build] - {10}.{1}\n// Description: {9}\n// Read: https://www.sylk.build/docs/go/client-stream\nfunc (c *{0}) {1}(messages []*{2}.{3}) *{7}.{8} {4}\n\tlog.Printf("Calling {1} %v", messages)\n\n\tctx, cancel := context.WithTimeout(c.ctx, 10*time.Second)\n\n\tdefer cancel()\n\n\tstream, err := c.{5}.{1}(ctx)\n\n\tif err != nil {4}\n\t\tlog.Fatalf("Client call {1} failed: %v", err)\n\t{6}\n\n\tfor _, message := range messages {4}\n\t\tif err := stream.Send(message); err != nil {4}\n\t\t\tlog.Fatalf("Client sending message %v stream failed: %v", message, err)\n\t\t{6}\n\t{6}\n\tresponse, err := stream.CloseAndRecv()\n\tif err != nil {4}\n\t\tlog.Fatalf("Client stream failed on getting response: %v", err)\n\t{6}\n\n\treturn response\n{6}'.format(self._project_package,rpc_name,rpc_msg_in_pkg,rpc_msg_input_type,_OPEN_BRCK,svc_name.lower(),_CLOSING_BRCK,rpc_msg_out_pkg,rpc_msg_output_type,r.get('description'),s))
-                # Server stream
-                elif rpc_client_stream == False and rpc_server_stream == True:
-                    list_of_rpcs.append('\n\n// sylk.build - {10}.{1}\n// Description: {9}\n// Read: https://www.sylk.build/docs/go/server-stream\nfunc (c *{0}) {1}(message *{2}.{3}) []*{7}.{8} {4}\n\tlog.Printf("Calling {1} %v", message)\n\n\tctx, cancel := context.WithTimeout(c.ctx, 10*time.Second)\n\n\tdefer cancel()\n\n\tstream, err := c.{5}.{1}(ctx, message)\n\n\tif err != nil {4}\n\t\tlog.Fatalf("Client call {1} failed: %v", err)\n\t{6}\n\n\tvar listResponses []*{7}.{8}\n\n\twaitc := make(chan struct{4}{6})\n\n\tgo func() {4}\n\t\tfor {4}\n\t\t\t{8}, err := stream.Recv()\n\t\t\tif err == io.EOF {4}\n\t\t\t\tclose(waitc)\n\t\t\t\tbreak\n\t\t\t{6}\n\t\t\tif err != nil {4}\n\t\t\t\tlog.Fatalf("Client call {1} stream message failed: %v", err)\n\t\t\t{6}\n\t\t\tlistResponses = append(listResponses, {8})\n\t\t{6}\n\t{6}()\n\t<-waitc\n\treturn listResponses\n{6}'.format(self._project_package,rpc_name,rpc_msg_in_pkg,rpc_msg_input_type,_OPEN_BRCK,svc_name.lower(),_CLOSING_BRCK,rpc_msg_out_pkg,rpc_msg_output_type,r.get('description'),s))
-                # BidiStream
-                elif rpc_client_stream and rpc_server_stream:
-                    list_of_rpcs.append('\n\n// sylk.build - {10}.{1}\n// Description: {9}\n// Read: https://www.sylk.build/docs/go/bidi-stream\nfunc (c *{0}) {1}(messages []*{2}.{3}) []*{7}.{8} {4}\n\tlog.Printf("Calling {1} %v", message)\n\n\tctx, cancel := context.WithTimeout(c.ctx, 10*time.Second)\n\n\tdefer cancel()\n\n\tstream, err := c.{5}.{1}(ctx)\n\n\tif err != nil {4}\n\t\tlog.Fatalf("Client call {1} failed: %v", err)\n\t{6}\n\n\tvar listResponses []*{7}.{8}\n\n\twaitc := make(chan struct{4}{6})\n\n\tgo func() {4}\n\t\tfor {4}\n\t\t\t{8}, err := stream.Recv()\n\t\t\tif err == io.EOF {4}\n\t\t\t\tclose(waitc)\n\t\t\t\tbreak\n\t\t\t{6}\n\t\t\tif err != nil {4}\n\t\t\t\tlog.Fatalf("Client call {1} stream message failed: %v", err)\n\t\t\t{6}\n\t\t\tlistResponses = append(listResponses, {8})\n\t\t{6}\n\t{6}()\n\tfor _, message := range messages {4}\n\t\tif err := stream.Send(message); err != nil {4}\n\t\t\tlog.Fatalf("Client.{1} stream.Send(%v) failed: %v", message, err)\n\t\t{6}\n\t{6}\n\tstream.CloseSend()\n\t<-waitc\n\treturn listResponses\n{6}'.format(self._project_package,rpc_name,rpc_msg_in_pkg,rpc_msg_input_type,_OPEN_BRCK,svc_name.lower(),_CLOSING_BRCK,rpc_msg_out_pkg,rpc_msg_output_type,r.get('description'),s))
+        svc = s
+        svc_name = s.get('name')
+        for r in svc.get("methods"):
+            ref_node = self._sylk_json._proto_tree._find_node(r.get("inputType"),self._sylk_json._proto_tree.root)
+            ref_node_parent = self._sylk_json._proto_tree.get_parent(ref_node.full_path)
+            pkg_ver = parse_version_component(ref_node_parent.full_path)
+            if pkg_ver is not None:
+                ref_node_parent = self._sylk_json._proto_tree.get_parent(ref_node_parent.full_path)
+                rpc_msg_in_pkg = ref_node_parent.name + f'v{pkg_ver.get("version")}{pkg_ver.get("channel") if pkg_ver.get("channel") is not None else ""}{pkg_ver.get("release") if pkg_ver.get("release") is not None else ""}'
+            else:
+                rpc_msg_in_pkg = ref_node_parent.full_path.split('.')[-1]
+            
+            rpc_msg_input_type = (
+                r.get("inputType").split(".")[-1][0].upper()
+                + r.get("inputType").split(".")[-1][1:]
+            )
+            if "google.protobuf" in r.get("inputType"):
+                well_known = r.get("inputType").split(".")[-1].lower()
+                rpc_msg_in_pkg = f"{well_known}pb"
+            ref_node = self._sylk_json._proto_tree._find_node(r.get("outputType"),self._sylk_json._proto_tree.root)
+            ref_node_parent = self._sylk_json._proto_tree.get_parent(ref_node.full_path)
+            pkg_ver = parse_version_component(ref_node_parent.full_path)
+            if pkg_ver is not None:
+                ref_node_parent = self._sylk_json._proto_tree.get_parent(ref_node_parent.full_path)
+                rpc_msg_out_pkg = ref_node_parent.name + f'v{pkg_ver.get("version")}{pkg_ver.get("channel") if pkg_ver.get("channel") is not None else ""}{pkg_ver.get("release") if pkg_ver.get("release") is not None else ""}'
+            else:
+                rpc_msg_out_pkg = ref_node_parent.full_path.split('.')[-1]
+            
+            rpc_msg_output_type = (
+                r.get("outputType").split(".")[-1][0].upper()
+                + r.get("outputType").split(".")[-1][1:]
+            )
+            if "google.protobuf" in r.get("outputType"):
+                well_known = r.get("outputType").split(".")[-1].lower()
+                rpc_msg_out_pkg = f"{well_known}pb"
+            rpc_client_stream = (
+                r.get("clientStreaming")
+                if r.get("clientStreaming") is not None
+                else False
+            )
+            rpc_server_stream = (
+                r.get("serverStreaming")
+                if r.get("serverStreaming") is not None
+                else False
+            )
+            rpc_name = r.get("name")[0].upper() + r.get("name")[1:]
+            # Unary
+            if rpc_server_stream == False and rpc_client_stream == False:
+                list_of_rpcs.append(
+                    '\n\n// [sylk.build] - {10}.{1}\n// Description: {9}\n// Read: https://www.sylk.build/docs/go/unary-call\nfunc (c *{0}) {1}(message *{2}.{3}) (*{7}.{8}, metadata.MD, metadata.MD) {4}\n\tlog.Printf("Calling {1} %v", message)\n\n\tctx, cancel := context.WithTimeout(c.ctx, 10*time.Second)\n\n\tdefer cancel()\n\n\tvar header, trailer metadata.MD\n\n\tresponse, err := c.{5}.{1}(ctx, message, grpc.Header(&header), grpc.Trailer(&trailer))\n\n\tif err != nil {4}\n\t\tlog.Printf("Client call {1} failed: %v", err)\n\t{6}\n\n\treturn response, header, trailer\n{6}'.format(
+                        svc_name,
+                        rpc_name,
+                        rpc_msg_in_pkg,
+                        rpc_msg_input_type,
+                        _OPEN_BRCK,
+                        svc_name.lower(),
+                        _CLOSING_BRCK,
+                        rpc_msg_out_pkg,
+                        rpc_msg_output_type,
+                        r.get("description"),
+                        s.get('fullName'),
+                    )
+                )
+            # Client stream
+            elif rpc_client_stream == True and rpc_server_stream == False:
+                list_of_rpcs.append(
+                    '\n\n// [sylk.build] - {10}.{1}\n// Description: {9}\n// Read: https://www.sylk.build/docs/go/client-stream\nfunc (c *{0}) {1}(messages []*{2}.{3}) *{7}.{8} {4}\n\tlog.Printf("Calling {1} %v", messages)\n\n\tctx, cancel := context.WithTimeout(c.ctx, 10*time.Second)\n\n\tdefer cancel()\n\n\tstream, err := c.{5}.{1}(ctx)\n\n\tif err != nil {4}\n\t\tlog.Printf("Client call {1} failed: %v", err)\n\t{6}\n\n\tfor _, message := range messages {4}\n\t\tif err := stream.Send(message); err != nil {4}\n\t\t\tlog.Printf("Client sending message %v stream failed: %v", message, err)\n\t\t{6}\n\t{6}\n\tresponse, err := stream.CloseAndRecv()\n\tif err != nil {4}\n\t\tlog.Printf("Client stream failed on getting response: %v", err)\n\t{6}\n\n\treturn response\n{6}'.format(
+                        svc_name,
+                        rpc_name,
+                        rpc_msg_in_pkg,
+                        rpc_msg_input_type,
+                        _OPEN_BRCK,
+                        svc_name.lower(),
+                        _CLOSING_BRCK,
+                        rpc_msg_out_pkg,
+                        rpc_msg_output_type,
+                        r.get("description"),
+                        s.get('fullName'),
+                    )
+                )
+            # Server stream
+            elif rpc_client_stream == False and rpc_server_stream == True:
+                list_of_rpcs.append(
+                    '\n\n// sylk.build - {10}.{1}\n// Description: {9}\n// Read: https://www.sylk.build/docs/go/server-stream\nfunc (c *{0}) {1}(message *{2}.{3}) []*{7}.{8} {4}\n\tlog.Printf("Calling {1} %v", message)\n\n\tctx, cancel := context.WithTimeout(c.ctx, 10*time.Second)\n\n\tdefer cancel()\n\n\tstream, err := c.{5}.{1}(ctx, message)\n\n\tif err != nil {4}\n\t\tlog.Printf("Client call {1} failed: %v", err)\n\t{6}\n\n\tvar listResponses []*{7}.{8}\n\n\twaitc := make(chan struct{4}{6})\n\n\tgo func() {4}\n\t\tfor {4}\n\t\t\t{8}, err := stream.Recv()\n\t\t\tif err == io.EOF {4}\n\t\t\t\tclose(waitc)\n\t\t\t\tbreak\n\t\t\t{6}\n\t\t\tif err != nil {4}\n\t\t\t\tlog.Printf("Client call {1} stream message failed: %v", err)\n\t\t\t{6}\n\t\t\tlistResponses = append(listResponses, {8})\n\t\t{6}\n\t{6}()\n\t<-waitc\n\treturn listResponses\n{6}'.format(
+                        svc_name,
+                        rpc_name,
+                        rpc_msg_in_pkg,
+                        rpc_msg_input_type,
+                        _OPEN_BRCK,
+                        svc_name.lower(),
+                        _CLOSING_BRCK,
+                        rpc_msg_out_pkg,
+                        rpc_msg_output_type,
+                        r.get("description"),
+                        s.get('fullName'),
+                    )
+                )
+            # BidiStream
+            elif rpc_client_stream and rpc_server_stream:
+                list_of_rpcs.append(
+                    '\n\n// sylk.build - {10}.{1}\n// Description: {9}\n// Read: https://www.sylk.build/docs/go/bidi-stream\nfunc (c *{0}) {1}(messages []*{2}.{3}) []*{7}.{8} {4}\n\tlog.Printf("Calling {1} %v", message)\n\n\tctx, cancel := context.WithTimeout(c.ctx, 10*time.Second)\n\n\tdefer cancel()\n\n\tstream, err := c.{5}.{1}(ctx)\n\n\tif err != nil {4}\n\t\tlog.Printf("Client call {1} failed: %v", err)\n\t{6}\n\n\tvar listResponses []*{7}.{8}\n\n\twaitc := make(chan struct{4}{6})\n\n\tgo func() {4}\n\t\tfor {4}\n\t\t\t{8}, err := stream.Recv()\n\t\t\tif err == io.EOF {4}\n\t\t\t\tclose(waitc)\n\t\t\t\tbreak\n\t\t\t{6}\n\t\t\tif err != nil {4}\n\t\t\t\tlog.Printf("Client call {1} stream message failed: %v", err)\n\t\t\t{6}\n\t\t\tlistResponses = append(listResponses, {8})\n\t\t{6}\n\t{6}()\n\tfor _, message := range messages {4}\n\t\tif err := stream.Send(message); err != nil {4}\n\t\t\tlog.Printf("Client.{1} stream.Send(%v) failed: %v", message, err)\n\t\t{6}\n\t{6}\n\tstream.CloseSend()\n\t<-waitc\n\treturn listResponses\n{6}'.format(
+                        svc_name,
+                        rpc_name,
+                        rpc_msg_in_pkg,
+                        rpc_msg_input_type,
+                        _OPEN_BRCK,
+                        svc_name.lower(),
+                        _CLOSING_BRCK,
+                        rpc_msg_out_pkg,
+                        rpc_msg_output_type,
+                        r.get("description"),
+                        s.get('fullName'),
+                    )
+                )
 
+        return "\n\n".join(list_of_rpcs)
 
-        return '\n\n'.join(list_of_rpcs)
 
-class SylkServiceGo():
+class SylkServiceGo:
     """A helper class to write 'Go' language services for sylk.build project services"""
-    
-    def __init__(self, project_package, name, imports=[], service=None, package=None, messages=[], enums=[], context: SylkContext = None,sylk_json: SylkJson= None):
+
+    def __init__(
+        self,
+        project_package,
+        name,
+        imports=[],
+        service=None,
+        package=None,
+        messages=[],
+        enums=[],
+        context: SylkContext = None,
+        sylk_json: SylkJson = None,
+    ):
         self._name = name
         self._imports = imports
         self._service = service
         self._project_package = project_package
         self._context = context
         self._sylk_json = sylk_json
+        self._service_name = self._name.split("/")[-1].split(".")[0]
+        self._service_path = ".".join(self._name.split("/")[:-1])
 
     def write_imports(self):
-        if self._imports is not None:
-            list_d = list(map(lambda i: i, _WELL_KNOWN_GO_IMPORTS))
-            go_package_name = self._sylk_json.project.get('goPackage')
-            # list_d.append('codes "google.golang.org/grpc/codes"')
-            # list_d.append('status "google.golang.org/grpc/status"')
-            name = self._name.split('/')[-1].split('.')[0]
-            path = '/'.join(self._name.split('/')[:-1])
-            list_d.append(f'{name}Servicer "{go_package_name}/services/{path}"')
-            list_d.append(f'"{go_package_name}/services/utils"')
-
-            for d in self._imports:
-                if 'google.protobuf.' in d:
-                    name = d.split('.')[-1]
-                    d_name = '{0}'.format(name).lower()
-                    list_d.append(f'"google.golang.org/protobuf/types/known/{d_name}pb"')
-                else:
-                    name = d.split('.')[1]
-                    d_name = '{0}'.format(name)
-                    d_path = self._sylk_json.get_path(d.split('.')[0],d.split('.')[1],d.split('.')[2])
-                    path = '/'.join(d_path.split('/')[:-1])
-                    list_d.append(f'{d_name} "{go_package_name}/services/{path}"')
-
-            list_d = '\n\t'.join(list_d)
-            return f'{list_d}'
+        list_d = list(map(lambda i: i, _WELL_KNOWN_GO_IMPORTS))
+        parent = self._sylk_json._proto_tree.get_parent(self._service.get('fullName'))
+        refs = self._sylk_json._proto_tree.get_parents_refs([self._service.get('fullName')])
+        
+        deps = self._sylk_json._proto_tree.get_references(self._service.get('fullName'))
+       
+        pkg_ver = self._sylk_json._proto_tree._parse_version_component(parent.full_path)
+        if pkg_ver is not None:
+            pkg_ver = f'v{pkg_ver.get("version")}{pkg_ver.get("channel","") if pkg_ver.get("channel","") is not None else ""}{pkg_ver.get("release","") if pkg_ver.get("release","") is not None else ""}'
+            pkg_name = parent.full_path.split('.')[-2]
         else:
-            return ''
+            pkg_ver = ''
+            pkg_name = parent.name
+        module_name = pkg_name if self._service.get('tag') is None and self._service.get('tag') != '' else self._service.get('tag')
+        base_protos = self._sylk_json._root_protos.replace('/','.')
+        go_package_name = self._sylk_json.project.get("goPackage")
+        
+        for d in deps:
+            if d.split('.')[0] == self._sylk_json._proto_tree.root.name:
+                root = self._sylk_json._proto_tree.root
+                dep_parent = self._sylk_json._proto_tree.get_parent(d)
+                base_path = f'{go_package_name}/services/' if self._sylk_json._root_protos is None or self._sylk_json._root_protos == '' else f'{go_package_name}/services/{base_protos}/'
+                msg_dep =self._sylk_json._proto_tree._find_node(d,root) 
+                dep_mod_version = parse_version_component(dep_parent.full_path)
+                if dep_mod_version is not None:
+                    channel = dep_mod_version.get("channel","") if dep_mod_version.get("channel") is not None else ''
+                    release = dep_mod_version.get("release","") if dep_mod_version.get("release") is not None else ''
+                    dep_mod_version = f'v{dep_mod_version.get("version")}{channel}{release}'
+                    temp_name = dep_parent.full_path.split('.')[-2]
+                else:
+                    temp_name = dep_parent.name
+                    dep_mod_version = ''
+                dep_mod_name = temp_name if msg_dep.properties.get('tag') is None or msg_dep.properties.get('tag') == '' else msg_dep.properties.get('tag')
+                imp_path = f'{dep_mod_name}{dep_mod_version} "{base_path}{dep_parent.full_path.replace(".","/")}"'
+            else:
+                root = self._sylk_json._proto_tree.proto_modules[d.split('.')[0]].root
+                dep_parent = self._sylk_json._proto_tree.proto_modules[d.split('.')[0]].get_parent(d)
+                msg_dep =self._sylk_json._proto_tree._find_node(d,root) 
+                dep_parent_version = parse_version_component(dep_parent.full_path)
+                if dep_parent_version is not None:
+                    channel = dep_mod_version.get("channel","") if dep_mod_version.get("channel") is not None else ''
+                    release = dep_mod_version.get("release","") if dep_mod_version.get("release") is not None else ''
+                    dep_mod_version = f'v{dep_mod_version.get("version")}{channel}{release}'
+                    temp_name = dep_parent.full_path.split('.')[-2]
+                else:
+                    temp_name = dep_parent.name
+                    dep_mod_version = ""
+                dep_mod_name = temp_name if msg_dep.properties.get('tag') is None or msg_dep.properties.get('tag') == '' else msg_dep.properties.get('tag')
+                imp_path = f'{dep_mod_name}{dep_parent_version} "{dep_parent.full_path.replace(".","/")}"'
+            if imp_path not in list_d:
+                list_d.append(
+                    imp_path
+                )
+        base_path = f'{go_package_name}/services/' if self._sylk_json._root_protos is None or self._sylk_json._root_protos == '' else f'{go_package_name}/services/{base_protos}/'
+        imp_path = f'{module_name}{pkg_ver} "{base_path}{parent.full_path.replace(".","/")}"'
+        if imp_path not in list_d:
+            list_d.append(
+                    imp_path
+                )
+        list_d = "\n".join(list_d)
+        return f"{list_d}"
+        # # 
+        # if self._imports is not None:
+        #     go_package_name = self._sylk_json.project.get("goPackage")
+        #     name = self._name.split("/")[-1].split(".")[0]
+        #     path = "/".join(self._name.split("/")[:-1])
+        #     ver = self._name.split("/")[-2]
+        #     list_d.append(f'{name}{ver} "{go_package_name}/services/{path}"')
+        #     list_d.append(f'"{go_package_name}/services/utils"')
+
+        #     for d in self._imports:
+        #         if "google.protobuf." in d:
+        #             name = d.split(".")[-1]
+        #             d_name = "{0}".format(name).lower()
+        #             list_d.append(
+        #                 f'"google.golang.org/protobuf/types/known/{d_name}pb"'
+        #             )
+        #         else:
+        #             name = d.split(".")[1]
+        #             d_name = "{0}".format(name)
+        #             d_path = self._sylk_json.get_path(
+        #                 d.split(".")[0], d.split(".")[1], d.split(".")[2]
+        #             )
+        #             path = "/".join(d_path.split("/")[:-1])
+        #             d_ver = d.split(".")[2]
+        #             list_d.append(
+        #                 f'{d_name}{d_ver} "{go_package_name}/services/{path}"'
+        #             )
+
+        #     list_d = "\n\t".join(list_d)
+        #     return f"{list_d}"
+        # else:
+        #     # When service is standalone we need to make sure that the defaults packages are imported
+        #     go_package_name = self._sylk_json.project.get("goPackage")
+        #     name = self._name.split("/")[-1].split(".")[0]
+        #     path = "/".join(self._name.split("/")[:-1])
+        #     ver = self._name.split("/")[-2]
+        #     list_d.append(f'{name}{ver} "{go_package_name}/services/{path}"')
+        #     list_d.append(f'"{go_package_name}/services/utils"')
+        #     list_d = "\n\t".join(list_d)
+        #     return f"{list_d}"
 
     def write_struct(self):
-        name = self._name.split('/')[-1].split('.')[0]
+        ver = parse_version_component(self._service.get('fullName'))
+        if ver is not None:
+            ver = f'v{ver.get("version")}{ver.get("channel") if ver.get("channel") is not None else ""}{ver.get("release") if ver.get("release") is not None else ""}'
+        else:
+            ver = ''
+        name = self._name
         temp_name = name[0].capitalize() + name[1:]
-
-        return 'type {0} struct {1}\n\t{3}Servicer.Unimplemented{0}Server\n{2}'.format(temp_name,_OPEN_BRCK,_CLOSING_BRCK,name)
+        return "type {0} struct {1}\n\t{3}{4}.Unimplemented{0}Server\n{2}".format(
+            temp_name, _OPEN_BRCK, _CLOSING_BRCK, name, ver
+        )
 
     def write_methods(self):
-        name = self._name.split('/')[-1].split('.')[0]
+        name = self._name.split("/")[-1].split(".")[0]
         temp_name = name[0].capitalize() + name[1:]
         list_of_rpcs = []
-        for rpc in self._service.get('methods'):
-            rpc_temp_name = rpc.get('name')[0].capitalize() + rpc.get('name')[1:]
-            rpc_output_type = rpc.get('serverStreaming') if rpc.get('serverStreaming') is not None else False
-            rpc_input_type = rpc.get('clientStreaming') if rpc.get('clientStreaming') is not None else False
-            rpc_input_name = rpc.get('inputType').split('.')[-1]
-            if 'google.protobuf.' in rpc.get('inputType'):
-                rpc_input_package_name = '{0}pb'.format(rpc.get('inputType').split('.')[-1]).lower()
-            else:
-                rpc_input_package_name = rpc.get('inputType').split('.')[1]
-            rpc_output_name = rpc.get('outputType').split('.')[-1]
-            if 'google.protobuf.' in rpc.get('outputType'):
-                rpc_output_package_name = '{0}pb'.format(rpc.get('outputType').split('.')[-1]).lower()
+        for rpc in self._service.get("methods"):
+            rpc_temp_name = rpc.get("name")[0].capitalize() + rpc.get("name")[1:]
+            rpc_output_type = (
+                rpc.get("serverStreaming")
+                if rpc.get("serverStreaming") is not None
+                else False
+            )
+            rpc_input_type = (
+                rpc.get("clientStreaming")
+                if rpc.get("clientStreaming") is not None
+                else False
+            )
+            rpc_input_name = rpc.get("inputType").split(".")[-1]
+            if "google.protobuf." in rpc.get("inputType"):
+                rpc_input_package_name = "{0}pb".format(
+                    rpc.get("inputType").split(".")[-1]
+                ).lower()
             else:
-                rpc_output_package_name = rpc.get('outputType').split('.')[1]
+                rpc_input_package_name = (
+                    rpc.get("inputType").split(".")[1]
+                    + rpc.get("inputType").split(".")[2]
+                )
+            rpc_output_name = rpc.get("outputType").split(".")[-1]
+            if "google.protobuf." in rpc.get("outputType"):
+                rpc_output_package_name = "{0}pb".format(
+                    rpc.get("outputType").split(".")[-1]
+                ).lower()
+            else:
+                rpc_output_package_name = (
+                    rpc.get("outputType").split(".")[1]
+                    + rpc.get("outputType").split(".")[2]
+                )
             temp_go_rpc_input_name = rpc_input_name[0].capitalize() + rpc_input_name[1:]
-            temp_go_rpc_output_name = rpc_output_name[0].capitalize() + rpc_output_name[1:]
-            rpc_description = rpc.get('description')
-            
+            temp_go_rpc_output_name = (
+                rpc_output_name[0].capitalize() + rpc_output_name[1:]
+            )
+            rpc_description = rpc.get("description")
+
             # Unary
             if rpc_output_type == False and rpc_input_type == False:
-                list_of_rpcs.append('\n'.join([
-                    f'\n\n// [sylk.build] - {name}.{rpc_temp_name} - {rpc_description}',
-                    f'func ({name}Servicer *{temp_name}) {rpc_temp_name}(ctx context.Context, {rpc_input_name} *{rpc_input_package_name}.{temp_go_rpc_input_name}) (response *{rpc_output_package_name}.{temp_go_rpc_output_name}, err error) {_OPEN_BRCK}',
-                    f'\tprintLog("{rpc_temp_name}",ctx, {rpc_input_name})',
-                    f'\treturn &{rpc_output_package_name}.{temp_go_rpc_output_name}{_OPEN_BRCK}{_CLOSING_BRCK}, nil',
-                    f'{_CLOSING_BRCK}'
-                    ]))
+                list_of_rpcs.append(
+                    "\n".join(
+                        [
+                            f"\n\n// [sylk.build] - {name}.{rpc_temp_name} - {rpc_description}",
+                            f"func ({name}Servicer *{temp_name}) {rpc_temp_name}(ctx context.Context, {rpc_input_name} *{rpc_input_package_name}.{temp_go_rpc_input_name}) (response *{rpc_output_package_name}.{temp_go_rpc_output_name}, err error) {_OPEN_BRCK}",
+                            f'\tprintLog("{rpc_temp_name}",ctx, {rpc_input_name})',
+                            f"\treturn &{rpc_output_package_name}.{temp_go_rpc_output_name}{_OPEN_BRCK}{_CLOSING_BRCK}, nil",
+                            f"{_CLOSING_BRCK}",
+                        ]
+                    )
+                )
             # Client stream
             elif rpc_input_type == True and rpc_output_type == False:
-                list_of_rpcs.append('\n'.join([
-                    f'\n\n// [sylk.build] - {name}.{rpc_temp_name} - {rpc_description}',
-                    f'func ({name}Servicer *{temp_name}) {rpc_temp_name}(stream {name}Servicer.{temp_name}_{rpc_temp_name}Server) (err error) {_OPEN_BRCK}',
-                    f'\tprintLog("{rpc_temp_name}",stream.Context(), nil)',
-                    f'\tfor {_OPEN_BRCK}',
-                    f'\t\tclientStreamRequest, err := stream.Recv()',
-                    f'\t\tif err == io.EOF {_OPEN_BRCK}',
-                    f'\t\t\tutils.ErrorLogger.Printf("[{rpc_temp_name}] Client stream closed.")',
-                    f'\t\t\tbreak',
-                    f'\t\t{_CLOSING_BRCK}',
-                    f'\t\tif err != nil {_OPEN_BRCK}',
-                    f'\t\t\tutils.ErrorLogger.Printf("[{rpc_temp_name}] Client stream Request error: \'%v\'.", err)',
-                    f'\t\t\treturn stream.SendAndClose(&{rpc_output_package_name}.{temp_go_rpc_output_name}{_OPEN_BRCK}{_CLOSING_BRCK})',
-                    f'\t\t{_CLOSING_BRCK}',
-                    f'\t\t// Do something with incoming object',
-                    f'\t\tutils.InfoLogger.Printf("[{rpc_temp_name}] Request received: \'%v\'.", clientStreamRequest)',
-                    f'\t{_CLOSING_BRCK}',
-                    f'\treturn stream.SendAndClose(&{rpc_output_package_name}.{temp_go_rpc_output_name}{_OPEN_BRCK}{_CLOSING_BRCK})',
-                    f'{_CLOSING_BRCK}',
-                ]))
+                list_of_rpcs.append(
+                    "\n".join(
+                        [
+                            f"\n\n// [sylk.build] - {name}.{rpc_temp_name} - {rpc_description}",
+                            f"func ({name}Servicer *{temp_name}) {rpc_temp_name}(stream {name}Servicer.{temp_name}_{rpc_temp_name}Server) (err error) {_OPEN_BRCK}",
+                            f'\tprintLog("{rpc_temp_name}",stream.Context(), nil)',
+                            f"\tfor {_OPEN_BRCK}",
+                            f"\t\tclientStreamRequest, err := stream.Recv()",
+                            f"\t\tif err == io.EOF {_OPEN_BRCK}",
+                            f'\t\t\tutils.ErrorLogger.Printf("[{rpc_temp_name}] Client stream closed.")',
+                            f"\t\t\tbreak",
+                            f"\t\t{_CLOSING_BRCK}",
+                            f"\t\tif err != nil {_OPEN_BRCK}",
+                            f"\t\t\tutils.ErrorLogger.Printf(\"[{rpc_temp_name}] Client stream Request error: '%v'.\", err)",
+                            f"\t\t\treturn stream.SendAndClose(&{rpc_output_package_name}.{temp_go_rpc_output_name}{_OPEN_BRCK}{_CLOSING_BRCK})",
+                            f"\t\t{_CLOSING_BRCK}",
+                            f"\t\t// Do something with incoming object",
+                            f"\t\tutils.InfoLogger.Printf(\"[{rpc_temp_name}] Request received: '%v'.\", clientStreamRequest)",
+                            f"\t{_CLOSING_BRCK}",
+                            f"\treturn stream.SendAndClose(&{rpc_output_package_name}.{temp_go_rpc_output_name}{_OPEN_BRCK}{_CLOSING_BRCK})",
+                            f"{_CLOSING_BRCK}",
+                        ]
+                    )
+                )
             # Server stream
             elif rpc_input_type == False and rpc_output_type == True:
-                list_of_rpcs.append('\n'.join([
-                    f'\n\n// [sylk.build] - {name}.{rpc_temp_name} - {rpc_description}',
-                    f'func ({name}Servicer *{temp_name}) {rpc_temp_name}({rpc_input_name} *{rpc_input_package_name}.{temp_go_rpc_input_name}, stream {name}Servicer.{temp_name}_{rpc_temp_name}Server) (err error) {_OPEN_BRCK}',
-                    f'\tprintLog("{rpc_temp_name}",stream.Context(), nil)',
-                    f'\t// Do loop for responses',
-                    f'\treturn nil',
-                    f'{_CLOSING_BRCK}',
-                ]))
+                list_of_rpcs.append(
+                    "\n".join(
+                        [
+                            f"\n\n// [sylk.build] - {name}.{rpc_temp_name} - {rpc_description}",
+                            f"func ({name}Servicer *{temp_name}) {rpc_temp_name}({rpc_input_name} *{rpc_input_package_name}.{temp_go_rpc_input_name}, stream {name}Servicer.{temp_name}_{rpc_temp_name}Server) (err error) {_OPEN_BRCK}",
+                            f'\tprintLog("{rpc_temp_name}",stream.Context(), nil)',
+                            f"\t// Do loop for responses",
+                            f"\treturn nil",
+                            f"{_CLOSING_BRCK}",
+                        ]
+                    )
+                )
             # BidiStream
             elif rpc_input_type and rpc_output_type:
+                list_of_rpcs.append(
+                    "\n".join(
+                        [
+                            f"\n\n// [sylk.build] - {name}.{rpc_temp_name} - {rpc_description}",
+                            f"func ({name}Servicer *{temp_name}) {rpc_temp_name}(stream {name}Servicer.{temp_name}_{rpc_temp_name}Server) (err error) {_OPEN_BRCK}",
+                            f'\tprintLog("{rpc_temp_name}",stream.Context(), nil)',
+                            f"\tfor {_OPEN_BRCK}",
+                            f"\t\tbidirectionalStreamRequest, err := stream.Recv()",
+                            f"\t\tif err == io.EOF {_OPEN_BRCK}",
+                            f'\t\t\tutils.ErrorLogger.Printf("[{rpc_temp_name}] Client stream closed.")',
+                            f"\t\t\tbreak",
+                            f"\t\t{_CLOSING_BRCK}",
+                            f"\t\tif err != nil {_OPEN_BRCK}",
+                            f"\t\t\tutils.ErrorLogger.Printf(\"[{rpc_temp_name}] Client stream Request error: '%v'.\", err)",
+                            f"\t\t\treturn stream.Send(&{rpc_output_package_name}.{temp_go_rpc_output_name}{_OPEN_BRCK}{_CLOSING_BRCK})",
+                            f"\t\t{_CLOSING_BRCK}",
+                            f"\t\t// Do something with incoming object",
+                            f"\t\tutils.InfoLogger.Printf(\"[{rpc_temp_name}] Request received: '%v'.\", bidirectionalStreamRequest)",
+                            f"\t\tstream.Send(&{rpc_output_package_name}.{temp_go_rpc_output_name}{_OPEN_BRCK}{_CLOSING_BRCK})",
+                            f"\t{_CLOSING_BRCK}",
+                            "\treturn nil",
+                            f"{_CLOSING_BRCK}",
+                        ]
+                    )
+                )
 
-                list_of_rpcs.append('\n'.join([
-                    f'\n\n// [sylk.build] - {name}.{rpc_temp_name} - {rpc_description}',
-                    f'func ({name}Servicer *{temp_name}) {rpc_temp_name}(stream {name}Servicer.{temp_name}_{rpc_temp_name}Server) (err error) {_OPEN_BRCK}',
-                    f'\tprintLog("{rpc_temp_name}",stream.Context(), nil)',
-                    f'\tfor {_OPEN_BRCK}',
-                    f'\t\tbidirectionalStreamRequest, err := stream.Recv()',
-                    f'\t\tif err == io.EOF {_OPEN_BRCK}',
-                    f'\t\t\tutils.ErrorLogger.Printf("[{rpc_temp_name}] Client stream closed.")',
-                    f'\t\t\tbreak',
-                    f'\t\t{_CLOSING_BRCK}',
-                    f'\t\tif err != nil {_OPEN_BRCK}',
-                    f'\t\t\tutils.ErrorLogger.Printf("[{rpc_temp_name}] Client stream Request error: \'%v\'.", err)',
-                    f'\t\t\treturn stream.Send(&{rpc_output_package_name}.{temp_go_rpc_output_name}{_OPEN_BRCK}{_CLOSING_BRCK})',
-                    f'\t\t{_CLOSING_BRCK}',
-                    f'\t\t// Do something with incoming object',
-                    f'\t\tutils.InfoLogger.Printf("[{rpc_temp_name}] Request received: \'%v\'.", bidirectionalStreamRequest)',
-                    f'\t\tstream.Send(&{rpc_output_package_name}.{temp_go_rpc_output_name}{_OPEN_BRCK}{_CLOSING_BRCK})',
-                    f'\t{_CLOSING_BRCK}',
-                    '\treturn nil',
-                    f'{_CLOSING_BRCK}'
-                ]))
-  
-        return '\n'.join(list_of_rpcs)
-
+        return "\n".join(list_of_rpcs)
 
     def write_log_func(self):
         return f'func printLog(name string, ctx context.Context, message interface{_OPEN_BRCK}{_CLOSING_BRCK}) {_OPEN_BRCK}\n\
 \tcontextMetadata, _ := metadata.FromIncomingContext(ctx)\n\
 \tutils.InfoLogger.Printf("[%s] Got RPC request: %v", name, message)\n\
 \tutils.DebugLogger.Printf("[%s] Metadata: %v", name, contextMetadata)\n\
 {_CLOSING_BRCK}'
 
     def to_str(self):
         return self.__str__()
 
     def __str__(self):
-        name = self._name.split('/')[-1].split('.')[0]
+        name = self._name.split("/")[-1].split(".")[0]
         temp_svc_name = name[0].capitalize() + name[1:]
-        return f'package {temp_svc_name}\n\nimport (\n\t{self.write_imports()}\n)\n\n{self.write_struct()}\n{self.write_methods()}\n\n{self.write_log_func()}'
+        return f"package {temp_svc_name}\n\nimport (\n\t{self.write_imports()}\n)\n\n{self.write_struct()}\n{self.write_methods()}\n\n{self.write_log_func()}"
+
 
-class SylkServiceJs():
+class SylkServiceJs:
     """A helper class to write 'Typescript' language services for sylk.build project services"""
-    
-    def __init__(self, project_package, name, imports=[], service=None, package=None, messages=[], enums=[], context: SylkContext = None,sylk_json: SylkJson= None):
+
+    def __init__(
+        self,
+        project_package,
+        name,
+        imports=[],
+        service=None,
+        package=None,
+        messages=[],
+        enums=[],
+        context: SylkContext = None,
+        sylk_json: SylkJson = None,
+    ):
         self._name = name
         self._imports = imports
         self._service = service
         self._project_package = project_package
         self._context = context
         self._sylk_json = sylk_json
 
     def write_imports(self):
-       return ''
+        return ""
 
     def write_class(self):
         rpcs = []
         if self._context is not None:
             functions = self._context.get_functions(self._name)
             if functions is not None:
                 for func in functions:
-                    func_code = func['code']
-                    rpcs.append(
-                        f'\t// @skip @@sylk - DO NOT REMOVE\n{func_code}')
+                    func_code = func["code"]
+                    rpcs.append(f"\t// @skip @@sylk - DO NOT REMOVE\n{func_code}")
         methods_exports = []
         methods_functions = []
-        for rpc in self._service.get('methods'):
-            rpc_name = rpc.get('name')
-            args = f'call, callback'
-            
+        for rpc in self._service.get("methods"):
+            rpc_name = rpc.get("name")
+            args = f"call, callback"
+
             # if rpc_type_in and rpc_type_out:
             #     handleType = 'handleBidiStreamingCall'
             #     args = f'call, {rpc_out_pkg}.{rpc_out_name}>'
             # elif rpc_type_in and rpc_type_out == False:
             #     handleType = 'handleClientStreamingCall'
             #     args = f'call: ServerReadableStream<{rpc_in_pkg}.{rpc_in_name}, {rpc_out_pkg}.{rpc_out_name}>,\n\t\tcallback: sendUnaryData<{rpc_out_pkg}.{rpc_out_name}>'
             # elif rpc_type_in == False and rpc_type_out:
             #     handleType = 'handleServerStreamingCall'
             #     args = f'call: ServerWritableStream<{rpc_in_pkg}.{rpc_in_name}, {rpc_out_pkg}.{rpc_out_name}>'
-            code = ''
+            code = ""
             if self._context is not None:
                 code = self._context.get_rpc(self._name, rpc_name)
                 if code is not None:
-                    code =code.get('code')
+                    code = code.get("code")
             temp_name = rpc_name[0].lower() + rpc_name[1:]
             methods.append(temp_name)
-            rpcs.append(f'\t// @rpc @@sylk - DO NOT REMOVE\nconst {temp_name} = function({args}) {_OPEN_BRCK}\n\t\n\n{_CLOSING_BRCK}\n\n')
+            rpcs.append(
+                f"\t// @rpc @@sylk - DO NOT REMOVE\nconst {temp_name} = function({args}) {_OPEN_BRCK}\n\t\n\n{_CLOSING_BRCK}\n\n"
+            )
             # rpcs.append(
-                # f'\t// @rpc @@sylk - DO NOT REMOVE\n\t{temp_name}= ({args}) => {_OPEN_BRCK}\n{code}\n\t{_CLOSING_BRCK}\n')
-        rpcs = ''.join(rpcs)
-        methods = ',\n\t'.join(methods_exports)
-        return f'\n{rpcs}\n\nmodule.exports = {_OPEN_BRCK}\n\t{methods}\n{_CLOSING_BRCK};'
+            # f'\t// @rpc @@sylk - DO NOT REMOVE\n\t{temp_name}= ({args}) => {_OPEN_BRCK}\n{code}\n\t{_CLOSING_BRCK}\n')
+        rpcs = "".join(rpcs)
+        methods = ",\n\t".join(methods_exports)
+        return (
+            f"\n{rpcs}\n\nmodule.exports = {_OPEN_BRCK}\n\t{methods}\n{_CLOSING_BRCK};"
+        )
 
     def to_str(self):
         return self.__str__()
 
     def __str__(self):
-        return f'{self.write_imports()}\nconst protoDefinitions = protoLoader.loadSync(\n\t[...PROTO_PATHS],\n\t{_OPEN_BRCK}\n\t\tincluderDirs: [`${_OPEN_BRCK}__dirname{_CLOSING_BRCK}`],\n\t\tkeepCase:true,\n\t\tlongs: String,\n\t\tenums: String,\n\t\tdefaults: true,\n\t\toneofs: true,\n\t{_CLOSING_BRCK}\n);\nconst protos = grpc.loadPackageDefinition(protoDefinitions);{self.write_class()}'
+        return f"{self.write_imports()}\nconst protoDefinitions = protoLoader.loadSync(\n\t[...PROTO_PATHS],\n\t{_OPEN_BRCK}\n\t\tincluderDirs: [`${_OPEN_BRCK}__dirname{_CLOSING_BRCK}`],\n\t\tkeepCase:true,\n\t\tlongs: String,\n\t\tenums: String,\n\t\tdefaults: true,\n\t\toneofs: true,\n\t{_CLOSING_BRCK}\n);\nconst protos = grpc.loadPackageDefinition(protoDefinitions);{self.write_class()}"
 
 
-def parse_code_file(file_content, seperator='@rpc'):
+def parse_code_file(file_content, seperator="@rpc"):
     log.debug(f"Parsing code file | seperator : {seperator}")
     # temp_lines = []
     # for lines in :
     #     drop_lines = False
     #     for line in lines:
     #         print(line)
     #         if nag in line:
     #             drop_lines = True
 
     #     if drop_lines == False:
     #         temp_lines.append(lines)
 
-    return [list(g) for k, g in groupby(file_content, key=lambda x: seperator not in x) if k][1:]
-
+    return [
+        list(g) for k, g in groupby(file_content, key=lambda x: seperator not in x) if k
+    ][1:]
 
 
 def validation(answers, current):
-
     if len(current) == 0:
         raise inquirerErrors.ValidationError(
-            current, reason='Resource name must not be blank')
-    if len(re.findall('\s', current)) > 0:
+            current, reason="Resource name must not be blank"
+        )
+    if len(re.findall("\s", current)) > 0:
         raise inquirerErrors.ValidationError(
-            current, reason='Resource name must not include blank spaces')
-    if len(re.findall('-', current)) > 0:
+            current, reason="Resource name must not include blank spaces"
+        )
+    if len(re.findall("-", current)) > 0:
         raise inquirerErrors.ValidationError(
-            current, reason='Resource name must not include hyphens, underscores are allowed')
+            current,
+            reason="Resource name must not include hyphens, underscores are allowed",
+        )
     return True
 
+
 def field_exists_validation(new_field, fields, msg):
     if new_field in fields:
         raise errors.SylkProtoError(
-            'Message', f'Field {new_field} already exits under {msg}')
+            "Message", f"Field {new_field} already exits under {msg}"
+        )
     return True
 
+
 def float_value_validate(answers, current):
     try:
         float(current)
     except Exception:
         raise inquirerErrors.ValidationError(
-            current, reason='Value must be valid float type')
+            current, reason="Value must be valid float type"
+        )
     return True
 
+
 def int_value_validate(answers, current):
     try:
         int(current)
     except Exception:
         raise inquirerErrors.ValidationError(
-            current, reason='Value must be valid integer type')
+            current, reason="Value must be valid integer type"
+        )
     return True
 
 
-
 def enum_value_validate(answers, current):
     try:
         int(current)
     except Exception:
         raise errors.ValidationError(
-            current, reason='Enum Value MUST be an integer value')
+            current, reason="Enum Value MUST be an integer value"
+        )
     return True
 
+
 # def send_analytic_event(args):
 #     stub = sylkanalytics()
 #     ts = Timestamp()
 #     ts.GetCurrentTime()
 #     temp_args = []
 #     if hasattr(args, '__dict__'):
 #         for k in args.__dict__:
 #             temp_args.append(str((k,args.__dict__[k])))
 #     else:
 #         temp_args = [str((k, v)) for k, v in args.items()]
-#     hostname=socket.gethostname() 
+#     hostname=socket.gethostname()
 #     # pretty.print_info(temp_args)
 #     try:
 #         stub.PublishCLIEvent(
 #         SylkAnalytics_pb2.CLIEvent(
 #             version=__version__.__version__,
 #             ts=ts,
 #             args=temp_args,
-#             os=platform() if hasattr(config,'token') == False else config.token.split(':')[0], 
+#             os=platform() if hasattr(config,'token') == False else config.token.split(':')[0],
 #             user_id='UNKNWON:'+hostname if hasattr(config,'token') == False else config.token+':'+hostname
 #             ))
 #     except Exception as e:
 #         pretty.print_warning(e)
 
 _BUILTINS_TEMPLATES = Literal[
     "@sylk/Blank",
     "@sylk/SamplePy",
     "@sylk/SampleTs",
     "@sylk/PubSubTs",
     "@sylk/HelloWorldPy",
-    "@sylk/HelloWorldTs"]
+    "@sylk/HelloWorldTs",
+]
+
 
-def attach_template(ARCHITECT,template:_BUILTINS_TEMPLATES):
-    if template != '@sylk/Blank':
+def attach_template(ARCHITECT, template: _BUILTINS_TEMPLATES):
+    if template != "@sylk/Blank":
         file_dir = os.path.dirname(__file__)
-        template_domain_name = template.split('/')[0].split('@')[-1]
-        template_name = template.split('/')[-1]
-        pretty.print_note(file_dir + '/templates/{0}/{1}.template.py'.format(template_domain_name,template_name))
-        os.chdir(ARCHITECT._path.split('sylk.json')[0])
-        subprocess.run(['python',file_dir + '/templates/{0}/{1}.template.py'.format(template_domain_name,template_name),'--domain',ARCHITECT._domain,'--project-name',ARCHITECT._project_name])
+        template_domain_name = template.split("/")[0].split("@")[-1]
+        template_name = template.split("/")[-1]
+        pretty.print_note(
+            file_dir
+            + "/templates/{0}/{1}.template.py".format(
+                template_domain_name, template_name
+            )
+        )
+        os.chdir(ARCHITECT._path.split("sylk.json")[0])
+        subprocess.run(
+            [
+                "python",
+                file_dir
+                + "/templates/{0}/{1}.template.py".format(
+                    template_domain_name, template_name
+                ),
+                "--domain",
+                ARCHITECT._domain,
+                "--project-name",
+                ARCHITECT._project_name,
+            ]
+        )
+
 
 def parse_extension_to_proto(
-    extension_type:Literal['FileOptions','MessageOptions','FieldOptions','ServiceOptions','MethodOptions'],
-    extension_message,ext_key,ext_value,sylk_json):
+    extension_type: Literal[
+        "FileOptions",
+        "MessageOptions",
+        "FieldOptions",
+        "ServiceOptions",
+        "MethodOptions",
+    ],
+    extension_message,
+    ext_key,
+    ext_value,
+    sylk_json,
+):
     extension_value = None
     # Get current key to parse
-    extension_field = next((f for f in extension_message.get('fields') if f.get('name') == ext_key.split('.')[-1]))
+    extension_field = next(
+        (
+            f
+            for f in extension_message.get("fields")
+            if f.get("name") == ext_key.split(".")[-1]
+        ),
+        None,
+    )
     # Get type and label for the extension field
-    type_ext = extension_field.get(
-        'fieldType').split('_')[-1].lower()
-    label_ext = extension_field.get(
-        'label').split('_')[-1].lower()
+    type_ext = extension_field.get("fieldType").split("_")[-1].lower()
+    label_ext = extension_field.get("label").split("_")[-1].lower()
     # Handle FileOptions extensions
-    if extension_type == 'FileOptions':
-        if label_ext == 'repeated':
+    if extension_type == "FileOptions":
+        if label_ext == "repeated":
             ext_values = []
             for v in ext_value:
-                extension_value = parse_extension_value(type_ext,v,sylk_json,extension_field)
+                extension_value = parse_extension_value(
+                    type_ext, v, sylk_json, extension_field
+                )
                 if extension_value is not None:
-                    ext_values.append(f'option ({ext_key}) = {extension_value};')
-            extension_value = '\n'.join(ext_values)
+                    ext_values.append(f"option ({ext_key}) = {extension_value};")
+            extension_value = "\n".join(ext_values)
         else:
-            extension_value = parse_extension_value(type_ext,ext_value,sylk_json,extension_field)
+            extension_value = parse_extension_value(
+                type_ext, ext_value, sylk_json, extension_field
+            )
             if extension_value is not None:
-                extension_value = f'option ({ext_key}) = {extension_value};'
-    
-    elif extension_type == 'MessageOptions':
-        if label_ext == 'repeated':
-           
+                extension_value = f"option {ext_key} = {extension_value};"
+
+    elif extension_type == "MessageOptions":
+        if label_ext == "repeated":
             pretty.print_error("Not supporting repeated MessageOptions")
-            extension_value = ''
+            extension_value = ""
         else:
-            extension_value = parse_extension_value(type_ext,ext_value,sylk_json,extension_field,2)
+            extension_value = parse_extension_value(
+                type_ext, ext_value, sylk_json, extension_field, 2
+            )
             if extension_value is not None:
-                extension_value = f'option ({ext_key}) = {extension_value};'
-    
-    elif extension_type == 'FieldOptions':
-        if label_ext == 'repeated':
+                extension_value = f"option ({ext_key}) = {extension_value};"
+
+    elif extension_type == "FieldOptions":
+        if label_ext == "repeated":
             pretty.print_error("Not supporting repeated FieldOptions")
-            extension_value = ''
+            extension_value = ""
         else:
-            extension_value = parse_extension_value(type_ext,ext_value,sylk_json,extension_field,2)
+            extension_value = parse_extension_value(
+                type_ext, ext_value, sylk_json, extension_field, 2
+            )
             if extension_value is not None:
-                extension_value = f'({ext_key}) = {extension_value}'
-    elif extension_type == 'ServiceOptions':
-        if label_ext == 'repeated':
+                extension_value = f"({ext_key}) = {extension_value}"
+    elif extension_type == "ServiceOptions":
+        if label_ext == "repeated":
             temp_value = []
             for v in ext_value:
-                extension_value = parse_extension_value(type_ext,v,sylk_json,extension_field,2)
+                extension_value = parse_extension_value(
+                    type_ext, v, sylk_json, extension_field, 2
+                )
                 if extension_value is not None:
-                    temp_value.append(f'option ({ext_key}) = {extension_value};')
+                    temp_value.append(f"option ({ext_key}) = {extension_value};")
 
-            extension_value = '\n\t'.join(temp_value)
+            extension_value = "\n\t".join(temp_value)
         else:
-            extension_value = parse_extension_value(type_ext,ext_value,sylk_json,extension_field,2)
+            extension_value = parse_extension_value(
+                type_ext, ext_value, sylk_json, extension_field, 2
+            )
             if extension_value is not None:
-                extension_value = f'option ({ext_key}) = {extension_value};'
-    elif extension_type == 'MethodOptions':
-        if label_ext == 'repeated':
+                extension_value = f"option ({ext_key}) = {extension_value};"
+    elif extension_type == "MethodOptions":
+        if label_ext == "repeated":
             pretty.print_error("Not supporting repeated MethodOptions")
-            extension_value = ''
+            extension_value = ""
         else:
-            extension_value = parse_extension_value(type_ext,ext_value,sylk_json,extension_field,2)
+            extension_value = parse_extension_value(
+                type_ext, ext_value, sylk_json, extension_field, 2
+            )
             if extension_value is not None:
-                extension_value = f'option ({ext_key}) = {extension_value};'
+                extension_value = f"option ({ext_key}) = {extension_value};"
 
     else:
-        raise errors.SylkValidationError('Extension Type Error','Extension of type {} is not valid !'.format(extension_type))
-
+        raise errors.SylkValidationError(
+            "Extension Type Error",
+            "Extension of type {} is not valid !".format(extension_type),
+        )
     return extension_value
 
-def parse_extension_value(type,value,sylk_json:SylkJson,field=None,num_tabs=1):
+
+def parse_extension_value(type, value, sylk_json: SylkJson, field=None, num_tabs=1):
     """
     This function serve as util for returning an extension proto value
     """
-    if 'int' in type:
+    if "int" in type:
         value = int(value)
-    elif type == 'float' or type == 'double':
+    elif type == "float" or type == "double":
         value = float(value)
-    elif type == 'string':
+    elif type == "string":
         value = f'"{value}"'
-    elif type == 'bool':
+    elif type == "bool":
         if value == 0:
             value = "false"
         elif value == 1:
             value = "true"
-    elif type == 'message':
+    elif type == "message":
         if field is not None:
-            ext_msg = sylk_json.get_message(field.get('messageType'))
+            ext_msg = sylk_json.get_message(field.get("messageType"))
             temp_values = []
             for k in value:
-                field_in_ext = next((f for f in ext_msg.get('fields') if f.get('name') == k),None)
+                field_in_ext = next(
+                    (f for f in ext_msg.get("fields") if f.get("name") == k), None
+                )
                 if field_in_ext is not None:
-                    field_ext_in_type = field_in_ext.get('fieldType').split('_')[-1].lower()
-                    parsed_value_field = parse_extension_value(field_ext_in_type,value[k],sylk_json,field_in_ext)
+                    field_ext_in_type = (
+                        field_in_ext.get("fieldType").split("_")[-1].lower()
+                    )
+                    parsed_value_field = parse_extension_value(
+                        field_ext_in_type, value[k], sylk_json, field_in_ext
+                    )
                     if parsed_value_field is not None:
-                        temp_values.append('{} : {}'.format(k,parsed_value_field))
+                        temp_values.append("{} : {}".format(k, parsed_value_field))
             if num_tabs > 1:
-                value = ',\n\t\t'.join(temp_values)
-                value = f'{_OPEN_BRCK}\n\t\t{value}\n\t{_CLOSING_BRCK}'
+                value = ",\n\t\t".join(temp_values)
+                value = f"{_OPEN_BRCK}\n\t\t{value}\n\t{_CLOSING_BRCK}"
             else:
-                value = ',\n\t'.join(temp_values)
-                value = f'{_OPEN_BRCK}\n\t{value}\n{_CLOSING_BRCK}'
-    elif type == 'enum':
-        if isinstance(value,float) or isinstance(value,int):
+                value = ",\n\t".join(temp_values)
+                value = f"{_OPEN_BRCK}\n\t{value}\n{_CLOSING_BRCK}"
+    elif type == "enum":
+        if isinstance(value, float) or isinstance(value, int):
             if value != 0:
                 value = int(value)
             else:
                 value = None
         else:
-            if 'UNKNOWN' not in value:
+            if "UNKNOWN" not in value:
                 value = value
-            else:    
+            else:
                 value = None
 
     return value
 
 
-_WellKnowns = ['google.protobuf.Timestamp','google.protobuf.Any','google.protobuf.Struct','google.protobuf.FieldMask']
+_WellKnowns = [
+    "google.protobuf",
+]
+
+_WellMap = [
+    ("struct.proto", ["Struct", "Value", "ListValue"]),
+    ("any.proto", ["Any"]),
+    ("field_mask.proto", ["FieldMask"]),
+    ("empty.proto", ["Empty"]),
+    ("duration.proto", ["Duration"]),
+    ("timestamp.proto", ["Timestamp"]),
+    (
+        "descriptor.proto",
+        ["FileOptions", "ServiceOptions", "MethodOptions", "MessageOptions"],
+    ),
+]
+
 
 # Python class for topological sorting of a DAG
 # Class to represent a graph
 class Graph:
-    def __init__(self,nodes,dependencies:bool=False):
-        self.graph = defaultdict(list) #dictionary containing adjacency List
+    def __init__(self, nodes, dependencies: bool = False):
+        self.graph = defaultdict(list)  # dictionary containing adjacency List
         self.graph[None] = []
 
         if dependencies:
             for p in nodes:
-                resource_name = p.get('package') if p.get('package') is not None else p.get('name')
-                
-                if p.get('dependencies') is not None and len(p.get('dependencies')) > 0 and True not in list(map(lambda x: x not in p.get('dependencies'),_WellKnowns)):
-                    for d in p.get('dependencies'):
-                        self.addEdge(resource_name,d)
+                resource_name = (
+                    p.get("package")
+                    if p.get("package") is not None
+                    else p.get("fullName")
+                )
+
+                if (
+                    p.get("dependencies") is not None
+                    and len(p.get("dependencies")) > 0
+                    and True
+                    not in list(map(lambda x: x in p.get("dependencies"), _WellKnowns))
+                ):
+                    for d in p.get("dependencies"):
+                        self.addEdge(resource_name, d)
                 else:
-                    self.addEdge(resource_name,None)
-        else:   
+                    self.addEdge(resource_name, None)
+        else:
             for m in nodes:
                 list_of_msgs = []
-                pkgName = '.'.join(m.get('fullName').split('.')[:3])
-                for f in m.get('fields'):
-                    if f.get('messageType') is not None and  f.get('messageType') not in _WellKnowns and pkgName in f.get('messageType'):
-                        list_of_msgs.append(f.get('messageType'))
-                    
+                for f in m.get("fields"):
+                    if (
+                        f.get("messageType") is not None
+                        and f.get("messageType") not in _WellKnowns
+                    ):
+                        list_of_msgs.append(f.get("messageType"))
+
                 if len(list_of_msgs) > 0:
                     for msg in list_of_msgs:
-                        self.addEdge(m.get('fullName'),msg)
+                        self.addEdge(m.get("fullName"), msg)
                 else:
-                    self.addEdge(m.get('fullName'),None)
+                    self.addEdge(m.get("fullName"), None)
 
     # function to add an edge to graph
-    def addEdge(self,u,v):
+    def addEdge(self, u, v):
         self.graph[u].append(v)
- 
+
     # A recursive function used by topologicalSort
-    def topologicalSortUtil(self,v,visited,stack):
- 
+    def topologicalSortUtil(self, v, visited, stack):
         # Mark the current node as visited.
         visited[v] = True
- 
+
         # Recur for all the vertices adjacent to this vertex
         for i in self.graph[v]:
             if visited[i] == False:
-                self.topologicalSortUtil(i,visited,stack)
+                self.topologicalSortUtil(i, visited, stack)
 
         # Push current vertex to stack which stores result
-        stack.insert(0,v)
- 
+        stack.insert(0, v)
+
     # The function to do Topological Sort. It uses recursive
     # topologicalSortUtil()
     def topologicalSort(self):
         visited = {}
         # Mark all the vertices as not visited
         for k in self.graph.keys():
             visited[k] = False
-        stack =[]
- 
+        stack = []
+
         # Call the recursive helper function to store Topological
         # Sort starting from all vertices one by one
         for i in list(self.graph.keys()):
             if visited[i] == False:
-                self.topologicalSortUtil(i,visited,stack)
- 
+                self.topologicalSortUtil(i, visited, stack)
+
         # Print contents of stack
         stack.remove(None)
         return stack
- 
+
+
 def read_to_parse_protos(file_paths):
     results = {}
     with concurrent.futures.ThreadPoolExecutor() as executor:
         # Submit file reading tasks to the thread pool
-        file_reading_tasks = {executor.submit(file_system.read_file, file_path): file_path for file_path in file_paths}
+        file_reading_tasks = {
+            executor.submit(file_system.read_file, file_path): file_path
+            for file_path in file_paths
+        }
 
         # Retrieve the results as they complete
         for future in concurrent.futures.as_completed(file_reading_tasks):
-            file_path = file_reading_tasks[future]  # Get the file path associated with the future
+            file_path = file_reading_tasks[
+                future
+            ]  # Get the file path associated with the future
             try:
                 file_contents = future.result()
-                results[file_path] = file_contents  # Store the file contents in the dictionary
+                results[
+                    file_path
+                ] = file_contents  # Store the file contents in the dictionary
             except Exception as e:
-                print(f'An error occurred while reading {file_path}: {e}')
+                print(f"An error occurred while reading {file_path}: {e}")
 
     return results
 
+
 def is_semver_less(semver1, semver2):
     if semver1 is None:
         return True
-    
+
     def parse_semver(semver):
-        major, minor, patch = map(int, semver.split('.'))
+        major, minor, patch = map(int, semver.split("."))
         return major, minor, patch
 
     major1, minor1, patch1 = parse_semver(semver1)
     major2, minor2, patch2 = parse_semver(semver2)
 
     if major1 < major2:
         return True
@@ -2322,8 +4440,8 @@
         return False
 
     if patch1 < patch2:
         return True
     elif patch1 > patch2:
         return False
 
-    return False
+    return False
```

## sylk/commons/interceptors.py

```diff
@@ -1,7 +1,28 @@
+# Copyright (c) 2023 sylk.build
+
+# Permission is hereby granted, free of charge, to any person obtaining
+# a copy of this software and associated documentation files (the
+# "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to
+# permit persons to whom the Software is furnished to do so, subject to
+# the following conditions:
+
+# The above copyright notice and this permission notice shall be
+# included in all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
 import datetime
 import grpc
 import logging
 from functools import wraps
 from sylk import __version__
 import time
 
@@ -186,8 +207,16 @@
         if hasattr(client,'_sylk_global_auth_key') and getattr(client,'_sylk_global_auth_key') is not None:
            logging.debug(f'Sylk Auth')
         else:
             logging.debug(f'Passed sylk auth: no global key for sylk client.')
 
         # Call the RPC method
         return func(client, context, *args, **kwargs)
-    return sylk_client_auth
+    return sylk_client_auth
+
+class SylkSimpleAuth(grpc.AuthMetadataPlugin):
+	def __init__(self, header, key):
+		self._header = header
+		self._key = key
+
+	def __call__(self, context, callback):
+		callback(((self._header, self._key),), None)
```

## sylk/commons/resources.py

```diff
@@ -15,89 +15,99 @@
 # EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 # MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
+from ensurepip import version
 import imp
 import logging
 import os
 import sys
 from typing import List
 from enum import Enum
 
 import grpc
 from google.protobuf.descriptor_pool import DescriptorPool
 from google.protobuf.json_format import MessageToDict, ParseDict
 from google.protobuf.descriptor import Descriptor
 from google.protobuf.descriptor_pb2 import DescriptorProto, FieldDescriptorProto
 from google.protobuf.struct_pb2 import Struct, Value, ListValue
-from google.protobuf.descriptor import FileDescriptor, Descriptor, MethodDescriptor,\
-    FieldDescriptor, ServiceDescriptor, EnumDescriptor
+from google.protobuf.descriptor import (
+    FileDescriptor,
+    Descriptor,
+    MethodDescriptor,
+    FieldDescriptor,
+    ServiceDescriptor,
+    EnumDescriptor,
+)
 from grpc_tools import command
 from sylk.cli import prompter
+from sylk import __version__
 from sylk.commons import errors
 from sylk.commons.pretty import print_error, print_info, print_note, print_warning
 
-from sylk.commons.protos.sylk.Sylk.v1 import  Sylk_pb2
+from sylk.commons.protos.sylk.Sylk.v2 import Sylk_pb2
 from sylk.commons.protos.sylk.SylkOrganization.v1 import SylkOrganization_pb2
 from sylk.commons.protos.sylk.SylkProject.v1 import SylkProject_pb2
-from sylk.commons.protos.sylk.SylkService.v1 import SylkService_pb2
-from sylk.commons.protos.sylk.SylkPackage.v1 import SylkPackage_pb2
+from sylk.commons.protos.sylk.SylkService.v2 import SylkService_pb2
+from sylk.commons.protos.sylk.SylkPackage.v2 import SylkPackage_pb2
 from sylk.commons.protos.sylk.SylkConfigs.v1 import SylkConfigs_pb2
-from sylk.commons.protos.sylk.SylkEnum.v1 import SylkEnum_pb2
+from sylk.commons.protos.sylk.SylkEnum.v2 import SylkEnum_pb2
+from sylk.commons.protos.sylk.SylkEnumValue.v1 import SylkEnumValue_pb2
 from sylk.commons.protos.sylk.SylkServer.v1 import SylkServer_pb2
 from sylk.commons.protos.sylk.SylkClient.v1 import SylkClient_pb2
 from sylk.commons.protos.sylk.SylkMethod.v1 import SylkMethod_pb2
-from sylk.commons.protos.sylk.SylkMessage.v1 import SylkMessage_pb2
+from sylk.commons.protos.sylk.SylkMessage.v2 import SylkMessage_pb2
 from sylk.commons.protos.sylk.SylkField.v1 import SylkField_pb2
 from sylk.commons.protos.sylk.SylkCommons.v1 import SylkCommons_pb2
 
+
 class ResourceTypes(Enum):
-    project = 'projects'
-    service = 'services'
-    package = 'packages'
-    files = 'files'
-    server = 'servers'
-    client = 'clients'
-    descriptor = 'descriptors'
+    project = "project"
+    service = "service"
+    package = "package"
+    files = "file"
+    server = "server"
+    client = "client"
+    descriptor = "descriptor"
 
 
 class ResourceKinds(Enum):
-    sylk_1 = 'sylk.project/tier1'
-    service_srvr_js = 'sylk.service/server/javascript'
-    service_client_js = 'sylk.service/client/javascript'
-    service_srvr_ts = 'sylk.service/server/typescript'
-    service_client_ts = 'sylk.service/client/typescript'
-    service_srvr_py = 'sylk.service/server/python'
-    service_client_py = 'sylk.service/client/python'
-    service_srvr_cs = 'sylk.service/server/csharp'
-    service_client_cs = 'sylk.service/client/csharp'
-    service_srvr_cpp = 'sylk.service/server/cpp'
-    service_client_cpp = 'sylk.service/client/cpp'
-    service_srvr_java = 'sylk.service/server/java'
-    service_client_java = 'sylk.service/client/java'
-    service_client_webpack = 'sylk.service/client/webpack'
-    file_proto = 'sylk.file/proto'
-    file_js = 'sylk.file/nodejs'
-    file_ts = 'sylk.file/typescript'
-    file_py = 'sylk.file/python'
-    file_cs = 'sylk.file/csharp'
-    file_go = 'sylk.file/go'
-    file_cpp = 'sylk.file/cpp'
-    file_java = 'sylk.file/java'
-    file_webpack = 'sylk.file/webpack'
-    method = 'sylk.descriptor/method'
-    field = 'sylk.descriptor/field'
-    oneof_field = 'sylk.descriptor/oneof_field'
-    message = 'sylk.descriptor/message'
-    enum = 'sylk.descriptor/enum'
-    enum_value = 'sylk.descriptor/enum_value'
-    health = 'sylk.health/check'
+    sylk_1 = "sylk.project/tier1"
+    service_srvr_js = "sylk.service/server/javascript"
+    service_client_js = "sylk.service/client/javascript"
+    service_srvr_ts = "sylk.service/server/typescript"
+    service_client_ts = "sylk.service/client/typescript"
+    service_srvr_py = "sylk.service/server/python"
+    service_client_py = "sylk.service/client/python"
+    service_srvr_cs = "sylk.service/server/csharp"
+    service_client_cs = "sylk.service/client/csharp"
+    service_srvr_cpp = "sylk.service/server/cpp"
+    service_client_cpp = "sylk.service/client/cpp"
+    service_srvr_java = "sylk.service/server/java"
+    service_client_java = "sylk.service/client/java"
+    service_client_webpack = "sylk.service/client/webpack"
+    file_proto = "sylk.file/proto"
+    file_js = "sylk.file/nodejs"
+    file_ts = "sylk.file/typescript"
+    file_py = "sylk.file/python"
+    file_cs = "sylk.file/csharp"
+    file_go = "sylk.file/go"
+    file_cpp = "sylk.file/cpp"
+    file_java = "sylk.file/java"
+    file_webpack = "sylk.file/webpack"
+    method = "method"
+    field = "field"
+    oneof_field = "oneof"
+    message = "message"
+    enum = "enum"
+    enum_value = "enum_value"
+    health = "check"
 
 
 fields_opt = [
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.SylkFieldTypes.TYPE_DOUBLE),
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.SylkFieldTypes.TYPE_FLOAT),
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.SylkFieldTypes.TYPE_INT64),
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.SylkFieldTypes.TYPE_INT32),
@@ -107,335 +117,620 @@
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.SylkFieldTypes.TYPE_BYTES),
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.SylkFieldTypes.TYPE_ENUM),
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.SylkFieldTypes.TYPE_ONEOF),
     SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.SylkFieldTypes.TYPE_MAP),
 ]
 field_label = [
     SylkField_pb2.SylkFieldLabels.Name(SylkField_pb2.SylkFieldLabels.LABEL_OPTIONAL),
-    SylkField_pb2.SylkFieldLabels.Name(SylkField_pb2.SylkFieldLabels.LABEL_REPEATED)
+    SylkField_pb2.SylkFieldLabels.Name(SylkField_pb2.SylkFieldLabels.LABEL_REPEATED),
 ]
 
+
 def get_blank_sylk_json(json=False):
+    domain = "sylk"
     sylkJson = Sylk_pb2.SylkJson(
-        organization=SylkOrganization_pb2.SylkOrganization(domain='sylk'),
+        organization=SylkOrganization_pb2.SylkOrganization(domain=domain),
         project=SylkProject_pb2.SylkProject(),
-        services={},
         packages={},
-        configs=SylkConfigs_pb2.SylkProjectConfigs())
+        sylk_version=__version__.__version__,
+        configs=SylkConfigs_pb2.SylkProjectConfigs(
+            proto_base_path="protos"
+        ),
+    )
     return sylkJson if json == False else MessageToDict(sylkJson)
 
 
-def generate_project(path, name, server_langauge='python', clients=[], package_name=None, json=False):
-    path = path.split('/sylk.json')[0]
+def generate_project(
+    path, name, server_langauge="python", clients=[], package_name=None, json=False
+):
+    path = path.split("/sylk.json")[0]
     # Init server
-    if server_langauge == 'python' or server_langauge == SylkServer_pb2.SylkServerLanguages.python:
+    if (
+        server_langauge == "python"
+        or server_langauge == SylkServer_pb2.SylkServerLanguages.python
+    ):
         temp_langugae = SylkServer_pb2.python
-    elif server_langauge == 'typescript' or server_langauge == SylkServer_pb2.SylkServerLanguages.typescript:
+    elif (
+        server_langauge == "typescript"
+        or server_langauge == SylkServer_pb2.SylkServerLanguages.typescript
+    ):
         temp_langugae = SylkServer_pb2.typescript
-    elif server_langauge == 'go' or server_langauge == SylkServer_pb2.SylkServerLanguages.go:
+    elif (
+        server_langauge == "go"
+        or server_langauge == SylkServer_pb2.SylkServerLanguages.go
+    ):
         temp_langugae = SylkServer_pb2.go
-    elif server_langauge == 'nodejs' or server_langauge == SylkServer_pb2.SylkServerLanguages.nodejs:
+    elif (
+        server_langauge == "nodejs"
+        or server_langauge == SylkServer_pb2.SylkServerLanguages.nodejs
+    ):
         temp_langugae = SylkServer_pb2.nodejs
     # Add more language support here...
     else:
-        raise errors.SylkValidationError('Server Language Error',f'Must pass a valid server language for your new project: "{server_langauge}"')
-    server = SylkServer_pb2.SylkServer(language=SylkServer_pb2.SylkServerLanguages.Name(temp_langugae))
-    
+        raise errors.SylkValidationError(
+            "Server Language Error",
+            f'Must pass a valid server language for your new project: "{server_langauge}"',
+        )
+    server = SylkServer_pb2.SylkServer(
+        language=SylkServer_pb2.SylkServerLanguages.Name(temp_langugae)
+    )
+
     # Creating packaeg name for project
     if package_name is None:
-        package_name = name.replace('-', '').replace('_', '').lower()
+        package_name = name.replace("-", "").replace("_", "").lower()
 
     # Parse clients languages
     go_package = None
     temp_clients = []
     if len(clients) > 0:
         for c in clients:
-            if c.language == SylkClient_pb2.python if hasattr(c,'language') else c['language'] == 'python':
+            if (
+                c.language == SylkClient_pb2.python
+                if hasattr(c, "language")
+                else c["language"] == "python"
+            ):
                 temp_c_lang = SylkClient_pb2.python
-            elif c.language == SylkClient_pb2.typescript if hasattr(c,'language') else c['language'] == 'typescript':
-                temp_c_lang  = SylkClient_pb2.typescript
-            elif c.language == SylkClient_pb2.nodejs if hasattr(c,'language') else c['language'] == 'nodejs':
+            elif (
+                c.language == SylkClient_pb2.typescript
+                if hasattr(c, "language")
+                else c["language"] == "typescript"
+            ):
+                temp_c_lang = SylkClient_pb2.typescript
+            elif (
+                c.language == SylkClient_pb2.nodejs
+                if hasattr(c, "language")
+                else c["language"] == "nodejs"
+            ):
                 temp_c_lang = SylkClient_pb2.nodejs
-            elif c.language == SylkClient_pb2.go if hasattr(c,'language') else c['language'] == 'go':
+            elif (
+                c.language == SylkClient_pb2.go
+                if hasattr(c, "language")
+                else c["language"] == "go"
+            ):
                 temp_c_lang = SylkClient_pb2.go
                 if json:
-                    go_package_input = prompter.QText(name='go_package',message='Enter a prefix to support Go package',default='github.com/{}'.format(package_name))
-                    go_package = prompter.ask_user_question(questions=[go_package_input])
+                    go_package_input = prompter.QText(
+                        name="go_package",
+                        message="Enter a prefix to support Go package",
+                        default="github.com/{}".format(package_name),
+                    )
+                    go_package = prompter.ask_user_question(
+                        questions=[go_package_input]
+                    )
                 if go_package is not None:
-                    go_package = go_package['go_package']
+                    go_package = go_package["go_package"]
                 else:
-                    go_package = 'github.com/{}'.format(package_name)
+                    go_package = "github.com/{}".format(package_name)
             # elif c['language'] == 'webpack':
             #     temp_c_lang = webpack
             # TODO Add more client supported languages
             else:
-                raise errors.SylkValidationError('Client Language Error','Client {} is not supported'.format(c['language']))
+                raise errors.SylkValidationError(
+                    "Client Language Error",
+                    "Client {} is not supported".format(c["language"]),
+                )
             client = SylkClient_pb2.SylkClient(
-                out_dir=get_uri_client(path, c.language if hasattr(c,'language') else c['language']),
-                language=SylkClient_pb2.SylkClientLanguages.Name(temp_c_lang))
+                out_dir=get_uri_client(
+                    path, c.language if hasattr(c, "language") else c["language"]
+                ),
+                language=SylkClient_pb2.SylkClientLanguages.Name(temp_c_lang),
+            )
             temp_clients.append(client)
     # Default client
     else:
-        client = SylkClient_pb2.SylkClient(out_dir=get_uri_client(
-            path, 'python'), language='python')
+        client = SylkClient_pb2.SylkClient(
+            out_dir=get_uri_client(path, "python"), language="python"
+        )
         temp_clients.append(client)
-  
+
     # Init project
     project = SylkProject_pb2.SylkProject(
         uri=get_uri_project(path, name),
         name=name,
         package_name=package_name,
         # version='0.0.1',
         # type=ResourceTypes.project.value,
         # kind=ResourceKinds.sylk_1.value,
         server=server,
         clients=temp_clients,
-        go_package=go_package
+        go_package=go_package,
     )
     # Return project as message or dict
     return project if json == False else MessageToDict(project)
 
- 
-def generate_service(path, domain, name, service_language, dependencies, description=None,methods=[],extensions=None, json=False,sylk_json=None):
-    path = path.split('/sylk.json')[0]
+
+def generate_service(
+    path,
+    full_name,
+    service_language,
+    dependencies,
+    description=None,
+    methods=[],
+    extensions=None,
+    json=False,
+    sylk_json=None,
+    tag=None,
+):
+    path = path.split("/sylk.json")[0]
     # Init service
     temp_methods = []
 
     if methods:
         for m in methods:
-            temp_methods.append(ParseDict(m,SylkMethod_pb2.SylkMethod()))
+            temp_methods.append(ParseDict(m, SylkMethod_pb2.SylkMethod()))
     temp_ext = {}
-    full_name = get_service_full_name(domain, name)
     if extensions is not None:
         for ext in extensions:
-            if '.'.join(ext.split('.')[:3]) not in dependencies and '.'.join(ext.split('.')[:3]) != full_name:
-                depend_name = '.'.join(ext.split('.')[:3])
+            if (
+                ".".join(ext.split(".")[:3]) not in dependencies
+                and ".".join(ext.split(".")[:3]) != full_name
+            ):
+                depend_name = ".".join(ext.split(".")[:3])
                 print_warning("Adding depndency {}".format(depend_name))
                 dependencies.append(depend_name)
             if sylk_json is not None:
-                pkg_path = 'protos/{0}/{1}/{2}/{1}.proto'.format(ext.split('.')[0],ext.split('.')[1],ext.split('.')[2])
-                if  sylk_json.get('packages'):
-                    ext_package = sylk_json.get('packages').get(pkg_path)
-                    ext_msg = next((m for m in ext_package.get('messages') if m.get('fullName') == '.'.join(ext.split('.')[:-1])),None)
+                pkg_path = "protos/{0}/{1}/{2}/{1}.proto".format(
+                    ext.split(".")[0], ext.split(".")[1], ext.split(".")[2]
+                )
+                if sylk_json.get("packages"):
+                    ext_package = sylk_json.get("packages").get(pkg_path)
+                    ext_msg = next(
+                        (
+                            m
+                            for m in ext_package.get("messages")
+                            if m.get("fullName") == ".".join(ext.split(".")[:-1])
+                        ),
+                        None,
+                    )
                     if ext_msg is not None:
-                        ext_field = next((f_ext for f_ext in ext_msg.get('fields') if f_ext.get('fullName') == ext),None)
+                        ext_field = next(
+                            (
+                                f_ext
+                                for f_ext in ext_msg.get("fields")
+                                if f_ext.get("fullName") == ext
+                            ),
+                            None,
+                        )
                         if ext_field is not None:
-                            temp_ext = parse_proto_extension(ext_field.get('fieldType'),ext_field.get('label'),ext_field,extensions[ext],temp_ext,sylk_json=sylk_json)
+                            temp_ext = parse_proto_extension(
+                                ext_field.get("fieldType"),
+                                ext_field.get("label"),
+                                ext_field,
+                                extensions[ext],
+                                temp_ext,
+                                sylk_json=sylk_json,
+                            )
             else:
-                print_error("Cannot parse extension value without context to sylk.json file !")
+                print_error(
+                    "Cannot parse extension value without context to sylk.json file !"
+                )
                 exit(1)
-    service = SylkService_pb2.SylkService(uri=get_uri_service(path, name, service_language.lower()),
-                                  name=name, full_name=get_service_full_name(domain, name), dependencies=dependencies,
-                                  methods=temp_methods,
-                                  description=description,
-                                  type= ResourceTypes.service.value,
-                                #   version='0.0.1',
-                                  extensions=temp_ext)
+    service = SylkService_pb2.SylkService(
+        # uri=get_uri_service(path, full_name, service_language.lower()),
+        name=full_name.split('.')[-1],
+        full_name=full_name,
+        dependencies=dependencies,
+        methods=temp_methods,
+        description=description,
+        type=ResourceTypes.service.value,
+        extensions=temp_ext,
+        tag=tag,
+    )
     # Init methods
     # service.methods = dependencies
 
     # Init dependencies
     # dependencies = []
     # service.dependencies = dependencies
     return service if json == False else MessageToDict(service)
 
 
-def generate_package(path, domain, name, dependencies=[],messages=[],enums=[],description=None,extensions=None, json=False,sylk_json=None):
-    path = path.split('/sylk.json')[0]
+def generate_package(
+    path,
+    pkg_full_path,
+    dependencies=[],
+    messages=[],
+    enums=[],
+    services=[],
+    description=None,
+    extensions=None,
+    json=False,
+    sylk_json=None,
+    version=None
+):
+    path = path.split("/sylk.json")[0]
+    name = pkg_full_path.split(".")[-2] if version else pkg_full_path.split(".")[-1]
     temp_msgs = []
     temp_enums = []
+    temp_services = []
     for m in messages:
-        temp_msgs.append(ParseDict(m,SylkMessage_pb2.SylkMessage()))
+        temp_msgs.append(ParseDict(m, SylkMessage_pb2.SylkMessage()))
     if enums is not None:
         for e in enums:
-            temp_enums.append(ParseDict(e,SylkEnum_pb2.SylkEnum()))
- 
-    full_name = get_package_full_name(domain, name)
+            temp_enums.append(ParseDict(e, SylkEnum_pb2.SylkEnum()))
+    if services is not None:
+        for s in services:
+            temp_services.append(ParseDict(s, SylkService_pb2.SylkService()))
+
     temp_ext = None
     if extensions is not None:
         temp_ext = {}
         for ext in extensions:
-            if '.'.join(ext.split('.')[:3]) not in dependencies and '.'.join(ext.split('.')[:3]) != full_name:
-                depend_name = '.'.join(ext.split('.')[:3])
+            if (
+                ".".join(ext.split(".")[:3]) not in dependencies
+                and ".".join(ext.split(".")[:3]) != pkg_full_path
+            ):
+                depend_name = ".".join(ext.split(".")[:3])
                 print_warning("Adding depndency {}".format(depend_name))
                 dependencies.append(depend_name)
             if sylk_json is not None:
-                pkg_path = 'protos/{0}/{1}/{2}/{1}.proto'.format(ext.split('.')[0],ext.split('.')[1],ext.split('.')[2])
-                if  sylk_json.get('packages'):
-                    ext_package = sylk_json.get('packages').get(pkg_path)
-                    ext_msg = next((m for m in ext_package.get('messages') if m.get('fullName') == '.'.join(ext.split('.')[:-1])),None)
+                pkg_path = "protos/{0}/{1}/{2}/{1}.proto".format(
+                    ext.split(".")[0], ext.split(".")[1], ext.split(".")[2]
+                )
+                if sylk_json.get("packages"):
+                    ext_package = sylk_json.get("packages").get(pkg_path)
+                    ext_msg = next(
+                        (
+                            m
+                            for m in ext_package.get("messages")
+                            if m.get("fullName") == ".".join(ext.split(".")[:-1])
+                        ),
+                        None,
+                    )
                     if ext_msg is not None:
-                        ext_field = next((f_ext for f_ext in ext_msg.get('fields') if f_ext.get('fullName') == ext),None)
+                        ext_field = next(
+                            (
+                                f_ext
+                                for f_ext in ext_msg.get("fields")
+                                if f_ext.get("fullName") == ext
+                            ),
+                            None,
+                        )
                         if ext_field is not None:
-                            temp_ext = parse_proto_extension(ext_field.get('fieldType'),ext_field.get('label'),ext_field,extensions[ext],temp_ext,sylk_json=sylk_json)
+                            temp_ext = parse_proto_extension(
+                                ext_field.get("fieldType"),
+                                ext_field.get("label"),
+                                ext_field,
+                                extensions[ext],
+                                temp_ext,
+                                sylk_json=sylk_json,
+                            )
             else:
-                print_error("Cannot parse extension value without context to sylk.json file !")
+                print_error(
+                    "Cannot parse extension value without context to sylk.json file !"
+                )
                 exit(1)
 
     package = SylkPackage_pb2.SylkPackage(
-        uri= get_uri_package(path, full_name),
-        type= ResourceTypes.package.value,
+        # uri=get_uri_package(path, pkg_full_path),
+        type=ResourceTypes.package.value,
         name=name,
-        package=full_name,
-        # version='0.0.1',
+        package=pkg_full_path,
         dependencies=dependencies,
         messages=temp_msgs,
         enums=temp_enums,
         description=description,
-        extensions=temp_ext
+        extensions=temp_ext,
+        services=temp_services
     )
 
     return package if json == False else MessageToDict(package)
 
 
-def generate_message(path, domain, package, name, fields=[], option=0, description=None,extensions=None, json=False,sylk_json=None):
-    path = path.split('/sylk.json')[0]
+def generate_message(
+    path,
+    domain,
+    package,
+    name,
+    fields=[],
+    option=0,
+    description=None,
+    extensions=None,
+    json=False,
+    sylk_json=None,
+    tag=None
+):
+    path = path.split("/sylk.json")[0]
     temp_fields = []
-    msg_fName = get_message_full_name(domain, package.name, name)
-    msg_uri = get_uri_message(path, msg_fName)
+    msg_fName = package.package + '.' + name
+    # msg_uri = get_uri_message(path, msg_fName)
     if option is None:
         option = 0
     else:
-        if 'google.protobuf.Descriptor' not in package.dependencies:
-            package.dependencies.append('google.protobuf.Descriptor')
+        if "google.protobuf.Descriptor" not in package.dependencies:
+            package.dependencies.append("google.protobuf.Descriptor")
     index = 0 if option == 0 else 55555
     for f in fields:
-        if next((n for n in temp_fields if n.name == f.get('name')), None) is None:
+        if next((n for n in temp_fields if n.name == f.get("name")), None) is None:
             index += 1
-            f_fName = get_field_full_name(
-                domain, package.name, name, f.get('name'))
+            f_fName = package.package + '.' + name + '.' + f.get('name')
             msg_type = None
-            msg_type_temp  = f.get('message_type') if f.get('message_type') is not None else f.get('messageType')
+            msg_type_temp = (
+                f.get("message_type")
+                if f.get("message_type") is not None
+                else f.get("messageType")
+            )
             if msg_type_temp is not None:
-                package_name = '.'.join(msg_type_temp.split('.')[:3])
-                if package_name not in package.dependencies and package.package not in msg_type_temp:
-                    package.dependencies.append(package_name)
-                if 'google.protobuf' in msg_type_temp:
-                    msg_type = '{0}.{1}.{2}'.format(msg_type_temp.split('.')[0],msg_type_temp.split('.')[1],msg_type_temp.split('.')[-1].capitalize()) if msg_type_temp is not None else None
-                else:
-                    msg_type = msg_type_temp
+                msg_type = msg_type_temp
             f_uri = get_uri_field(path, f_fName)
             fields_oneof = []
-            oneofs_fields = f.get('oneof_fields') if f.get('oneof_fields')  is not None else f.get('oneofFields') 
-            if oneofs_fields :
+            oneofs_fields = (
+                f.get("oneof_fields")
+                if f.get("oneof_fields") is not None
+                else f.get("oneofFields")
+            )
+            if oneofs_fields:
                 for f_oneof in oneofs_fields:
-                    f_oneof_full_name = get_oneof_field_full_name(domain=domain,package=package.name,message=name,parent_field=f.get('name'),name=f_oneof.get('name'))
-                    f_oneof_uri = get_uri_oneof_field(path, f_oneof_full_name)
-                    fields_oneof.append(SylkField_pb2.SylkOneOfField(uri=f_oneof_uri,
-                        name=f_oneof.get('name'),
-                        full_name=f_oneof_full_name,
-                        description=f_oneof.get('description'),
-                        index=index,
-                        field_type=f_oneof.get('fieldType') if f_oneof.get('fieldType') is not None else f_oneof.get('field_type'),
-                        enum_type=f_oneof.get('enumType') if f_oneof.get('enumType') is not None else f_oneof.get('enum_type'),
-                        type=ResourceTypes.descriptor.value,
-                        kind=ResourceKinds.oneof_field.value,
-                        message_type=f_oneof.get('messageType')  if f_oneof.get('messageType') is not None else f_oneof.get('message_type')))
+                    f_oneof_full_name = get_oneof_field_full_name(
+                        domain=domain,
+                        package=package.name,
+                        message=name,
+                        parent_field=f.get("name"),
+                        name=f_oneof.get("name"),
+                    )
+                    # f_oneof_uri = get_uri_oneof_field(path, f_oneof_full_name)
+                    fields_oneof.append(
+                        SylkField_pb2.SylkOneOfField(
+                            # uri=f_oneof_uri,
+                            name=f_oneof.get("name"),
+                            full_name=f_oneof_full_name,
+                            description=f_oneof.get("description"),
+                            index=index,
+                            field_type=f_oneof.get("fieldType")
+                            if f_oneof.get("fieldType") is not None
+                            else f_oneof.get("field_type"),
+                            enum_type=f_oneof.get("enumType")
+                            if f_oneof.get("enumType") is not None
+                            else f_oneof.get("enum_type"),
+                            type=ResourceTypes.descriptor.value,
+                            kind=ResourceKinds.oneof_field.value,
+                            message_type=f_oneof.get("messageType")
+                            if f_oneof.get("messageType") is not None
+                            else f_oneof.get("message_type"),
+                        )
+                    )
                     index += 1
             temp_ext = None
-            if f.get('extensions') is not None:
+            if f.get("extensions") is not None:
                 temp_ext = {}
-                for ext in f.get('extensions'):
-                    if '.'.join(ext.split('.')[:3]) not in package.dependencies:
-                        depend_name = '.'.join(ext.split('.')[:3])
+                for ext in f.get("extensions"):
+                    if ".".join(ext.split(".")[:3]) not in package.dependencies:
+                        depend_name = ".".join(ext.split(".")[:3])
                         print_warning("Adding depndency {}".format(depend_name))
                         package.dependencies.append(depend_name)
 
                     if sylk_json is not None:
-                        pkg_path = 'protos/{0}/{1}/{2}/{1}.proto'.format(ext.split('.')[0],ext.split('.')[1],ext.split('.')[2])
-                        if  sylk_json.get('packages'):
-                            ext_package = sylk_json.get('packages').get(pkg_path)
-                            ext_msg = next((m for m in ext_package.get('messages') if m.get('fullName') == '.'.join(ext.split('.')[:-1])),None)
+                        pkg_path = "protos/{0}/{1}/{2}/{1}.proto".format(
+                            ext.split(".")[0], ext.split(".")[1], ext.split(".")[2]
+                        )
+                        if sylk_json.get("packages"):
+                            ext_package = sylk_json.get("packages").get(pkg_path)
+                            ext_msg = next(
+                                (
+                                    m
+                                    for m in ext_package.get("messages")
+                                    if m.get("fullName")
+                                    == ".".join(ext.split(".")[:-1])
+                                ),
+                                None,
+                            )
                             if ext_msg is not None:
-                                ext_field = next((f_ext for f_ext in ext_msg.get('fields') if f_ext.get('fullName') == ext),None)
+                                ext_field = next(
+                                    (
+                                        f_ext
+                                        for f_ext in ext_msg.get("fields")
+                                        if f_ext.get("fullName") == ext
+                                    ),
+                                    None,
+                                )
                                 if ext_field is not None:
-                                    temp_ext = parse_proto_extension(ext_field.get('fieldType'),ext_field.get('label'),ext_field,f.get('extensions')[ext],temp_ext,sylk_json=sylk_json)
+                                    temp_ext = parse_proto_extension(
+                                        ext_field.get("fieldType"),
+                                        ext_field.get("label"),
+                                        ext_field,
+                                        f.get("extensions")[ext],
+                                        temp_ext,
+                                        sylk_json=sylk_json,
+                                    )
                     else:
-                        print_error("Cannot parse extension value without context to sylk.json file !")
+                        print_error(
+                            "Cannot parse extension value without context to sylk.json file !"
+                        )
                         exit(1)
-            temp_fields.append(SylkField_pb2.SylkField(uri=f_uri, name=f.get('name'), full_name=f_fName,
-                                                 description=f.get(
-                                                     'description'),
-                                                 index=index, field_type=f.get(
-                                                     'field_type') if f.get(
-                                                     'field_type') is not None else f.get(
-                                                     'fieldType'),
-                                                 label=f.get('label'),
-                                                 enum_type=f.get('enum_type') if f.get('enum_type') is not None else f.get('enumType'),
-                                                 type=ResourceTypes.descriptor.value,
-                                                 kind=ResourceKinds.field.value,
-                                                 message_type=msg_type,
-                                                 extensions=temp_ext,
-                                                 key_type=f.get('key_type') if f.get('key_type') is not None else f.get('keyType'),
-                                                 value_type=f.get('value_type') if f.get('value_type') is not None else f.get('valueType'),
-                                                 oneof_fields=fields_oneof))
+            temp_fields.append(
+                SylkField_pb2.SylkField(
+                    # uri=f_uri,
+                    name=f.get("name"),
+                    full_name=f_fName,
+                    description=f.get("description"),
+                    index=index,
+                    field_type=f.get("field_type")
+                    if f.get("field_type") is not None
+                    else f.get("fieldType"),
+                    label=f.get("label"),
+                    enum_type=f.get("enum_type")
+                    if f.get("enum_type") is not None
+                    else f.get("enumType"),
+                    type=ResourceTypes.descriptor.value,
+                    kind=ResourceKinds.field.value,
+                    message_type=msg_type,
+                    extensions=temp_ext,
+                    key_type=f.get("key_type")
+                    if f.get("key_type") is not None
+                    else f.get("keyType"),
+                    value_type=f.get("value_type")
+                    if f.get("value_type") is not None
+                    else f.get("valueType"),
+                    oneof_fields=fields_oneof,
+                )
+            )
         else:
             logging.warning(
-                f"Cannot insert field {f.get('name')} already exists under {name} message")
-    
+                f"Cannot insert field {f.get('name')} already exists under {name} message"
+            )
+
     temp_ext = {}
     if extensions is not None:
         temp_ext = {}
 
         for ext in extensions:
-            if '.'.join(ext.split('.')[:3]) not in package.dependencies and '.'.join(ext.split('.')[:3]) != package.package:
-                depend_name = '.'.join(ext.split('.')[:3])
+            if (
+                ".".join(ext.split(".")[:3]) not in package.dependencies
+                and ".".join(ext.split(".")[:3]) != package.package
+            ):
+                depend_name = ".".join(ext.split(".")[:3])
                 print_warning("Adding dependency {}".format(depend_name))
                 package.dependencies.append(depend_name)
             if sylk_json is not None:
-                pkg_path = 'protos/{0}/{1}/{2}/{1}.proto'.format(ext.split('.')[0],ext.split('.')[1],ext.split('.')[2])
-                if  sylk_json.get('packages'):
-                    ext_package = sylk_json.get('packages').get(pkg_path)
-                    ext_msg = next((m for m in ext_package.get('messages') if m.get('fullName') == '.'.join(ext.split('.')[:-1])),None)
+                pkg_path = "protos/{0}/{1}/{2}/{1}.proto".format(
+                    ext.split(".")[0], ext.split(".")[1], ext.split(".")[2]
+                )
+                if sylk_json.get("packages"):
+                    ext_package = sylk_json.get("packages").get(pkg_path)
+                    ext_msg = next(
+                        (
+                            m
+                            for m in ext_package.get("messages")
+                            if m.get("fullName") == ".".join(ext.split(".")[:-1])
+                        ),
+                        None,
+                    )
                     if ext_msg is not None:
-                        ext_field = next((f_ext for f_ext in ext_msg.get('fields') if f_ext.get('fullName') == ext),None)
+                        ext_field = next(
+                            (
+                                f_ext
+                                for f_ext in ext_msg.get("fields")
+                                if f_ext.get("fullName") == ext
+                            ),
+                            None,
+                        )
                         if ext_field is not None:
-                            temp_ext = parse_proto_extension(ext_field.get('fieldType'),ext_field.get('label'),ext_field,extensions[ext],temp_ext,sylk_json=sylk_json)
+                            temp_ext = parse_proto_extension(
+                                ext_field.get("fieldType"),
+                                ext_field.get("label"),
+                                ext_field,
+                                extensions[ext],
+                                temp_ext,
+                                sylk_json=sylk_json,
+                            )
             else:
-                print_error("Cannot parse extension value without context to sylk.json file !")
+                print_error(
+                    "Cannot parse extension value without context to sylk.json file !"
+                )
                 exit(1)
-    
-    msg = SylkMessage_pb2.SylkMessage(uri=msg_uri, name=name, full_name=msg_fName, fields=temp_fields, type=ResourceTypes.descriptor.value,extensions=temp_ext,
-                       kind=ResourceKinds.message.value, extension_type=SylkCommons_pb2.SylkExtensions.Name(option) if isinstance(option,int) else option, description=description)
+
+    msg = SylkMessage_pb2.SylkMessage(
+        # uri=msg_uri,
+        name=name,
+        full_name=msg_fName,
+        fields=temp_fields,
+        type=ResourceTypes.descriptor.value,
+        extensions=temp_ext,
+        kind=ResourceKinds.message.value,
+        extension_type=SylkCommons_pb2.SylkExtensions.Name(option)
+        if isinstance(option, int)
+        else option,
+        description=description,
+        tag=tag
+    )
     return msg if json == False else MessageToDict(msg)
 
 
-def generate_enum(path, domain, package, name, enum_values, json=False,description=None):
-    path = path.split('/sylk.json')[0]
+def generate_enum(
+    path, domain, package, name, enum_values, json=False, description=None, tag=None
+):
+    path = path.split("/sylk.json")[0]
 
-    e_fName = get_enum_full_name(domain, package, name)
-    e_uri = get_uri_enum(path, e_fName)
+    e_fName = package.package + '.' + name
+    # e_uri = get_uri_enum(path, e_fName)
     temp_values = []
     index = 0
     for ev in enum_values:
-        ev_fName = get_enum_value_full_name(
-            domain, package, name, ev.get('name'))
-        ev_uri = get_uri_enum_value(path, ev_fName)
-        temp_values.append(SylkEnum_pb2.SylkEnumValue__pb2.SylkEnumValue(uri=ev_uri, name=ev.get(
-            'name'), number=ev.get('number'), index=index,type=ResourceTypes.descriptor.value,kind=ResourceKinds.enum_value.value,description=ev.get('description')))
-        index = + 1
+        # ev_fName = get_enum_value_full_name(
+        #     domain, package, name, ev.get("name"), version=version
+        # )
+        # ev_uri = get_uri_enum_value(path, ev_fName)
+        temp_values.append(
+            SylkEnumValue_pb2.SylkEnumValue(
+                # uri=ev_uri,
+                name=ev.get("name"),
+                number=ev.get("number"),
+                index=index,
+                type=ResourceTypes.descriptor.value,
+                kind=ResourceKinds.enum_value.value,
+                description=ev.get("description"),
+            )
+        )
+        index = +1
 
-    ENUM = SylkEnum_pb2.SylkEnum(uri=e_uri, name=name,type=ResourceTypes.descriptor.value,kind=ResourceKinds.enum.value,
-                            full_name=e_fName, values=temp_values,description=description)
+    ENUM = SylkEnum_pb2.SylkEnum(
+        # uri=e_uri,
+        name=name,
+        type=ResourceTypes.descriptor.value,
+        kind=ResourceKinds.enum.value,
+        full_name=e_fName,
+        values=temp_values,
+        description=description,
+        tag=tag
+    )
     return ENUM if json == False else MessageToDict(ENUM)
 
 
-def generate_rpc(path, name, client_streaming, server_streaming, in_type, out_type, description=None, json=False):
-    path = path.split('/sylk.json')[0]
-    RPC = SylkMethod_pb2.SylkMethod(uri=get_uri_rpc(path, name), name=name, full_name=get_method_full_name(name), type=ResourceTypes.descriptor.value, kind=ResourceKinds.method.value,
-                             input_type=in_type, output_type=out_type, client_streaming=client_streaming, server_streaming=server_streaming, description=description)
+def generate_rpc(
+    path,
+    name,
+    client_streaming,
+    server_streaming,
+    in_type,
+    out_type,
+    description=None,
+    json=False,
+):
+    path = path.split("/sylk.json")[0]
+    RPC = SylkMethod_pb2.SylkMethod(
+        # uri=get_uri_rpc(path, name),
+        name=name.split('.')[-1],
+        full_name=name,
+        type=ResourceTypes.descriptor.value,
+        kind=ResourceKinds.method.value,
+        input_type=in_type,
+        output_type=out_type,
+        client_streaming=client_streaming,
+        server_streaming=server_streaming,
+        description=description,
+    )
     return RPC if json == False else MessageToDict(RPC)
 
 
 def parse_proto(proto_path) -> FileDescriptor:
     # print_note(f"Parsing proto file into python module -> {proto_path}")
     try:
-        sys.path.index(os.getcwd()+'/protos')
+        sys.path.index(os.getcwd() + "/protos")
     except:
-        sys.path.append(os.getcwd()+'/protos')
+        sys.path.append(os.getcwd() + "/protos")
 
     proto = grpc.protos_and_services(proto_path)
     return proto
 
 
 def parse_pool(pool) -> DescriptorPool:
     return pool
@@ -486,262 +781,463 @@
 
 
 def get_uri_project(path, name):
     return construct_uri(path, ResourceTypes.project, ResourceKinds.sylk_1, name)
 
 
 def get_uri_client(path, language):
-    uri = 'unknown'
-    if language == 'python' or language == SylkClient_pb2.SylkClientLanguages.python:
+    uri = "unknown"
+    if language == "python" or language == SylkClient_pb2.SylkClientLanguages.python:
         uri = construct_uri(path, ResourceTypes.client, ResourceKinds.file_py)
-    elif language == 'typescript' or language == SylkClient_pb2.SylkClientLanguages.typescript:
+    elif (
+        language == "typescript"
+        or language == SylkClient_pb2.SylkClientLanguages.typescript
+    ):
         uri = construct_uri(path, ResourceTypes.client, ResourceKinds.file_ts)
-    elif language == 'go' or language == SylkClient_pb2.SylkClientLanguages.go:
+    elif language == "go" or language == SylkClient_pb2.SylkClientLanguages.go:
         uri = construct_uri(path, ResourceTypes.client, ResourceKinds.file_go)
-    elif language == 'nodejs' or language == SylkClient_pb2.SylkClientLanguages.nodejs:
+    elif language == "nodejs" or language == SylkClient_pb2.SylkClientLanguages.nodejs:
         uri = construct_uri(path, ResourceTypes.client, ResourceKinds.file_js)
-    elif language == 'webpack':
+    elif language == "webpack":
         uri = construct_uri(path, ResourceTypes.client, ResourceKinds.file_webpack)
     else:
-        raise errors.SylkValidationError('Client Not Supported','Client of type {} is not supported yet !'.format(language))
+        raise errors.SylkValidationError(
+            "Client Not Supported",
+            "Client of type {} is not supported yet !".format(language),
+        )
     return uri
 
 
 def get_uri_service(path, name, language):
     kind = None
-    if language == 'python':
+    if language == "python":
         kind = ResourceKinds.service_srvr_py
-    elif language == 'typescript':
+    elif language == "typescript":
         kind = ResourceKinds.service_srvr_ts
 
     return construct_uri(path, ResourceTypes.service, kind, name)
 
 
 def get_uri_rpc(path, name):
     return construct_uri(path, ResourceTypes.descriptor, ResourceKinds.method, name)
 
 
 def get_uri_package(path, full_name):
-    return construct_uri(path, ResourceTypes.package, ResourceKinds.file_proto, full_name)
+    return construct_uri(
+        path, ResourceTypes.package, ResourceKinds.file_proto, full_name
+    )
 
 
 def get_uri_message(path, full_name):
-    return construct_uri(path, ResourceTypes.descriptor, ResourceKinds.message, full_name)
+    return construct_uri(
+        path, ResourceTypes.descriptor, ResourceKinds.message, full_name
+    )
 
 
 def get_uri_enum(path, full_name):
     return construct_uri(path, ResourceTypes.descriptor, ResourceKinds.enum, full_name)
 
 
 def get_uri_enum_value(path, full_name):
-    return construct_uri(path, ResourceTypes.descriptor, ResourceKinds.enum_value, full_name)
+    return construct_uri(
+        path, ResourceTypes.descriptor, ResourceKinds.enum_value, full_name
+    )
 
 
 def get_uri_field(path, full_name):
     return construct_uri(path, ResourceTypes.descriptor, ResourceKinds.field, full_name)
 
+
 def get_uri_oneof_field(path, full_name):
-    return construct_uri(path, ResourceTypes.descriptor, ResourceKinds.oneof_field, full_name)
+    return construct_uri(
+        path, ResourceTypes.descriptor, ResourceKinds.oneof_field, full_name
+    )
+
 
-def construct_uri(path, resource_type: ResourceTypes, resource_kind: ResourceKinds, full_name=None):
-    uri = 'unknown'
+def construct_uri(
+    path, resource_type: ResourceTypes, resource_kind: ResourceKinds, full_name=None
+):
+    uri = "unknown"
     # Project
     if resource_type == ResourceTypes.project:
-        uri = f'{path}'
+        uri = f"{path}"
     # Client
     elif resource_type == ResourceTypes.client:
-        client_kind = resource_kind.value.split('/')[-1]
-        uri = f'{path}/{ResourceTypes.client.value}/{client_kind}'
+        client_kind = resource_kind.value.split("/")[-1]
+        uri = f"{path}/{ResourceTypes.client.value}/{client_kind}"
     # Server
     elif resource_type == ResourceTypes.server:
         pass
     # Service
     elif resource_type == ResourceTypes.service:
-        uri = f'{path}/protos/{full_name}.proto'
+        uri = f"{path}/protos/{full_name}"
     # Package
     elif resource_type == ResourceTypes.package:
-        uri = f'{path}/{resource_type.value}/{full_name}'
+        uri = f"{path}/{resource_type.value}/{full_name}"
     # Descriptors
     elif resource_type == ResourceTypes.descriptor:
         # Method
         if resource_kind == ResourceKinds.method:
-            uri = f'{path}/methods/{full_name}'
+            uri = f"{path}/methods/{full_name}"
         # Message
         elif resource_kind == ResourceKinds.message:
-            uri = f'{path}/messages/{full_name}'
+            uri = f"{path}/messages/{full_name}"
         # Enum
         elif resource_kind == ResourceKinds.enum:
-            uri = f'{path}/enums/{full_name}'
+            uri = f"{path}/enums/{full_name}"
         # Enum
         elif resource_kind == ResourceKinds.enum_value:
-            uri = f'{path}/enums/{full_name}'
+            uri = f"{path}/enums/{full_name}"
         # Field
         elif resource_kind == ResourceKinds.field:
-            uri = f'{path}/fields/{full_name}'
+            uri = f"{path}/fields/{full_name}"
         # Oneof Field
         elif resource_kind == ResourceKinds.oneof_field:
-            uri = f'{path}/oneof_field/{full_name}'
+            uri = f"{path}/oneof_field/{full_name}"
 
     return uri
 
 
-def get_service_full_name(domain, name):
-    return construct_full_name(ResourceTypes.service, ResourceKinds.file_proto, domain, name=name)
+def get_service_full_name(domain, name, version):
+    return construct_full_name(
+        ResourceTypes.service,
+        ResourceKinds.file_proto,
+        domain,
+        name=name,
+        version=version,
+    )
 
 
-def get_package_full_name(domain, name):
-    return construct_full_name(ResourceTypes.package, ResourceKinds.file_proto, domain, name=name)
+def get_package_full_name(domain, name, version):
+    return construct_full_name(
+        ResourceTypes.package,
+        ResourceKinds.file_proto,
+        domain,
+        name=name,
+        version=version,
+    )
 
 
 def get_method_full_name(name):
     pass
 
 
 def get_message_full_name(domain, package, name):
-    return construct_full_name(ResourceTypes.descriptor, ResourceKinds.message, domain, parent_name=package, name=name)
+    return construct_full_name(
+        ResourceTypes.descriptor,
+        ResourceKinds.message,
+        domain,
+        parent_name=package,
+        name=name,
+    )
+
+
+def get_field_full_name(domain, package, message, name, version="v1"):
+    return construct_full_name(
+        ResourceTypes.descriptor,
+        ResourceKinds.field,
+        domain,
+        parent_name=[package, message],
+        name=name,
+        version=version,
+    )
+
 
-def get_field_full_name(domain, package, message, name):
-    return construct_full_name(ResourceTypes.descriptor, ResourceKinds.field, domain, parent_name=[package, message], name=name)
+def get_oneof_field_full_name(
+    domain, package, message, parent_field, name, version="v1"
+):
+    return construct_full_name(
+        ResourceTypes.descriptor,
+        ResourceKinds.oneof_field,
+        domain,
+        parent_name=[package, message, parent_field],
+        name=name,
+        version=version,
+    )
 
-def get_oneof_field_full_name(domain, package, message,parent_field, name):
-    return construct_full_name(ResourceTypes.descriptor, ResourceKinds.oneof_field, domain, parent_name=[package, message, parent_field], name=name)
 
-def get_enum_full_name(domain, package, enum):
-    return construct_full_name(ResourceTypes.descriptor, ResourceKinds.enum, domain, parent_name=package, name=enum)
+def get_enum_full_name(domain, package, enum, version="v1"):
+    return construct_full_name(
+        ResourceTypes.descriptor,
+        ResourceKinds.enum,
+        domain,
+        parent_name=package,
+        name=enum,
+        version=version,
+    )
 
 
-def get_enum_value_full_name(domain, package, enum, name):
-    return construct_full_name(ResourceTypes.descriptor, ResourceKinds.enum_value, domain, parent_name=[package, enum], name=name)
+def get_enum_value_full_name(domain, package, enum, name, version="v1"):
+    return construct_full_name(
+        ResourceTypes.descriptor,
+        ResourceKinds.enum_value,
+        domain,
+        parent_name=[package, enum],
+        name=name,
+        version=version,
+    )
 
 
-def construct_full_name(resource_type: ResourceTypes, resource_kind: ResourceKinds, domain=None, parent_name=None, name=None, version='v1'):
-    full_name = 'unknown'
+def construct_full_name(
+    resource_type: ResourceTypes,
+    resource_kind: ResourceKinds,
+    domain=None,
+    parent_name=None,
+    name=None,
+    version="v1",
+):
+    full_name = "unknown"
     # Service
     if resource_type == ResourceTypes.service:
-        full_name = f'{domain}.{name}.{version}'
+        full_name = f"{domain}.{name}.{version}"
     # Package
     elif resource_type == ResourceTypes.package:
-        full_name = f'{domain}.{name}.{version}'
+        full_name = f"{domain}.{name}.{version}"
     # Descriptors
     elif resource_type == ResourceTypes.descriptor:
         # Method
         if resource_kind == ResourceKinds.method:
-            full_name = f'{domain}.{parent_name}.{version}.{name}'
+            full_name = f"{domain}.{parent_name}.{version}.{name}"
         # Message
         elif resource_kind == ResourceKinds.message:
-            full_name = f'{domain}.{parent_name}.{version}.{name}'
+            full_name = f"{domain}.{parent_name}.{version}.{name}"
         # Enum
         elif resource_kind == ResourceKinds.enum:
-            full_name = f'{domain}.{parent_name}.{version}.{name}'
-         # EnumValue
+            full_name = f"{domain}.{parent_name}.{version}.{name}"
+        # EnumValue
         elif resource_kind == ResourceKinds.enum_value:
-            full_name = f'{domain}.{parent_name[0]}.{version}.{parent_name[1]}.{name}'
+            full_name = f"{domain}.{parent_name[0]}.{version}.{parent_name[1]}.{name}"
         # Field
         elif resource_kind == ResourceKinds.field:
-            full_name = f'{domain}.{parent_name[0]}.{version}.{parent_name[1]}.{name}'
+            full_name = f"{domain}.{parent_name[0]}.{version}.{parent_name[1]}.{name}"
         # Oneof Field
         elif resource_kind == ResourceKinds.oneof_field:
-            full_name = f'{domain}.{parent_name[0]}.{version}.{parent_name[1]}.{parent_name[2]}.{name}'
+            full_name = f"{domain}.{parent_name[0]}.{version}.{parent_name[1]}.{parent_name[2]}.{name}"
 
     return full_name
 
 
 def proto_to_dict(proto):
     return MessageToDict(proto)
 
-def parse_proto_extension(field_opt_type,field_opt_label,description,value,field_extensions,sylk_json):
-    if 'REPEATED' in field_opt_label:
+
+def parse_proto_extension(
+    field_opt_type, field_opt_label, description, value, field_extensions, sylk_json
+):
+    if "REPEATED" in field_opt_label:
         list_values_temp = []
         for field_opt_value in value:
-            if 'BOOL' in field_opt_type:
-                if hasattr(field_opt_value,'bool_value') == False:
+            if "BOOL" in field_opt_type:
+                if hasattr(field_opt_value, "bool_value") == False:
                     field_opt_value = Value(bool_value=field_opt_value)
                 list_values_temp.append(field_opt_value)
-            elif 'STRING' in field_opt_type:
-                if hasattr(field_opt_value,'string_value') == False:
+            elif "STRING" in field_opt_type:
+                if hasattr(field_opt_value, "string_value") == False:
                     field_opt_value = Value(string_value=field_opt_value)
                 list_values_temp.append(field_opt_value)
-            elif 'INT' in field_opt_type:
-                if hasattr(field_opt_value,'string_value') == False:
+            elif "INT" in field_opt_type:
+                if hasattr(field_opt_value, "string_value") == False:
                     field_opt_value = Value(number_value=field_opt_value)
                 list_values_temp.append(field_opt_value)
-            elif 'MESSAGE' in field_opt_type:
+            elif "MESSAGE" in field_opt_type:
                 struct_temp = Struct()
-                ext_package_path = 'protos/{0}/{1}/{2}/{1}.proto'.format(description.get('fullName').split('.')[0],description.get('fullName').split('.')[1],description.get('fullName').split('.')[2])
-                message_type = next((m for m in sylk_json.get('packages').get(ext_package_path).get('messages') if m.get('fullName') == '.'.join(description.get('fullName').split('.')[:-1])),None)
-                for field_ext_temp in message_type.get('fields'):
-                    if field_ext_temp.get('fieldType') == 'TYPE_MESSAGE' or field_ext_temp.get('fieldType') == 'TYPE_MAP' or field_ext_temp.get('fieldType') == 'TYPE_ENUM':
-                        raise errors.SylkValidationError('Extension values parse error','There are too many nested levels for {}'.format(field_ext_temp.full_name))
-                    struct_temp.update({field_ext_temp.get('name'):getattr(field_opt_value,field_ext_temp.get('name'))})
+                ext_package_path = "protos/{0}/{1}/{2}/{1}.proto".format(
+                    description.get("fullName").split(".")[0],
+                    description.get("fullName").split(".")[1],
+                    description.get("fullName").split(".")[2],
+                )
+                message_type = next(
+                    (
+                        m
+                        for m in sylk_json.get("packages")
+                        .get(ext_package_path)
+                        .get("messages")
+                        if m.get("fullName")
+                        == ".".join(description.get("fullName").split(".")[:-1])
+                    ),
+                    None,
+                )
+                for field_ext_temp in message_type.get("fields"):
+                    if (
+                        field_ext_temp.get("fieldType") == "TYPE_MESSAGE"
+                        or field_ext_temp.get("fieldType") == "TYPE_MAP"
+                        or field_ext_temp.get("fieldType") == "TYPE_ENUM"
+                    ):
+                        raise errors.SylkValidationError(
+                            "Extension values parse error",
+                            "There are too many nested levels for {}".format(
+                                field_ext_temp.full_name
+                            ),
+                        )
+                    struct_temp.update(
+                        {
+                            field_ext_temp.get("name"): getattr(
+                                field_opt_value, field_ext_temp.get("name")
+                            )
+                        }
+                    )
                 list_values_temp.append(Value(struct_value=struct_temp))
-            elif 'ENUM' in field_opt_type:
-                ext_package_path = 'protos/{0}/{1}/{2}/{1}.proto'.format(description.get('fullName').split('.')[0],description.get('fullName').split('.')[1],description.get('fullName').split('.')[2])
-                enum_type = next((e for e in sylk_json.get('packages').get(ext_package_path).get('enums') if e.get('fullName') == '.'.join(description.get('fullName').split('.')[:-1])),None)
-                enum_value = next((ev for ev in enum_type.get('values') if ev.get('number') == field_opt_value),None)
+            elif "ENUM" in field_opt_type:
+                ext_package_path = "protos/{0}/{1}/{2}/{1}.proto".format(
+                    description.get("fullName").split(".")[0],
+                    description.get("fullName").split(".")[1],
+                    description.get("fullName").split(".")[2],
+                )
+                enum_type = next(
+                    (
+                        e
+                        for e in sylk_json.get("packages")
+                        .get(ext_package_path)
+                        .get("enums")
+                        if e.get("fullName")
+                        == ".".join(description.get("fullName").split(".")[:-1])
+                    ),
+                    None,
+                )
+                enum_value = next(
+                    (
+                        ev
+                        for ev in enum_type.get("values")
+                        if ev.get("number") == field_opt_value
+                    ),
+                    None,
+                )
                 # if hasattr(field_opt_value,'string_value') == False:
                 #     field_opt_value = Value(string_value=enum_value.get('name'))
-                list_values_temp.append(Value(string_value=enum_value.get('name')))
+                list_values_temp.append(Value(string_value=enum_value.get("name")))
             else:
-                print_warning("Not supporting field type [{0}] for field extensions {1}".format(field_opt_type,description.get('fullName')))
+                print_warning(
+                    "Not supporting field type [{0}] for field extensions {1}".format(
+                        field_opt_type, description.get("fullName")
+                    )
+                )
         list_values = ListValue(values=list_values_temp)
-        field_extensions[description.get('fullName')] = Value(list_value=list_values)
+        field_extensions[description.get("fullName")] = Value(list_value=list_values)
     else:
-        if 'BOOL' in field_opt_type:
-            if hasattr(value,'bool_value'):
+        if "BOOL" in field_opt_type:
+            if hasattr(value, "bool_value"):
                 value = value.bool_value
-            field_extensions[description.get('fullName')] = Value(bool_value=value)
-        elif 'STRING' in field_opt_type:
-            if hasattr(value,'string_value'):
+            field_extensions[description.get("fullName")] = Value(bool_value=value)
+        elif "STRING" in field_opt_type:
+            if hasattr(value, "string_value"):
                 value = value.string_value
-            field_extensions[description.get('fullName')] = Value(string_value=getattr(value,'string_value') if hasattr(value,'string_value') != False else value)
-        elif 'INT' in field_opt_type or 'FLOAT' in field_opt_type  or 'DOUBLE' in field_opt_type:
-            if hasattr(value,'number_value'):
+            field_extensions[description.get("fullName")] = Value(
+                string_value=getattr(value, "string_value")
+                if hasattr(value, "string_value") != False
+                else value
+            )
+        elif (
+            "INT" in field_opt_type
+            or "FLOAT" in field_opt_type
+            or "DOUBLE" in field_opt_type
+        ):
+            if hasattr(value, "number_value"):
                 value = value.number_value
-            field_extensions[description.get('fullName')] = Value(number_value=value)
-        elif 'MESSAGE' in field_opt_type:
-
-                struct_temp = Struct()
-                ext_package_path = 'protos/{0}/{1}/{2}/{1}.proto'.format(description.get('messageType').split('.')[0],description.get('messageType').split('.')[1],description.get('messageType').split('.')[2])
-
-                message_type = next((m for m in sylk_json.get('packages').get(ext_package_path).get('messages') if m.get('fullName') == description.get('messageType')),None)
-                temp_dict = {}
-                
-                for field_ext_temp in message_type.get('fields'):
-
-                    if field_ext_temp.get('fieldType') == 'TYPE_MESSAGE' or field_ext_temp.get('fieldType') == 'TYPE_MAP' or field_ext_temp.get('fieldType') == 'TYPE_ENUM':
-                        raise errors.SylkValidationError('Extension values parse error','There are too many nested levels for {}'.format(field_ext_temp.full_name))
-                    try:
-                        if isinstance(value,dict):
-                            temp_value = value.get(field_ext_temp.get('name'))
-                        else:
-                            temp_value = getattr(value,field_ext_temp.get('name'))
-                        temp_dict[field_ext_temp.get('name')] = temp_value
-                        # struct_temp.update({:temp_value})
-                    except AttributeError:
-                        if hasattr(value,'struct_value'):
-                            f = field_ext_temp.get('name')
-                            if 'BOOL' in field_ext_temp.get('fieldType'):
-                                temp_dict[field_ext_temp.get('name')]= value.struct_value.fields[f].bool_value
-                            elif 'INT' in field_ext_temp.get('fieldType') or 'FLOAT' in field_ext_temp.get('fieldType') or 'DOUBLE' in field_ext_temp.get('fieldType'):
-                                temp_dict[field_ext_temp.get('name')] = value.struct_value.fields[f].number_value
-                            elif 'STRING' in field_ext_temp.get('fieldType'):
-                                temp_dict[field_ext_temp.get('name')] = value.struct_value.fields[f].string_value
-                                # struct_temp.update({field_ext_temp.get('name'):value.struct_value.fields[f].string_value})
-                            
-                            # TODO handle enum type for nested object field
-                    except Exception as e:
-                        print_info(e)
-
-                struct_temp.update(temp_dict)
-                field_extensions[description.get('fullName')] = Value(struct_value=struct_temp)
-        elif 'ENUM' in field_opt_type:
-            ext_package_path = 'protos/{0}/{1}/{2}/{1}.proto'.format(description.get('fullName').split('.')[0],description.get('fullName').split('.')[1],description.get('fullName').split('.')[2])
-            enum_type = next((e for e in sylk_json.get('packages').get(ext_package_path).get('enums') if e.get('fullName') == '.'.join(description.get('fullName').split('.')[:-1])),None)
-            enum_value = next((ev for ev in enum_type.get('values') if ev.get('number') == field_opt_value),None)
-            field_extensions[description.get('fullName')] = Value(string_value=enum_value.get('name'))
+            field_extensions[description.get("fullName")] = Value(number_value=value)
+        elif "MESSAGE" in field_opt_type:
+            struct_temp = Struct()
+            ext_package_path = "protos/{0}/{1}/{2}/{1}.proto".format(
+                description.get("messageType").split(".")[0],
+                description.get("messageType").split(".")[1],
+                description.get("messageType").split(".")[2],
+            )
+
+            message_type = next(
+                (
+                    m
+                    for m in sylk_json.get("packages")
+                    .get(ext_package_path)
+                    .get("messages")
+                    if m.get("fullName") == description.get("messageType")
+                ),
+                None,
+            )
+            temp_dict = {}
+
+            for field_ext_temp in message_type.get("fields"):
+                if (
+                    field_ext_temp.get("fieldType") == "TYPE_MESSAGE"
+                    or field_ext_temp.get("fieldType") == "TYPE_MAP"
+                    or field_ext_temp.get("fieldType") == "TYPE_ENUM"
+                ):
+                    raise errors.SylkValidationError(
+                        "Extension values parse error",
+                        "There are too many nested levels for {}".format(
+                            field_ext_temp.full_name
+                        ),
+                    )
+                try:
+                    if isinstance(value, dict):
+                        temp_value = value.get(field_ext_temp.get("name"))
+                    else:
+                        temp_value = getattr(value, field_ext_temp.get("name"))
+                    temp_dict[field_ext_temp.get("name")] = temp_value
+                    # struct_temp.update({:temp_value})
+                except AttributeError:
+                    if hasattr(value, "struct_value"):
+                        f = field_ext_temp.get("name")
+                        if "BOOL" in field_ext_temp.get("fieldType"):
+                            temp_dict[
+                                field_ext_temp.get("name")
+                            ] = value.struct_value.fields[f].bool_value
+                        elif (
+                            "INT" in field_ext_temp.get("fieldType")
+                            or "FLOAT" in field_ext_temp.get("fieldType")
+                            or "DOUBLE" in field_ext_temp.get("fieldType")
+                        ):
+                            temp_dict[
+                                field_ext_temp.get("name")
+                            ] = value.struct_value.fields[f].number_value
+                        elif "STRING" in field_ext_temp.get("fieldType"):
+                            temp_dict[
+                                field_ext_temp.get("name")
+                            ] = value.struct_value.fields[f].string_value
+                            # struct_temp.update({field_ext_temp.get('name'):value.struct_value.fields[f].string_value})
+
+                        # TODO handle enum type for nested object field
+                except Exception as e:
+                    print_info(e)
+
+            struct_temp.update(temp_dict)
+            field_extensions[description.get("fullName")] = Value(
+                struct_value=struct_temp
+            )
+        elif "ENUM" in field_opt_type:
+            ext_package_path = "protos/{0}/{1}/{2}/{1}.proto".format(
+                description.get("fullName").split(".")[0],
+                description.get("fullName").split(".")[1],
+                description.get("fullName").split(".")[2],
+            )
+            enum_type = next(
+                (
+                    e
+                    for e in sylk_json.get("packages")
+                    .get(ext_package_path)
+                    .get("enums")
+                    if e.get("fullName")
+                    == ".".join(description.get("fullName").split(".")[:-1])
+                ),
+                None,
+            )
+            enum_value = next(
+                (
+                    ev
+                    for ev in enum_type.get("values")
+                    if ev.get("number") == field_opt_value
+                ),
+                None,
+            )
+            field_extensions[description.get("fullName")] = Value(
+                string_value=enum_value.get("name")
+            )
         else:
-            print_warning("Not supporting field type [{0}] for field extensions {1}".format(field_opt_type,description.get('fullName')))
-    
+            print_warning(
+                "Not supporting field type [{0}] for field extensions {1}".format(
+                    field_opt_type, description.get("fullName")
+                )
+            )
+
     return field_extensions
 
+
 def add_field_to_message():
-    pass
+    pass
```

## sylk/commons/sylk.py

```diff
@@ -1,9 +1,55 @@
-class SylkBuilder:
+# Copyright (c) 2023 sylk.build
+
+# Permission is hereby granted, free of charge, to any person obtaining
+# a copy of this software and associated documentation files (the
+# "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to
+# permit persons to whom the Software is furnished to do so, subject to
+# the following conditions:
+
+# The above copyright notice and this permission notice shall be
+# included in all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+from collections import deque
+import json
+import logging
+import re
+from typing import Dict, List
+from sylk.commons.protos.sylk.SylkClient.v1 import SylkClient_pb2
+from sylk.commons.protos.sylk.SylkEnumValue.v1 import SylkEnumValue_pb2
+from sylk.commons.protos.sylk.SylkField.v1 import SylkField_pb2
+from sylk import __version__
+from sylk.commons.protos.sylk.SylkMessage.v2 import SylkMessage_pb2
+from sylk.commons.protos.sylk.SylkEnum.v2 import SylkEnum_pb2
+from sylk.commons.protos.sylk.SylkMethod.v1 import SylkMethod_pb2
+from sylk.commons.protos.sylk.SylkPackage.v2 import SylkPackage_pb2
+from sylk.commons.protos.sylk.SylkServer.v1 import SylkServer_pb2
+from sylk.commons.protos.sylk.SylkService.v2 import SylkService_pb2
+from sylk.commons.protos.sylk.SylkProject.v1 import SylkProject_pb2
+
+from google.protobuf.json_format import MessageToDict, ParseDict
+from google.protobuf.any_pb2 import Any
+
+logger = logging.getLogger(__name__)
+logging.basicConfig(
+    level=logging.INFO,
+    format="[{plugin_name}] - %(message)s".format(plugin_name="sylk-tree"),
+)
 
+
+class SylkBuilder:
     def __init__(self) -> None:
         self._parse_configs()
         self._parse_current_project()
 
     def _parse_configs(self):
         pass
 
@@ -28,8 +74,831 @@
     def get_fields(self):
         pass
 
     def get_enum_values(self):
         pass
 
     def get_ext(self):
-        pass
+        pass
+
+
+class Node:
+    def __init__(self, name, type=None, properties=None, parent=None):
+        self.name = name
+        self.children = []
+        self.type = type
+        self.properties = properties if properties else {}
+        self.references = []
+        self.parent = parent
+        self.full_path = self._calculate_full_path()
+
+    def add_child(self, child):
+        self.children.append(child)
+
+    def _calculate_full_path(self):
+        if self.parent:
+            return f"{self.parent.full_path}.{self.name}"
+        return self.name
+
+
+class SylkTree:
+    VALID_PROPERTIES = [
+        "root",
+        "message",
+        "enum",
+        "service",
+        "field",
+        "value",
+        "method",
+        "package",
+        "oneof"
+    ]
+
+    TYPE_RULES = {
+        "enum": ["value"],
+        "service": ["method"],
+        "message": ["field", "enum", "message"],
+        "package": ["package", "service", "message", "enum"],
+        "root": ["package"],
+        "field": ["oneof"],
+    }
+
+    def __init__(self, root_name, project_name=None):
+        self.root = Node(root_name, "root")
+        self.project_name = project_name
+        self.proto_modules: Dict[str, SylkTree] = {}
+
+    def load_module(self, module):
+        self.proto_modules[module.root.name] = module
+
+    def resolve_dependency_order(self,messages: List[Dict]):
+        def topological_sort(nodes):
+            sorted_nodes = []
+            visited = set()
+            def dfs(node):
+                if node["node"] in visited:
+                    return
+                visited.add(node["node"])
+                for ref_node in node["refs"]:
+                    ref = next((n for n in nodes if n["node"] == ref_node), None)
+                    if ref:
+                        dfs(ref)
+                sorted_nodes.append(node["node"])
+
+            for node in nodes:
+                dfs(node)
+
+            sorted_nodes
+            return sorted_nodes
+        # Create a dictionary to store the mapping of message name to message object
+        message_map = {message.get('fullName'): message for message in messages}
+
+        # Create a list of nodes where each node is a message name with its references being the field types
+        nodes = []
+        for message in messages:
+            refs = [
+                field.get('messageType')
+                for field in message.get('fields')
+                if field.get('fieldType') is not None
+                and (field.get('fieldType') == SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.TYPE_MESSAGE)
+                or field.get('valueType') == SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.TYPE_ENUM))
+            ] + [
+                field.get('enumType')
+                for field in message.get('fields')
+                if field.get('fieldType') is not None
+                and (field.get('fieldType') == SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.TYPE_ENUM)
+                or field.get('valueType') == SylkField_pb2.SylkFieldTypes.Name(SylkField_pb2.TYPE_ENUM))
+            ]
+            nodes.append({"node": message.get('fullName'), "refs": refs})
+
+        # Perform topological sorting
+        sorted_message_names = topological_sort(nodes)
+
+        # Reorder the messages based on the sorted names
+        sorted_messages = [message_map[name] for name in sorted_message_names]
+
+        return sorted_messages
+
+    def add_node(self, path, type=None, properties=None):
+        current_node = self.root
+
+        # Split the path into individual node names
+        node_names = path.split(".")
+
+        # Check if the first node name matches the root node name
+        if node_names[0] != current_node.name:
+            raise ValueError(
+                f"Invalid path. The root node '{current_node.name}' does not match the path '{path}'"
+            )
+
+        for i, name in enumerate(node_names[1:]):
+            # Check if the current node already has a child with the same name
+            child_node = self._find_child_node(name, current_node)
+            if child_node:
+                current_node = child_node
+            else:
+                # Create a new node and add it as a child of the current node
+                new_node = Node(name, type, properties, current_node)
+
+                current_node.add_child(new_node)
+                current_node = new_node
+                # Validate the parent hierarchy based on node types
+                if current_node != self.root and i > 0:
+                    if (
+                        name not in self.VALID_PROPERTIES
+                        and current_node.name != self.root.name
+                    ):
+                        parent_type = current_node.parent.type
+                        type = current_node.type
+                        if type not in self.TYPE_RULES.get(parent_type, []):
+                            raise ValueError(
+                                f"Invalid parent hierarchy for node '{current_node.name}' of type '{type}' under '{parent_type}'"
+                            )
+
+    def dfs_traversal(self):
+        return self._dfs(self.root)
+
+    def bfs_traversal(self):
+        self._bfs(self.root)
+
+    def get_parent(self, node_name) -> Node:
+        if node_name.split(".")[0] != self.root.name:
+            n = self._find_node(node_name, self.proto_modules[node_name.split(".")[0]].root)
+        else:
+            n = self.root
+        return self._find_parent(node_name, n)
+
+    def get_parents_refs(self, refs) -> List[str]:
+        packages_paths = []
+        for ref in refs:
+            if ref.split('.')[0] != self.root.name:
+                p = self._find_parent(ref, self.proto_modules[ref.split('.')[0]].root)
+            else:
+                p = self._find_parent(ref, self.root)
+            if p is not None:
+                if p.full_path not in packages_paths:
+                    packages_paths.append(p.full_path)
+            else: 
+                raise ValueError(
+                    f"Failed to find parent for '{ref}' is not a message node."
+                )
+        return packages_paths
+
+    def get_references(self, node_name):
+        node = self._find_node(node_name, self.root)
+        if node:
+            return self._get_references_helper(node)
+        else:
+            logger.error("Node not found.")
+
+    def resolve_dependencies(self):
+        sorted_nodes = self._topological_sort()
+        if sorted_nodes:
+            # logger.debug("Dependency resolution order:")
+            # for node in sorted_nodes:
+            #     logger.debug(node.name)
+            return sorted_nodes
+        else:
+            logger.error("Dependency cycle detected. Unable to resolve dependencies.")
+        return None
+
+    def _dfs(self, node):
+        yield self._process_node(node)
+
+        for child in node.children:
+            self._dfs(child)
+
+    def _bfs(self, node):
+        queue = deque()
+        queue.append(node)
+
+        while queue:
+            current_node = queue.popleft()
+            yield self._process_node(current_node)
+
+            for child in current_node.children:
+                queue.append(child)
+
+    def _process_node(self, node):
+        return node
+        # logger.debug(f"Node: {node.name}")
+        # logger.debug(f"Properties: {node.properties}")
+        # logger.debug(f"References: {node.references}")
+
+    def _find_parent(self, node_path, current_node, recursive=False):
+        path_parts = node_path.split(".")
+        if len(path_parts) > 1:
+            parent_path = ".".join(path_parts[:-1])
+            parent_node = self._find_node(parent_path, current_node)
+            if recursive:
+                if parent_node.type != 'package':
+                    parent_node = self._find_parent(parent_node.full_path,current_node,recursive)
+            return parent_node
+
+        return None
+
+    def _find_node(self, node_path, current_node) -> Node:
+        if current_node.full_path == node_path:
+            return current_node
+
+        for child in current_node.children:
+            found_node = self._find_node(node_path, child)
+            if found_node:
+                return found_node
+
+        return None
+        # if current_node.name == node_name:
+        #     return current_node
+
+        # for child in current_node.children:
+        #     found_node = self._find_node(node_name, child)
+        #     if found_node:
+        #         return found_node
+
+        # return None
+
+    def _find_child_node(self, name, current_node):
+        for child in current_node.children:
+            if child.name == name:
+                return child
+
+        return None
+
+    def _parse_version_component(self, full_name: str) -> dict or None:
+        full_name = full_name.replace("/", ".")
+        if full_name:
+            segments = full_name.split(".")
+
+            pattern = r"^v(\d+)(alpha|beta)?(\d+)?$"
+
+            for segment in segments:
+                regex = re.compile("[@!#$%^&*()<>?/\|}{~:]")
+                # Pass the string in search
+                # method of regex object.
+                if regex.search(segment) is not None:
+                    raise Exception("package name cannot hold any special characters")
+
+                match = re.match(pattern, segment)
+
+                if match:
+                    version = int(match.group(1))
+                    channel = match.group(2)
+                    release = int(match.group(3)) if match.group(3) else None
+                    return {"version": version, "channel": channel, "release": release}
+
+        return None
+
+    def _find_package_node(self, node: Node):
+        if node.type == "package":
+            return node
+
+        for child in node.children:
+            package_node = self._find_package_node(child)
+            if package_node:
+                return package_node
+
+        return None
+
+    def validate_properties(self, type):
+        return type in self.VALID_PROPERTIES
+
+    def add_node_with_validated_properties(self, path, type=None, properties=None):
+        if properties and not self.validate_properties(type):
+            raise ValueError("Invalid properties")
+        self.add_node(path, type, properties)
+
+    def get_all_file_paths(self):
+        files = []
+        for node in self._bfs(self.root):
+            if node.type == "package":
+                if len([c for c in node.children if c.type != "package"]) > 0:
+                    tags = set(
+                        [
+                            c.properties.get("tag")
+                            for c in node.children
+                            if c.properties.get("tag") is not None
+                        ]
+                    )
+                    if len(tags) > 0:
+                        for t in tags:
+                            files.append(
+                                node.full_path.replace(".", "/") + "/" + f"{t}.proto"
+                            )
+
+                    if len(
+                        [
+                            c.properties.get("tag")
+                            for c in node.children
+                            if c.properties.get("tag") is not None
+                        ]
+                    ) != len([c for c in node.children if c.type != "package"]):
+                        ver = self._parse_version_component(node.full_path)
+                        if ver is not None:
+                            pkg_name = node.full_path.split(".")[-2]
+                        else:
+                            pkg_name = node.full_path.split(".")[-1]
+                        files.append(
+                            node.full_path.replace(".", "/") + "/" + f"{pkg_name}.proto"
+                        )
+
+        for mod in self.proto_modules:
+            module = self.proto_modules[mod].root
+            for node in self._bfs(module):
+                if node.type == "package":
+                    if len([c for c in node.children if c.type != "package"]) > 0:
+                        tags = set(
+                            [
+                                c.properties.get("tag")
+                                for c in node.children
+                                if c.properties.get("tag") is not None
+                            ]
+                        )
+                        if len(tags) > 0:
+                            for t in tags:
+                                files.append(
+                                    node.full_path.replace(".", "/")
+                                    + "/"
+                                    + f"{t}.proto"
+                                )
+                        if len(
+                            [
+                                c.properties.get("tag")
+                                for c in node.children
+                                if c.properties.get("tag") is not None
+                            ]
+                        ) < len(
+                            [
+                                c
+                                for c in node.children
+                                if c.type != "package"
+                                and c.properties.get("tag") is None
+                            ]
+                        ):
+                            ver = self._parse_version_component(node.full_path)
+                            if ver is not None:
+                                pkg_name = node.full_path.split(".")[-2]
+                            else:
+                                pkg_name = node.full_path.split(".")[-1]
+                            files.append(
+                                node.full_path.replace(".", "/")
+                                + "/"
+                                + f"{pkg_name}.proto"
+                            )
+        return files
+    
+    def update_node_prop(self, node_path, props):
+        node = self._find_node(node_path,self.root)
+        if node is not None:
+            node.properties = { **node.properties, **props}
+
+
+    def _get_file_paths(self, references: List[str]):
+        files = []
+        for ref in references:
+            if ref.split(".")[0] != self.root.name:
+                n = self._find_node(ref, self.proto_modules[ref.split(".")[0]].root)
+                p = self._find_parent(
+                    n.full_path, self.proto_modules[ref.split(".")[0]].root
+                )
+            else:
+                n = self._find_node(ref, self.root)
+                p = self._find_parent(n.full_path, self.root, True)
+            tag = None
+            if n.properties is not None:
+                tag = n.properties.get("tag")
+            if tag is not None:
+                file = p.full_path.replace(".", "/") + f"/{tag}.proto"
+                if file not in files:
+                    files.append(file)
+            else:
+                ver = self._parse_version_component(p.full_path)
+                if ver is not None:
+                    pkg_name = p.full_path.split(".")[-2]
+                else:
+                    pkg_name = p.full_path.split(".")[-1]
+
+                file = p.full_path.replace(".", "/") + f"/{pkg_name}.proto"
+                if file not in files:
+                    files.append(file)
+        return files
+
+    def _get_references_helper(self, node: Node):
+        if node.type == "message":
+            for child in node.children:
+                node.references.extend(self._get_references_helper(child))
+        elif node.type == "service":
+            for child in node.children:
+                node.references.extend(self._get_references_helper(child))
+        elif node.type == "enum":
+            for child in node.children:
+                node.references.extend(self._get_references_helper(child))
+        elif node.type == "package":
+            for child in node.children:
+                node.references.extend(self._get_references_helper(child))
+        elif node.type == "field":
+            for child in node.children:
+                node.references.extend(self._get_references_helper(child))
+        elif node.type == "root":
+            for child in node.children:
+                node.references.extend(self._get_references_helper(child))
+        return node.references
+
+    def _resolve_dependencies_refs(self, node):
+        for dep in node.references:
+            refs = self.get_references(dep)
+            for ref in refs:
+                if dep in ref:
+                    return f'"{node.full_path}" found in "{dep}" dependencies'
+        return None
+
+    def nested_topological_sort(self,children):
+        in_degree = {}
+        sorted_nodes = []
+        visited = set()
+
+        def dfs(node):
+            if node in visited:
+                return
+            visited.add(node)
+            if node in in_degree:
+                for ref_node in in_degree[node]:
+                    dfs(ref_node)
+            sorted_nodes.append(node)
+
+        # Calculate the in-degree for each node
+        for child in children:
+            refs = child.references
+            for ref_node in refs:
+                if ref_node not in in_degree:
+                    in_degree[ref_node] = set()
+                in_degree[ref_node].add(child.full_path)
+
+        # Perform topological sorting using DFS
+        for child in children:
+            dfs(child.full_path)
+        sorted_nodes.reverse()
+        return sorted_nodes
+
+    def topological_sort(self):
+        in_degree = {}
+        sorted_nodes = []
+        queue = deque()
+        nodes = []
+        for n in [
+            pkg
+            for pkg in self._bfs(self.root)
+            
+        ]:  
+            if n.type == "package" and len([c for c in n.children if c.type != "package"]) > 0:
+                refs = [
+                    self.get_parent(c) for c in self.get_references(n.full_path)
+                ]
+                nodes.append({"node": n.full_path, "refs": [r.full_path for r in refs if r is not None]})
+            else:
+                nodes.append({"node": n.full_path, "refs": []})
+        # Calculate the in-degree for each node
+        sorted_nodes = []
+        visited = set()
+
+        def dfs(node):
+            if node["node"] in visited:
+                return
+            visited.add(node["node"])
+            for ref_node in node["refs"]:
+                ref = next((n for n in nodes if n["node"] == ref_node), None)
+                if ref:
+                    dfs(ref)
+            sorted_nodes.append(node["node"])
+
+        for node in nodes:
+            dfs(node)
+        sorted_nodes.reverse()
+        return sorted_nodes
+
+    def _topological_sort(self):
+        in_degree = {}
+        sorted_nodes = []
+        queue = deque()
+
+        # Calculate the in-degree for each node
+        self._calculate_in_degree(self.root, in_degree)
+
+        # Enqueue nodes with no incoming edges (in-degree = 0)
+        for node in in_degree:
+            if in_degree[node] == 0:
+                queue.append(node)
+
+        # Perform topological sorting using Kahn's algorithm
+        while queue:
+            current_node = queue.popleft()
+            sorted_nodes.append(current_node)
+
+            for child in current_node.children:
+                if (
+                    child.type != "type"
+                    and len([c for c in child.children if c.type != "package"]) > 0
+                ):
+                    in_degree[child] -= 1
+                    if in_degree[child] == 0:
+                        queue.append(child)
+
+            # Resolve dependencies based on references
+            for ref_node_name in current_node.references:
+                ref_node = self._find_parent(ref_node_name, self.root)
+                if ref_node:
+                    in_degree[ref_node] -= 1
+                    if in_degree[ref_node] == 0:
+                        queue.append(ref_node)
+
+        # Check for a dependency cycle
+        # print(len(sorted_nodes), len(in_degree))
+        # if len(sorted_nodes) != len(in_degree):
+        #     return None
+
+        return sorted_nodes
+
+    def _calculate_in_degree(self, node, in_degree):
+        if node not in in_degree:
+            in_degree[node] = 0
+
+        for child in node.children:
+            if child in in_degree:
+                in_degree[child] += 1
+            else:
+                in_degree[child] = 1
+
+            self._calculate_in_degree(child, in_degree)
+
+    def add_field_reference(self, message_path, field_name, ref_path):
+        root_module = self.root
+        message_node = self._find_node(message_path, self.root)
+        if ref_path.split(".")[0] != self.root.name:
+            root_module = self.proto_modules[ref_path.split(".")[0]].root
+        ref_node = self._find_node(ref_path, root_module)
+        if message_node and ref_node:
+            field = [field for field in message_node.children if field.name == field_name]
+            if message_node.type == "message":
+                ref_node_name = ref_node.full_path
+                if len(field) == 1:
+                    field[0].references.append(ref_node_name)
+                if ref_node_name not in message_node.references:
+                    message_node.references.append(ref_node_name)
+            elif message_node.type == "field":
+                ref_node_name = ref_node.full_path
+                message_node = self._find_parent(message_node.full_path, self.root)
+                if len(field) == 1:
+                    field[0].references.append(ref_node_name)
+                if ref_node_name not in message_node.references:
+                    message_node.references.append(ref_node_name)
+            else:
+                raise ValueError(
+                    f"The node '{message_node.name}' is not a message node."
+                )
+        else:
+            logger.info(f"parent: {message_path}, ref: {ref_path}")
+            raise ValueError("One or both nodes not found in the tree.")
+
+    def add_method_reference(self, method_path, ref_path):
+        method_node = self._find_node(method_path, self.root)
+        if ref_path.split(".")[0] != self.root.name:
+            ref_node = self._find_node(
+                ref_path, self.proto_modules[ref_path.split(".")[0]].root
+            )
+        else:
+            ref_node = self._find_node(ref_path, self.root)
+        if method_node and ref_node:
+            if method_node.type == "method":
+                ref_node_name = ref_node.full_path
+                if ref_node_name not in method_node.references:
+                    method_node.references.append(ref_node_name)
+            else:
+                raise ValueError(f"The node '{method_node.name}' is not a method node.")
+        else:
+            raise ValueError("One or both nodes not found in the tree.")
+
+    def _get_full_path(self, node):
+        if node is not None:
+            if node.parent == self.root:
+                return node.parent.name + "." + node.name
+            else:
+                return f"{self._get_full_path(node.parent)}.{node.name}"
+        else:
+            return ""
+
+    # def _flatten_packages(self, node, packages_dict):
+    #     if "package" in node.properties and not self._contains_only_packages(node):
+    #         package_path = self._get_full_path(node)
+    #         packages_dict[package_path] = self._node_to_dict(node)
+
+    #     for child in node.children:
+    #         self._flatten_packages(child, packages_dict)
+
+    def _flatten_packages(self, node: Node, packages_dict):
+
+        if node.type == "package":
+            if self._has_messages_services_enums(node) or self._is_empty(node):
+                package_path = self._get_full_path(node)
+                packages_dict[package_path.replace(".", "/")] = self._node_to_dict(node)
+            else:
+                for child in node.children:
+                    self._flatten_packages(child, packages_dict)
+        else:
+            for child in node.children:
+                self._flatten_packages(child, packages_dict)
+
+    def to_dict(self, base_path: str):
+        tree_dict = {
+            "organization": {"domain": self.root.name},
+            "packages": {},
+            "configs": {
+                "host": "localhost",
+                "port": 44880,
+                "protoBasePath": ""
+            },
+            "sylk_version": __version__.__version__,
+            "project": MessageToDict(
+                SylkProject_pb2.SylkProject(
+                    name=self.project_name,
+                    package_name=self.project_name.replace("-", "")
+                    .replace(" ", "_")
+                    .lower(),
+                    uri=base_path,
+                    server=SylkServer_pb2.SylkServer(
+                        language=SylkServer_pb2.SylkServerLanguages.python
+                    ),
+                    clients= [
+                        SylkClient_pb2.SylkClient(
+                            language=SylkClient_pb2.SylkClientLanguages.python
+                        )
+                    ]
+                )
+            ),
+        }
+
+        # if self.root.type == "root":
+        #     tree_dict["project"] = self._node_to_dict(self.root)
+        self._flatten_packages(self.root, tree_dict["packages"])
+
+        return tree_dict
+
+    def _has_messages_services_enums(self, node):
+        for child in node.children:
+            if (
+                "message" == child.type
+                or "service" == child.type
+                or "enum" == child.type
+            ):
+                return True
+        return False
+
+    def _is_empty(self, node):
+        return len(node.children) == 0
+
+    def _node_to_dict(self, node: Node):
+        childrens = []
+        if self.root != node:
+            msgs = self.nested_topological_sort(node.children)
+            for m in msgs:
+                child_dict = self._node_to_dict(self._find_node(m,self.root))
+                childrens.append(child_dict)
+
+            for child in node.children:
+                if child.full_path not in msgs:
+                    child_dict = self._node_to_dict(child)
+                    childrens.append(child_dict)
+        node_dict = None
+        message_type_url = 'types.googleapis.com/sylk.SylkMessage.v2.SylkMessage'
+        enum_type_url = 'types.googleapis.com/sylk.SylkEnum.v2.SylkEnum'
+        if node.type == "message":
+            node_dict = MessageToDict(
+                SylkMessage_pb2.SylkMessage(
+                    full_name=node.full_path,
+                    name=node.name,
+                    type=node.type,
+                    inlines=list(
+                        map(
+                            lambda c: ParseDict(
+                                {
+                                    "@type": enum_type_url if c.get('type') == 'enum' else message_type_url,
+                                    **c,
+                                },
+                                Any(),
+                            ),
+                            [
+                                c
+                                for c in childrens
+                                if c.get("type") == "message" or c.get("type") == "enum"
+                            ],
+                        )
+                    ),
+                    fields=[
+                        ParseDict(c, SylkField_pb2.SylkField())
+                        for c in childrens
+                        if c.get("type") == "field"
+                    ],
+                    **node.properties,
+                )
+            )
+        elif node.type == "enum":
+            node_dict = MessageToDict(
+                SylkEnum_pb2.SylkEnum(
+                    full_name=node.full_path,
+                    name=node.name,
+                    type=node.type,
+                    values=[
+                        ParseDict(c, SylkEnumValue_pb2.SylkEnumValue())
+                        for c in childrens
+                        if c.get("type") == "value"
+                    ],
+                    **node.properties,
+                )
+            )
+        elif node.type == "service":
+            node_dict = MessageToDict(
+                SylkService_pb2.SylkService(
+                    full_name=node.full_path,
+                    name=node.name,
+                    type=node.type,
+                    methods=[
+                        ParseDict(c, SylkMethod_pb2.SylkMethod())
+                        for c in childrens
+                        if c.get("type") == "method"
+                    ],
+                    **node.properties,
+                )
+            )
+
+        elif node.type == "package":
+            refs = self.get_references(node.full_path)
+            deps = self.get_parents_refs(refs)
+            # files = self._get_file_paths(refs)
+            node_dict = MessageToDict(
+                SylkPackage_pb2.SylkPackage(
+                    package=node.full_path,
+                    type=node.type,
+                    dependencies=deps,
+                    services=[
+                        ParseDict(c, SylkService_pb2.SylkService())
+                        for c in childrens
+                        if c.get("type") == "service"
+                    ],
+                    messages=[
+                        ParseDict(c, SylkMessage_pb2.SylkMessage())
+                        for c in childrens
+                        if c.get("type") == "message"
+                    ],
+                    enums=[
+                        ParseDict(c, SylkEnum_pb2.SylkEnum())
+                        for c in childrens
+                        if c.get("type") == "enum"
+                    ],
+                    **node.properties,
+                )
+            )
+
+        elif node.type == "field":
+            node_dict = MessageToDict(
+                SylkField_pb2.SylkField(
+                    full_name=node.full_path,
+                    name=node.name,
+                    type=node.type,
+                    oneof_fields=list(
+                        map(
+                            lambda c: ParseDict(c.properties, SylkField_pb2.SylkOneOfField()),
+                            [c for c in node.children if c.type == 'oneof']
+                        ),
+                    ),
+                    **node.properties,
+                )
+            )
+        elif node.type == "value":
+            node_dict = MessageToDict(
+                SylkEnumValue_pb2.SylkEnumValue(
+                    full_name=node.full_path,
+                    name=node.name,
+                    type=node.type,
+                    **node.properties,
+                )
+            )
+        elif node.type == "method":
+            node_dict = MessageToDict(
+                SylkMethod_pb2.SylkMethod(
+                    full_name=node.full_path,
+                    name=node.name,
+                    type=node.type,
+                    **node.properties,
+                )
+            )
+        else:
+            pass
+        return node_dict
+
+    def save_to_json(self, filename):
+        # Save the tree state to a JSON file
+        tree_dict = self.to_dict()
+        with open(filename, "w") as file:
+            json.dump(tree_dict, file, indent=4)
+
+    def to_json(self, base_path):
+        # Save the tree state to a JSON file
+        tree_dict = self.to_dict(base_path)
+        return json.dumps(tree_dict, indent=4)
```

## sylk/commons/protos/__init__.py

```diff
@@ -1,716 +1,1704 @@
 from typing import Tuple, Iterator, Any
 import grpc
 import sys
 from functools import partial
-from sylk.commons.interceptors import sylk_client_pre_rpc
+from sylk.commons.interceptors import sylk_client_pre_rpc, SylkSimpleAuth
 import logging
-from .sylk.Packages.v1 import Packages_pb2_grpc as PackagesService
-from .sylk.Methods.v1 import Methods_pb2_grpc as MethodsService
-from .sylk.Users.v1 import Users_pb2_grpc as UsersService
-from .sylk.Enums.v1 import Enums_pb2_grpc as EnumsService
-from .sylk.Messages.v1 import Messages_pb2_grpc as MessagesService
-from .sylk.Organizations.v1 import Organizations_pb2_grpc as OrganizationsService
-from .sylk.Fields.v1 import Fields_pb2_grpc as FieldsService
-from .sylk.Projects.v1 import Projects_pb2_grpc as ProjectsService
-from .sylk.EnumValues.v1 import EnumValues_pb2_grpc as EnumValuesService
-from .sylk.Services.v1 import Services_pb2_grpc as ServicesService
-from .sylk.SylkUser.v1 import SylkUser_pb2 as SylkUser
-from .sylk.SylkMethod.v1 import SylkMethod_pb2 as SylkMethod
-from .sylk.SylkPackage.v1 import SylkPackage_pb2 as SylkPackage
-from .sylk.SylkCommons.v1 import SylkCommons_pb2 as SylkCommons
-from .sylk.SylkMessage.v1 import SylkMessage_pb2 as SylkMessage
-from .sylk.SylkConfigs.v1 import SylkConfigs_pb2 as SylkConfigs
-from .sylk.SylkClient.v1 import SylkClient_pb2 as SylkClient
-from .sylk.SylkProject.v1 import SylkProject_pb2 as SylkProject
-from .sylk.SylkEnumValue.v1 import SylkEnumValue_pb2 as SylkEnumValue
-from .sylk.SylkField.v1 import SylkField_pb2 as SylkField
-from .sylk.SylkServer.v1 import SylkServer_pb2 as SylkServer
-from .sylk.SylkApi.v1 import SylkApi_pb2 as SylkApi
-from .sylk.Sylk.v1 import Sylk_pb2 as Sylk
-from .sylk.SylkService.v1 import SylkService_pb2 as SylkService
-from .sylk.SylkEnum.v1 import SylkEnum_pb2 as SylkEnum
-from .sylk.SylkOrganization.v1 import SylkOrganization_pb2 as SylkOrganization
+from google.protobuf import empty_pb2
+from google.protobuf import any_pb2
+
+from .sylk.Packages.v1 import Packages_pb2_grpc as Packages_v1_service, Packages_pb2
+from .sylk.Methods.v1 import Methods_pb2_grpc as Methods_v1_service, Methods_pb2
+from .sylk.Users.v1 import Users_pb2_grpc as Users_v1_service, Users_pb2
+from .sylk.Enums.v1 import Enums_pb2_grpc as Enums_v1_service, Enums_pb2
+from .sylk.Messages.v1 import Messages_pb2_grpc as Messages_v1_service, Messages_pb2
+from .sylk.Activities.v1 import Activities_pb2_grpc as Activities_v1_service, Activities_pb2
+from .sylk.Organizations.v1 import Organizations_pb2_grpc as Organizations_v1_service, Organizations_pb2
+from .sylk.Fields.v1 import Fields_pb2_grpc as Fields_v1_service, Fields_pb2
+from .sylk.Projects.v1 import Projects_pb2_grpc as Projects_v1_service, Projects_pb2
+from .sylk.EnumValues.v1 import EnumValues_pb2_grpc as EnumValues_v1_service, EnumValues_pb2
+from .sylk.Services.v1 import Services_pb2_grpc as Services_v1_service, Services_pb2
+from .sylk.Folders.v2 import Folders_pb2_grpc as Folders_v2_service, Folders_pb2
+from .sylk.Packages.v2 import Packages_pb2_grpc as Packages_v2_service, Packages_pb2
+from .sylk.Services.v2 import Services_pb2_grpc as Services_v2_service, Services_pb2
+from .sylk.Messages.v2 import Messages_pb2_grpc as Messages_v2_service, Messages_pb2
+from .sylk.Tags.v2 import Tags_pb2_grpc as Tags_v2_service, Tags_pb2
+from .sylk.Enums.v2 import Enums_pb2_grpc as Enums_v2_service, Enums_pb2
+from .sylk.EnumValues.v2 import EnumValues_pb2_grpc as EnumValues_v2_service
+from .sylk.Methods.v2 import Methods_pb2_grpc as Methods_v2_service
+
+from .sylk.Fields.v2 import Fields_pb2_grpc as Fields_v2_service, Fields_pb2
+from .sylk.Integrations.v2 import Integrations_pb2_grpc as Integrations_v2_service
+from .sylk.ActivityLog.v1 import ActivityLog_pb2 as ActivityLog_v1
+from .sylk.SylkUser.v1 import SylkUser_pb2 as SylkUser_v1
+from .sylk.SylkMethod.v1 import SylkMethod_pb2 as SylkMethod_v1
+from .sylk.SylkPackage.v1 import SylkPackage_pb2 as SylkPackage_v1
+from .sylk.SylkCommons.v1 import SylkCommons_pb2 as SylkCommons_v1
+from .sylk.SylkMessage.v1 import SylkMessage_pb2 as SylkMessage_v1
+from .sylk.SylkConfigs.v1 import SylkConfigs_pb2 as SylkConfigs_v1
+from .sylk.SylkClient.v1 import SylkClient_pb2 as SylkClient_v1
+from .sylk.SylkProject.v1 import SylkProject_pb2 as SylkProject_v1
+from .sylk.SylkEnumValue.v1 import SylkEnumValue_pb2 as SylkEnumValue_v1
+from .sylk.SylkField.v1 import SylkField_pb2 as SylkField_v1
+from .sylk.SylkServer.v1 import SylkServer_pb2 as SylkServer_v1
+from .sylk.SylkApi.v1 import SylkApi_pb2 as SylkApi_v1
+from .sylk.Sylk.v1 import Sylk_pb2 as Sylk_v1
+from .sylk.SylkService.v1 import SylkService_pb2 as SylkService_v1
+from .sylk.SylkEnum.v1 import SylkEnum_pb2 as SylkEnum_v1
+from .sylk.SylkOrganization.v1 import SylkOrganization_pb2 as SylkOrganization_v1
+from .sylk.Folders.v2 import Folders_pb2 as Folders_v2
+from .sylk.SylkPackage.v2 import SylkPackage_pb2 as SylkPackage_v2
+from .sylk.Sylk.v2 import Sylk_pb2 as Sylk_v2
+from .sylk.Packages.v2 import Packages_pb2 as Packages_v2
+from .sylk.Services.v2 import Services_pb2 as Services_v2
+from .sylk.Messages.v2 import Messages_pb2 as Messages_v2
+from .sylk.Tags.v2 import Tags_pb2 as Tags_v2
+from .sylk.SylkService.v2 import SylkService_pb2 as SylkService_v2
+from .sylk.SylkMessage.v2 import SylkMessage_pb2 as SylkMessage_v2
+from .sylk.SylkEnum.v2 import SylkEnum_pb2 as SylkEnum_v2
+from .sylk.Enums.v2 import Enums_pb2 as Enums_v2
+from .sylk.EnumValues.v2 import EnumValues_pb2 as EnumValues_v2
+from .sylk.Methods.v2 import Methods_pb2 as Methods_v2
+from .sylk.Fields.v2 import Fields_pb2 as Fields_v2
+from .sylk.Integrations.v2 import Integrations_pb2 as Integrations_v2
 
 # For available channel options in python visit https://github.com/grpc/grpc/blob/v1.46.x/include/grpc/impl/codegen/grpc_types.h
 _CHANNEL_OPTIONS = (("grpc.keepalive_permit_without_calls", 1),
 	("grpc.keepalive_time_ms", 120000),
 	("grpc.keepalive_timeout_ms", 20000),
 	("grpc.http2.min_time_between_pings_ms", 120000),
 	("grpc.http2.max_pings_without_data", 1),)
 
 # Global metadata
-_METADATA = (('sylk-version','0.1.2'),)
+_METADATA = (('sylk-version','0.2.0'),)
 
 # Global auth key that will be verified by sylk client
 _GLOBAL_AUTH_KEY = None
 
 # Generated thanks to [sylk.build](https://www.sylk.build)
-class sylkcore:
 
-	def __init__(self, host="localhost", port=44880, timeout=10, log_level='ERROR'):
-		logging.root.setLevel(log_level)
-		self._sylk_global_auth_key = _GLOBAL_AUTH_KEY
-		channel = grpc.insecure_channel('{0}:{1}'.format(host, port),_CHANNEL_OPTIONS)
-		try:
-			grpc.channel_ready_future(channel).result(timeout=timeout)
-		except grpc.FutureTimeoutError:
-			logging.error('Timed out: Server seems to be offline. Verify your connection configs.')
-			sys.exit(1)
-		self.PackagesStub = PackagesService.PackagesStub(channel)
-		self.MethodsStub = MethodsService.MethodsStub(channel)
-		self.UsersStub = UsersService.UsersStub(channel)
-		self.EnumsStub = EnumsService.EnumsStub(channel)
-		self.MessagesStub = MessagesService.MessagesStub(channel)
-		self.OrganizationsStub = OrganizationsService.OrganizationsStub(channel)
-		self.FieldsStub = FieldsService.FieldsStub(channel)
-		self.ProjectsStub = ProjectsService.ProjectsStub(channel)
-		self.EnumValuesStub = EnumValuesService.EnumValuesStub(channel)
-		self.ServicesStub = ServicesService.ServicesStub(channel)
+
+
+class Packages_v1:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Packages/v1/Packages.proto
+	Service: Packages
+	Version: v1
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Packages_v1_stub = Packages_v1_service.PackagesStub(self.channel)
+
+	def GetPackage_WithCall(self, request: SylkApi_v1.GetPackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.GetPackageResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Packages_v1_stub.GetPackage.with_call(request,metadata=metadata)
+
+	
+	def GetPackage(self, request: SylkApi_v1.GetPackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.GetPackageResponse:
+		"""sylk - """
+
+		return self.Packages_v1_stub.GetPackage(request,metadata=metadata)
+
+	
+	def CreatePackage_WithCall(self, request: SylkApi_v1.CreatePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.CreatePackageResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Packages_v1_stub.CreatePackage.with_call(request,metadata=metadata)
+
+	
+	def CreatePackage(self, request: SylkApi_v1.CreatePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.CreatePackageResponse:
+		"""sylk - """
+
+		return self.Packages_v1_stub.CreatePackage(request,metadata=metadata)
 
 	
-	def GetPackage_WithCall(self, request: SylkApi.GetPackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.GetPackageResponse, Any]:
+	def DeletePackage_WithCall(self, request: SylkApi_v1.DeletePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.DeletePackageResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.PackagesStub.GetPackage.with_call(request,metadata=metadata)
+		return self.Packages_v1_stub.DeletePackage.with_call(request,metadata=metadata)
 
 	
-	def GetPackage(self, request: SylkApi.GetPackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.GetPackageResponse:
+	def DeletePackage(self, request: SylkApi_v1.DeletePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.DeletePackageResponse:
 		"""sylk - """
 
-		return self.PackagesStub.GetPackage(request,metadata=metadata)
+		return self.Packages_v1_stub.DeletePackage(request,metadata=metadata)
 
 	
-	def CreatePackage_WithCall(self, request: SylkApi.CreatePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.CreatePackageResponse, Any]:
+	def UpdatePackage_WithCall(self, request: SylkApi_v1.UpdatePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdatePackageResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.PackagesStub.CreatePackage.with_call(request,metadata=metadata)
+		return self.Packages_v1_stub.UpdatePackage.with_call(request,metadata=metadata)
 
 	
-	def CreatePackage(self, request: SylkApi.CreatePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.CreatePackageResponse:
+	def UpdatePackage(self, request: SylkApi_v1.UpdatePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdatePackageResponse:
 		"""sylk - """
 
-		return self.PackagesStub.CreatePackage(request,metadata=metadata)
+		return self.Packages_v1_stub.UpdatePackage(request,metadata=metadata)
 
 	
-	def DeletePackage_WithCall(self, request: SylkApi.DeletePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.DeletePackageResponse, Any]:
+	def ListPackages_WithCall(self, request: SylkApi_v1.ListPackagesRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[SylkApi_v1.GetPackageResponse], Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.PackagesStub.DeletePackage.with_call(request,metadata=metadata)
+		return self.Packages_v1_stub.ListPackages.with_call(request,metadata=metadata)
 
 	
-	def DeletePackage(self, request: SylkApi.DeletePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.DeletePackageResponse:
+	def ListPackages(self, request: SylkApi_v1.ListPackagesRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[SylkApi_v1.GetPackageResponse]:
 		"""sylk - """
 
-		return self.PackagesStub.DeletePackage(request,metadata=metadata)
+		return self.Packages_v1_stub.ListPackages(request,metadata=metadata)
+
+
+class Methods_v1:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Methods/v1/Methods.proto
+	Service: Methods
+	Version: v1
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Methods_v1_stub = Methods_v1_service.MethodsStub(self.channel)
+
+	def CreateMethod_WithCall(self, request: SylkApi_v1.CreateMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.CreateMethodResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Methods_v1_stub.CreateMethod.with_call(request,metadata=metadata)
+
+	
+	def CreateMethod(self, request: SylkApi_v1.CreateMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.CreateMethodResponse:
+		"""sylk - """
+
+		return self.Methods_v1_stub.CreateMethod(request,metadata=metadata)
+
+	
+	def GetMethod_WithCall(self, request: SylkApi_v1.GetMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.GetMethodResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Methods_v1_stub.GetMethod.with_call(request,metadata=metadata)
+
+	
+	def GetMethod(self, request: SylkApi_v1.GetMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.GetMethodResponse:
+		"""sylk - """
+
+		return self.Methods_v1_stub.GetMethod(request,metadata=metadata)
+
+	
+	def DeleteMethod_WithCall(self, request: SylkApi_v1.DeleteMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.DeleteMethodResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Methods_v1_stub.DeleteMethod.with_call(request,metadata=metadata)
+
+	
+	def DeleteMethod(self, request: SylkApi_v1.DeleteMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.DeleteMethodResponse:
+		"""sylk - """
+
+		return self.Methods_v1_stub.DeleteMethod(request,metadata=metadata)
+
+	
+	def UpdateMethod_WithCall(self, request: SylkApi_v1.UpdateMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateMethodResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Methods_v1_stub.UpdateMethod.with_call(request,metadata=metadata)
 
 	
-	def UpdatePackage_WithCall(self, request: SylkApi.UpdatePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdatePackageResponse, Any]:
+	def UpdateMethod(self, request: SylkApi_v1.UpdateMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateMethodResponse:
+		"""sylk - """
+
+		return self.Methods_v1_stub.UpdateMethod(request,metadata=metadata)
+
+
+class Users_v1:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Users/v1/Users.proto
+	Service: Users
+	Version: v1
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Users_v1_stub = Users_v1_service.UsersStub(self.channel)
+
+	def CreateUser_WithCall(self, request: SylkApi_v1.CreateUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.CreateUserResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.PackagesStub.UpdatePackage.with_call(request,metadata=metadata)
+		return self.Users_v1_stub.CreateUser.with_call(request,metadata=metadata)
 
 	
-	def UpdatePackage(self, request: SylkApi.UpdatePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdatePackageResponse:
+	def CreateUser(self, request: SylkApi_v1.CreateUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.CreateUserResponse:
 		"""sylk - """
 
-		return self.PackagesStub.UpdatePackage(request,metadata=metadata)
+		return self.Users_v1_stub.CreateUser(request,metadata=metadata)
+
+	
+	def GetAccessToken_WithCall(self, request: SylkApi_v1.GetAccessTokenRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.GetAccessTokenResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Users_v1_stub.GetAccessToken.with_call(request,metadata=metadata)
+
+	
+	def GetAccessToken(self, request: SylkApi_v1.GetAccessTokenRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.GetAccessTokenResponse:
+		"""sylk - """
+		return self.Users_v1_stub.GetAccessToken(request,metadata=metadata)
 
 	
-	def ListPackages_WithCall(self, request: SylkApi.ListPackagesRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[SylkApi.GetPackageResponse], Any]:
+	def CreateAccessToken_WithCall(self, request: SylkApi_v1.CreateAccessTokenRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.CreateAccessTokenResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.PackagesStub.ListPackages.with_call(request,metadata=metadata)
+		return self.Users_v1_stub.CreateAccessToken.with_call(request,metadata=metadata)
 
 	
-	def ListPackages(self, request: SylkApi.ListPackagesRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[SylkApi.GetPackageResponse]:
+	def CreateAccessToken(self, request: SylkApi_v1.CreateAccessTokenRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.CreateAccessTokenResponse:
 		"""sylk - """
 
-		return self.PackagesStub.ListPackages(request,metadata=metadata)
+		return self.Users_v1_stub.CreateAccessToken(request,metadata=metadata)
 
 	
-	def CreateMethod_WithCall(self, request: SylkApi.CreateMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.CreateMethodResponse, Any]:
+	def GetUser_WithCall(self, request: SylkApi_v1.GetUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.GetUserResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.MethodsStub.CreateMethod.with_call(request,metadata=metadata)
+		return self.Users_v1_stub.GetUser.with_call(request,metadata=metadata)
 
 	
-	def CreateMethod(self, request: SylkApi.CreateMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.CreateMethodResponse:
+	def GetUser(self, request: SylkApi_v1.GetUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.GetUserResponse:
 		"""sylk - """
 
-		return self.MethodsStub.CreateMethod(request,metadata=metadata)
+		return self.Users_v1_stub.GetUser(request,metadata=metadata)
 
 	
-	def GetMethod_WithCall(self, request: SylkApi.GetMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.GetMethodResponse, Any]:
+	def ListAccessTokens_WithCall(self, request: SylkApi_v1.ListAccessTokensRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[SylkApi_v1.GetAccessTokenResponse], Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.MethodsStub.GetMethod.with_call(request,metadata=metadata)
+		return self.Users_v1_stub.ListAccessTokens.with_call(request,metadata=metadata)
 
 	
-	def GetMethod(self, request: SylkApi.GetMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.GetMethodResponse:
+	def ListAccessTokens(self, request: SylkApi_v1.ListAccessTokensRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[SylkApi_v1.GetAccessTokenResponse]:
 		"""sylk - """
 
-		return self.MethodsStub.GetMethod(request,metadata=metadata)
+		return self.Users_v1_stub.ListAccessTokens(request,metadata=metadata)
 
 	
-	def DeleteMethod_WithCall(self, request: SylkApi.DeleteMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.DeleteMethodResponse, Any]:
+	def RevokeAccessToken_WithCall(self, request: SylkApi_v1.RevokeAccessTokenRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.RevokeAccessTokenResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.MethodsStub.DeleteMethod.with_call(request,metadata=metadata)
+		return self.Users_v1_stub.RevokeAccessToken.with_call(request,metadata=metadata)
 
 	
-	def DeleteMethod(self, request: SylkApi.DeleteMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.DeleteMethodResponse:
+	def RevokeAccessToken(self, request: SylkApi_v1.RevokeAccessTokenRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.RevokeAccessTokenResponse:
 		"""sylk - """
 
-		return self.MethodsStub.DeleteMethod(request,metadata=metadata)
+		return self.Users_v1_stub.RevokeAccessToken(request,metadata=metadata)
 
 	
-	def UpdateMethod_WithCall(self, request: SylkApi.UpdateMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateMethodResponse, Any]:
+	def UpdateUser_WithCall(self, request: SylkApi_v1.UpdateUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateUserResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.MethodsStub.UpdateMethod.with_call(request,metadata=metadata)
+		return self.Users_v1_stub.UpdateUser.with_call(request,metadata=metadata)
 
 	
-	def UpdateMethod(self, request: SylkApi.UpdateMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateMethodResponse:
+	def UpdateUser(self, request: SylkApi_v1.UpdateUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateUserResponse:
 		"""sylk - """
 
-		return self.MethodsStub.UpdateMethod(request,metadata=metadata)
+		return self.Users_v1_stub.UpdateUser(request,metadata=metadata)
+
+
+class Enums_v1:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Enums/v1/Enums.proto
+	Service: Enums
+	Version: v1
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Enums_v1_stub = Enums_v1_service.EnumsStub(self.channel)
+
+	def GetEnum_WithCall(self, request: SylkApi_v1.GetEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.GetEnumResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Enums_v1_stub.GetEnum.with_call(request,metadata=metadata)
+
+	
+	def GetEnum(self, request: SylkApi_v1.GetEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.GetEnumResponse:
+		"""sylk - """
+
+		return self.Enums_v1_stub.GetEnum(request,metadata=metadata)
 
 	
-	def CreateUser_WithCall(self, request: SylkApi.CreateUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.CreateUserResponse, Any]:
+	def UpdateEnum_WithCall(self, request: SylkApi_v1.UpdateEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateEnumResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.UsersStub.CreateUser.with_call(request,metadata=metadata)
+		return self.Enums_v1_stub.UpdateEnum.with_call(request,metadata=metadata)
 
 	
-	def CreateUser(self, request: SylkApi.CreateUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.CreateUserResponse:
+	def UpdateEnum(self, request: SylkApi_v1.UpdateEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateEnumResponse:
 		"""sylk - """
 
-		return self.UsersStub.CreateUser(request,metadata=metadata)
+		return self.Enums_v1_stub.UpdateEnum(request,metadata=metadata)
 
 	
-	def GetAccessToken_WithCall(self, request: SylkApi.GetAccessTokenRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.GetAccessTokenResponse, Any]:
+	def DeleteEnum_WithCall(self, request: SylkApi_v1.DeleteEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.DeleteEnumResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.UsersStub.GetAccessToken.with_call(request,metadata=metadata)
+		return self.Enums_v1_stub.DeleteEnum.with_call(request,metadata=metadata)
 
 	
-	def GetAccessToken(self, request: SylkApi.GetAccessTokenRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.GetAccessTokenResponse:
+	def DeleteEnum(self, request: SylkApi_v1.DeleteEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.DeleteEnumResponse:
 		"""sylk - """
 
-		return self.UsersStub.GetAccessToken(request,metadata=metadata)
+		return self.Enums_v1_stub.DeleteEnum(request,metadata=metadata)
 
 	
-	def CreateAccessToken_WithCall(self, request: SylkApi.CreateAccessTokenRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.CreateAccessTokenResponse, Any]:
+	def CreateEnum_WithCall(self, request: SylkApi_v1.CreateEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.CreateEnumResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.UsersStub.CreateAccessToken.with_call(request,metadata=metadata)
+		return self.Enums_v1_stub.CreateEnum.with_call(request,metadata=metadata)
 
 	
-	def CreateAccessToken(self, request: SylkApi.CreateAccessTokenRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.CreateAccessTokenResponse:
+	def CreateEnum(self, request: SylkApi_v1.CreateEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.CreateEnumResponse:
 		"""sylk - """
 
-		return self.UsersStub.CreateAccessToken(request,metadata=metadata)
+		return self.Enums_v1_stub.CreateEnum(request,metadata=metadata)
+
+
+class Messages_v1:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Messages/v1/Messages.proto
+	Service: Messages
+	Version: v1
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Messages_v1_stub = Messages_v1_service.MessagesStub(self.channel)
+
+	def GetMessage_WithCall(self, request: SylkApi_v1.GetMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.GetMessageResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Messages_v1_stub.GetMessage.with_call(request,metadata=metadata)
 
 	
-	def GetUser_WithCall(self, request: SylkApi.GetUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.GetUserResponse, Any]:
+	def GetMessage(self, request: SylkApi_v1.GetMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.GetMessageResponse:
+		"""sylk - """
+
+		return self.Messages_v1_stub.GetMessage(request,metadata=metadata)
+
+	
+	def UpdateMessage_WithCall(self, request: SylkApi_v1.UpdateMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateMessageResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.UsersStub.GetUser.with_call(request,metadata=metadata)
+		return self.Messages_v1_stub.UpdateMessage.with_call(request,metadata=metadata)
 
 	
-	def GetUser(self, request: SylkApi.GetUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.GetUserResponse:
+	def UpdateMessage(self, request: SylkApi_v1.UpdateMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateMessageResponse:
 		"""sylk - """
 
-		return self.UsersStub.GetUser(request,metadata=metadata)
+		return self.Messages_v1_stub.UpdateMessage(request,metadata=metadata)
 
 	
-	def ListAccessTokens_WithCall(self, request: SylkApi.ListAccessTokensRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[SylkApi.GetAccessTokenResponse], Any]:
+	def CreateMessage_WithCall(self, request: SylkApi_v1.CreateMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.CreateMessageResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.UsersStub.ListAccessTokens.with_call(request,metadata=metadata)
+		return self.Messages_v1_stub.CreateMessage.with_call(request,metadata=metadata)
 
 	
-	def ListAccessTokens(self, request: SylkApi.ListAccessTokensRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[SylkApi.GetAccessTokenResponse]:
+	def CreateMessage(self, request: SylkApi_v1.CreateMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.CreateMessageResponse:
 		"""sylk - """
 
-		return self.UsersStub.ListAccessTokens(request,metadata=metadata)
+		return self.Messages_v1_stub.CreateMessage(request,metadata=metadata)
 
 	
-	def RevokeAccessToken_WithCall(self, request: SylkApi.RevokeAccessTokenRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.RevokeAccessTokenResponse, Any]:
+	def DeleteMessage_WithCall(self, request: SylkApi_v1.DeleteMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.DeleteMessageResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.UsersStub.RevokeAccessToken.with_call(request,metadata=metadata)
+		return self.Messages_v1_stub.DeleteMessage.with_call(request,metadata=metadata)
 
 	
-	def RevokeAccessToken(self, request: SylkApi.RevokeAccessTokenRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.RevokeAccessTokenResponse:
+	def DeleteMessage(self, request: SylkApi_v1.DeleteMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.DeleteMessageResponse:
 		"""sylk - """
 
-		return self.UsersStub.RevokeAccessToken(request,metadata=metadata)
+		return self.Messages_v1_stub.DeleteMessage(request,metadata=metadata)
+
+
+class Activities_v1:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Activities/v1/Activities.proto
+	Service: Activities
+	Version: v1
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Activities_v1_stub = Activities_v1_service.ActivitiesStub(self.channel)
+
+	def ListActivityLogs_WithCall(self, request: ActivityLog_v1.ListActivityLogsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[ActivityLog_v1.ActivityLog], Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Activities_v1_stub.ListActivityLogs.with_call(request,metadata=metadata)
+
+	
+	def ListActivityLogs(self, request: ActivityLog_v1.ListActivityLogsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[ActivityLog_v1.ActivityLog]:
+		"""sylk - """
+
+		return self.Activities_v1_stub.ListActivityLogs(request,metadata=metadata)
+
+	
+	def GetActivityLogs_WithCall(self, request: ActivityLog_v1.ListActivityLogsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[ActivityLog_v1.GetActivityLogsResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Activities_v1_stub.GetActivityLogs.with_call(request,metadata=metadata)
 
 	
-	def UpdateUser_WithCall(self, request: SylkApi.UpdateUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateUserResponse, Any]:
+	def GetActivityLogs(self, request: ActivityLog_v1.ListActivityLogsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> ActivityLog_v1.GetActivityLogsResponse:
+		"""sylk - """
+
+		return self.Activities_v1_stub.GetActivityLogs(request,metadata=metadata)
+
+
+class Organizations_v1:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Organizations/v1/Organizations.proto
+	Service: Organizations
+	Version: v1
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Organizations_v1_stub = Organizations_v1_service.OrganizationsStub(self.channel)
+
+	def AcceprUserInvite_WithCall(self, request: SylkApi_v1.AcceptUserInviteRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.AcceptUserInviteResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.UsersStub.UpdateUser.with_call(request,metadata=metadata)
+		return self.Organizations_v1_stub.AcceprUserInvite.with_call(request,metadata=metadata)
 
 	
-	def UpdateUser(self, request: SylkApi.UpdateUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateUserResponse:
+	def AcceprUserInvite(self, request: SylkApi_v1.AcceptUserInviteRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.AcceptUserInviteResponse:
 		"""sylk - """
 
-		return self.UsersStub.UpdateUser(request,metadata=metadata)
+		return self.Organizations_v1_stub.AcceprUserInvite(request,metadata=metadata)
 
 	
-	def GetEnum_WithCall(self, request: SylkApi.GetEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.GetEnumResponse, Any]:
+	def GetOrganization_WithCall(self, request: SylkApi_v1.GetOrganizationRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.GetOrganizationResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.EnumsStub.GetEnum.with_call(request,metadata=metadata)
+		return self.Organizations_v1_stub.GetOrganization.with_call(request,metadata=metadata)
 
 	
-	def GetEnum(self, request: SylkApi.GetEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.GetEnumResponse:
+	def GetOrganization(self, request: SylkApi_v1.GetOrganizationRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.GetOrganizationResponse:
 		"""sylk - """
 
-		return self.EnumsStub.GetEnum(request,metadata=metadata)
+		return self.Organizations_v1_stub.GetOrganization(request,metadata=metadata)
 
 	
-	def UpdateEnum_WithCall(self, request: SylkApi.UpdateEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateEnumResponse, Any]:
+	def UpdateOrganization_WithCall(self, request: SylkApi_v1.UpdateOrganizationRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateOrganizationResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.EnumsStub.UpdateEnum.with_call(request,metadata=metadata)
+		return self.Organizations_v1_stub.UpdateOrganization.with_call(request,metadata=metadata)
 
 	
-	def UpdateEnum(self, request: SylkApi.UpdateEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateEnumResponse:
+	def UpdateOrganization(self, request: SylkApi_v1.UpdateOrganizationRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateOrganizationResponse:
 		"""sylk - """
 
-		return self.EnumsStub.UpdateEnum(request,metadata=metadata)
+		return self.Organizations_v1_stub.UpdateOrganization(request,metadata=metadata)
 
 	
-	def DeleteEnum_WithCall(self, request: SylkApi.DeleteEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.DeleteEnumResponse, Any]:
+	def ListOrganizations_WithCall(self, request: SylkApi_v1.ListOrganizationsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[SylkApi_v1.GetOrganizationResponse], Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.EnumsStub.DeleteEnum.with_call(request,metadata=metadata)
+		return self.Organizations_v1_stub.ListOrganizations.with_call(request,metadata=metadata)
 
 	
-	def DeleteEnum(self, request: SylkApi.DeleteEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.DeleteEnumResponse:
+	def ListOrganizations(self, request: SylkApi_v1.ListOrganizationsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[SylkApi_v1.GetOrganizationResponse]:
 		"""sylk - """
 
-		return self.EnumsStub.DeleteEnum(request,metadata=metadata)
+		return self.Organizations_v1_stub.ListOrganizations(request,metadata=metadata)
 
 	
-	def CreateEnum_WithCall(self, request: SylkApi.CreateEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.CreateEnumResponse, Any]:
+	def AddUser_WithCall(self, request: SylkApi_v1.AddUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.AddUserResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.EnumsStub.CreateEnum.with_call(request,metadata=metadata)
+		return self.Organizations_v1_stub.AddUser.with_call(request,metadata=metadata)
 
 	
-	def CreateEnum(self, request: SylkApi.CreateEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.CreateEnumResponse:
+	def AddUser(self, request: SylkApi_v1.AddUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.AddUserResponse:
 		"""sylk - """
 
-		return self.EnumsStub.CreateEnum(request,metadata=metadata)
+		return self.Organizations_v1_stub.AddUser(request,metadata=metadata)
 
 	
-	def GetMessage_WithCall(self, request: SylkApi.GetMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.GetMessageResponse, Any]:
+	def UpdateUserStatus_WithCall(self, request: SylkApi_v1.UpdateUserStatusRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateUserStatusResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.MessagesStub.GetMessage.with_call(request,metadata=metadata)
+		return self.Organizations_v1_stub.UpdateUserStatus.with_call(request,metadata=metadata)
 
 	
-	def GetMessage(self, request: SylkApi.GetMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.GetMessageResponse:
+	def UpdateUserStatus(self, request: SylkApi_v1.UpdateUserStatusRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateUserStatusResponse:
 		"""sylk - """
 
-		return self.MessagesStub.GetMessage(request,metadata=metadata)
+		return self.Organizations_v1_stub.UpdateUserStatus(request,metadata=metadata)
 
 	
-	def UpdateMessage_WithCall(self, request: SylkApi.UpdateMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateMessageResponse, Any]:
+	def RemoveUser_WithCall(self, request: SylkApi_v1.RemoveUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.RemoveUserResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.MessagesStub.UpdateMessage.with_call(request,metadata=metadata)
+		return self.Organizations_v1_stub.RemoveUser.with_call(request,metadata=metadata)
 
 	
-	def UpdateMessage(self, request: SylkApi.UpdateMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateMessageResponse:
+	def RemoveUser(self, request: SylkApi_v1.RemoveUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.RemoveUserResponse:
 		"""sylk - """
 
-		return self.MessagesStub.UpdateMessage(request,metadata=metadata)
+		return self.Organizations_v1_stub.RemoveUser(request,metadata=metadata)
 
 	
-	def CreateMessage_WithCall(self, request: SylkApi.CreateMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.CreateMessageResponse, Any]:
+	def UpdateUserRole_WithCall(self, request: SylkApi_v1.UpdateUserRoleRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateUserRoleResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Organizations_v1_stub.UpdateUserRole.with_call(request,metadata=metadata)
+
+	
+	def UpdateUserRole(self, request: SylkApi_v1.UpdateUserRoleRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateUserRoleResponse:
+		"""sylk - """
+
+		return self.Organizations_v1_stub.UpdateUserRole(request,metadata=metadata)
+
+
+class Fields_v1:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Fields/v1/Fields.proto
+	Service: Fields
+	Version: v1
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Fields_v1_stub = Fields_v1_service.FieldsStub(self.channel)
+
+	def CreateField_WithCall(self, request: SylkApi_v1.CreateFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.CreateFieldResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.MessagesStub.CreateMessage.with_call(request,metadata=metadata)
+		return self.Fields_v1_stub.CreateField.with_call(request,metadata=metadata)
 
 	
-	def CreateMessage(self, request: SylkApi.CreateMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.CreateMessageResponse:
+	def CreateField(self, request: SylkApi_v1.CreateFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.CreateFieldResponse:
 		"""sylk - """
 
-		return self.MessagesStub.CreateMessage(request,metadata=metadata)
+		return self.Fields_v1_stub.CreateField(request,metadata=metadata)
 
 	
-	def DeleteMessage_WithCall(self, request: SylkApi.DeleteMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.DeleteMessageResponse, Any]:
+	def GetField_WithCall(self, request: SylkApi_v1.GetFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.GetFieldResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.MessagesStub.DeleteMessage.with_call(request,metadata=metadata)
+		return self.Fields_v1_stub.GetField.with_call(request,metadata=metadata)
 
 	
-	def DeleteMessage(self, request: SylkApi.DeleteMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.DeleteMessageResponse:
+	def GetField(self, request: SylkApi_v1.GetFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.GetFieldResponse:
 		"""sylk - """
 
-		return self.MessagesStub.DeleteMessage(request,metadata=metadata)
+		return self.Fields_v1_stub.GetField(request,metadata=metadata)
 
 	
-	def AcceprUserInvite_WithCall(self, request: SylkApi.AcceptUserInviteRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.AcceptUserInviteResponse, Any]:
+	def DeleteField_WithCall(self, request: SylkApi_v1.DeleteFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.DeleteFieldResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.OrganizationsStub.AcceprUserInvite.with_call(request,metadata=metadata)
+		return self.Fields_v1_stub.DeleteField.with_call(request,metadata=metadata)
 
 	
-	def AcceprUserInvite(self, request: SylkApi.AcceptUserInviteRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.AcceptUserInviteResponse:
+	def DeleteField(self, request: SylkApi_v1.DeleteFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.DeleteFieldResponse:
 		"""sylk - """
 
-		return self.OrganizationsStub.AcceprUserInvite(request,metadata=metadata)
+		return self.Fields_v1_stub.DeleteField(request,metadata=metadata)
 
 	
-	def GetOrganization_WithCall(self, request: SylkApi.GetOrganizationRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.GetOrganizationResponse, Any]:
+	def UpdateField_WithCall(self, request: SylkApi_v1.UpdateFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateFieldResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.OrganizationsStub.GetOrganization.with_call(request,metadata=metadata)
+		return self.Fields_v1_stub.UpdateField.with_call(request,metadata=metadata)
 
 	
-	def GetOrganization(self, request: SylkApi.GetOrganizationRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.GetOrganizationResponse:
+	def UpdateField(self, request: SylkApi_v1.UpdateFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateFieldResponse:
 		"""sylk - """
 
-		return self.OrganizationsStub.GetOrganization(request,metadata=metadata)
+		return self.Fields_v1_stub.UpdateField(request,metadata=metadata)
+
+
+class Projects_v1:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Projects/v1/Projects.proto
+	Service: Projects
+	Version: v1
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Projects_v1_stub = Projects_v1_service.ProjectsStub(self.channel)
+
+	def UpdateUserRoleProject_WithCall(self, request: SylkApi_v1.UpdateUserRoleRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateUserRoleResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Projects_v1_stub.UpdateUserRoleProject.with_call(request,metadata=metadata)
 
 	
-	def UpdateOrganization_WithCall(self, request: SylkApi.UpdateOrganizationRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateOrganizationResponse, Any]:
+	def UpdateUserRoleProject(self, request: SylkApi_v1.UpdateUserRoleRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateUserRoleResponse:
+		"""sylk - """
+
+		return self.Projects_v1_stub.UpdateUserRoleProject(request,metadata=metadata)
+
+	
+	def RemoveUserProject_WithCall(self, request: SylkApi_v1.RemoveUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.RemoveUserResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.OrganizationsStub.UpdateOrganization.with_call(request,metadata=metadata)
+		return self.Projects_v1_stub.RemoveUserProject.with_call(request,metadata=metadata)
 
 	
-	def UpdateOrganization(self, request: SylkApi.UpdateOrganizationRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateOrganizationResponse:
+	def RemoveUserProject(self, request: SylkApi_v1.RemoveUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.RemoveUserResponse:
 		"""sylk - """
 
-		return self.OrganizationsStub.UpdateOrganization(request,metadata=metadata)
+		return self.Projects_v1_stub.RemoveUserProject(request,metadata=metadata)
 
 	
-	def ListOrganizations_WithCall(self, request: SylkApi.ListOrganizationsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[SylkApi.GetOrganizationResponse], Any]:
+	def AddUserProject_WithCall(self, request: SylkApi_v1.AddUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.AddUserResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.OrganizationsStub.ListOrganizations.with_call(request,metadata=metadata)
+		return self.Projects_v1_stub.AddUserProject.with_call(request,metadata=metadata)
 
 	
-	def ListOrganizations(self, request: SylkApi.ListOrganizationsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[SylkApi.GetOrganizationResponse]:
+	def AddUserProject(self, request: SylkApi_v1.AddUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.AddUserResponse:
 		"""sylk - """
 
-		return self.OrganizationsStub.ListOrganizations(request,metadata=metadata)
+		return self.Projects_v1_stub.AddUserProject(request,metadata=metadata)
 
 	
-	def AddUser_WithCall(self, request: SylkApi.AddUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.AddUserResponse, Any]:
+	def GetProject_WithCall(self, request: SylkApi_v1.GetProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.GetProjectResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.OrganizationsStub.AddUser.with_call(request,metadata=metadata)
+		return self.Projects_v1_stub.GetProject.with_call(request,metadata=metadata)
 
 	
-	def AddUser(self, request: SylkApi.AddUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.AddUserResponse:
+	def GetProject(self, request: SylkApi_v1.GetProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.GetProjectResponse:
 		"""sylk - """
 
-		return self.OrganizationsStub.AddUser(request,metadata=metadata)
+		return self.Projects_v1_stub.GetProject(request,metadata=metadata)
 
 	
-	def UpdateUserStatus_WithCall(self, request: SylkApi.UpdateUserStatusRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateUserStatusResponse, Any]:
+	def UpdateProject_WithCall(self, request: SylkApi_v1.UpdateProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateProjectResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.OrganizationsStub.UpdateUserStatus.with_call(request,metadata=metadata)
+		return self.Projects_v1_stub.UpdateProject.with_call(request,metadata=metadata)
 
 	
-	def UpdateUserStatus(self, request: SylkApi.UpdateUserStatusRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateUserStatusResponse:
+	def UpdateProject(self, request: SylkApi_v1.UpdateProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateProjectResponse:
 		"""sylk - """
 
-		return self.OrganizationsStub.UpdateUserStatus(request,metadata=metadata)
+		return self.Projects_v1_stub.UpdateProject(request,metadata=metadata)
 
 	
-	def RemoveUser_WithCall(self, request: SylkApi.RemoveUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.RemoveUserResponse, Any]:
+	def CreateProject_WithCall(self, request: SylkApi_v1.CreateProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.CreateProjectResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.OrganizationsStub.RemoveUser.with_call(request,metadata=metadata)
+		return self.Projects_v1_stub.CreateProject.with_call(request,metadata=metadata)
 
 	
-	def RemoveUser(self, request: SylkApi.RemoveUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.RemoveUserResponse:
+	def CreateProject(self, request: SylkApi_v1.CreateProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.CreateProjectResponse:
 		"""sylk - """
 
-		return self.OrganizationsStub.RemoveUser(request,metadata=metadata)
+		return self.Projects_v1_stub.CreateProject(request,metadata=metadata)
 
 	
-	def UpdateUserRole_WithCall(self, request: SylkApi.UpdateUserRoleRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateUserRoleResponse, Any]:
+	def DeleteProject_WithCall(self, request: SylkApi_v1.DeleteProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.DeleteProjectResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.OrganizationsStub.UpdateUserRole.with_call(request,metadata=metadata)
+		return self.Projects_v1_stub.DeleteProject.with_call(request,metadata=metadata)
 
 	
-	def UpdateUserRole(self, request: SylkApi.UpdateUserRoleRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateUserRoleResponse:
+	def DeleteProject(self, request: SylkApi_v1.DeleteProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.DeleteProjectResponse:
 		"""sylk - """
 
-		return self.OrganizationsStub.UpdateUserRole(request,metadata=metadata)
+		return self.Projects_v1_stub.DeleteProject(request,metadata=metadata)
 
 	
-	def CreateField_WithCall(self, request: SylkApi.CreateFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.CreateFieldResponse, Any]:
+	def ListProjects_WithCall(self, request: SylkApi_v1.ListProjectsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[SylkApi_v1.GetProjectResponse], Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.FieldsStub.CreateField.with_call(request,metadata=metadata)
+		return self.Projects_v1_stub.ListProjects.with_call(request,metadata=metadata)
 
 	
-	def CreateField(self, request: SylkApi.CreateFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.CreateFieldResponse:
+	def ListProjects(self, request: SylkApi_v1.ListProjectsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[SylkApi_v1.GetProjectResponse]:
 		"""sylk - """
 
-		return self.FieldsStub.CreateField(request,metadata=metadata)
+		return self.Projects_v1_stub.ListProjects(request,metadata=metadata)
 
 	
-	def GetField_WithCall(self, request: SylkApi.GetFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.GetFieldResponse, Any]:
+	def UpdateUserStatusProject_WithCall(self, request: SylkApi_v1.UpdateUserStatusRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateUserStatusResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.FieldsStub.GetField.with_call(request,metadata=metadata)
+		return self.Projects_v1_stub.UpdateUserStatusProject.with_call(request,metadata=metadata)
 
 	
-	def GetField(self, request: SylkApi.GetFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.GetFieldResponse:
+	def UpdateUserStatusProject(self, request: SylkApi_v1.UpdateUserStatusRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateUserStatusResponse:
 		"""sylk - """
 
-		return self.FieldsStub.GetField(request,metadata=metadata)
+		return self.Projects_v1_stub.UpdateUserStatusProject(request,metadata=metadata)
+
+
+class EnumValues_v1:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/EnumValues/v1/EnumValues.proto
+	Service: EnumValues
+	Version: v1
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.EnumValues_v1_stub = EnumValues_v1_service.EnumValuesStub(self.channel)
+
+	def GetEnumValue_WithCall(self, request: SylkApi_v1.GetEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.GetEnumValueResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.EnumValues_v1_stub.GetEnumValue.with_call(request,metadata=metadata)
 
 	
-	def DeleteField_WithCall(self, request: SylkApi.DeleteFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.DeleteFieldResponse, Any]:
+	def GetEnumValue(self, request: SylkApi_v1.GetEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.GetEnumValueResponse:
+		"""sylk - """
+
+		return self.EnumValues_v1_stub.GetEnumValue(request,metadata=metadata)
+
+	
+	def CreateEnumValue_WithCall(self, request: SylkApi_v1.CreateEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.CreateEnumValueResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.FieldsStub.DeleteField.with_call(request,metadata=metadata)
+		return self.EnumValues_v1_stub.CreateEnumValue.with_call(request,metadata=metadata)
 
 	
-	def DeleteField(self, request: SylkApi.DeleteFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.DeleteFieldResponse:
+	def CreateEnumValue(self, request: SylkApi_v1.CreateEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.CreateEnumValueResponse:
 		"""sylk - """
 
-		return self.FieldsStub.DeleteField(request,metadata=metadata)
+		return self.EnumValues_v1_stub.CreateEnumValue(request,metadata=metadata)
 
 	
-	def UpdateField_WithCall(self, request: SylkApi.UpdateFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateFieldResponse, Any]:
+	def DeleteEnumValue_WithCall(self, request: SylkApi_v1.DeleteEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.DeleteEnumValueResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.FieldsStub.UpdateField.with_call(request,metadata=metadata)
+		return self.EnumValues_v1_stub.DeleteEnumValue.with_call(request,metadata=metadata)
 
 	
-	def UpdateField(self, request: SylkApi.UpdateFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateFieldResponse:
+	def DeleteEnumValue(self, request: SylkApi_v1.DeleteEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.DeleteEnumValueResponse:
 		"""sylk - """
 
-		return self.FieldsStub.UpdateField(request,metadata=metadata)
+		return self.EnumValues_v1_stub.DeleteEnumValue(request,metadata=metadata)
+
+	
+	def UpdateEnumValue_WithCall(self, request: SylkApi_v1.UpdateEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateEnumValueResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.EnumValues_v1_stub.UpdateEnumValue.with_call(request,metadata=metadata)
 
 	
-	def UpdateUserRoleProject_WithCall(self, request: SylkApi.UpdateUserRoleRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateUserRoleResponse, Any]:
+	def UpdateEnumValue(self, request: SylkApi_v1.UpdateEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateEnumValueResponse:
+		"""sylk - """
+
+		return self.EnumValues_v1_stub.UpdateEnumValue(request,metadata=metadata)
+
+
+class Services_v1:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Services/v1/Services.proto
+	Service: Services
+	Version: v1
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Services_v1_stub = Services_v1_service.ServicesStub(self.channel)
+
+	def CreateService_WithCall(self, request: SylkApi_v1.CreateServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.CreateServiceResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ProjectsStub.UpdateUserRoleProject.with_call(request,metadata=metadata)
+		return self.Services_v1_stub.CreateService.with_call(request,metadata=metadata)
 
 	
-	def UpdateUserRoleProject(self, request: SylkApi.UpdateUserRoleRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateUserRoleResponse:
+	def CreateService(self, request: SylkApi_v1.CreateServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.CreateServiceResponse:
 		"""sylk - """
 
-		return self.ProjectsStub.UpdateUserRoleProject(request,metadata=metadata)
+		return self.Services_v1_stub.CreateService(request,metadata=metadata)
 
 	
-	def RemoveUserProject_WithCall(self, request: SylkApi.RemoveUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.RemoveUserResponse, Any]:
+	def GetService_WithCall(self, request: SylkApi_v1.GetServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.GetServiceResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ProjectsStub.RemoveUserProject.with_call(request,metadata=metadata)
+		return self.Services_v1_stub.GetService.with_call(request,metadata=metadata)
 
 	
-	def RemoveUserProject(self, request: SylkApi.RemoveUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.RemoveUserResponse:
+	def GetService(self, request: SylkApi_v1.GetServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.GetServiceResponse:
 		"""sylk - """
 
-		return self.ProjectsStub.RemoveUserProject(request,metadata=metadata)
+		return self.Services_v1_stub.GetService(request,metadata=metadata)
 
 	
-	def AddUserProject_WithCall(self, request: SylkApi.AddUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.AddUserResponse, Any]:
+	def UpdateService_WithCall(self, request: SylkApi_v1.UpdateServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.UpdateServiceResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ProjectsStub.AddUserProject.with_call(request,metadata=metadata)
+		return self.Services_v1_stub.UpdateService.with_call(request,metadata=metadata)
 
 	
-	def AddUserProject(self, request: SylkApi.AddUserRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.AddUserResponse:
+	def UpdateService(self, request: SylkApi_v1.UpdateServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.UpdateServiceResponse:
 		"""sylk - """
 
-		return self.ProjectsStub.AddUserProject(request,metadata=metadata)
+		return self.Services_v1_stub.UpdateService(request,metadata=metadata)
 
 	
-	def GetProject_WithCall(self, request: SylkApi.GetProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.GetProjectResponse, Any]:
+	def ListServices_WithCall(self, request: SylkApi_v1.ListServicesRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[SylkApi_v1.GetServiceResponse], Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ProjectsStub.GetProject.with_call(request,metadata=metadata)
+		return self.Services_v1_stub.ListServices.with_call(request,metadata=metadata)
 
 	
-	def GetProject(self, request: SylkApi.GetProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.GetProjectResponse:
+	def ListServices(self, request: SylkApi_v1.ListServicesRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[SylkApi_v1.GetServiceResponse]:
 		"""sylk - """
 
-		return self.ProjectsStub.GetProject(request,metadata=metadata)
+		return self.Services_v1_stub.ListServices(request,metadata=metadata)
 
 	
-	def UpdateProject_WithCall(self, request: SylkApi.UpdateProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateProjectResponse, Any]:
+	def DeleteService_WithCall(self, request: SylkApi_v1.DeleteServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi_v1.DeleteServiceResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ProjectsStub.UpdateProject.with_call(request,metadata=metadata)
+		return self.Services_v1_stub.DeleteService.with_call(request,metadata=metadata)
 
 	
-	def UpdateProject(self, request: SylkApi.UpdateProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateProjectResponse:
+	def DeleteService(self, request: SylkApi_v1.DeleteServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi_v1.DeleteServiceResponse:
 		"""sylk - """
 
-		return self.ProjectsStub.UpdateProject(request,metadata=metadata)
+		return self.Services_v1_stub.DeleteService(request,metadata=metadata)
+
+
+class Folders_v2:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Folders/v2/Folders.proto
+	Service: Folders
+	Version: v2
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Folders_v2_stub = Folders_v2_service.FoldersStub(self.channel)
+
+	def GetFolder_WithCall(self, request: Folders_v2.GetFolderRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Folders_v2.Folder, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Folders_v2_stub.GetFolder.with_call(request,metadata=metadata)
 
 	
-	def CreateProject_WithCall(self, request: SylkApi.CreateProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.CreateProjectResponse, Any]:
+	def GetFolder(self, request: Folders_v2.GetFolderRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Folders_v2.Folder:
+		"""sylk - """
+
+		return self.Folders_v2_stub.GetFolder(request,metadata=metadata)
+
+	
+	def CreateFolder_WithCall(self, request: Folders_v2.CreateFolderRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Folders_v2.Folder, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ProjectsStub.CreateProject.with_call(request,metadata=metadata)
+		return self.Folders_v2_stub.CreateFolder.with_call(request,metadata=metadata)
 
 	
-	def CreateProject(self, request: SylkApi.CreateProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.CreateProjectResponse:
+	def CreateFolder(self, request: Folders_v2.CreateFolderRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Folders_v2.Folder:
 		"""sylk - """
 
-		return self.ProjectsStub.CreateProject(request,metadata=metadata)
+		return self.Folders_v2_stub.CreateFolder(request,metadata=metadata)
 
 	
-	def DeleteProject_WithCall(self, request: SylkApi.DeleteProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.DeleteProjectResponse, Any]:
+	def ListFolders_WithCall(self, request: Folders_v2.ListFoldersRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[Folders_v2.Folder], Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ProjectsStub.DeleteProject.with_call(request,metadata=metadata)
+		return self.Folders_v2_stub.ListFolders.with_call(request,metadata=metadata)
 
 	
-	def DeleteProject(self, request: SylkApi.DeleteProjectRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.DeleteProjectResponse:
+	def ListFolders(self, request: Folders_v2.ListFoldersRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[Folders_v2.Folder]:
 		"""sylk - """
 
-		return self.ProjectsStub.DeleteProject(request,metadata=metadata)
+		return self.Folders_v2_stub.ListFolders(request,metadata=metadata)
 
 	
-	def ListProjects_WithCall(self, request: SylkApi.ListProjectsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[SylkApi.GetProjectResponse], Any]:
+	def DeleteFolder_WithCall(self, request: Folders_v2.DeleteFolderRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[empty_pb2.Empty, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ProjectsStub.ListProjects.with_call(request,metadata=metadata)
+		return self.Folders_v2_stub.DeleteFolder.with_call(request,metadata=metadata)
 
 	
-	def ListProjects(self, request: SylkApi.ListProjectsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[SylkApi.GetProjectResponse]:
+	def DeleteFolder(self, request: Folders_v2.DeleteFolderRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> empty_pb2.Empty:
 		"""sylk - """
 
-		return self.ProjectsStub.ListProjects(request,metadata=metadata)
+		return self.Folders_v2_stub.DeleteFolder(request,metadata=metadata)
+
+	
+	def UpdateFolder_WithCall(self, request: Folders_v2.UpdateFolderRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Folders_v2.Folder, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Folders_v2_stub.UpdateFolder.with_call(request,metadata=metadata)
 
 	
-	def UpdateUserStatusProject_WithCall(self, request: SylkApi.UpdateUserStatusRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateUserStatusResponse, Any]:
+	def UpdateFolder(self, request: Folders_v2.UpdateFolderRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Folders_v2.Folder:
+		"""sylk - """
+
+		return self.Folders_v2_stub.UpdateFolder(request,metadata=metadata)
+
+
+class Packages_v2:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Packages/v2/Packages.proto
+	Service: Packages
+	Version: v2
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Packages_v2_stub = Packages_v2_service.PackagesStub(self.channel)
+
+	def GetPackage_WithCall(self, request: Packages_v2.GetPackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Packages_v2.GetPackageResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ProjectsStub.UpdateUserStatusProject.with_call(request,metadata=metadata)
+		return self.Packages_v2_stub.GetPackage.with_call(request,metadata=metadata)
 
 	
-	def UpdateUserStatusProject(self, request: SylkApi.UpdateUserStatusRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateUserStatusResponse:
+	def GetPackage(self, request: Packages_v2.GetPackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Packages_v2.GetPackageResponse:
 		"""sylk - """
 
-		return self.ProjectsStub.UpdateUserStatusProject(request,metadata=metadata)
+		return self.Packages_v2_stub.GetPackage(request,metadata=metadata)
 
 	
-	def GetEnumValue_WithCall(self, request: SylkApi.GetEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.GetEnumValueResponse, Any]:
+	def CreatePackage_WithCall(self, request: Packages_v2.CreatePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Packages_v2.CreatePackageResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.EnumValuesStub.GetEnumValue.with_call(request,metadata=metadata)
+		return self.Packages_v2_stub.CreatePackage.with_call(request,metadata=metadata)
 
 	
-	def GetEnumValue(self, request: SylkApi.GetEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.GetEnumValueResponse:
+	def CreatePackage(self, request: Packages_v2.CreatePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Packages_v2.CreatePackageResponse:
 		"""sylk - """
 
-		return self.EnumValuesStub.GetEnumValue(request,metadata=metadata)
+		return self.Packages_v2_stub.CreatePackage(request,metadata=metadata)
 
 	
-	def CreateEnumValue_WithCall(self, request: SylkApi.CreateEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.CreateEnumValueResponse, Any]:
+	def DeletePackage_WithCall(self, request: Packages_v2.DeletePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[empty_pb2.Empty, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.EnumValuesStub.CreateEnumValue.with_call(request,metadata=metadata)
+		return self.Packages_v2_stub.DeletePackage.with_call(request,metadata=metadata)
 
 	
-	def CreateEnumValue(self, request: SylkApi.CreateEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.CreateEnumValueResponse:
+	def DeletePackage(self, request: Packages_v2.DeletePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> empty_pb2.Empty:
 		"""sylk - """
 
-		return self.EnumValuesStub.CreateEnumValue(request,metadata=metadata)
+		return self.Packages_v2_stub.DeletePackage(request,metadata=metadata)
 
 	
-	def DeleteEnumValue_WithCall(self, request: SylkApi.DeleteEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.DeleteEnumValueResponse, Any]:
+	def UpdatePackage_WithCall(self, request: Packages_v2.UpdatePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Packages_v2.UpdatePackageResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.EnumValuesStub.DeleteEnumValue.with_call(request,metadata=metadata)
+		return self.Packages_v2_stub.UpdatePackage.with_call(request,metadata=metadata)
 
 	
-	def DeleteEnumValue(self, request: SylkApi.DeleteEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.DeleteEnumValueResponse:
+	def UpdatePackage(self, request: Packages_v2.UpdatePackageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Packages_v2.UpdatePackageResponse:
 		"""sylk - """
 
-		return self.EnumValuesStub.DeleteEnumValue(request,metadata=metadata)
+		return self.Packages_v2_stub.UpdatePackage(request,metadata=metadata)
+
+
+class Services_v2:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Services/v2/Services.proto
+	Service: Services
+	Version: v2
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Services_v2_stub = Services_v2_service.ServicesStub(self.channel)
+
+	def GetService_WithCall(self, request: Services_v2.GetServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Services_v2.GetServiceResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Services_v2_stub.GetService.with_call(request,metadata=metadata)
+
+	
+	def GetService(self, request: Services_v2.GetServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Services_v2.GetServiceResponse:
+		"""sylk - """
+
+		return self.Services_v2_stub.GetService(request,metadata=metadata)
 
 	
-	def UpdateEnumValue_WithCall(self, request: SylkApi.UpdateEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateEnumValueResponse, Any]:
+	def DeleteService_WithCall(self, request: Services_v2.DeleteServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[empty_pb2.Empty, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.EnumValuesStub.UpdateEnumValue.with_call(request,metadata=metadata)
+		return self.Services_v2_stub.DeleteService.with_call(request,metadata=metadata)
 
 	
-	def UpdateEnumValue(self, request: SylkApi.UpdateEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateEnumValueResponse:
+	def DeleteService(self, request: Services_v2.DeleteServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> empty_pb2.Empty:
 		"""sylk - """
 
-		return self.EnumValuesStub.UpdateEnumValue(request,metadata=metadata)
+		return self.Services_v2_stub.DeleteService(request,metadata=metadata)
 
 	
-	def CreateService_WithCall(self, request: SylkApi.CreateServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.CreateServiceResponse, Any]:
+	def CreateService_WithCall(self, request: Services_v2.CreateServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Services_v2.CreateServiceResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ServicesStub.CreateService.with_call(request,metadata=metadata)
+		return self.Services_v2_stub.CreateService.with_call(request,metadata=metadata)
 
 	
-	def CreateService(self, request: SylkApi.CreateServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.CreateServiceResponse:
+	def CreateService(self, request: Services_v2.CreateServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Services_v2.CreateServiceResponse:
 		"""sylk - """
 
-		return self.ServicesStub.CreateService(request,metadata=metadata)
+		return self.Services_v2_stub.CreateService(request,metadata=metadata)
 
 	
-	def GetService_WithCall(self, request: SylkApi.GetServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.GetServiceResponse, Any]:
+	def UpdateService_WithCall(self, request: Services_v2.UpdateServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Services_v2.UpdateServiceResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ServicesStub.GetService.with_call(request,metadata=metadata)
+		return self.Services_v2_stub.UpdateService.with_call(request,metadata=metadata)
 
 	
-	def GetService(self, request: SylkApi.GetServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.GetServiceResponse:
+	def UpdateService(self, request: Services_v2.UpdateServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Services_v2.UpdateServiceResponse:
 		"""sylk - """
 
-		return self.ServicesStub.GetService(request,metadata=metadata)
+		return self.Services_v2_stub.UpdateService(request,metadata=metadata)
+
+
+class Messages_v2:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Messages/v2/Messages.proto
+	Service: Messages
+	Version: v2
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Messages_v2_stub = Messages_v2_service.MessagesStub(self.channel)
+
+	def GetMessage_WithCall(self, request: Messages_v2.GetMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Messages_v2.GetMessageResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Messages_v2_stub.GetMessage.with_call(request,metadata=metadata)
+
+	
+	def GetMessage(self, request: Messages_v2.GetMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Messages_v2.GetMessageResponse:
+		"""sylk - """
+
+		return self.Messages_v2_stub.GetMessage(request,metadata=metadata)
 
 	
-	def UpdateService_WithCall(self, request: SylkApi.UpdateServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.UpdateServiceResponse, Any]:
+	def CreateMessage_WithCall(self, request: Messages_v2.CreateMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Messages_v2.CreateMessageResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ServicesStub.UpdateService.with_call(request,metadata=metadata)
+		return self.Messages_v2_stub.CreateMessage.with_call(request,metadata=metadata)
 
 	
-	def UpdateService(self, request: SylkApi.UpdateServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.UpdateServiceResponse:
+	def CreateMessage(self, request: Messages_v2.CreateMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Messages_v2.CreateMessageResponse:
 		"""sylk - """
 
-		return self.ServicesStub.UpdateService(request,metadata=metadata)
+		return self.Messages_v2_stub.CreateMessage(request,metadata=metadata)
 
 	
-	def ListServices_WithCall(self, request: SylkApi.ListServicesRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[SylkApi.GetServiceResponse], Any]:
+	def UpdateMessage_WithCall(self, request: Messages_v2.UpdateMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Messages_v2.UpdateMessageResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ServicesStub.ListServices.with_call(request,metadata=metadata)
+		return self.Messages_v2_stub.UpdateMessage.with_call(request,metadata=metadata)
 
 	
-	def ListServices(self, request: SylkApi.ListServicesRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[SylkApi.GetServiceResponse]:
+	def UpdateMessage(self, request: Messages_v2.UpdateMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Messages_v2.UpdateMessageResponse:
 		"""sylk - """
 
-		return self.ServicesStub.ListServices(request,metadata=metadata)
+		return self.Messages_v2_stub.UpdateMessage(request,metadata=metadata)
+
+	
+	def DeleteMessage_WithCall(self, request: Messages_v2.DeleteMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[empty_pb2.Empty, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Messages_v2_stub.DeleteMessage.with_call(request,metadata=metadata)
 
 	
-	def DeleteService_WithCall(self, request: SylkApi.DeleteServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[SylkApi.DeleteServiceResponse, Any]:
+	def DeleteMessage(self, request: Messages_v2.DeleteMessageRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> empty_pb2.Empty:
+		"""sylk - """
+
+		return self.Messages_v2_stub.DeleteMessage(request,metadata=metadata)
+
+
+class Tags_v2:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Tags/v2/Tags.proto
+	Service: Tags
+	Version: v2
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Tags_v2_stub = Tags_v2_service.TagsStub(self.channel)
+
+	def GetTag_WithCall(self, request: Tags_v2.GetTagRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Tags_v2.Tag, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Tags_v2_stub.GetTag.with_call(request,metadata=metadata)
+
+	
+	def GetTag(self, request: Tags_v2.GetTagRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tags_v2.Tag:
+		"""sylk - """
+
+		return self.Tags_v2_stub.GetTag(request,metadata=metadata)
+
+	
+	def UpdateTag_WithCall(self, request: Tags_v2.UpdateTagRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Tags_v2.Tag, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Tags_v2_stub.UpdateTag.with_call(request,metadata=metadata)
+
+	
+	def UpdateTag(self, request: Tags_v2.UpdateTagRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tags_v2.Tag:
+		"""sylk - """
+
+		return self.Tags_v2_stub.UpdateTag(request,metadata=metadata)
+
+	
+	def CreateTag_WithCall(self, request: Tags_v2.CreateTagRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Tags_v2.Tag, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Tags_v2_stub.CreateTag.with_call(request,metadata=metadata)
+
+	
+	def CreateTag(self, request: Tags_v2.CreateTagRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tags_v2.Tag:
+		"""sylk - """
+
+		return self.Tags_v2_stub.CreateTag(request,metadata=metadata)
+
+	
+	def DeleteTag_WithCall(self, request: Tags_v2.DeleteTagRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[empty_pb2.Empty, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Tags_v2_stub.DeleteTag.with_call(request,metadata=metadata)
+
+	
+	def DeleteTag(self, request: Tags_v2.DeleteTagRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> empty_pb2.Empty:
+		"""sylk - """
+
+		return self.Tags_v2_stub.DeleteTag(request,metadata=metadata)
+
+	
+	def TagResource_WithCall(self, request: Tags_v2.TagResourceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[empty_pb2.Empty, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Tags_v2_stub.TagResource.with_call(request,metadata=metadata)
+
+	
+	def TagResource(self, request: Tags_v2.TagResourceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> empty_pb2.Empty:
+		"""sylk - """
+
+		return self.Tags_v2_stub.TagResource(request,metadata=metadata)
+
+	
+	def ListTags_WithCall(self, request: Tags_v2.ListTagsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Iterator[Tags_v2.Tag], Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Tags_v2_stub.ListTags.with_call(request,metadata=metadata)
+
+	
+	def ListTags(self, request: Tags_v2.ListTagsRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Iterator[Tags_v2.Tag]:
+		"""sylk - """
+
+		return self.Tags_v2_stub.ListTags(request,metadata=metadata)
+
+	
+	def UntagResource_WithCall(self, request: Tags_v2.UntagResourceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[empty_pb2.Empty, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Tags_v2_stub.UntagResource.with_call(request,metadata=metadata)
+
+	
+	def UntagResource(self, request: Tags_v2.UntagResourceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> empty_pb2.Empty:
+		"""sylk - """
+
+		return self.Tags_v2_stub.UntagResource(request,metadata=metadata)
+
+
+class Enums_v2:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Enums/v2/Enums.proto
+	Service: Enums
+	Version: v2
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Enums_v2_stub = Enums_v2_service.EnumsStub(self.channel)
+
+	def GetEnum_WithCall(self, request: Enums_v2.GetEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Enums_v2.GetEnumResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Enums_v2_stub.GetEnum.with_call(request,metadata=metadata)
+
+	
+	def GetEnum(self, request: Enums_v2.GetEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Enums_v2.GetEnumResponse:
+		"""sylk - """
+
+		return self.Enums_v2_stub.GetEnum(request,metadata=metadata)
+
+	
+	def CreateEnum_WithCall(self, request: Enums_v2.CreateEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Enums_v2.CreateEnumResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Enums_v2_stub.CreateEnum.with_call(request,metadata=metadata)
+
+	
+	def CreateEnum(self, request: Enums_v2.CreateEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Enums_v2.CreateEnumResponse:
+		"""sylk - """
+
+		return self.Enums_v2_stub.CreateEnum(request,metadata=metadata)
+
+	
+	def DeleteEnum_WithCall(self, request: Enums_v2.DeleteEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[empty_pb2.Empty, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Enums_v2_stub.DeleteEnum.with_call(request,metadata=metadata)
+
+	
+	def DeleteEnum(self, request: Enums_v2.DeleteEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> empty_pb2.Empty:
+		"""sylk - """
+
+		return self.Enums_v2_stub.DeleteEnum(request,metadata=metadata)
+
+	
+	def UpdateEnum_WithCall(self, request: Enums_v2.UpdateEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Enums_v2.UpdateEnumResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Enums_v2_stub.UpdateEnum.with_call(request,metadata=metadata)
+
+	
+	def UpdateEnum(self, request: Enums_v2.UpdateEnumRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Enums_v2.UpdateEnumResponse:
+		"""sylk - """
+
+		return self.Enums_v2_stub.UpdateEnum(request,metadata=metadata)
+
+
+class EnumValues_v2:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/EnumValues/v2/EnumValues.proto
+	Service: EnumValues
+	Version: v2
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.EnumValues_v2_stub = EnumValues_v2_service.EnumValuesStub(self.channel)
+
+	def GetEnumValue_WithCall(self, request: EnumValues_v2.GetEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[EnumValues_v2.GetEnumValueResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.EnumValues_v2_stub.GetEnumValue.with_call(request,metadata=metadata)
+
+	
+	def GetEnumValue(self, request: EnumValues_v2.GetEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> EnumValues_v2.GetEnumValueResponse:
+		"""sylk - """
+
+		return self.EnumValues_v2_stub.GetEnumValue(request,metadata=metadata)
+
+	
+	def CreateEnumValue_WithCall(self, request: EnumValues_v2.CreateEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[EnumValues_v2.CreateEnumValueResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.EnumValues_v2_stub.CreateEnumValue.with_call(request,metadata=metadata)
+
+	
+	def CreateEnumValue(self, request: EnumValues_v2.CreateEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> EnumValues_v2.CreateEnumValueResponse:
+		"""sylk - """
+
+		return self.EnumValues_v2_stub.CreateEnumValue(request,metadata=metadata)
+
+	
+	def UpdateEnumValue_WithCall(self, request: EnumValues_v2.UpdateEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[EnumValues_v2.UpdateEnumValueResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.EnumValues_v2_stub.UpdateEnumValue.with_call(request,metadata=metadata)
+
+	
+	def UpdateEnumValue(self, request: EnumValues_v2.UpdateEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> EnumValues_v2.UpdateEnumValueResponse:
+		"""sylk - """
+
+		return self.EnumValues_v2_stub.UpdateEnumValue(request,metadata=metadata)
+
+	
+	def DeleteEnumValue_WithCall(self, request: EnumValues_v2.DeleteEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[empty_pb2.Empty, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.EnumValues_v2_stub.DeleteEnumValue.with_call(request,metadata=metadata)
+
+	
+	def DeleteEnumValue(self, request: EnumValues_v2.DeleteEnumValueRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> empty_pb2.Empty:
+		"""sylk - """
+
+		return self.EnumValues_v2_stub.DeleteEnumValue(request,metadata=metadata)
+
+
+class Methods_v2:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Methods/v2/Methods.proto
+	Service: Methods
+	Version: v2
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Methods_v2_stub = Methods_v2_service.MethodsStub(self.channel)
+
+	def GetMethod_WithCall(self, request: Methods_v2.GetMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Methods_v2.GetMethodResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Methods_v2_stub.GetMethod.with_call(request,metadata=metadata)
+
+	
+	def GetMethod(self, request: Methods_v2.GetMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Methods_v2.GetMethodResponse:
+		"""sylk - """
+
+		return self.Methods_v2_stub.GetMethod(request,metadata=metadata)
+
+	
+	def CreateMethod_WithCall(self, request: Methods_v2.CreateMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Methods_v2.CreateMethodResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Methods_v2_stub.CreateMethod.with_call(request,metadata=metadata)
+
+	
+	def CreateMethod(self, request: Methods_v2.CreateMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Methods_v2.CreateMethodResponse:
+		"""sylk - """
+
+		return self.Methods_v2_stub.CreateMethod(request,metadata=metadata)
+
+	
+	def UpdateMethod_WithCall(self, request: Methods_v2.UpdateMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Methods_v2.UpdateMethodResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Methods_v2_stub.UpdateMethod.with_call(request,metadata=metadata)
+
+	
+	def UpdateMethod(self, request: Methods_v2.UpdateMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Methods_v2.UpdateMethodResponse:
+		"""sylk - """
+
+		return self.Methods_v2_stub.UpdateMethod(request,metadata=metadata)
+
+	
+	def DeleteMethod_WithCall(self, request: Methods_v2.DeleteMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[empty_pb2.Empty, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Methods_v2_stub.DeleteMethod.with_call(request,metadata=metadata)
+
+	
+	def DeleteMethod(self, request: Methods_v2.DeleteMethodRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> empty_pb2.Empty:
+		"""sylk - """
+
+		return self.Methods_v2_stub.DeleteMethod(request,metadata=metadata)
+
+
+class Fields_v2:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Fields/v2/Fields.proto
+	Service: Fields
+	Version: v2
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Fields_v2_stub = Fields_v2_service.FieldsStub(self.channel)
+
+	def GetField_WithCall(self, request: Fields_v2.GetFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Fields_v2.GetFieldResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Fields_v2_stub.GetField.with_call(request,metadata=metadata)
+
+	
+	def GetField(self, request: Fields_v2.GetFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Fields_v2.GetFieldResponse:
+		"""sylk - """
+
+		return self.Fields_v2_stub.GetField(request,metadata=metadata)
+
+	
+	def CreateField_WithCall(self, request: Fields_v2.CreateFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Fields_v2.CreateFieldResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Fields_v2_stub.CreateField.with_call(request,metadata=metadata)
+
+	
+	def CreateField(self, request: Fields_v2.CreateFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Fields_v2.CreateFieldResponse:
+		"""sylk - """
+
+		return self.Fields_v2_stub.CreateField(request,metadata=metadata)
+
+	
+	def UpdateField_WithCall(self, request: Fields_v2.UpdateFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Fields_v2.UpdateFieldResponse, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Fields_v2_stub.UpdateField.with_call(request,metadata=metadata)
+
+	
+	def UpdateField(self, request: Fields_v2.UpdateFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Fields_v2.UpdateFieldResponse:
+		"""sylk - """
+
+		return self.Fields_v2_stub.UpdateField(request,metadata=metadata)
+
+	
+	def DeleteField_WithCall(self, request: Fields_v2.DeleteFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[empty_pb2.Empty, Any]:
+		"""sylk -  Returns: RPC output and a call object"""
+
+		return self.Fields_v2_stub.DeleteField.with_call(request,metadata=metadata)
+
+	
+	def DeleteField(self, request: Fields_v2.DeleteFieldRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> empty_pb2.Empty:
+		"""sylk - """
+
+		return self.Fields_v2_stub.DeleteField(request,metadata=metadata)
+
+
+class Integrations_v2:
+	"""
+	service class generated by sylk.build
+
+	File: protos/sylk/Integrations/v2/Integrations.proto
+	Service: Integrations
+	Version: v2
+	"""
+
+	def __init__(self,channel: grpc.ChannelCredentials = None, client_opt = {}):
+		logging.root.setLevel(client_opt.get('log_level','ERROR'))
+		if channel is None:
+			self.channel = grpc.insecure_channel('{0}:{1}'.format(client_opt.get('host','localhost'), client_opt.get('port',44880)),_CHANNEL_OPTIONS)
+			try:
+				grpc.channel_ready_future(self.channel).result(timeout=client_opt.get('timeout',10))
+			except grpc.FutureTimeoutError:
+				logging.error('Timedout: server seems to be offline. verify your connection configs.')
+				sys.exit(1)
+		else:
+			self.channel = channel
+		self.Integrations_v2_stub = Integrations_v2_service.IntegrationsStub(self.channel)
+
+	def GetIntegration_WithCall(self, request: Integrations_v2.GetIntegrationRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Tuple[Integrations_v2.GetIntegrationResponse, Any]:
 		"""sylk -  Returns: RPC output and a call object"""
 
-		return self.ServicesStub.DeleteService.with_call(request,metadata=metadata)
+		return self.Integrations_v2_stub.GetIntegration.with_call(request,metadata=metadata)
 
 	
-	def DeleteService(self, request: SylkApi.DeleteServiceRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> SylkApi.DeleteServiceResponse:
+	def GetIntegration(self, request: Integrations_v2.GetIntegrationRequest, metadata: Tuple[Tuple[str,str]] = _METADATA) -> Integrations_v2.GetIntegrationResponse:
 		"""sylk - """
 
-		return self.ServicesStub.DeleteService(request,metadata=metadata)
+		return self.Integrations_v2_stub.GetIntegration(request,metadata=metadata)
```

## sylk/commons/protos/sylk/EnumValues/v1/EnumValues_pb2.py

```diff
@@ -10,19 +10,18 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from sylk.commons.protos.sylk.SylkApi.v1 import SylkApi_pb2 as sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n#sylk/EnumValues/v1/EnumValues.proto\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\x9b\x03\n\nEnumValues\x12[\n\x0cGetEnumValue\x12$.sylk.SylkApi.v1.GetEnumValueRequest\x1a%.sylk.SylkApi.v1.GetEnumValueResponse\x12\x64\n\x0f\x43reateEnumValue\x12\'.sylk.SylkApi.v1.CreateEnumValueRequest\x1a(.sylk.SylkApi.v1.CreateEnumValueResponse\x12\x64\n\x0f\x44\x65leteEnumValue\x12\'.sylk.SylkApi.v1.DeleteEnumValueRequest\x1a(.sylk.SylkApi.v1.DeleteEnumValueResponse\x12\x64\n\x0fUpdateEnumValue\x12\'.sylk.SylkApi.v1.UpdateEnumValueRequest\x1a(.sylk.SylkApi.v1.UpdateEnumValueResponseBDZBgithub.com/sylk-build/sylk-core/services/protos/sylk/EnumValues/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n#sylk/EnumValues/v1/EnumValues.proto\x12\x12sylk.EnumValues.v1\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\x9b\x03\n\nEnumValues\x12[\n\x0cGetEnumValue\x12$.sylk.SylkApi.v1.GetEnumValueRequest\x1a%.sylk.SylkApi.v1.GetEnumValueResponse\x12\x64\n\x0f\x43reateEnumValue\x12\'.sylk.SylkApi.v1.CreateEnumValueRequest\x1a(.sylk.SylkApi.v1.CreateEnumValueResponse\x12\x64\n\x0f\x44\x65leteEnumValue\x12\'.sylk.SylkApi.v1.DeleteEnumValueRequest\x1a(.sylk.SylkApi.v1.DeleteEnumValueResponse\x12\x64\n\x0fUpdateEnumValue\x12\'.sylk.SylkApi.v1.UpdateEnumValueRequest\x1a(.sylk.SylkApi.v1.UpdateEnumValueResponseb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.EnumValues.v1.EnumValues_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZBgithub.com/sylk-build/sylk-core/services/protos/sylk/EnumValues/v1'
-  _globals['_ENUMVALUES']._serialized_start=71
-  _globals['_ENUMVALUES']._serialized_end=482
+  _globals['_ENUMVALUES']._serialized_start=91
+  _globals['_ENUMVALUES']._serialized_end=502
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/EnumValues/v1/EnumValues_pb2_grpc.py

```diff
@@ -11,30 +11,30 @@
     def __init__(self, channel):
         """Constructor.
 
         Args:
             channel: A grpc.Channel.
         """
         self.GetEnumValue = channel.unary_unary(
-                '/EnumValues/GetEnumValue',
+                '/sylk.EnumValues.v1.EnumValues/GetEnumValue',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetEnumValueRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetEnumValueResponse.FromString,
                 )
         self.CreateEnumValue = channel.unary_unary(
-                '/EnumValues/CreateEnumValue',
+                '/sylk.EnumValues.v1.EnumValues/CreateEnumValue',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateEnumValueRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateEnumValueResponse.FromString,
                 )
         self.DeleteEnumValue = channel.unary_unary(
-                '/EnumValues/DeleteEnumValue',
+                '/sylk.EnumValues.v1.EnumValues/DeleteEnumValue',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteEnumValueRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteEnumValueResponse.FromString,
                 )
         self.UpdateEnumValue = channel.unary_unary(
-                '/EnumValues/UpdateEnumValue',
+                '/sylk.EnumValues.v1.EnumValues/UpdateEnumValue',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateEnumValueRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateEnumValueResponse.FromString,
                 )
 
 
 class EnumValuesServicer(object):
     """Missing associated documentation comment in .proto file."""
@@ -88,15 +88,15 @@
             'UpdateEnumValue': grpc.unary_unary_rpc_method_handler(
                     servicer.UpdateEnumValue,
                     request_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateEnumValueRequest.FromString,
                     response_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateEnumValueResponse.SerializeToString,
             ),
     }
     generic_handler = grpc.method_handlers_generic_handler(
-            'EnumValues', rpc_method_handlers)
+            'sylk.EnumValues.v1.EnumValues', rpc_method_handlers)
     server.add_generic_rpc_handlers((generic_handler,))
 
 
  # This class is part of an EXPERIMENTAL API.
 class EnumValues(object):
     """Missing associated documentation comment in .proto file."""
 
@@ -107,15 +107,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/EnumValues/GetEnumValue',
+        return grpc.experimental.unary_unary(request, target, '/sylk.EnumValues.v1.EnumValues/GetEnumValue',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetEnumValueRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetEnumValueResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def CreateEnumValue(request,
@@ -124,15 +124,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/EnumValues/CreateEnumValue',
+        return grpc.experimental.unary_unary(request, target, '/sylk.EnumValues.v1.EnumValues/CreateEnumValue',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateEnumValueRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateEnumValueResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def DeleteEnumValue(request,
@@ -141,15 +141,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/EnumValues/DeleteEnumValue',
+        return grpc.experimental.unary_unary(request, target, '/sylk.EnumValues.v1.EnumValues/DeleteEnumValue',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteEnumValueRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteEnumValueResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdateEnumValue(request,
@@ -158,12 +158,12 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/EnumValues/UpdateEnumValue',
+        return grpc.experimental.unary_unary(request, target, '/sylk.EnumValues.v1.EnumValues/UpdateEnumValue',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateEnumValueRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateEnumValueResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
```

## sylk/commons/protos/sylk/Enums/v1/Enums_pb2.py

```diff
@@ -10,19 +10,18 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from sylk.commons.protos.sylk.SylkApi.v1 import SylkApi_pb2 as sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x19sylk/Enums/v1/Enums.proto\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xda\x02\n\x05\x45nums\x12L\n\x07GetEnum\x12\x1f.sylk.SylkApi.v1.GetEnumRequest\x1a .sylk.SylkApi.v1.GetEnumResponse\x12U\n\nUpdateEnum\x12\".sylk.SylkApi.v1.UpdateEnumRequest\x1a#.sylk.SylkApi.v1.UpdateEnumResponse\x12U\n\nDeleteEnum\x12\".sylk.SylkApi.v1.DeleteEnumRequest\x1a#.sylk.SylkApi.v1.DeleteEnumResponse\x12U\n\nCreateEnum\x12\".sylk.SylkApi.v1.CreateEnumRequest\x1a#.sylk.SylkApi.v1.CreateEnumResponseB?Z=github.com/sylk-build/sylk-core/services/protos/sylk/Enums/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x19sylk/Enums/v1/Enums.proto\x12\rsylk.Enums.v1\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xda\x02\n\x05\x45nums\x12L\n\x07GetEnum\x12\x1f.sylk.SylkApi.v1.GetEnumRequest\x1a .sylk.SylkApi.v1.GetEnumResponse\x12U\n\nUpdateEnum\x12\".sylk.SylkApi.v1.UpdateEnumRequest\x1a#.sylk.SylkApi.v1.UpdateEnumResponse\x12U\n\nDeleteEnum\x12\".sylk.SylkApi.v1.DeleteEnumRequest\x1a#.sylk.SylkApi.v1.DeleteEnumResponse\x12U\n\nCreateEnum\x12\".sylk.SylkApi.v1.CreateEnumRequest\x1a#.sylk.SylkApi.v1.CreateEnumResponseb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.Enums.v1.Enums_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'Z=github.com/sylk-build/sylk-core/services/protos/sylk/Enums/v1'
-  _globals['_ENUMS']._serialized_start=61
-  _globals['_ENUMS']._serialized_end=407
+  _globals['_ENUMS']._serialized_start=76
+  _globals['_ENUMS']._serialized_end=422
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/Enums/v1/Enums_pb2_grpc.py

```diff
@@ -11,30 +11,30 @@
     def __init__(self, channel):
         """Constructor.
 
         Args:
             channel: A grpc.Channel.
         """
         self.GetEnum = channel.unary_unary(
-                '/Enums/GetEnum',
+                '/sylk.Enums.v1.Enums/GetEnum',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetEnumRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetEnumResponse.FromString,
                 )
         self.UpdateEnum = channel.unary_unary(
-                '/Enums/UpdateEnum',
+                '/sylk.Enums.v1.Enums/UpdateEnum',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateEnumRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateEnumResponse.FromString,
                 )
         self.DeleteEnum = channel.unary_unary(
-                '/Enums/DeleteEnum',
+                '/sylk.Enums.v1.Enums/DeleteEnum',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteEnumRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteEnumResponse.FromString,
                 )
         self.CreateEnum = channel.unary_unary(
-                '/Enums/CreateEnum',
+                '/sylk.Enums.v1.Enums/CreateEnum',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateEnumRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateEnumResponse.FromString,
                 )
 
 
 class EnumsServicer(object):
     """Missing associated documentation comment in .proto file."""
@@ -88,15 +88,15 @@
             'CreateEnum': grpc.unary_unary_rpc_method_handler(
                     servicer.CreateEnum,
                     request_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateEnumRequest.FromString,
                     response_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateEnumResponse.SerializeToString,
             ),
     }
     generic_handler = grpc.method_handlers_generic_handler(
-            'Enums', rpc_method_handlers)
+            'sylk.Enums.v1.Enums', rpc_method_handlers)
     server.add_generic_rpc_handlers((generic_handler,))
 
 
  # This class is part of an EXPERIMENTAL API.
 class Enums(object):
     """Missing associated documentation comment in .proto file."""
 
@@ -107,15 +107,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Enums/GetEnum',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Enums.v1.Enums/GetEnum',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetEnumRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetEnumResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdateEnum(request,
@@ -124,15 +124,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Enums/UpdateEnum',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Enums.v1.Enums/UpdateEnum',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateEnumRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateEnumResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def DeleteEnum(request,
@@ -141,15 +141,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Enums/DeleteEnum',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Enums.v1.Enums/DeleteEnum',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteEnumRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteEnumResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def CreateEnum(request,
@@ -158,12 +158,12 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Enums/CreateEnum',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Enums.v1.Enums/CreateEnum',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateEnumRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateEnumResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
```

## sylk/commons/protos/sylk/Fields/v1/Fields_pb2.py

```diff
@@ -10,19 +10,18 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from sylk.commons.protos.sylk.SylkApi.v1 import SylkApi_pb2 as sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1bsylk/Fields/v1/Fields.proto\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xe7\x02\n\x06\x46ields\x12X\n\x0b\x43reateField\x12#.sylk.SylkApi.v1.CreateFieldRequest\x1a$.sylk.SylkApi.v1.CreateFieldResponse\x12O\n\x08GetField\x12 .sylk.SylkApi.v1.GetFieldRequest\x1a!.sylk.SylkApi.v1.GetFieldResponse\x12X\n\x0b\x44\x65leteField\x12#.sylk.SylkApi.v1.DeleteFieldRequest\x1a$.sylk.SylkApi.v1.DeleteFieldResponse\x12X\n\x0bUpdateField\x12#.sylk.SylkApi.v1.UpdateFieldRequest\x1a$.sylk.SylkApi.v1.UpdateFieldResponseB@Z>github.com/sylk-build/sylk-core/services/protos/sylk/Fields/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1bsylk/Fields/v1/Fields.proto\x12\x0esylk.Fields.v1\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xe7\x02\n\x06\x46ields\x12X\n\x0b\x43reateField\x12#.sylk.SylkApi.v1.CreateFieldRequest\x1a$.sylk.SylkApi.v1.CreateFieldResponse\x12O\n\x08GetField\x12 .sylk.SylkApi.v1.GetFieldRequest\x1a!.sylk.SylkApi.v1.GetFieldResponse\x12X\n\x0b\x44\x65leteField\x12#.sylk.SylkApi.v1.DeleteFieldRequest\x1a$.sylk.SylkApi.v1.DeleteFieldResponse\x12X\n\x0bUpdateField\x12#.sylk.SylkApi.v1.UpdateFieldRequest\x1a$.sylk.SylkApi.v1.UpdateFieldResponseb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.Fields.v1.Fields_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'Z>github.com/sylk-build/sylk-core/services/protos/sylk/Fields/v1'
-  _globals['_FIELDS']._serialized_start=63
-  _globals['_FIELDS']._serialized_end=422
+  _globals['_FIELDS']._serialized_start=79
+  _globals['_FIELDS']._serialized_end=438
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/Fields/v1/Fields_pb2_grpc.py

```diff
@@ -11,30 +11,30 @@
     def __init__(self, channel):
         """Constructor.
 
         Args:
             channel: A grpc.Channel.
         """
         self.CreateField = channel.unary_unary(
-                '/Fields/CreateField',
+                '/sylk.Fields.v1.Fields/CreateField',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateFieldRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateFieldResponse.FromString,
                 )
         self.GetField = channel.unary_unary(
-                '/Fields/GetField',
+                '/sylk.Fields.v1.Fields/GetField',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetFieldRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetFieldResponse.FromString,
                 )
         self.DeleteField = channel.unary_unary(
-                '/Fields/DeleteField',
+                '/sylk.Fields.v1.Fields/DeleteField',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteFieldRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteFieldResponse.FromString,
                 )
         self.UpdateField = channel.unary_unary(
-                '/Fields/UpdateField',
+                '/sylk.Fields.v1.Fields/UpdateField',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateFieldRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateFieldResponse.FromString,
                 )
 
 
 class FieldsServicer(object):
     """Missing associated documentation comment in .proto file."""
@@ -88,15 +88,15 @@
             'UpdateField': grpc.unary_unary_rpc_method_handler(
                     servicer.UpdateField,
                     request_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateFieldRequest.FromString,
                     response_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateFieldResponse.SerializeToString,
             ),
     }
     generic_handler = grpc.method_handlers_generic_handler(
-            'Fields', rpc_method_handlers)
+            'sylk.Fields.v1.Fields', rpc_method_handlers)
     server.add_generic_rpc_handlers((generic_handler,))
 
 
  # This class is part of an EXPERIMENTAL API.
 class Fields(object):
     """Missing associated documentation comment in .proto file."""
 
@@ -107,15 +107,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Fields/CreateField',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Fields.v1.Fields/CreateField',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateFieldRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateFieldResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def GetField(request,
@@ -124,15 +124,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Fields/GetField',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Fields.v1.Fields/GetField',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetFieldRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetFieldResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def DeleteField(request,
@@ -141,15 +141,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Fields/DeleteField',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Fields.v1.Fields/DeleteField',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteFieldRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteFieldResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdateField(request,
@@ -158,12 +158,12 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Fields/UpdateField',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Fields.v1.Fields/UpdateField',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateFieldRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateFieldResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
```

## sylk/commons/protos/sylk/Messages/v1/Messages_pb2.py

```diff
@@ -10,19 +10,18 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from sylk.commons.protos.sylk.SylkApi.v1 import SylkApi_pb2 as sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fsylk/Messages/v1/Messages.proto\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\x81\x03\n\x08Messages\x12U\n\nGetMessage\x12\".sylk.SylkApi.v1.GetMessageRequest\x1a#.sylk.SylkApi.v1.GetMessageResponse\x12^\n\rUpdateMessage\x12%.sylk.SylkApi.v1.UpdateMessageRequest\x1a&.sylk.SylkApi.v1.UpdateMessageResponse\x12^\n\rCreateMessage\x12%.sylk.SylkApi.v1.CreateMessageRequest\x1a&.sylk.SylkApi.v1.CreateMessageResponse\x12^\n\rDeleteMessage\x12%.sylk.SylkApi.v1.DeleteMessageRequest\x1a&.sylk.SylkApi.v1.DeleteMessageResponseBBZ@github.com/sylk-build/sylk-core/services/protos/sylk/Messages/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fsylk/Messages/v1/Messages.proto\x12\x10sylk.Messages.v1\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\x81\x03\n\x08Messages\x12U\n\nGetMessage\x12\".sylk.SylkApi.v1.GetMessageRequest\x1a#.sylk.SylkApi.v1.GetMessageResponse\x12^\n\rUpdateMessage\x12%.sylk.SylkApi.v1.UpdateMessageRequest\x1a&.sylk.SylkApi.v1.UpdateMessageResponse\x12^\n\rCreateMessage\x12%.sylk.SylkApi.v1.CreateMessageRequest\x1a&.sylk.SylkApi.v1.CreateMessageResponse\x12^\n\rDeleteMessage\x12%.sylk.SylkApi.v1.DeleteMessageRequest\x1a&.sylk.SylkApi.v1.DeleteMessageResponseb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.Messages.v1.Messages_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'Z@github.com/sylk-build/sylk-core/services/protos/sylk/Messages/v1'
-  _globals['_MESSAGES']._serialized_start=67
-  _globals['_MESSAGES']._serialized_end=452
+  _globals['_MESSAGES']._serialized_start=85
+  _globals['_MESSAGES']._serialized_end=470
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/Messages/v1/Messages_pb2_grpc.py

```diff
@@ -11,30 +11,30 @@
     def __init__(self, channel):
         """Constructor.
 
         Args:
             channel: A grpc.Channel.
         """
         self.GetMessage = channel.unary_unary(
-                '/Messages/GetMessage',
+                '/sylk.Messages.v1.Messages/GetMessage',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetMessageRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetMessageResponse.FromString,
                 )
         self.UpdateMessage = channel.unary_unary(
-                '/Messages/UpdateMessage',
+                '/sylk.Messages.v1.Messages/UpdateMessage',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateMessageRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateMessageResponse.FromString,
                 )
         self.CreateMessage = channel.unary_unary(
-                '/Messages/CreateMessage',
+                '/sylk.Messages.v1.Messages/CreateMessage',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateMessageRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateMessageResponse.FromString,
                 )
         self.DeleteMessage = channel.unary_unary(
-                '/Messages/DeleteMessage',
+                '/sylk.Messages.v1.Messages/DeleteMessage',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteMessageRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteMessageResponse.FromString,
                 )
 
 
 class MessagesServicer(object):
     """Missing associated documentation comment in .proto file."""
@@ -88,15 +88,15 @@
             'DeleteMessage': grpc.unary_unary_rpc_method_handler(
                     servicer.DeleteMessage,
                     request_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteMessageRequest.FromString,
                     response_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteMessageResponse.SerializeToString,
             ),
     }
     generic_handler = grpc.method_handlers_generic_handler(
-            'Messages', rpc_method_handlers)
+            'sylk.Messages.v1.Messages', rpc_method_handlers)
     server.add_generic_rpc_handlers((generic_handler,))
 
 
  # This class is part of an EXPERIMENTAL API.
 class Messages(object):
     """Missing associated documentation comment in .proto file."""
 
@@ -107,15 +107,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Messages/GetMessage',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Messages.v1.Messages/GetMessage',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetMessageRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetMessageResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdateMessage(request,
@@ -124,15 +124,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Messages/UpdateMessage',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Messages.v1.Messages/UpdateMessage',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateMessageRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateMessageResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def CreateMessage(request,
@@ -141,15 +141,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Messages/CreateMessage',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Messages.v1.Messages/CreateMessage',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateMessageRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateMessageResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def DeleteMessage(request,
@@ -158,12 +158,12 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Messages/DeleteMessage',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Messages.v1.Messages/DeleteMessage',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteMessageRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteMessageResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
```

## sylk/commons/protos/sylk/Methods/v1/Methods_pb2.py

```diff
@@ -10,19 +10,18 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from sylk.commons.protos.sylk.SylkApi.v1 import SylkApi_pb2 as sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1dsylk/Methods/v1/Methods.proto\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xf4\x02\n\x07Methods\x12[\n\x0c\x43reateMethod\x12$.sylk.SylkApi.v1.CreateMethodRequest\x1a%.sylk.SylkApi.v1.CreateMethodResponse\x12R\n\tGetMethod\x12!.sylk.SylkApi.v1.GetMethodRequest\x1a\".sylk.SylkApi.v1.GetMethodResponse\x12[\n\x0c\x44\x65leteMethod\x12$.sylk.SylkApi.v1.DeleteMethodRequest\x1a%.sylk.SylkApi.v1.DeleteMethodResponse\x12[\n\x0cUpdateMethod\x12$.sylk.SylkApi.v1.UpdateMethodRequest\x1a%.sylk.SylkApi.v1.UpdateMethodResponseBAZ?github.com/sylk-build/sylk-core/services/protos/sylk/Methods/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1dsylk/Methods/v1/Methods.proto\x12\x0fsylk.Methods.v1\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xf4\x02\n\x07Methods\x12[\n\x0c\x43reateMethod\x12$.sylk.SylkApi.v1.CreateMethodRequest\x1a%.sylk.SylkApi.v1.CreateMethodResponse\x12R\n\tGetMethod\x12!.sylk.SylkApi.v1.GetMethodRequest\x1a\".sylk.SylkApi.v1.GetMethodResponse\x12[\n\x0c\x44\x65leteMethod\x12$.sylk.SylkApi.v1.DeleteMethodRequest\x1a%.sylk.SylkApi.v1.DeleteMethodResponse\x12[\n\x0cUpdateMethod\x12$.sylk.SylkApi.v1.UpdateMethodRequest\x1a%.sylk.SylkApi.v1.UpdateMethodResponseb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.Methods.v1.Methods_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'Z?github.com/sylk-build/sylk-core/services/protos/sylk/Methods/v1'
-  _globals['_METHODS']._serialized_start=65
-  _globals['_METHODS']._serialized_end=437
+  _globals['_METHODS']._serialized_start=82
+  _globals['_METHODS']._serialized_end=454
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/Methods/v1/Methods_pb2_grpc.py

```diff
@@ -11,30 +11,30 @@
     def __init__(self, channel):
         """Constructor.
 
         Args:
             channel: A grpc.Channel.
         """
         self.CreateMethod = channel.unary_unary(
-                '/Methods/CreateMethod',
+                '/sylk.Methods.v1.Methods/CreateMethod',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateMethodRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateMethodResponse.FromString,
                 )
         self.GetMethod = channel.unary_unary(
-                '/Methods/GetMethod',
+                '/sylk.Methods.v1.Methods/GetMethod',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetMethodRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetMethodResponse.FromString,
                 )
         self.DeleteMethod = channel.unary_unary(
-                '/Methods/DeleteMethod',
+                '/sylk.Methods.v1.Methods/DeleteMethod',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteMethodRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteMethodResponse.FromString,
                 )
         self.UpdateMethod = channel.unary_unary(
-                '/Methods/UpdateMethod',
+                '/sylk.Methods.v1.Methods/UpdateMethod',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateMethodRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateMethodResponse.FromString,
                 )
 
 
 class MethodsServicer(object):
     """Missing associated documentation comment in .proto file."""
@@ -88,15 +88,15 @@
             'UpdateMethod': grpc.unary_unary_rpc_method_handler(
                     servicer.UpdateMethod,
                     request_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateMethodRequest.FromString,
                     response_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateMethodResponse.SerializeToString,
             ),
     }
     generic_handler = grpc.method_handlers_generic_handler(
-            'Methods', rpc_method_handlers)
+            'sylk.Methods.v1.Methods', rpc_method_handlers)
     server.add_generic_rpc_handlers((generic_handler,))
 
 
  # This class is part of an EXPERIMENTAL API.
 class Methods(object):
     """Missing associated documentation comment in .proto file."""
 
@@ -107,15 +107,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Methods/CreateMethod',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Methods.v1.Methods/CreateMethod',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateMethodRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateMethodResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def GetMethod(request,
@@ -124,15 +124,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Methods/GetMethod',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Methods.v1.Methods/GetMethod',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetMethodRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetMethodResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def DeleteMethod(request,
@@ -141,15 +141,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Methods/DeleteMethod',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Methods.v1.Methods/DeleteMethod',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteMethodRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteMethodResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdateMethod(request,
@@ -158,12 +158,12 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Methods/UpdateMethod',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Methods.v1.Methods/UpdateMethod',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateMethodRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateMethodResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
```

## sylk/commons/protos/sylk/Organizations/v1/Organizations_pb2.py

```diff
@@ -10,19 +10,18 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from sylk.commons.protos.sylk.SylkApi.v1 import SylkApi_pb2 as sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n)sylk/Organizations/v1/Organizations.proto\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xaa\x06\n\rOrganizations\x12g\n\x10\x41\x63\x63\x65prUserInvite\x12(.sylk.SylkApi.v1.AcceptUserInviteRequest\x1a).sylk.SylkApi.v1.AcceptUserInviteResponse\x12\x64\n\x0fGetOrganization\x12\'.sylk.SylkApi.v1.GetOrganizationRequest\x1a(.sylk.SylkApi.v1.GetOrganizationResponse\x12m\n\x12UpdateOrganization\x12*.sylk.SylkApi.v1.UpdateOrganizationRequest\x1a+.sylk.SylkApi.v1.UpdateOrganizationResponse\x12j\n\x11ListOrganizations\x12).sylk.SylkApi.v1.ListOrganizationsRequest\x1a(.sylk.SylkApi.v1.GetOrganizationResponse0\x01\x12L\n\x07\x41\x64\x64User\x12\x1f.sylk.SylkApi.v1.AddUserRequest\x1a .sylk.SylkApi.v1.AddUserResponse\x12g\n\x10UpdateUserStatus\x12(.sylk.SylkApi.v1.UpdateUserStatusRequest\x1a).sylk.SylkApi.v1.UpdateUserStatusResponse\x12U\n\nRemoveUser\x12\".sylk.SylkApi.v1.RemoveUserRequest\x1a#.sylk.SylkApi.v1.RemoveUserResponse\x12\x61\n\x0eUpdateUserRole\x12&.sylk.SylkApi.v1.UpdateUserRoleRequest\x1a\'.sylk.SylkApi.v1.UpdateUserRoleResponseBGZEgithub.com/sylk-build/sylk-core/services/protos/sylk/Organizations/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n)sylk/Organizations/v1/Organizations.proto\x12\x15sylk.Organizations.v1\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xaa\x06\n\rOrganizations\x12g\n\x10\x41\x63\x63\x65prUserInvite\x12(.sylk.SylkApi.v1.AcceptUserInviteRequest\x1a).sylk.SylkApi.v1.AcceptUserInviteResponse\x12\x64\n\x0fGetOrganization\x12\'.sylk.SylkApi.v1.GetOrganizationRequest\x1a(.sylk.SylkApi.v1.GetOrganizationResponse\x12m\n\x12UpdateOrganization\x12*.sylk.SylkApi.v1.UpdateOrganizationRequest\x1a+.sylk.SylkApi.v1.UpdateOrganizationResponse\x12j\n\x11ListOrganizations\x12).sylk.SylkApi.v1.ListOrganizationsRequest\x1a(.sylk.SylkApi.v1.GetOrganizationResponse0\x01\x12L\n\x07\x41\x64\x64User\x12\x1f.sylk.SylkApi.v1.AddUserRequest\x1a .sylk.SylkApi.v1.AddUserResponse\x12g\n\x10UpdateUserStatus\x12(.sylk.SylkApi.v1.UpdateUserStatusRequest\x1a).sylk.SylkApi.v1.UpdateUserStatusResponse\x12U\n\nRemoveUser\x12\".sylk.SylkApi.v1.RemoveUserRequest\x1a#.sylk.SylkApi.v1.RemoveUserResponse\x12\x61\n\x0eUpdateUserRole\x12&.sylk.SylkApi.v1.UpdateUserRoleRequest\x1a\'.sylk.SylkApi.v1.UpdateUserRoleResponseb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.Organizations.v1.Organizations_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZEgithub.com/sylk-build/sylk-core/services/protos/sylk/Organizations/v1'
-  _globals['_ORGANIZATIONS']._serialized_start=77
-  _globals['_ORGANIZATIONS']._serialized_end=887
+  _globals['_ORGANIZATIONS']._serialized_start=100
+  _globals['_ORGANIZATIONS']._serialized_end=910
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/Organizations/v1/Organizations_pb2_grpc.py

```diff
@@ -11,50 +11,50 @@
     def __init__(self, channel):
         """Constructor.
 
         Args:
             channel: A grpc.Channel.
         """
         self.AcceprUserInvite = channel.unary_unary(
-                '/Organizations/AcceprUserInvite',
+                '/sylk.Organizations.v1.Organizations/AcceprUserInvite',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.AcceptUserInviteRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.AcceptUserInviteResponse.FromString,
                 )
         self.GetOrganization = channel.unary_unary(
-                '/Organizations/GetOrganization',
+                '/sylk.Organizations.v1.Organizations/GetOrganization',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetOrganizationRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetOrganizationResponse.FromString,
                 )
         self.UpdateOrganization = channel.unary_unary(
-                '/Organizations/UpdateOrganization',
+                '/sylk.Organizations.v1.Organizations/UpdateOrganization',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateOrganizationRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateOrganizationResponse.FromString,
                 )
         self.ListOrganizations = channel.unary_stream(
-                '/Organizations/ListOrganizations',
+                '/sylk.Organizations.v1.Organizations/ListOrganizations',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.ListOrganizationsRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetOrganizationResponse.FromString,
                 )
         self.AddUser = channel.unary_unary(
-                '/Organizations/AddUser',
+                '/sylk.Organizations.v1.Organizations/AddUser',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.AddUserRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.AddUserResponse.FromString,
                 )
         self.UpdateUserStatus = channel.unary_unary(
-                '/Organizations/UpdateUserStatus',
+                '/sylk.Organizations.v1.Organizations/UpdateUserStatus',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserStatusRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserStatusResponse.FromString,
                 )
         self.RemoveUser = channel.unary_unary(
-                '/Organizations/RemoveUser',
+                '/sylk.Organizations.v1.Organizations/RemoveUser',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.RemoveUserRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.RemoveUserResponse.FromString,
                 )
         self.UpdateUserRole = channel.unary_unary(
-                '/Organizations/UpdateUserRole',
+                '/sylk.Organizations.v1.Organizations/UpdateUserRole',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRoleRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRoleResponse.FromString,
                 )
 
 
 class OrganizationsServicer(object):
     """Missing associated documentation comment in .proto file."""
@@ -156,15 +156,15 @@
             'UpdateUserRole': grpc.unary_unary_rpc_method_handler(
                     servicer.UpdateUserRole,
                     request_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRoleRequest.FromString,
                     response_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRoleResponse.SerializeToString,
             ),
     }
     generic_handler = grpc.method_handlers_generic_handler(
-            'Organizations', rpc_method_handlers)
+            'sylk.Organizations.v1.Organizations', rpc_method_handlers)
     server.add_generic_rpc_handlers((generic_handler,))
 
 
  # This class is part of an EXPERIMENTAL API.
 class Organizations(object):
     """Missing associated documentation comment in .proto file."""
 
@@ -175,15 +175,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Organizations/AcceprUserInvite',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Organizations.v1.Organizations/AcceprUserInvite',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.AcceptUserInviteRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.AcceptUserInviteResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def GetOrganization(request,
@@ -192,15 +192,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Organizations/GetOrganization',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Organizations.v1.Organizations/GetOrganization',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetOrganizationRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetOrganizationResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdateOrganization(request,
@@ -209,15 +209,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Organizations/UpdateOrganization',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Organizations.v1.Organizations/UpdateOrganization',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateOrganizationRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateOrganizationResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def ListOrganizations(request,
@@ -226,15 +226,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_stream(request, target, '/Organizations/ListOrganizations',
+        return grpc.experimental.unary_stream(request, target, '/sylk.Organizations.v1.Organizations/ListOrganizations',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.ListOrganizationsRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetOrganizationResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def AddUser(request,
@@ -243,15 +243,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Organizations/AddUser',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Organizations.v1.Organizations/AddUser',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.AddUserRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.AddUserResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdateUserStatus(request,
@@ -260,15 +260,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Organizations/UpdateUserStatus',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Organizations.v1.Organizations/UpdateUserStatus',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserStatusRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserStatusResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def RemoveUser(request,
@@ -277,15 +277,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Organizations/RemoveUser',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Organizations.v1.Organizations/RemoveUser',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.RemoveUserRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.RemoveUserResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdateUserRole(request,
@@ -294,12 +294,12 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Organizations/UpdateUserRole',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Organizations.v1.Organizations/UpdateUserRole',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRoleRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRoleResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
```

## sylk/commons/protos/sylk/Packages/v1/Packages_pb2.py

```diff
@@ -10,19 +10,18 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from sylk.commons.protos.sylk.SylkApi.v1 import SylkApi_pb2 as sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fsylk/Packages/v1/Packages.proto\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xde\x03\n\x08Packages\x12U\n\nGetPackage\x12\".sylk.SylkApi.v1.GetPackageRequest\x1a#.sylk.SylkApi.v1.GetPackageResponse\x12^\n\rCreatePackage\x12%.sylk.SylkApi.v1.CreatePackageRequest\x1a&.sylk.SylkApi.v1.CreatePackageResponse\x12^\n\rDeletePackage\x12%.sylk.SylkApi.v1.DeletePackageRequest\x1a&.sylk.SylkApi.v1.DeletePackageResponse\x12^\n\rUpdatePackage\x12%.sylk.SylkApi.v1.UpdatePackageRequest\x1a&.sylk.SylkApi.v1.UpdatePackageResponse\x12[\n\x0cListPackages\x12$.sylk.SylkApi.v1.ListPackagesRequest\x1a#.sylk.SylkApi.v1.GetPackageResponse0\x01\x42\x42Z@github.com/sylk-build/sylk-core/services/protos/sylk/Packages/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fsylk/Packages/v1/Packages.proto\x12\x10sylk.Packages.v1\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xde\x03\n\x08Packages\x12U\n\nGetPackage\x12\".sylk.SylkApi.v1.GetPackageRequest\x1a#.sylk.SylkApi.v1.GetPackageResponse\x12^\n\rCreatePackage\x12%.sylk.SylkApi.v1.CreatePackageRequest\x1a&.sylk.SylkApi.v1.CreatePackageResponse\x12^\n\rDeletePackage\x12%.sylk.SylkApi.v1.DeletePackageRequest\x1a&.sylk.SylkApi.v1.DeletePackageResponse\x12^\n\rUpdatePackage\x12%.sylk.SylkApi.v1.UpdatePackageRequest\x1a&.sylk.SylkApi.v1.UpdatePackageResponse\x12[\n\x0cListPackages\x12$.sylk.SylkApi.v1.ListPackagesRequest\x1a#.sylk.SylkApi.v1.GetPackageResponse0\x01\x62\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.Packages.v1.Packages_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'Z@github.com/sylk-build/sylk-core/services/protos/sylk/Packages/v1'
-  _globals['_PACKAGES']._serialized_start=67
-  _globals['_PACKAGES']._serialized_end=545
+  _globals['_PACKAGES']._serialized_start=85
+  _globals['_PACKAGES']._serialized_end=563
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/Packages/v1/Packages_pb2_grpc.py

```diff
@@ -11,35 +11,35 @@
     def __init__(self, channel):
         """Constructor.
 
         Args:
             channel: A grpc.Channel.
         """
         self.GetPackage = channel.unary_unary(
-                '/Packages/GetPackage',
+                '/sylk.Packages.v1.Packages/GetPackage',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetPackageRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetPackageResponse.FromString,
                 )
         self.CreatePackage = channel.unary_unary(
-                '/Packages/CreatePackage',
+                '/sylk.Packages.v1.Packages/CreatePackage',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreatePackageRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreatePackageResponse.FromString,
                 )
         self.DeletePackage = channel.unary_unary(
-                '/Packages/DeletePackage',
+                '/sylk.Packages.v1.Packages/DeletePackage',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeletePackageRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeletePackageResponse.FromString,
                 )
         self.UpdatePackage = channel.unary_unary(
-                '/Packages/UpdatePackage',
+                '/sylk.Packages.v1.Packages/UpdatePackage',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdatePackageRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdatePackageResponse.FromString,
                 )
         self.ListPackages = channel.unary_stream(
-                '/Packages/ListPackages',
+                '/sylk.Packages.v1.Packages/ListPackages',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.ListPackagesRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetPackageResponse.FromString,
                 )
 
 
 class PackagesServicer(object):
     """Missing associated documentation comment in .proto file."""
@@ -105,15 +105,15 @@
             'ListPackages': grpc.unary_stream_rpc_method_handler(
                     servicer.ListPackages,
                     request_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.ListPackagesRequest.FromString,
                     response_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetPackageResponse.SerializeToString,
             ),
     }
     generic_handler = grpc.method_handlers_generic_handler(
-            'Packages', rpc_method_handlers)
+            'sylk.Packages.v1.Packages', rpc_method_handlers)
     server.add_generic_rpc_handlers((generic_handler,))
 
 
  # This class is part of an EXPERIMENTAL API.
 class Packages(object):
     """Missing associated documentation comment in .proto file."""
 
@@ -124,15 +124,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Packages/GetPackage',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Packages.v1.Packages/GetPackage',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetPackageRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetPackageResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def CreatePackage(request,
@@ -141,15 +141,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Packages/CreatePackage',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Packages.v1.Packages/CreatePackage',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreatePackageRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreatePackageResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def DeletePackage(request,
@@ -158,15 +158,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Packages/DeletePackage',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Packages.v1.Packages/DeletePackage',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeletePackageRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeletePackageResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdatePackage(request,
@@ -175,15 +175,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Packages/UpdatePackage',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Packages.v1.Packages/UpdatePackage',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdatePackageRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdatePackageResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def ListPackages(request,
@@ -192,12 +192,12 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_stream(request, target, '/Packages/ListPackages',
+        return grpc.experimental.unary_stream(request, target, '/sylk.Packages.v1.Packages/ListPackages',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.ListPackagesRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetPackageResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
```

## sylk/commons/protos/sylk/Projects/v1/Projects_pb2.py

```diff
@@ -10,19 +10,18 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from sylk.commons.protos.sylk.SylkApi.v1 import SylkApi_pb2 as sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fsylk/Projects/v1/Projects.proto\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xeb\x06\n\x08Projects\x12h\n\x15UpdateUserRoleProject\x12&.sylk.SylkApi.v1.UpdateUserRoleRequest\x1a\'.sylk.SylkApi.v1.UpdateUserRoleResponse\x12\\\n\x11RemoveUserProject\x12\".sylk.SylkApi.v1.RemoveUserRequest\x1a#.sylk.SylkApi.v1.RemoveUserResponse\x12S\n\x0e\x41\x64\x64UserProject\x12\x1f.sylk.SylkApi.v1.AddUserRequest\x1a .sylk.SylkApi.v1.AddUserResponse\x12U\n\nGetProject\x12\".sylk.SylkApi.v1.GetProjectRequest\x1a#.sylk.SylkApi.v1.GetProjectResponse\x12^\n\rUpdateProject\x12%.sylk.SylkApi.v1.UpdateProjectRequest\x1a&.sylk.SylkApi.v1.UpdateProjectResponse\x12^\n\rCreateProject\x12%.sylk.SylkApi.v1.CreateProjectRequest\x1a&.sylk.SylkApi.v1.CreateProjectResponse\x12^\n\rDeleteProject\x12%.sylk.SylkApi.v1.DeleteProjectRequest\x1a&.sylk.SylkApi.v1.DeleteProjectResponse\x12[\n\x0cListProjects\x12$.sylk.SylkApi.v1.ListProjectsRequest\x1a#.sylk.SylkApi.v1.GetProjectResponse0\x01\x12n\n\x17UpdateUserStatusProject\x12(.sylk.SylkApi.v1.UpdateUserStatusRequest\x1a).sylk.SylkApi.v1.UpdateUserStatusResponseBBZ@github.com/sylk-build/sylk-core/services/protos/sylk/Projects/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fsylk/Projects/v1/Projects.proto\x12\x10sylk.Projects.v1\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xeb\x06\n\x08Projects\x12h\n\x15UpdateUserRoleProject\x12&.sylk.SylkApi.v1.UpdateUserRoleRequest\x1a\'.sylk.SylkApi.v1.UpdateUserRoleResponse\x12\\\n\x11RemoveUserProject\x12\".sylk.SylkApi.v1.RemoveUserRequest\x1a#.sylk.SylkApi.v1.RemoveUserResponse\x12S\n\x0e\x41\x64\x64UserProject\x12\x1f.sylk.SylkApi.v1.AddUserRequest\x1a .sylk.SylkApi.v1.AddUserResponse\x12U\n\nGetProject\x12\".sylk.SylkApi.v1.GetProjectRequest\x1a#.sylk.SylkApi.v1.GetProjectResponse\x12^\n\rUpdateProject\x12%.sylk.SylkApi.v1.UpdateProjectRequest\x1a&.sylk.SylkApi.v1.UpdateProjectResponse\x12^\n\rCreateProject\x12%.sylk.SylkApi.v1.CreateProjectRequest\x1a&.sylk.SylkApi.v1.CreateProjectResponse\x12^\n\rDeleteProject\x12%.sylk.SylkApi.v1.DeleteProjectRequest\x1a&.sylk.SylkApi.v1.DeleteProjectResponse\x12[\n\x0cListProjects\x12$.sylk.SylkApi.v1.ListProjectsRequest\x1a#.sylk.SylkApi.v1.GetProjectResponse0\x01\x12n\n\x17UpdateUserStatusProject\x12(.sylk.SylkApi.v1.UpdateUserStatusRequest\x1a).sylk.SylkApi.v1.UpdateUserStatusResponseb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.Projects.v1.Projects_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'Z@github.com/sylk-build/sylk-core/services/protos/sylk/Projects/v1'
-  _globals['_PROJECTS']._serialized_start=67
-  _globals['_PROJECTS']._serialized_end=942
+  _globals['_PROJECTS']._serialized_start=85
+  _globals['_PROJECTS']._serialized_end=960
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/Projects/v1/Projects_pb2_grpc.py

```diff
@@ -11,55 +11,55 @@
     def __init__(self, channel):
         """Constructor.
 
         Args:
             channel: A grpc.Channel.
         """
         self.UpdateUserRoleProject = channel.unary_unary(
-                '/Projects/UpdateUserRoleProject',
+                '/sylk.Projects.v1.Projects/UpdateUserRoleProject',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRoleRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRoleResponse.FromString,
                 )
         self.RemoveUserProject = channel.unary_unary(
-                '/Projects/RemoveUserProject',
+                '/sylk.Projects.v1.Projects/RemoveUserProject',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.RemoveUserRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.RemoveUserResponse.FromString,
                 )
         self.AddUserProject = channel.unary_unary(
-                '/Projects/AddUserProject',
+                '/sylk.Projects.v1.Projects/AddUserProject',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.AddUserRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.AddUserResponse.FromString,
                 )
         self.GetProject = channel.unary_unary(
-                '/Projects/GetProject',
+                '/sylk.Projects.v1.Projects/GetProject',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetProjectRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetProjectResponse.FromString,
                 )
         self.UpdateProject = channel.unary_unary(
-                '/Projects/UpdateProject',
+                '/sylk.Projects.v1.Projects/UpdateProject',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateProjectRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateProjectResponse.FromString,
                 )
         self.CreateProject = channel.unary_unary(
-                '/Projects/CreateProject',
+                '/sylk.Projects.v1.Projects/CreateProject',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateProjectRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateProjectResponse.FromString,
                 )
         self.DeleteProject = channel.unary_unary(
-                '/Projects/DeleteProject',
+                '/sylk.Projects.v1.Projects/DeleteProject',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteProjectRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteProjectResponse.FromString,
                 )
         self.ListProjects = channel.unary_stream(
-                '/Projects/ListProjects',
+                '/sylk.Projects.v1.Projects/ListProjects',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.ListProjectsRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetProjectResponse.FromString,
                 )
         self.UpdateUserStatusProject = channel.unary_unary(
-                '/Projects/UpdateUserStatusProject',
+                '/sylk.Projects.v1.Projects/UpdateUserStatusProject',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserStatusRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserStatusResponse.FromString,
                 )
 
 
 class ProjectsServicer(object):
     """Missing associated documentation comment in .proto file."""
@@ -173,15 +173,15 @@
             'UpdateUserStatusProject': grpc.unary_unary_rpc_method_handler(
                     servicer.UpdateUserStatusProject,
                     request_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserStatusRequest.FromString,
                     response_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserStatusResponse.SerializeToString,
             ),
     }
     generic_handler = grpc.method_handlers_generic_handler(
-            'Projects', rpc_method_handlers)
+            'sylk.Projects.v1.Projects', rpc_method_handlers)
     server.add_generic_rpc_handlers((generic_handler,))
 
 
  # This class is part of an EXPERIMENTAL API.
 class Projects(object):
     """Missing associated documentation comment in .proto file."""
 
@@ -192,15 +192,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Projects/UpdateUserRoleProject',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Projects.v1.Projects/UpdateUserRoleProject',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRoleRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRoleResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def RemoveUserProject(request,
@@ -209,15 +209,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Projects/RemoveUserProject',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Projects.v1.Projects/RemoveUserProject',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.RemoveUserRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.RemoveUserResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def AddUserProject(request,
@@ -226,15 +226,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Projects/AddUserProject',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Projects.v1.Projects/AddUserProject',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.AddUserRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.AddUserResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def GetProject(request,
@@ -243,15 +243,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Projects/GetProject',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Projects.v1.Projects/GetProject',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetProjectRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetProjectResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdateProject(request,
@@ -260,15 +260,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Projects/UpdateProject',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Projects.v1.Projects/UpdateProject',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateProjectRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateProjectResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def CreateProject(request,
@@ -277,15 +277,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Projects/CreateProject',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Projects.v1.Projects/CreateProject',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateProjectRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateProjectResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def DeleteProject(request,
@@ -294,15 +294,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Projects/DeleteProject',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Projects.v1.Projects/DeleteProject',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteProjectRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteProjectResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def ListProjects(request,
@@ -311,15 +311,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_stream(request, target, '/Projects/ListProjects',
+        return grpc.experimental.unary_stream(request, target, '/sylk.Projects.v1.Projects/ListProjects',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.ListProjectsRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetProjectResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdateUserStatusProject(request,
@@ -328,12 +328,12 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Projects/UpdateUserStatusProject',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Projects.v1.Projects/UpdateUserStatusProject',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserStatusRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserStatusResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
```

## sylk/commons/protos/sylk/Services/v1/Services_pb2.py

```diff
@@ -10,19 +10,18 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from sylk.commons.protos.sylk.SylkApi.v1 import SylkApi_pb2 as sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fsylk/Services/v1/Services.proto\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xde\x03\n\x08Services\x12^\n\rCreateService\x12%.sylk.SylkApi.v1.CreateServiceRequest\x1a&.sylk.SylkApi.v1.CreateServiceResponse\x12U\n\nGetService\x12\".sylk.SylkApi.v1.GetServiceRequest\x1a#.sylk.SylkApi.v1.GetServiceResponse\x12^\n\rUpdateService\x12%.sylk.SylkApi.v1.UpdateServiceRequest\x1a&.sylk.SylkApi.v1.UpdateServiceResponse\x12[\n\x0cListServices\x12$.sylk.SylkApi.v1.ListServicesRequest\x1a#.sylk.SylkApi.v1.GetServiceResponse0\x01\x12^\n\rDeleteService\x12%.sylk.SylkApi.v1.DeleteServiceRequest\x1a&.sylk.SylkApi.v1.DeleteServiceResponseBBZ@github.com/sylk-build/sylk-core/services/protos/sylk/Services/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fsylk/Services/v1/Services.proto\x12\x10sylk.Services.v1\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xde\x03\n\x08Services\x12^\n\rCreateService\x12%.sylk.SylkApi.v1.CreateServiceRequest\x1a&.sylk.SylkApi.v1.CreateServiceResponse\x12U\n\nGetService\x12\".sylk.SylkApi.v1.GetServiceRequest\x1a#.sylk.SylkApi.v1.GetServiceResponse\x12^\n\rUpdateService\x12%.sylk.SylkApi.v1.UpdateServiceRequest\x1a&.sylk.SylkApi.v1.UpdateServiceResponse\x12[\n\x0cListServices\x12$.sylk.SylkApi.v1.ListServicesRequest\x1a#.sylk.SylkApi.v1.GetServiceResponse0\x01\x12^\n\rDeleteService\x12%.sylk.SylkApi.v1.DeleteServiceRequest\x1a&.sylk.SylkApi.v1.DeleteServiceResponseb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.Services.v1.Services_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'Z@github.com/sylk-build/sylk-core/services/protos/sylk/Services/v1'
-  _globals['_SERVICES']._serialized_start=67
-  _globals['_SERVICES']._serialized_end=545
+  _globals['_SERVICES']._serialized_start=85
+  _globals['_SERVICES']._serialized_end=563
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/Services/v1/Services_pb2_grpc.py

```diff
@@ -11,35 +11,35 @@
     def __init__(self, channel):
         """Constructor.
 
         Args:
             channel: A grpc.Channel.
         """
         self.CreateService = channel.unary_unary(
-                '/Services/CreateService',
+                '/sylk.Services.v1.Services/CreateService',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateServiceRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateServiceResponse.FromString,
                 )
         self.GetService = channel.unary_unary(
-                '/Services/GetService',
+                '/sylk.Services.v1.Services/GetService',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetServiceRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetServiceResponse.FromString,
                 )
         self.UpdateService = channel.unary_unary(
-                '/Services/UpdateService',
+                '/sylk.Services.v1.Services/UpdateService',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateServiceRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateServiceResponse.FromString,
                 )
         self.ListServices = channel.unary_stream(
-                '/Services/ListServices',
+                '/sylk.Services.v1.Services/ListServices',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.ListServicesRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetServiceResponse.FromString,
                 )
         self.DeleteService = channel.unary_unary(
-                '/Services/DeleteService',
+                '/sylk.Services.v1.Services/DeleteService',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteServiceRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteServiceResponse.FromString,
                 )
 
 
 class ServicesServicer(object):
     """Missing associated documentation comment in .proto file."""
@@ -105,15 +105,15 @@
             'DeleteService': grpc.unary_unary_rpc_method_handler(
                     servicer.DeleteService,
                     request_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteServiceRequest.FromString,
                     response_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteServiceResponse.SerializeToString,
             ),
     }
     generic_handler = grpc.method_handlers_generic_handler(
-            'Services', rpc_method_handlers)
+            'sylk.Services.v1.Services', rpc_method_handlers)
     server.add_generic_rpc_handlers((generic_handler,))
 
 
  # This class is part of an EXPERIMENTAL API.
 class Services(object):
     """Missing associated documentation comment in .proto file."""
 
@@ -124,15 +124,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Services/CreateService',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Services.v1.Services/CreateService',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateServiceRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateServiceResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def GetService(request,
@@ -141,15 +141,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Services/GetService',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Services.v1.Services/GetService',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetServiceRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetServiceResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdateService(request,
@@ -158,15 +158,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Services/UpdateService',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Services.v1.Services/UpdateService',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateServiceRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateServiceResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def ListServices(request,
@@ -175,15 +175,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_stream(request, target, '/Services/ListServices',
+        return grpc.experimental.unary_stream(request, target, '/sylk.Services.v1.Services/ListServices',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.ListServicesRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetServiceResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def DeleteService(request,
@@ -192,12 +192,12 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Services/DeleteService',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Services.v1.Services/DeleteService',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteServiceRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.DeleteServiceResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
```

## sylk/commons/protos/sylk/Sylk/v1/Sylk_pb2.py

```diff
@@ -14,23 +14,22 @@
 from sylk.commons.protos.sylk.SylkProject.v1 import SylkProject_pb2 as sylk_dot_SylkProject_dot_v1_dot_SylkProject__pb2
 from sylk.commons.protos.sylk.SylkOrganization.v1 import SylkOrganization_pb2 as sylk_dot_SylkOrganization_dot_v1_dot_SylkOrganization__pb2
 from sylk.commons.protos.sylk.SylkService.v1 import SylkService_pb2 as sylk_dot_SylkService_dot_v1_dot_SylkService__pb2
 from sylk.commons.protos.sylk.SylkPackage.v1 import SylkPackage_pb2 as sylk_dot_SylkPackage_dot_v1_dot_SylkPackage__pb2
 from sylk.commons.protos.sylk.SylkConfigs.v1 import SylkConfigs_pb2 as sylk_dot_SylkConfigs_dot_v1_dot_SylkConfigs__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x17sylk/Sylk/v1/Sylk.proto\x12\x0csylk.Sylk.v1\x1a%sylk/SylkProject/v1/SylkProject.proto\x1a/sylk/SylkOrganization/v1/SylkOrganization.proto\x1a%sylk/SylkService/v1/SylkService.proto\x1a%sylk/SylkPackage/v1/SylkPackage.proto\x1a%sylk/SylkConfigs/v1/SylkConfigs.proto\"\xe5\x03\n\x08SylkJson\x12\x14\n\x0csylk_version\x18\x05 \x01(\t\x12\x31\n\x07project\x18\x06 \x01(\x0b\x32 .sylk.SylkProject.v1.SylkProject\x12@\n\x0corganization\x18\x01 \x01(\x0b\x32*.sylk.SylkOrganization.v1.SylkOrganization\x12\x36\n\x08services\x18\x03 \x03(\x0b\x32$.sylk.Sylk.v1.SylkJson.ServicesEntry\x12\x36\n\x08packages\x18\x02 \x03(\x0b\x32$.sylk.Sylk.v1.SylkJson.PackagesEntry\x12\x38\n\x07\x63onfigs\x18\x04 \x01(\x0b\x32\'.sylk.SylkConfigs.v1.SylkProjectConfigs\x1aQ\n\rServicesEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12/\n\x05value\x18\x02 \x01(\x0b\x32 .sylk.SylkService.v1.SylkService:\x02\x38\x01\x1aQ\n\rPackagesEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12/\n\x05value\x18\x02 \x01(\x0b\x32 .sylk.SylkPackage.v1.SylkPackage:\x02\x38\x01\x42>Z<github.com/sylk-build/sylk-core/services/protos/sylk/Sylk/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x17sylk/Sylk/v1/Sylk.proto\x12\x0csylk.Sylk.v1\x1a%sylk/SylkProject/v1/SylkProject.proto\x1a/sylk/SylkOrganization/v1/SylkOrganization.proto\x1a%sylk/SylkService/v1/SylkService.proto\x1a%sylk/SylkPackage/v1/SylkPackage.proto\x1a%sylk/SylkConfigs/v1/SylkConfigs.proto\"\xe5\x03\n\x08SylkJson\x12\x14\n\x0csylk_version\x18\x05 \x01(\t\x12\x31\n\x07project\x18\x06 \x01(\x0b\x32 .sylk.SylkProject.v1.SylkProject\x12@\n\x0corganization\x18\x01 \x01(\x0b\x32*.sylk.SylkOrganization.v1.SylkOrganization\x12\x36\n\x08services\x18\x03 \x03(\x0b\x32$.sylk.Sylk.v1.SylkJson.ServicesEntry\x12\x36\n\x08packages\x18\x02 \x03(\x0b\x32$.sylk.Sylk.v1.SylkJson.PackagesEntry\x12\x38\n\x07\x63onfigs\x18\x04 \x01(\x0b\x32\'.sylk.SylkConfigs.v1.SylkProjectConfigs\x1aQ\n\rServicesEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12/\n\x05value\x18\x02 \x01(\x0b\x32 .sylk.SylkService.v1.SylkService:\x02\x38\x01\x1aQ\n\rPackagesEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12/\n\x05value\x18\x02 \x01(\x0b\x32 .sylk.SylkPackage.v1.SylkPackage:\x02\x38\x01\x62\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.Sylk.v1.Sylk_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'Z<github.com/sylk-build/sylk-core/services/protos/sylk/Sylk/v1'
   _SYLKJSON_SERVICESENTRY._options = None
   _SYLKJSON_SERVICESENTRY._serialized_options = b'8\001'
   _SYLKJSON_PACKAGESENTRY._options = None
   _SYLKJSON_PACKAGESENTRY._serialized_options = b'8\001'
   _globals['_SYLKJSON']._serialized_start=247
   _globals['_SYLKJSON']._serialized_end=732
   _globals['_SYLKJSON_SERVICESENTRY']._serialized_start=568
```

## sylk/commons/protos/sylk/SylkApi/v1/SylkApi_pb2.py

```diff
@@ -21,23 +21,22 @@
 from sylk.commons.protos.sylk.SylkField.v1 import SylkField_pb2 as sylk_dot_SylkField_dot_v1_dot_SylkField__pb2
 from sylk.commons.protos.sylk.SylkEnum.v1 import SylkEnum_pb2 as sylk_dot_SylkEnum_dot_v1_dot_SylkEnum__pb2
 from sylk.commons.protos.sylk.SylkEnumValue.v1 import SylkEnumValue_pb2 as sylk_dot_SylkEnumValue_dot_v1_dot_SylkEnumValue__pb2
 from google.protobuf import struct_pb2 as google_dot_protobuf_dot_struct__pb2
 from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1dsylk/SylkApi/v1/SylkApi.proto\x12\x0fsylk.SylkApi.v1\x1a/sylk/SylkOrganization/v1/SylkOrganization.proto\x1a\x1fsylk/SylkUser/v1/SylkUser.proto\x1a%sylk/SylkProject/v1/SylkProject.proto\x1a%sylk/SylkPackage/v1/SylkPackage.proto\x1a%sylk/SylkService/v1/SylkService.proto\x1a%sylk/SylkMessage/v1/SylkMessage.proto\x1a#sylk/SylkMethod/v1/SylkMethod.proto\x1a!sylk/SylkField/v1/SylkField.proto\x1a\x1fsylk/SylkEnum/v1/SylkEnum.proto\x1a)sylk/SylkEnumValue/v1/SylkEnumValue.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"$\n\x12RemoveUserResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\"K\n\x11RemoveUserRequest\x12\x12\n\nproject_id\x18\x03 \x01(\t\x12\x12\n\nuser_email\x18\x01 \x01(\t\x12\x0e\n\x06org_id\x18\x02 \x01(\t\"g\n\x19UpdateOrganizationRequest\x12\x0e\n\x06org_id\x18\x01 \x01(\t\x12:\n\x06update\x18\x02 \x01(\x0b\x32*.sylk.SylkOrganization.v1.SylkOrganization\"\\\n\x17GetOrganizationResponse\x12\x41\n\x06result\x18\x01 \x01(\x0b\x32\x31.sylk.SylkOrganization.v1.SylkOrganizationDisplay\"(\n\x16GetOrganizationRequest\x12\x0e\n\x06org_id\x18\x01 \x01(\t\"*\n\x18UpdateUserStatusResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\"w\n\x17UpdateUserStatusRequest\x12\x18\n\x10user_email_or_id\x18\x01 \x01(\t\x12\x0e\n\x06org_id\x18\x03 \x01(\t\x12\x32\n\x06status\x18\x02 \x01(\x0e\x32\".sylk.SylkUser.v1.SylkUserStatuses\"(\n\x16UpdateUserRoleResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\"{\n\x15UpdateUserRoleRequest\x12-\n\x04role\x18\x03 \x01(\x0e\x32\x1f.sylk.SylkUser.v1.SylkUserRoles\x12\x0f\n\x07user_id\x18\x01 \x01(\t\x12\x0e\n\x06org_id\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x04 \x01(\t\"\'\n\x15\x44\x65leteProjectResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\"\'\n\x14\x44\x65leteProjectRequest\x12\x0f\n\x07project\x18\x01 \x01(\t\"e\n\x15UpdateProjectResponse\x12\x38\n\x07updated\x18\x02 \x01(\x0b\x32\'.sylk.SylkProject.v1.SylkProjectDisplay\x12\x12\n\nproject_id\x18\x01 \x01(\t\"\\\n\x14UpdateProjectRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x30\n\x06update\x18\x02 \x01(\x0b\x32 .sylk.SylkProject.v1.SylkProject\"M\n\x12GetProjectResponse\x12\x37\n\x06result\x18\x01 \x01(\x0b\x32\'.sylk.SylkProject.v1.SylkProjectDisplay\"$\n\x11GetProjectRequest\x12\x0f\n\x07project\x18\x01 \x01(\t\"D\n\x0fGetUserResponse\x12\x31\n\x06result\x18\x01 \x01(\x0b\x32!.sylk.SylkUser.v1.SylkUserDisplay\"!\n\x0eGetUserRequest\x12\x0f\n\x07user_id\x18\x01 \x01(\t\"!\n\x0f\x41\x64\x64UserResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\"t\n\x0e\x41\x64\x64UserRequest\x12-\n\x04role\x18\x02 \x01(\x0e\x32\x1f.sylk.SylkUser.v1.SylkUserRoles\x12\x0e\n\x06org_id\x18\x03 \x01(\t\x12\x0f\n\x07project\x18\x04 \x01(\t\x12\x12\n\nuser_email\x18\x01 \x01(\t\"*\n\x18\x41\x63\x63\x65ptUserInviteResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\"8\n\x17\x41\x63\x63\x65ptUserInviteRequest\x12\r\n\x05\x65mail\x18\x01 \x01(\t\x12\x0e\n\x06org_id\x18\x02 \x01(\t\"R\n\x12UpdateUserResponse\x12+\n\x07updated\x18\x02 \x01(\x0b\x32\x1a.sylk.SylkUser.v1.SylkUser\x12\x0f\n\x07user_id\x18\x01 \x01(\t\"P\n\x11UpdateUserRequest\x12*\n\x06update\x18\x02 \x01(\x0b\x32\x1a.sylk.SylkUser.v1.SylkUser\x12\x0f\n\x07user_id\x18\x01 \x01(\t\"\x80\x01\n\x12\x43reateUserResponse\x12(\n\x04user\x18\x01 \x01(\x0b\x32\x1a.sylk.SylkUser.v1.SylkUser\x12@\n\x0corganization\x18\x02 \x01(\x0b\x32*.sylk.SylkOrganization.v1.SylkOrganization\"M\n\x11\x43reateUserRequest\x12\x0e\n\x06org_id\x18\x01 \x01(\t\x12(\n\x04user\x18\x02 \x01(\x0b\x32\x1a.sylk.SylkUser.v1.SylkUser\"+\n\x18ListOrganizationsRequest\x12\x0f\n\x07user_id\x18\x01 \x01(\t\"i\n\x1aUpdateOrganizationResponse\x12;\n\x07updated\x18\x02 \x01(\x0b\x32*.sylk.SylkOrganization.v1.SylkOrganization\x12\x0e\n\x06org_id\x18\x01 \x01(\t\"8\n\x11GetPackageRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07package\x18\x02 \x01(\t\"M\n\x12GetPackageResponse\x12\x37\n\x06result\x18\x01 \x01(\x0b\x32\'.sylk.SylkPackage.v1.SylkPackageDisplay\"]\n\x14\x43reatePackageRequest\x12\x31\n\x07package\x18\x02 \x01(\x0b\x32 .sylk.SylkPackage.v1.SylkPackage\x12\x12\n\nproject_id\x18\x01 \x01(\t\"d\n\x15\x43reatePackageResponse\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x37\n\x06result\x18\x02 \x01(\x0b\x32\'.sylk.SylkPackage.v1.SylkPackageDisplay\"m\n\x14UpdatePackageRequest\x12\x12\n\nproject_id\x18\x02 \x01(\t\x12\x0f\n\x07package\x18\x01 \x01(\t\x12\x30\n\x06update\x18\x03 \x01(\x0b\x32 .sylk.SylkPackage.v1.SylkPackage\"v\n\x15UpdatePackageResponse\x12\x38\n\x07updated\x18\x03 \x01(\x0b\x32\'.sylk.SylkPackage.v1.SylkPackageDisplay\x12\x0f\n\x07package\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\";\n\x14\x44\x65letePackageRequest\x12\x12\n\nproject_id\x18\x02 \x01(\t\x12\x0f\n\x07package\x18\x01 \x01(\t\"<\n\x15\x44\x65letePackageResponse\x12\x0f\n\x07package\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"8\n\x11GetServiceRequest\x12\x0f\n\x07service\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"M\n\x12GetServiceResponse\x12\x37\n\x06result\x18\x01 \x01(\x0b\x32\'.sylk.SylkService.v1.SylkServiceDisplay\"]\n\x14\x43reateServiceRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x31\n\x07service\x18\x02 \x01(\x0b\x32 .sylk.SylkService.v1.SylkService\"d\n\x15\x43reateServiceResponse\x12\x37\n\x06result\x18\x02 \x01(\x0b\x32\'.sylk.SylkService.v1.SylkServiceDisplay\x12\x12\n\nproject_id\x18\x01 \x01(\t\"m\n\x14UpdateServiceRequest\x12\x0f\n\x07service\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x30\n\x06update\x18\x03 \x01(\x0b\x32 .sylk.SylkService.v1.SylkService\"v\n\x15UpdateServiceResponse\x12\x38\n\x07updated\x18\x03 \x01(\x0b\x32\'.sylk.SylkService.v1.SylkServiceDisplay\x12\x0f\n\x07service\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\";\n\x14\x44\x65leteServiceRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07service\x18\x02 \x01(\t\"<\n\x15\x44\x65leteServiceResponse\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07service\x18\x02 \x01(\t\")\n\x13ListServicesRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\")\n\x13ListPackagesRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\"8\n\x11GetMessageRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07message\x18\x02 \x01(\t\"M\n\x12GetMessageResponse\x12\x37\n\x06result\x18\x01 \x01(\x0b\x32\'.sylk.SylkMessage.v1.SylkMessageDisplay\"n\n\x14\x43reateMessageRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07package\x18\x02 \x01(\t\x12\x31\n\x07message\x18\x03 \x01(\x0b\x32 .sylk.SylkMessage.v1.SylkMessage\"u\n\x15\x43reateMessageResponse\x12\x37\n\x06result\x18\x03 \x01(\x0b\x32\'.sylk.SylkMessage.v1.SylkMessageDisplay\x12\x0f\n\x07message\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"m\n\x14UpdateMessageRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07message\x18\x02 \x01(\t\x12\x30\n\x06update\x18\x03 \x01(\x0b\x32 .sylk.SylkMessage.v1.SylkMessage\"v\n\x15UpdateMessageResponse\x12\x0f\n\x07message\x18\x02 \x01(\t\x12\x38\n\x07updated\x18\x03 \x01(\x0b\x32\'.sylk.SylkMessage.v1.SylkMessageDisplay\x12\x12\n\nproject_id\x18\x01 \x01(\t\";\n\x14\x44\x65leteMessageRequest\x12\x0f\n\x07message\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"<\n\x15\x44\x65leteMessageResponse\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07message\x18\x02 \x01(\t\"6\n\x10GetMethodRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0e\n\x06method\x18\x02 \x01(\t\"J\n\x11GetMethodResponse\x12\x35\n\x06result\x18\x01 \x01(\x0b\x32%.sylk.SylkMethod.v1.SylkMethodDisplay\"j\n\x13\x43reateMethodRequest\x12\x0f\n\x07service\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12.\n\x06method\x18\x03 \x01(\x0b\x32\x1e.sylk.SylkMethod.v1.SylkMethod\"r\n\x14\x43reateMethodResponse\x12\x35\n\x06result\x18\x03 \x01(\x0b\x32%.sylk.SylkMethod.v1.SylkMethodDisplay\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07service\x18\x02 \x01(\t\"i\n\x13UpdateMethodRequest\x12\x0e\n\x06method\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12.\n\x06update\x18\x03 \x01(\x0b\x32\x1e.sylk.SylkMethod.v1.SylkMethod\"r\n\x14UpdateMethodResponse\x12\x0e\n\x06method\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x36\n\x07updated\x18\x03 \x01(\x0b\x32%.sylk.SylkMethod.v1.SylkMethodDisplay\"9\n\x13\x44\x65leteMethodRequest\x12\x0e\n\x06method\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\":\n\x14\x44\x65leteMethodResponse\x12\x0e\n\x06method\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"4\n\x0fGetFieldRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\r\n\x05\x66ield\x18\x02 \x01(\t\"G\n\x10GetFieldResponse\x12\x33\n\x06result\x18\x01 \x01(\x0b\x32#.sylk.SylkField.v1.SylkFieldDisplay\"e\n\x12UpdateFieldRequest\x12\r\n\x05\x66ield\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12,\n\x06update\x18\x03 \x01(\x0b\x32\x1c.sylk.SylkField.v1.SylkField\"n\n\x13UpdateFieldResponse\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\r\n\x05\x66ield\x18\x02 \x01(\t\x12\x34\n\x07updated\x18\x03 \x01(\x0b\x32#.sylk.SylkField.v1.SylkFieldDisplay\"7\n\x12\x44\x65leteFieldRequest\x12\r\n\x05\x66ield\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"8\n\x13\x44\x65leteFieldResponse\x12\r\n\x05\x66ield\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"f\n\x12\x43reateFieldRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07message\x18\x02 \x01(\t\x12+\n\x05\x66ield\x18\x03 \x01(\x0b\x32\x1c.sylk.SylkField.v1.SylkField\"J\n\x13\x43reateFieldResponse\x12\x33\n\x06result\x18\x01 \x01(\x0b\x32#.sylk.SylkField.v1.SylkFieldDisplay\"2\n\x0eGetEnumRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0c\n\x04\x65num\x18\x02 \x01(\t\"D\n\x0fGetEnumResponse\x12\x31\n\x06result\x18\x01 \x01(\x0b\x32!.sylk.SylkEnum.v1.SylkEnumDisplay\"b\n\x11\x43reateEnumRequest\x12\x0f\n\x07package\x18\x02 \x01(\t\x12(\n\x04\x65num\x18\x03 \x01(\x0b\x32\x1a.sylk.SylkEnum.v1.SylkEnum\x12\x12\n\nproject_id\x18\x01 \x01(\t\"[\n\x12\x43reateEnumResponse\x12\x31\n\x06result\x18\x02 \x01(\x0b\x32!.sylk.SylkEnum.v1.SylkEnumDisplay\x12\x12\n\nproject_id\x18\x01 \x01(\t\"a\n\x11UpdateEnumRequest\x12*\n\x06update\x18\x03 \x01(\x0b\x32\x1a.sylk.SylkEnum.v1.SylkEnum\x12\x0c\n\x04\x65num\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"j\n\x12UpdateEnumResponse\x12\x0c\n\x04\x65num\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x32\n\x07updated\x18\x03 \x01(\x0b\x32!.sylk.SylkEnum.v1.SylkEnumDisplay\"5\n\x11\x44\x65leteEnumRequest\x12\x0c\n\x04\x65num\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"6\n\x12\x44\x65leteEnumResponse\x12\x0c\n\x04\x65num\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"=\n\x13GetEnumValueRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x12\n\nenum_value\x18\x02 \x01(\t\"S\n\x14GetEnumValueResponse\x12;\n\x06result\x18\x01 \x01(\x0b\x32+.sylk.SylkEnumValue.v1.SylkEnumValueDisplay\"t\n\x16\x43reateEnumValueRequest\x12\x0c\n\x04\x65num\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x38\n\nenum_value\x18\x03 \x01(\x0b\x32$.sylk.SylkEnumValue.v1.SylkEnumValue\"V\n\x17\x43reateEnumValueResponse\x12;\n\x06result\x18\x01 \x01(\x0b\x32+.sylk.SylkEnumValue.v1.SylkEnumValueDisplay\"v\n\x16UpdateEnumValueRequest\x12\x34\n\x06update\x18\x03 \x01(\x0b\x32$.sylk.SylkEnumValue.v1.SylkEnumValue\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x12\n\nenum_value\x18\x02 \x01(\t\"\x7f\n\x17UpdateEnumValueResponse\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12<\n\x07updated\x18\x03 \x01(\x0b\x32+.sylk.SylkEnumValue.v1.SylkEnumValueDisplay\x12\x12\n\nenum_value\x18\x02 \x01(\t\"@\n\x16\x44\x65leteEnumValueRequest\x12\x12\n\nenum_value\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"A\n\x17\x44\x65leteEnumValueResponse\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x12\n\nenum_value\x18\x02 \x01(\t\"a\n\x1eListOrganizationsResponseCache\x12?\n\rorganizations\x18\x01 \x03(\x0b\x32(.sylk.SylkApi.v1.GetOrganizationResponse\"%\n\x13ListProjectsRequest\x12\x0e\n\x06org_id\x18\x01 \x01(\t\"Y\n\x14\x43reateProjectRequest\x12\x31\n\x07project\x18\x02 \x01(\x0b\x32 .sylk.SylkProject.v1.SylkProject\x12\x0e\n\x06org_id\x18\x01 \x01(\t\"`\n\x15\x43reateProjectResponse\x12\x0e\n\x06org_id\x18\x02 \x01(\t\x12\x37\n\x06result\x18\x01 \x01(\x0b\x32\'.sylk.SylkProject.v1.SylkProjectDisplay\"R\n\x19ListProjectsResponseCache\x12\x35\n\x08projects\x18\x01 \x03(\x0b\x32#.sylk.SylkApi.v1.GetProjectResponse\"9\n\rCachedSession\x12(\n\x07session\x18\x01 \x01(\x0b\x32\x17.google.protobuf.Struct\"o\n\x18\x43reateAccessTokenRequest\x12\x13\n\x0b\x64\x65scription\x18\x03 \x01(\t\x12\x0e\n\x06org_id\x18\x01 \x01(\t\x12.\n\nexpires_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\"+\n\x19\x43reateAccessTokenResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\")\n\x17ListAccessTokensRequest\x12\x0e\n\x06org_id\x18\x01 \x01(\t\"O\n\x16GetAccessTokenResponse\x12\x35\n\x06result\x18\x01 \x01(\x0b\x32%.sylk.SylkUser.v1.PersonalAccessToken\"&\n\x15GetAccessTokenRequest\x12\r\n\x05token\x18\x01 \x01(\t\"9\n\x18RevokeAccessTokenRequest\x12\r\n\x05token\x18\x01 \x01(\t\x12\x0e\n\x06org_id\x18\x02 \x01(\t\"+\n\x19RevokeAccessTokenResponse\x12\x0e\n\x06status\x18\x01 \x01(\tBAZ?github.com/sylk-build/sylk-core/services/protos/sylk/SylkApi/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1dsylk/SylkApi/v1/SylkApi.proto\x12\x0fsylk.SylkApi.v1\x1a/sylk/SylkOrganization/v1/SylkOrganization.proto\x1a\x1fsylk/SylkUser/v1/SylkUser.proto\x1a%sylk/SylkProject/v1/SylkProject.proto\x1a%sylk/SylkPackage/v1/SylkPackage.proto\x1a%sylk/SylkService/v1/SylkService.proto\x1a%sylk/SylkMessage/v1/SylkMessage.proto\x1a#sylk/SylkMethod/v1/SylkMethod.proto\x1a!sylk/SylkField/v1/SylkField.proto\x1a\x1fsylk/SylkEnum/v1/SylkEnum.proto\x1a)sylk/SylkEnumValue/v1/SylkEnumValue.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"$\n\x12RemoveUserResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\"K\n\x11RemoveUserRequest\x12\x12\n\nproject_id\x18\x03 \x01(\t\x12\x12\n\nuser_email\x18\x01 \x01(\t\x12\x0e\n\x06org_id\x18\x02 \x01(\t\"g\n\x19UpdateOrganizationRequest\x12\x0e\n\x06org_id\x18\x01 \x01(\t\x12:\n\x06update\x18\x02 \x01(\x0b\x32*.sylk.SylkOrganization.v1.SylkOrganization\"\\\n\x17GetOrganizationResponse\x12\x41\n\x06result\x18\x01 \x01(\x0b\x32\x31.sylk.SylkOrganization.v1.SylkOrganizationDisplay\"(\n\x16GetOrganizationRequest\x12\x0e\n\x06org_id\x18\x01 \x01(\t\"*\n\x18UpdateUserStatusResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\"w\n\x17UpdateUserStatusRequest\x12\x18\n\x10user_email_or_id\x18\x01 \x01(\t\x12\x0e\n\x06org_id\x18\x03 \x01(\t\x12\x32\n\x06status\x18\x02 \x01(\x0e\x32\".sylk.SylkUser.v1.SylkUserStatuses\"(\n\x16UpdateUserRoleResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\"{\n\x15UpdateUserRoleRequest\x12-\n\x04role\x18\x03 \x01(\x0e\x32\x1f.sylk.SylkUser.v1.SylkUserRoles\x12\x0f\n\x07user_id\x18\x01 \x01(\t\x12\x0e\n\x06org_id\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x04 \x01(\t\"\'\n\x15\x44\x65leteProjectResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\"\'\n\x14\x44\x65leteProjectRequest\x12\x0f\n\x07project\x18\x01 \x01(\t\"e\n\x15UpdateProjectResponse\x12\x38\n\x07updated\x18\x02 \x01(\x0b\x32\'.sylk.SylkProject.v1.SylkProjectDisplay\x12\x12\n\nproject_id\x18\x01 \x01(\t\"\\\n\x14UpdateProjectRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x30\n\x06update\x18\x02 \x01(\x0b\x32 .sylk.SylkProject.v1.SylkProject\"M\n\x12GetProjectResponse\x12\x37\n\x06result\x18\x01 \x01(\x0b\x32\'.sylk.SylkProject.v1.SylkProjectDisplay\"$\n\x11GetProjectRequest\x12\x0f\n\x07project\x18\x01 \x01(\t\"D\n\x0fGetUserResponse\x12\x31\n\x06result\x18\x01 \x01(\x0b\x32!.sylk.SylkUser.v1.SylkUserDisplay\"!\n\x0eGetUserRequest\x12\x0f\n\x07user_id\x18\x01 \x01(\t\"!\n\x0f\x41\x64\x64UserResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\"t\n\x0e\x41\x64\x64UserRequest\x12-\n\x04role\x18\x02 \x01(\x0e\x32\x1f.sylk.SylkUser.v1.SylkUserRoles\x12\x0e\n\x06org_id\x18\x03 \x01(\t\x12\x0f\n\x07project\x18\x04 \x01(\t\x12\x12\n\nuser_email\x18\x01 \x01(\t\"*\n\x18\x41\x63\x63\x65ptUserInviteResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\"8\n\x17\x41\x63\x63\x65ptUserInviteRequest\x12\r\n\x05\x65mail\x18\x01 \x01(\t\x12\x0e\n\x06org_id\x18\x02 \x01(\t\"R\n\x12UpdateUserResponse\x12+\n\x07updated\x18\x02 \x01(\x0b\x32\x1a.sylk.SylkUser.v1.SylkUser\x12\x0f\n\x07user_id\x18\x01 \x01(\t\"P\n\x11UpdateUserRequest\x12*\n\x06update\x18\x02 \x01(\x0b\x32\x1a.sylk.SylkUser.v1.SylkUser\x12\x0f\n\x07user_id\x18\x01 \x01(\t\"\x80\x01\n\x12\x43reateUserResponse\x12(\n\x04user\x18\x01 \x01(\x0b\x32\x1a.sylk.SylkUser.v1.SylkUser\x12@\n\x0corganization\x18\x02 \x01(\x0b\x32*.sylk.SylkOrganization.v1.SylkOrganization\"M\n\x11\x43reateUserRequest\x12\x0e\n\x06org_id\x18\x01 \x01(\t\x12(\n\x04user\x18\x02 \x01(\x0b\x32\x1a.sylk.SylkUser.v1.SylkUser\"+\n\x18ListOrganizationsRequest\x12\x0f\n\x07user_id\x18\x01 \x01(\t\"i\n\x1aUpdateOrganizationResponse\x12;\n\x07updated\x18\x02 \x01(\x0b\x32*.sylk.SylkOrganization.v1.SylkOrganization\x12\x0e\n\x06org_id\x18\x01 \x01(\t\"8\n\x11GetPackageRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07package\x18\x02 \x01(\t\"M\n\x12GetPackageResponse\x12\x37\n\x06result\x18\x01 \x01(\x0b\x32\'.sylk.SylkPackage.v1.SylkPackageDisplay\"]\n\x14\x43reatePackageRequest\x12\x31\n\x07package\x18\x02 \x01(\x0b\x32 .sylk.SylkPackage.v1.SylkPackage\x12\x12\n\nproject_id\x18\x01 \x01(\t\"d\n\x15\x43reatePackageResponse\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x37\n\x06result\x18\x02 \x01(\x0b\x32\'.sylk.SylkPackage.v1.SylkPackageDisplay\"m\n\x14UpdatePackageRequest\x12\x12\n\nproject_id\x18\x02 \x01(\t\x12\x0f\n\x07package\x18\x01 \x01(\t\x12\x30\n\x06update\x18\x03 \x01(\x0b\x32 .sylk.SylkPackage.v1.SylkPackage\"v\n\x15UpdatePackageResponse\x12\x38\n\x07updated\x18\x03 \x01(\x0b\x32\'.sylk.SylkPackage.v1.SylkPackageDisplay\x12\x0f\n\x07package\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\";\n\x14\x44\x65letePackageRequest\x12\x12\n\nproject_id\x18\x02 \x01(\t\x12\x0f\n\x07package\x18\x01 \x01(\t\"<\n\x15\x44\x65letePackageResponse\x12\x0f\n\x07package\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"8\n\x11GetServiceRequest\x12\x0f\n\x07service\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"M\n\x12GetServiceResponse\x12\x37\n\x06result\x18\x01 \x01(\x0b\x32\'.sylk.SylkService.v1.SylkServiceDisplay\"]\n\x14\x43reateServiceRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x31\n\x07service\x18\x02 \x01(\x0b\x32 .sylk.SylkService.v1.SylkService\"d\n\x15\x43reateServiceResponse\x12\x37\n\x06result\x18\x02 \x01(\x0b\x32\'.sylk.SylkService.v1.SylkServiceDisplay\x12\x12\n\nproject_id\x18\x01 \x01(\t\"m\n\x14UpdateServiceRequest\x12\x0f\n\x07service\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x30\n\x06update\x18\x03 \x01(\x0b\x32 .sylk.SylkService.v1.SylkService\"v\n\x15UpdateServiceResponse\x12\x38\n\x07updated\x18\x03 \x01(\x0b\x32\'.sylk.SylkService.v1.SylkServiceDisplay\x12\x0f\n\x07service\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\";\n\x14\x44\x65leteServiceRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07service\x18\x02 \x01(\t\"<\n\x15\x44\x65leteServiceResponse\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07service\x18\x02 \x01(\t\")\n\x13ListServicesRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\")\n\x13ListPackagesRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\"8\n\x11GetMessageRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07message\x18\x02 \x01(\t\"M\n\x12GetMessageResponse\x12\x37\n\x06result\x18\x01 \x01(\x0b\x32\'.sylk.SylkMessage.v1.SylkMessageDisplay\"n\n\x14\x43reateMessageRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07package\x18\x02 \x01(\t\x12\x31\n\x07message\x18\x03 \x01(\x0b\x32 .sylk.SylkMessage.v1.SylkMessage\"u\n\x15\x43reateMessageResponse\x12\x37\n\x06result\x18\x03 \x01(\x0b\x32\'.sylk.SylkMessage.v1.SylkMessageDisplay\x12\x0f\n\x07message\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"m\n\x14UpdateMessageRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07message\x18\x02 \x01(\t\x12\x30\n\x06update\x18\x03 \x01(\x0b\x32 .sylk.SylkMessage.v1.SylkMessage\"v\n\x15UpdateMessageResponse\x12\x0f\n\x07message\x18\x02 \x01(\t\x12\x38\n\x07updated\x18\x03 \x01(\x0b\x32\'.sylk.SylkMessage.v1.SylkMessageDisplay\x12\x12\n\nproject_id\x18\x01 \x01(\t\";\n\x14\x44\x65leteMessageRequest\x12\x0f\n\x07message\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"<\n\x15\x44\x65leteMessageResponse\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07message\x18\x02 \x01(\t\"6\n\x10GetMethodRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0e\n\x06method\x18\x02 \x01(\t\"J\n\x11GetMethodResponse\x12\x35\n\x06result\x18\x01 \x01(\x0b\x32%.sylk.SylkMethod.v1.SylkMethodDisplay\"j\n\x13\x43reateMethodRequest\x12\x0f\n\x07service\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12.\n\x06method\x18\x03 \x01(\x0b\x32\x1e.sylk.SylkMethod.v1.SylkMethod\"r\n\x14\x43reateMethodResponse\x12\x35\n\x06result\x18\x03 \x01(\x0b\x32%.sylk.SylkMethod.v1.SylkMethodDisplay\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07service\x18\x02 \x01(\t\"i\n\x13UpdateMethodRequest\x12\x0e\n\x06method\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12.\n\x06update\x18\x03 \x01(\x0b\x32\x1e.sylk.SylkMethod.v1.SylkMethod\"r\n\x14UpdateMethodResponse\x12\x0e\n\x06method\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x36\n\x07updated\x18\x03 \x01(\x0b\x32%.sylk.SylkMethod.v1.SylkMethodDisplay\"9\n\x13\x44\x65leteMethodRequest\x12\x0e\n\x06method\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\":\n\x14\x44\x65leteMethodResponse\x12\x0e\n\x06method\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"4\n\x0fGetFieldRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\r\n\x05\x66ield\x18\x02 \x01(\t\"G\n\x10GetFieldResponse\x12\x33\n\x06result\x18\x01 \x01(\x0b\x32#.sylk.SylkField.v1.SylkFieldDisplay\"e\n\x12UpdateFieldRequest\x12\r\n\x05\x66ield\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12,\n\x06update\x18\x03 \x01(\x0b\x32\x1c.sylk.SylkField.v1.SylkField\"n\n\x13UpdateFieldResponse\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\r\n\x05\x66ield\x18\x02 \x01(\t\x12\x34\n\x07updated\x18\x03 \x01(\x0b\x32#.sylk.SylkField.v1.SylkFieldDisplay\"7\n\x12\x44\x65leteFieldRequest\x12\r\n\x05\x66ield\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"8\n\x13\x44\x65leteFieldResponse\x12\r\n\x05\x66ield\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"f\n\x12\x43reateFieldRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0f\n\x07message\x18\x02 \x01(\t\x12+\n\x05\x66ield\x18\x03 \x01(\x0b\x32\x1c.sylk.SylkField.v1.SylkField\"J\n\x13\x43reateFieldResponse\x12\x33\n\x06result\x18\x01 \x01(\x0b\x32#.sylk.SylkField.v1.SylkFieldDisplay\"2\n\x0eGetEnumRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x0c\n\x04\x65num\x18\x02 \x01(\t\"D\n\x0fGetEnumResponse\x12\x31\n\x06result\x18\x01 \x01(\x0b\x32!.sylk.SylkEnum.v1.SylkEnumDisplay\"b\n\x11\x43reateEnumRequest\x12\x0f\n\x07package\x18\x02 \x01(\t\x12(\n\x04\x65num\x18\x03 \x01(\x0b\x32\x1a.sylk.SylkEnum.v1.SylkEnum\x12\x12\n\nproject_id\x18\x01 \x01(\t\"[\n\x12\x43reateEnumResponse\x12\x31\n\x06result\x18\x02 \x01(\x0b\x32!.sylk.SylkEnum.v1.SylkEnumDisplay\x12\x12\n\nproject_id\x18\x01 \x01(\t\"a\n\x11UpdateEnumRequest\x12*\n\x06update\x18\x03 \x01(\x0b\x32\x1a.sylk.SylkEnum.v1.SylkEnum\x12\x0c\n\x04\x65num\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"j\n\x12UpdateEnumResponse\x12\x0c\n\x04\x65num\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x32\n\x07updated\x18\x03 \x01(\x0b\x32!.sylk.SylkEnum.v1.SylkEnumDisplay\"5\n\x11\x44\x65leteEnumRequest\x12\x0c\n\x04\x65num\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"6\n\x12\x44\x65leteEnumResponse\x12\x0c\n\x04\x65num\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"=\n\x13GetEnumValueRequest\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x12\n\nenum_value\x18\x02 \x01(\t\"S\n\x14GetEnumValueResponse\x12;\n\x06result\x18\x01 \x01(\x0b\x32+.sylk.SylkEnumValue.v1.SylkEnumValueDisplay\"t\n\x16\x43reateEnumValueRequest\x12\x0c\n\x04\x65num\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x38\n\nenum_value\x18\x03 \x01(\x0b\x32$.sylk.SylkEnumValue.v1.SylkEnumValue\"V\n\x17\x43reateEnumValueResponse\x12;\n\x06result\x18\x01 \x01(\x0b\x32+.sylk.SylkEnumValue.v1.SylkEnumValueDisplay\"v\n\x16UpdateEnumValueRequest\x12\x34\n\x06update\x18\x03 \x01(\x0b\x32$.sylk.SylkEnumValue.v1.SylkEnumValue\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x12\n\nenum_value\x18\x02 \x01(\t\"\x7f\n\x17UpdateEnumValueResponse\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12<\n\x07updated\x18\x03 \x01(\x0b\x32+.sylk.SylkEnumValue.v1.SylkEnumValueDisplay\x12\x12\n\nenum_value\x18\x02 \x01(\t\"@\n\x16\x44\x65leteEnumValueRequest\x12\x12\n\nenum_value\x18\x02 \x01(\t\x12\x12\n\nproject_id\x18\x01 \x01(\t\"A\n\x17\x44\x65leteEnumValueResponse\x12\x12\n\nproject_id\x18\x01 \x01(\t\x12\x12\n\nenum_value\x18\x02 \x01(\t\"a\n\x1eListOrganizationsResponseCache\x12?\n\rorganizations\x18\x01 \x03(\x0b\x32(.sylk.SylkApi.v1.GetOrganizationResponse\"%\n\x13ListProjectsRequest\x12\x0e\n\x06org_id\x18\x01 \x01(\t\"Y\n\x14\x43reateProjectRequest\x12\x31\n\x07project\x18\x02 \x01(\x0b\x32 .sylk.SylkProject.v1.SylkProject\x12\x0e\n\x06org_id\x18\x01 \x01(\t\"`\n\x15\x43reateProjectResponse\x12\x0e\n\x06org_id\x18\x02 \x01(\t\x12\x37\n\x06result\x18\x01 \x01(\x0b\x32\'.sylk.SylkProject.v1.SylkProjectDisplay\"R\n\x19ListProjectsResponseCache\x12\x35\n\x08projects\x18\x01 \x03(\x0b\x32#.sylk.SylkApi.v1.GetProjectResponse\"9\n\rCachedSession\x12(\n\x07session\x18\x01 \x01(\x0b\x32\x17.google.protobuf.Struct\"o\n\x18\x43reateAccessTokenRequest\x12\x13\n\x0b\x64\x65scription\x18\x03 \x01(\t\x12\x0e\n\x06org_id\x18\x01 \x01(\t\x12.\n\nexpires_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\"+\n\x19\x43reateAccessTokenResponse\x12\x0e\n\x06status\x18\x01 \x01(\t\")\n\x17ListAccessTokensRequest\x12\x0e\n\x06org_id\x18\x01 \x01(\t\"O\n\x16GetAccessTokenResponse\x12\x35\n\x06result\x18\x01 \x01(\x0b\x32%.sylk.SylkUser.v1.PersonalAccessToken\"&\n\x15GetAccessTokenRequest\x12\r\n\x05token\x18\x01 \x01(\t\"9\n\x18RevokeAccessTokenRequest\x12\r\n\x05token\x18\x01 \x01(\t\x12\x0e\n\x06org_id\x18\x02 \x01(\t\"+\n\x19RevokeAccessTokenResponse\x12\x0e\n\x06status\x18\x01 \x01(\tb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkApi.v1.SylkApi_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'Z?github.com/sylk-build/sylk-core/services/protos/sylk/SylkApi/v1'
   _globals['_REMOVEUSERRESPONSE']._serialized_start=499
   _globals['_REMOVEUSERRESPONSE']._serialized_end=535
   _globals['_REMOVEUSERREQUEST']._serialized_start=537
   _globals['_REMOVEUSERREQUEST']._serialized_end=612
   _globals['_UPDATEORGANIZATIONREQUEST']._serialized_start=614
   _globals['_UPDATEORGANIZATIONREQUEST']._serialized_end=717
   _globals['_GETORGANIZATIONRESPONSE']._serialized_start=719
```

## sylk/commons/protos/sylk/SylkClient/v1/SylkClient_pb2.py

```diff
@@ -9,21 +9,20 @@
 # @@protoc_insertion_point(imports)
 
 _sym_db = _symbol_database.Default()
 
 
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n#sylk/SylkClient/v1/SylkClient.proto\x12\x12sylk.SylkClient.v1\"X\n\nSylkClient\x12\x0f\n\x07out_dir\x18\x02 \x01(\t\x12\x39\n\x08language\x18\x01 \x01(\x0e\x32\'.sylk.SylkClient.v1.SylkClientLanguages*f\n\x13SylkClientLanguages\x12\x1f\n\x1b\x44\x45\x46\x41ULT_SYLKCLIENTLANGUAGES\x10\x00\x12\n\n\x06python\x10\x01\x12\n\n\x06nodejs\x10\x02\x12\x0e\n\ntypescript\x10\x03\x12\x06\n\x02go\x10\x04\x42\x44ZBgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkClient/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n#sylk/SylkClient/v1/SylkClient.proto\x12\x12sylk.SylkClient.v1\"X\n\nSylkClient\x12\x0f\n\x07out_dir\x18\x02 \x01(\t\x12\x39\n\x08language\x18\x01 \x01(\x0e\x32\'.sylk.SylkClient.v1.SylkClientLanguages*f\n\x13SylkClientLanguages\x12\x1f\n\x1b\x44\x45\x46\x41ULT_SYLKCLIENTLANGUAGES\x10\x00\x12\n\n\x06python\x10\x01\x12\n\n\x06nodejs\x10\x02\x12\x0e\n\ntypescript\x10\x03\x12\x06\n\x02go\x10\x04\x62\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkClient.v1.SylkClient_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZBgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkClient/v1'
   _globals['_SYLKCLIENTLANGUAGES']._serialized_start=149
   _globals['_SYLKCLIENTLANGUAGES']._serialized_end=251
   _globals['_SYLKCLIENT']._serialized_start=59
   _globals['_SYLKCLIENT']._serialized_end=147
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkCommons/v1/SylkCommons_pb2.py

```diff
@@ -9,25 +9,24 @@
 # @@protoc_insertion_point(imports)
 
 _sym_db = _symbol_database.Default()
 
 
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n%sylk/SylkCommons/v1/SylkCommons.proto\x12\x13sylk.SylkCommons.v1\"B\n\x0bSylkContext\x12\x33\n\x05\x66iles\x18\x01 \x03(\x0b\x32$.sylk.SylkCommons.v1.SylkFileContext\"f\n\x0fSylkFileContext\x12\x0c\n\x04\x66ile\x18\x01 \x01(\t\x12\x0c\n\x04\x63ode\x18\x03 \x01(\x0c\x12\x37\n\x07methods\x18\x02 \x03(\x0b\x32&.sylk.SylkCommons.v1.SylkMethodContext\"=\n\x11SylkMethodContext\x12\x0c\n\x04\x63ode\x18\x02 \x01(\t\x12\x0c\n\x04type\x18\x03 \x01(\t\x12\x0c\n\x04name\x18\x01 \x01(\t*\x8a\x01\n\x0eSylkExtensions\x12\x1a\n\x16\x44\x45\x46\x41ULT_SYLKEXTENSIONS\x10\x00\x12\x0f\n\x0b\x46ileOptions\x10\x01\x12\x12\n\x0eMessageOptions\x10\x02\x12\x10\n\x0c\x46ieldOptions\x10\x03\x12\x12\n\x0eServiceOptions\x10\x04\x12\x11\n\rMethodOptions\x10\x05\x42\x45ZCgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkCommons/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n%sylk/SylkCommons/v1/SylkCommons.proto\x12\x13sylk.SylkCommons.v1\"=\n\x11SylkMethodContext\x12\x0c\n\x04\x63ode\x18\x02 \x01(\t\x12\x0c\n\x04type\x18\x03 \x01(\t\x12\x0c\n\x04name\x18\x01 \x01(\t\"f\n\x0fSylkFileContext\x12\x0c\n\x04\x66ile\x18\x01 \x01(\t\x12\x0c\n\x04\x63ode\x18\x03 \x01(\x0c\x12\x37\n\x07methods\x18\x02 \x03(\x0b\x32&.sylk.SylkCommons.v1.SylkMethodContext\"B\n\x0bSylkContext\x12\x33\n\x05\x66iles\x18\x01 \x03(\x0b\x32$.sylk.SylkCommons.v1.SylkFileContext*\x8a\x01\n\x0eSylkExtensions\x12\x1a\n\x16\x44\x45\x46\x41ULT_SYLKEXTENSIONS\x10\x00\x12\x0f\n\x0b\x46ileOptions\x10\x01\x12\x12\n\x0eMessageOptions\x10\x02\x12\x10\n\x0c\x46ieldOptions\x10\x03\x12\x12\n\x0eServiceOptions\x10\x04\x12\x11\n\rMethodOptions\x10\x05\x62\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkCommons.v1.SylkCommons_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZCgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkCommons/v1'
   _globals['_SYLKEXTENSIONS']._serialized_start=298
   _globals['_SYLKEXTENSIONS']._serialized_end=436
-  _globals['_SYLKCONTEXT']._serialized_start=62
-  _globals['_SYLKCONTEXT']._serialized_end=128
-  _globals['_SYLKFILECONTEXT']._serialized_start=130
-  _globals['_SYLKFILECONTEXT']._serialized_end=232
-  _globals['_SYLKMETHODCONTEXT']._serialized_start=234
-  _globals['_SYLKMETHODCONTEXT']._serialized_end=295
+  _globals['_SYLKMETHODCONTEXT']._serialized_start=62
+  _globals['_SYLKMETHODCONTEXT']._serialized_end=123
+  _globals['_SYLKFILECONTEXT']._serialized_start=125
+  _globals['_SYLKFILECONTEXT']._serialized_end=227
+  _globals['_SYLKCONTEXT']._serialized_start=229
+  _globals['_SYLKCONTEXT']._serialized_end=295
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkConfigs/v1/SylkConfigs_pb2.py

```diff
@@ -9,23 +9,22 @@
 # @@protoc_insertion_point(imports)
 
 _sym_db = _symbol_database.Default()
 
 
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n%sylk/SylkConfigs/v1/SylkConfigs.proto\x12\x13sylk.SylkConfigs.v1\"\x92\x01\n\x13SylkTemplateConfigs\x12\x0f\n\x07include\x18\x03 \x03(\t\x12\x0f\n\x07\x65xclude\x18\x02 \x03(\t\x12\x0c\n\x04name\x18\x05 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x10\n\x08out_path\x18\x06 \x01(\t\x12\x14\n\x0cinclude_code\x18\x01 \x01(\x08\x12\x0e\n\x06\x61uthor\x18\x07 \x01(\t\"\xe1\x01\n\x12SylkProjectConfigs\x12\x13\n\x0b\x64\x65scription\x18\x03 \x01(\t\x12\x0c\n\x04host\x18\x01 \x01(\t\x12:\n\x08template\x18\x05 \x01(\x0b\x32(.sylk.SylkConfigs.v1.SylkTemplateConfigs\x12\x0c\n\x04port\x18\x02 \x01(\x05\x12\x17\n\x0f\x63urrent_version\x18\x04 \x01(\t\x12\x0f\n\x07plugins\x18\x06 \x03(\t\x12\x17\n\x0fproto_base_path\x18\x07 \x01(\t\x12\x1b\n\x13proto_compiled_path\x18\x08 \x01(\t\"\x8a\x01\n\x0eSylkCliConfigs\x12\x16\n\x0esylk_templates\x18\x06 \x03(\t\x12\x0c\n\x04port\x18\x02 \x01(\x05\x12\r\n\x05token\x18\x03 \x01(\t\x12\x11\n\tanalytics\x18\x04 \x01(\x08\x12\x11\n\tfirst_run\x18\x05 \x01(\x08\x12\x0c\n\x04host\x18\x01 \x01(\t\x12\x0f\n\x07plugins\x18\x07 \x03(\tBEZCgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkConfigs/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n%sylk/SylkConfigs/v1/SylkConfigs.proto\x12\x13sylk.SylkConfigs.v1\"\x92\x01\n\x13SylkTemplateConfigs\x12\x0f\n\x07include\x18\x03 \x03(\t\x12\x0f\n\x07\x65xclude\x18\x02 \x03(\t\x12\x0c\n\x04name\x18\x05 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x10\n\x08out_path\x18\x06 \x01(\t\x12\x14\n\x0cinclude_code\x18\x01 \x01(\x08\x12\x0e\n\x06\x61uthor\x18\x07 \x01(\t\"\xe1\x01\n\x12SylkProjectConfigs\x12\x13\n\x0b\x64\x65scription\x18\x03 \x01(\t\x12\x0c\n\x04host\x18\x01 \x01(\t\x12:\n\x08template\x18\x05 \x01(\x0b\x32(.sylk.SylkConfigs.v1.SylkTemplateConfigs\x12\x0c\n\x04port\x18\x02 \x01(\x05\x12\x17\n\x0f\x63urrent_version\x18\x04 \x01(\t\x12\x0f\n\x07plugins\x18\x06 \x03(\t\x12\x17\n\x0fproto_base_path\x18\x07 \x01(\t\x12\x1b\n\x13proto_compiled_path\x18\x08 \x01(\t\"\xfc\x01\n\x0eSylkCliConfigs\x12\x16\n\x0esylk_templates\x18\x06 \x03(\t\x12\x0c\n\x04port\x18\x02 \x01(\x05\x12\r\n\x05token\x18\x03 \x01(\t\x12\x11\n\tanalytics\x18\x04 \x01(\x08\x12\x11\n\tfirst_run\x18\x05 \x01(\x08\x12\x0c\n\x04host\x18\x01 \x01(\t\x12\x0f\n\x07plugins\x18\x07 \x03(\t\x12\x17\n\x0fproto_base_path\x18\x08 \x01(\t\x12\x1b\n\x13proto_compiled_path\x18\t \x01(\t\x12:\n\x08template\x18\n \x01(\x0b\x32(.sylk.SylkConfigs.v1.SylkTemplateConfigsb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkConfigs.v1.SylkConfigs_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZCgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkConfigs/v1'
   _globals['_SYLKTEMPLATECONFIGS']._serialized_start=63
   _globals['_SYLKTEMPLATECONFIGS']._serialized_end=209
   _globals['_SYLKPROJECTCONFIGS']._serialized_start=212
   _globals['_SYLKPROJECTCONFIGS']._serialized_end=437
   _globals['_SYLKCLICONFIGS']._serialized_start=440
-  _globals['_SYLKCLICONFIGS']._serialized_end=578
+  _globals['_SYLKCLICONFIGS']._serialized_end=692
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkEnum/v1/SylkEnum_pb2.py

```diff
@@ -11,21 +11,20 @@
 _sym_db = _symbol_database.Default()
 
 
 from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2
 from sylk.commons.protos.sylk.SylkEnumValue.v1 import SylkEnumValue_pb2 as sylk_dot_SylkEnumValue_dot_v1_dot_SylkEnumValue__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fsylk/SylkEnum/v1/SylkEnum.proto\x12\x10sylk.SylkEnum.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a)sylk/SylkEnumValue/v1/SylkEnumValue.proto\"\x9b\x01\n\x0fSylkEnumDisplay\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12(\n\x04\x65num\x18\x01 \x01(\x0b\x32\x1a.sylk.SylkEnum.v1.SylkEnum\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\"\x9f\x01\n\x08SylkEnum\x12\x0c\n\x04type\x18\x06 \x01(\t\x12\x0c\n\x04kind\x18\x07 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x34\n\x06values\x18\x05 \x03(\x0b\x32$.sylk.SylkEnumValue.v1.SylkEnumValue\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12\x11\n\tfull_name\x18\x03 \x01(\tBBZ@github.com/sylk-build/sylk-core/services/protos/sylk/SylkEnum/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fsylk/SylkEnum/v1/SylkEnum.proto\x12\x10sylk.SylkEnum.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a)sylk/SylkEnumValue/v1/SylkEnumValue.proto\"\x9f\x01\n\x08SylkEnum\x12\x0c\n\x04type\x18\x06 \x01(\t\x12\x0c\n\x04kind\x18\x07 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x34\n\x06values\x18\x05 \x03(\x0b\x32$.sylk.SylkEnumValue.v1.SylkEnumValue\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12\x11\n\tfull_name\x18\x03 \x01(\t\"\x9b\x01\n\x0fSylkEnumDisplay\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12(\n\x04\x65num\x18\x01 \x01(\x0b\x32\x1a.sylk.SylkEnum.v1.SylkEnum\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestampb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkEnum.v1.SylkEnum_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'Z@github.com/sylk-build/sylk-core/services/protos/sylk/SylkEnum/v1'
-  _globals['_SYLKENUMDISPLAY']._serialized_start=130
-  _globals['_SYLKENUMDISPLAY']._serialized_end=285
-  _globals['_SYLKENUM']._serialized_start=288
-  _globals['_SYLKENUM']._serialized_end=447
+  _globals['_SYLKENUM']._serialized_start=130
+  _globals['_SYLKENUM']._serialized_end=289
+  _globals['_SYLKENUMDISPLAY']._serialized_start=292
+  _globals['_SYLKENUMDISPLAY']._serialized_end=447
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkEnumValue/v1/SylkEnumValue_pb2.py

```diff
@@ -10,21 +10,20 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n)sylk/SylkEnumValue/v1/SylkEnumValue.proto\x12\x15sylk.SylkEnumValue.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\xb0\x01\n\x14SylkEnumValueDisplay\x12\x38\n\nenum_value\x18\x01 \x01(\x0b\x32$.sylk.SylkEnumValue.v1.SylkEnumValue\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\"\x8d\x01\n\rSylkEnumValue\x12\x0c\n\x04kind\x18\x08 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x06 \x01(\t\x12\r\n\x05index\x18\x04 \x01(\x05\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x0e\n\x06number\x18\x05 \x01(\x05\x12\x11\n\tfull_name\x18\x03 \x01(\t\x12\x0c\n\x04type\x18\x07 \x01(\tBGZEgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkEnumValue/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n)sylk/SylkEnumValue/v1/SylkEnumValue.proto\x12\x15sylk.SylkEnumValue.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\x8d\x01\n\rSylkEnumValue\x12\x0c\n\x04kind\x18\x08 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x06 \x01(\t\x12\r\n\x05index\x18\x04 \x01(\x05\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x0e\n\x06number\x18\x05 \x01(\x05\x12\x11\n\tfull_name\x18\x03 \x01(\t\x12\x0c\n\x04type\x18\x07 \x01(\t\"\xb0\x01\n\x14SylkEnumValueDisplay\x12\x38\n\nenum_value\x18\x01 \x01(\x0b\x32$.sylk.SylkEnumValue.v1.SylkEnumValue\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestampb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkEnumValue.v1.SylkEnumValue_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZEgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkEnumValue/v1'
-  _globals['_SYLKENUMVALUEDISPLAY']._serialized_start=102
-  _globals['_SYLKENUMVALUEDISPLAY']._serialized_end=278
-  _globals['_SYLKENUMVALUE']._serialized_start=281
-  _globals['_SYLKENUMVALUE']._serialized_end=422
+  _globals['_SYLKENUMVALUE']._serialized_start=102
+  _globals['_SYLKENUMVALUE']._serialized_end=243
+  _globals['_SYLKENUMVALUEDISPLAY']._serialized_start=246
+  _globals['_SYLKENUMVALUEDISPLAY']._serialized_end=422
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkField/v1/SylkField_pb2.py

```diff
@@ -11,31 +11,30 @@
 _sym_db = _symbol_database.Default()
 
 
 from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2
 from google.protobuf import struct_pb2 as google_dot_protobuf_dot_struct__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n!sylk/SylkField/v1/SylkField.proto\x12\x11sylk.SylkField.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1cgoogle/protobuf/struct.proto\"\x9f\x01\n\x10SylkFieldDisplay\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12+\n\x05\x66ield\x18\x01 \x01(\x0b\x32\x1c.sylk.SylkField.v1.SylkField\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\"\xbf\x04\n\tSylkField\x12\x0c\n\x04type\x18\x0b \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12\x37\n\x0coneof_fields\x18\x0f \x03(\x0b\x32!.sylk.SylkField.v1.SylkOneOfField\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x11\n\tenum_type\x18\n \x01(\t\x12\x35\n\nfield_type\x18\x05 \x01(\x0e\x32!.sylk.SylkField.v1.SylkFieldTypes\x12\x14\n\x0cmessage_type\x18\t \x01(\t\x12\x0c\n\x04kind\x18\x0c \x01(\t\x12\x11\n\tfull_name\x18\x03 \x01(\t\x12@\n\nextensions\x18\x0e \x03(\x0b\x32,.sylk.SylkField.v1.SylkField.ExtensionsEntry\x12\r\n\x05index\x18\r \x01(\x05\x12\x31\n\x05label\x18\x06 \x01(\x0e\x32\".sylk.SylkField.v1.SylkFieldLabels\x12\x33\n\x08key_type\x18\x07 \x01(\x0e\x32!.sylk.SylkField.v1.SylkFieldTypes\x12\x35\n\nvalue_type\x18\x08 \x01(\x0e\x32!.sylk.SylkField.v1.SylkFieldTypes\x1aJ\n\x0f\x45xtensionsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12&\n\x05value\x18\x02 \x01(\x0b\x32\x17.google.protobuf.Struct:\x02\x38\x01\"\xe6\x01\n\x0eSylkOneOfField\x12\x11\n\tenum_type\x18\x08 \x01(\t\x12\x11\n\tfull_name\x18\x03 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12\x14\n\x0cmessage_type\x18\x07 \x01(\t\x12\x35\n\nfield_type\x18\x05 \x01(\x0e\x32!.sylk.SylkField.v1.SylkFieldTypes\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x31\n\x05label\x18\x06 \x01(\x0e\x32\".sylk.SylkField.v1.SylkFieldLabels*\xfa\x02\n\x0eSylkFieldTypes\x12\x1a\n\x16\x44\x45\x46\x41ULT_SYLKFIELDTYPES\x10\x00\x12\x0f\n\x0bTYPE_DOUBLE\x10\x01\x12\x0e\n\nTYPE_FLOAT\x10\x02\x12\x0e\n\nTYPE_INT64\x10\x03\x12\x0f\n\x0bTYPE_UINT64\x10\x04\x12\x0e\n\nTYPE_INT32\x10\x05\x12\x10\n\x0cTYPE_FIXED64\x10\x06\x12\x10\n\x0cTYPE_FIXED32\x10\x07\x12\r\n\tTYPE_BOOL\x10\x08\x12\x0f\n\x0bTYPE_STRING\x10\t\x12\x0e\n\nTYPE_GROUP\x10\n\x12\x10\n\x0cTYPE_MESSAGE\x10\x0b\x12\x0e\n\nTYPE_BYTES\x10\x0c\x12\x0f\n\x0bTYPE_UINT32\x10\r\x12\r\n\tTYPE_ENUM\x10\x0e\x12\x11\n\rTYPE_SFIXED32\x10\x0f\x12\x11\n\rTYPE_SFIXED64\x10\x10\x12\x0f\n\x0bTYPE_SINT32\x10\x11\x12\x0f\n\x0bTYPE_SINT64\x10\x12\x12\x0c\n\x08TYPE_MAP\x10\x13\x12\x0e\n\nTYPE_ONEOF\x10\x14*j\n\x0fSylkFieldLabels\x12\x1b\n\x17\x44\x45\x46\x41ULT_SYLKFIELDLABELS\x10\x00\x12\x12\n\x0eLABEL_OPTIONAL\x10\x01\x12\x12\n\x0eLABEL_REQUIRED\x10\x02\x12\x12\n\x0eLABEL_REPEATED\x10\x03\x42\x43ZAgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkField/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n!sylk/SylkField/v1/SylkField.proto\x12\x11sylk.SylkField.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1cgoogle/protobuf/struct.proto\"\x83\x02\n\x0eSylkOneOfField\x12\x11\n\tenum_type\x18\x08 \x01(\t\x12\x11\n\tfull_name\x18\x03 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12\x14\n\x0cmessage_type\x18\x07 \x01(\t\x12\x35\n\nfield_type\x18\x05 \x01(\x0e\x32!.sylk.SylkField.v1.SylkFieldTypes\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x31\n\x05label\x18\x06 \x01(\x0e\x32\".sylk.SylkField.v1.SylkFieldLabels\x12\r\n\x05index\x18\t \x01(\x05\x12\x0c\n\x04kind\x18\n \x01(\t\"\xbf\x04\n\tSylkField\x12\x0c\n\x04type\x18\x0b \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12\x37\n\x0coneof_fields\x18\x0f \x03(\x0b\x32!.sylk.SylkField.v1.SylkOneOfField\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x11\n\tenum_type\x18\n \x01(\t\x12\x35\n\nfield_type\x18\x05 \x01(\x0e\x32!.sylk.SylkField.v1.SylkFieldTypes\x12\x14\n\x0cmessage_type\x18\t \x01(\t\x12\x0c\n\x04kind\x18\x0c \x01(\t\x12\x11\n\tfull_name\x18\x03 \x01(\t\x12@\n\nextensions\x18\x0e \x03(\x0b\x32,.sylk.SylkField.v1.SylkField.ExtensionsEntry\x12\r\n\x05index\x18\r \x01(\x05\x12\x31\n\x05label\x18\x06 \x01(\x0e\x32\".sylk.SylkField.v1.SylkFieldLabels\x12\x33\n\x08key_type\x18\x07 \x01(\x0e\x32!.sylk.SylkField.v1.SylkFieldTypes\x12\x35\n\nvalue_type\x18\x08 \x01(\x0e\x32!.sylk.SylkField.v1.SylkFieldTypes\x1aJ\n\x0f\x45xtensionsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12&\n\x05value\x18\x02 \x01(\x0b\x32\x17.google.protobuf.Struct:\x02\x38\x01\"\xab\x01\n\x10SylkFieldDisplay\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12+\n\x05\x66ield\x18\x01 \x01(\x0b\x32\x1c.sylk.SylkField.v1.SylkField\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\n\n\x02id\x18\x04 \x01(\t*\xfa\x02\n\x0eSylkFieldTypes\x12\x1a\n\x16\x44\x45\x46\x41ULT_SYLKFIELDTYPES\x10\x00\x12\x0f\n\x0bTYPE_DOUBLE\x10\x01\x12\x0e\n\nTYPE_FLOAT\x10\x02\x12\x0e\n\nTYPE_INT64\x10\x03\x12\x0f\n\x0bTYPE_UINT64\x10\x04\x12\x0e\n\nTYPE_INT32\x10\x05\x12\x10\n\x0cTYPE_FIXED64\x10\x06\x12\x10\n\x0cTYPE_FIXED32\x10\x07\x12\r\n\tTYPE_BOOL\x10\x08\x12\x0f\n\x0bTYPE_STRING\x10\t\x12\x0e\n\nTYPE_GROUP\x10\n\x12\x10\n\x0cTYPE_MESSAGE\x10\x0b\x12\x0e\n\nTYPE_BYTES\x10\x0c\x12\x0f\n\x0bTYPE_UINT32\x10\r\x12\r\n\tTYPE_ENUM\x10\x0e\x12\x11\n\rTYPE_SFIXED32\x10\x0f\x12\x11\n\rTYPE_SFIXED64\x10\x10\x12\x0f\n\x0bTYPE_SINT32\x10\x11\x12\x0f\n\x0bTYPE_SINT64\x10\x12\x12\x0c\n\x08TYPE_MAP\x10\x13\x12\x0e\n\nTYPE_ONEOF\x10\x14*j\n\x0fSylkFieldLabels\x12\x1b\n\x17\x44\x45\x46\x41ULT_SYLKFIELDLABELS\x10\x00\x12\x12\n\x0eLABEL_OPTIONAL\x10\x01\x12\x12\n\x0eLABEL_REQUIRED\x10\x02\x12\x12\n\x0eLABEL_REPEATED\x10\x03\x62\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkField.v1.SylkField_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZAgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkField/v1'
   _SYLKFIELD_EXTENSIONSENTRY._options = None
   _SYLKFIELD_EXTENSIONSENTRY._serialized_options = b'8\001'
-  _globals['_SYLKFIELDTYPES']._serialized_start=1093
-  _globals['_SYLKFIELDTYPES']._serialized_end=1471
-  _globals['_SYLKFIELDLABELS']._serialized_start=1473
-  _globals['_SYLKFIELDLABELS']._serialized_end=1579
-  _globals['_SYLKFIELDDISPLAY']._serialized_start=120
-  _globals['_SYLKFIELDDISPLAY']._serialized_end=279
-  _globals['_SYLKFIELD']._serialized_start=282
-  _globals['_SYLKFIELD']._serialized_end=857
-  _globals['_SYLKFIELD_EXTENSIONSENTRY']._serialized_start=783
-  _globals['_SYLKFIELD_EXTENSIONSENTRY']._serialized_end=857
-  _globals['_SYLKONEOFFIELD']._serialized_start=860
-  _globals['_SYLKONEOFFIELD']._serialized_end=1090
+  _globals['_SYLKFIELDTYPES']._serialized_start=1134
+  _globals['_SYLKFIELDTYPES']._serialized_end=1512
+  _globals['_SYLKFIELDLABELS']._serialized_start=1514
+  _globals['_SYLKFIELDLABELS']._serialized_end=1620
+  _globals['_SYLKONEOFFIELD']._serialized_start=120
+  _globals['_SYLKONEOFFIELD']._serialized_end=379
+  _globals['_SYLKFIELD']._serialized_start=382
+  _globals['_SYLKFIELD']._serialized_end=957
+  _globals['_SYLKFIELD_EXTENSIONSENTRY']._serialized_start=883
+  _globals['_SYLKFIELD_EXTENSIONSENTRY']._serialized_end=957
+  _globals['_SYLKFIELDDISPLAY']._serialized_start=960
+  _globals['_SYLKFIELDDISPLAY']._serialized_end=1131
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkMessage/v1/SylkMessage_pb2.py

```diff
@@ -13,25 +13,24 @@
 
 from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2
 from sylk.commons.protos.sylk.SylkCommons.v1 import SylkCommons_pb2 as sylk_dot_SylkCommons_dot_v1_dot_SylkCommons__pb2
 from google.protobuf import struct_pb2 as google_dot_protobuf_dot_struct__pb2
 from sylk.commons.protos.sylk.SylkField.v1 import SylkField_pb2 as sylk_dot_SylkField_dot_v1_dot_SylkField__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n%sylk/SylkMessage/v1/SylkMessage.proto\x12\x13sylk.SylkMessage.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a%sylk/SylkCommons/v1/SylkCommons.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a!sylk/SylkField/v1/SylkField.proto\"\xa7\x01\n\x12SylkMessageDisplay\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x31\n\x07message\x18\x01 \x01(\x0b\x32 .sylk.SylkMessage.v1.SylkMessage\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\"\xe9\x02\n\x0bSylkMessage\x12;\n\x0e\x65xtension_type\x18\t \x01(\x0e\x32#.sylk.SylkCommons.v1.SylkExtensions\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12\x44\n\nextensions\x18\x08 \x03(\x0b\x32\x30.sylk.SylkMessage.v1.SylkMessage.ExtensionsEntry\x12\x11\n\tfull_name\x18\x03 \x01(\t\x12\x0c\n\x04type\x18\x06 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x0c\n\x04kind\x18\x07 \x01(\t\x12,\n\x06\x66ields\x18\x05 \x03(\x0b\x32\x1c.sylk.SylkField.v1.SylkField\x1aJ\n\x0f\x45xtensionsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12&\n\x05value\x18\x02 \x01(\x0b\x32\x17.google.protobuf.Struct:\x02\x38\x01\x42\x45ZCgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkMessage/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n%sylk/SylkMessage/v1/SylkMessage.proto\x12\x13sylk.SylkMessage.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a%sylk/SylkCommons/v1/SylkCommons.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a!sylk/SylkField/v1/SylkField.proto\"\xe9\x02\n\x0bSylkMessage\x12;\n\x0e\x65xtension_type\x18\t \x01(\x0e\x32#.sylk.SylkCommons.v1.SylkExtensions\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12\x44\n\nextensions\x18\x08 \x03(\x0b\x32\x30.sylk.SylkMessage.v1.SylkMessage.ExtensionsEntry\x12\x11\n\tfull_name\x18\x03 \x01(\t\x12\x0c\n\x04type\x18\x06 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x0c\n\x04kind\x18\x07 \x01(\t\x12,\n\x06\x66ields\x18\x05 \x03(\x0b\x32\x1c.sylk.SylkField.v1.SylkField\x1aJ\n\x0f\x45xtensionsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12&\n\x05value\x18\x02 \x01(\x0b\x32\x17.google.protobuf.Struct:\x02\x38\x01\"\xa7\x01\n\x12SylkMessageDisplay\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x31\n\x07message\x18\x01 \x01(\x0b\x32 .sylk.SylkMessage.v1.SylkMessage\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestampb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkMessage.v1.SylkMessage_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZCgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkMessage/v1'
   _SYLKMESSAGE_EXTENSIONSENTRY._options = None
   _SYLKMESSAGE_EXTENSIONSENTRY._serialized_options = b'8\001'
-  _globals['_SYLKMESSAGEDISPLAY']._serialized_start=200
-  _globals['_SYLKMESSAGEDISPLAY']._serialized_end=367
-  _globals['_SYLKMESSAGE']._serialized_start=370
-  _globals['_SYLKMESSAGE']._serialized_end=731
-  _globals['_SYLKMESSAGE_EXTENSIONSENTRY']._serialized_start=657
-  _globals['_SYLKMESSAGE_EXTENSIONSENTRY']._serialized_end=731
+  _globals['_SYLKMESSAGE']._serialized_start=200
+  _globals['_SYLKMESSAGE']._serialized_end=561
+  _globals['_SYLKMESSAGE_EXTENSIONSENTRY']._serialized_start=487
+  _globals['_SYLKMESSAGE_EXTENSIONSENTRY']._serialized_end=561
+  _globals['_SYLKMESSAGEDISPLAY']._serialized_start=564
+  _globals['_SYLKMESSAGEDISPLAY']._serialized_end=731
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkMethod/v1/SylkMethod_pb2.py

```diff
@@ -11,25 +11,24 @@
 _sym_db = _symbol_database.Default()
 
 
 from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2
 from google.protobuf import struct_pb2 as google_dot_protobuf_dot_struct__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n#sylk/SylkMethod/v1/SylkMethod.proto\x12\x12sylk.SylkMethod.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1cgoogle/protobuf/struct.proto\"\xa3\x01\n\x11SylkMethodDisplay\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12.\n\x06method\x18\x01 \x01(\x0b\x32\x1e.sylk.SylkMethod.v1.SylkMethod\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\"\xd8\x02\n\nSylkMethod\x12\x18\n\x10\x63lient_streaming\x18\x07 \x01(\x08\x12\x11\n\tfull_name\x18\x03 \x01(\t\x12\x0c\n\x04type\x18\t \x01(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x18\n\x10server_streaming\x18\x08 \x01(\x08\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x0c\n\x04kind\x18\n \x01(\t\x12\x42\n\nextensions\x18\x0b \x03(\x0b\x32..sylk.SylkMethod.v1.SylkMethod.ExtensionsEntry\x12\x12\n\ninput_type\x18\x05 \x01(\t\x12\x13\n\x0boutput_type\x18\x06 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x1aJ\n\x0f\x45xtensionsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12&\n\x05value\x18\x02 \x01(\x0b\x32\x17.google.protobuf.Struct:\x02\x38\x01\x42\x44ZBgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkMethod/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n#sylk/SylkMethod/v1/SylkMethod.proto\x12\x12sylk.SylkMethod.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1cgoogle/protobuf/struct.proto\"\xd8\x02\n\nSylkMethod\x12\x18\n\x10\x63lient_streaming\x18\x07 \x01(\x08\x12\x11\n\tfull_name\x18\x03 \x01(\t\x12\x0c\n\x04type\x18\t \x01(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x18\n\x10server_streaming\x18\x08 \x01(\x08\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x0c\n\x04kind\x18\n \x01(\t\x12\x42\n\nextensions\x18\x0b \x03(\x0b\x32..sylk.SylkMethod.v1.SylkMethod.ExtensionsEntry\x12\x12\n\ninput_type\x18\x05 \x01(\t\x12\x13\n\x0boutput_type\x18\x06 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x1aJ\n\x0f\x45xtensionsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12&\n\x05value\x18\x02 \x01(\x0b\x32\x17.google.protobuf.Struct:\x02\x38\x01\"\xaf\x01\n\x11SylkMethodDisplay\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12.\n\x06method\x18\x01 \x01(\x0b\x32\x1e.sylk.SylkMethod.v1.SylkMethod\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\n\n\x02id\x18\x04 \x01(\tb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkMethod.v1.SylkMethod_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZBgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkMethod/v1'
   _SYLKMETHOD_EXTENSIONSENTRY._options = None
   _SYLKMETHOD_EXTENSIONSENTRY._serialized_options = b'8\001'
-  _globals['_SYLKMETHODDISPLAY']._serialized_start=123
-  _globals['_SYLKMETHODDISPLAY']._serialized_end=286
-  _globals['_SYLKMETHOD']._serialized_start=289
-  _globals['_SYLKMETHOD']._serialized_end=633
-  _globals['_SYLKMETHOD_EXTENSIONSENTRY']._serialized_start=559
-  _globals['_SYLKMETHOD_EXTENSIONSENTRY']._serialized_end=633
+  _globals['_SYLKMETHOD']._serialized_start=123
+  _globals['_SYLKMETHOD']._serialized_end=467
+  _globals['_SYLKMETHOD_EXTENSIONSENTRY']._serialized_start=393
+  _globals['_SYLKMETHOD_EXTENSIONSENTRY']._serialized_end=467
+  _globals['_SYLKMETHODDISPLAY']._serialized_start=470
+  _globals['_SYLKMETHODDISPLAY']._serialized_end=645
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkOrganization/v1/SylkOrganization_pb2.py

```diff
@@ -11,21 +11,20 @@
 _sym_db = _symbol_database.Default()
 
 
 from sylk.commons.protos.sylk.SylkProject.v1 import SylkProject_pb2 as sylk_dot_SylkProject_dot_v1_dot_SylkProject__pb2
 from sylk.commons.protos.sylk.SylkUser.v1 import SylkUser_pb2 as sylk_dot_SylkUser_dot_v1_dot_SylkUser__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n/sylk/SylkOrganization/v1/SylkOrganization.proto\x12\x18sylk.SylkOrganization.v1\x1a%sylk/SylkProject/v1/SylkProject.proto\x1a\x1fsylk/SylkUser/v1/SylkUser.proto\"\xc8\x01\n\x17SylkOrganizationDisplay\x12@\n\x0corganization\x18\x01 \x01(\x0b\x32*.sylk.SylkOrganization.v1.SylkOrganization\x12\x39\n\x08projects\x18\x03 \x03(\x0b\x32\'.sylk.SylkProject.v1.SylkProjectDisplay\x12\x30\n\x05users\x18\x02 \x03(\x0b\x32!.sylk.SylkUser.v1.SylkUserDisplay\"N\n\x10SylkOrganization\x12\r\n\x05orgId\x18\x01 \x01(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\r\n\x05owner\x18\x04 \x01(\t\x12\x0e\n\x06\x64omain\x18\x03 \x01(\tBJZHgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkOrganization/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n/sylk/SylkOrganization/v1/SylkOrganization.proto\x12\x18sylk.SylkOrganization.v1\x1a%sylk/SylkProject/v1/SylkProject.proto\x1a\x1fsylk/SylkUser/v1/SylkUser.proto\"N\n\x10SylkOrganization\x12\r\n\x05orgId\x18\x01 \x01(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\r\n\x05owner\x18\x04 \x01(\t\x12\x0e\n\x06\x64omain\x18\x03 \x01(\t\"\xc8\x01\n\x17SylkOrganizationDisplay\x12@\n\x0corganization\x18\x01 \x01(\x0b\x32*.sylk.SylkOrganization.v1.SylkOrganization\x12\x39\n\x08projects\x18\x03 \x03(\x0b\x32\'.sylk.SylkProject.v1.SylkProjectDisplay\x12\x30\n\x05users\x18\x02 \x03(\x0b\x32!.sylk.SylkUser.v1.SylkUserDisplayb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkOrganization.v1.SylkOrganization_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZHgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkOrganization/v1'
-  _globals['_SYLKORGANIZATIONDISPLAY']._serialized_start=150
-  _globals['_SYLKORGANIZATIONDISPLAY']._serialized_end=350
-  _globals['_SYLKORGANIZATION']._serialized_start=352
-  _globals['_SYLKORGANIZATION']._serialized_end=430
+  _globals['_SYLKORGANIZATION']._serialized_start=149
+  _globals['_SYLKORGANIZATION']._serialized_end=227
+  _globals['_SYLKORGANIZATIONDISPLAY']._serialized_start=230
+  _globals['_SYLKORGANIZATIONDISPLAY']._serialized_end=430
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkPackage/v1/SylkPackage_pb2.py

```diff
@@ -13,25 +13,24 @@
 
 from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2
 from sylk.commons.protos.sylk.SylkMessage.v1 import SylkMessage_pb2 as sylk_dot_SylkMessage_dot_v1_dot_SylkMessage__pb2
 from google.protobuf import struct_pb2 as google_dot_protobuf_dot_struct__pb2
 from sylk.commons.protos.sylk.SylkEnum.v1 import SylkEnum_pb2 as sylk_dot_SylkEnum_dot_v1_dot_SylkEnum__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n%sylk/SylkPackage/v1/SylkPackage.proto\x12\x13sylk.SylkPackage.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a%sylk/SylkMessage/v1/SylkMessage.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fsylk/SylkEnum/v1/SylkEnum.proto\"\xa7\x01\n\x12SylkPackageDisplay\x12\x31\n\x07package\x18\x01 \x01(\x0b\x32 .sylk.SylkPackage.v1.SylkPackage\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\"\xe3\x02\n\x0bSylkPackage\x12\x32\n\x08messages\x18\x04 \x03(\x0b\x32 .sylk.SylkMessage.v1.SylkMessage\x12\x44\n\nextensions\x18\t \x03(\x0b\x32\x30.sylk.SylkPackage.v1.SylkPackage.ExtensionsEntry\x12\x0c\n\x04type\x18\x07 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x06 \x01(\t\x12)\n\x05\x65nums\x18\x05 \x03(\x0b\x32\x1a.sylk.SylkEnum.v1.SylkEnum\x12\x0f\n\x07package\x18\x03 \x01(\t\x12\x14\n\x0c\x64\x65pendencies\x18\x08 \x03(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x1aJ\n\x0f\x45xtensionsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12&\n\x05value\x18\x02 \x01(\x0b\x32\x17.google.protobuf.Struct:\x02\x38\x01\x42\x45ZCgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkPackage/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n%sylk/SylkPackage/v1/SylkPackage.proto\x12\x13sylk.SylkPackage.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a%sylk/SylkMessage/v1/SylkMessage.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fsylk/SylkEnum/v1/SylkEnum.proto\"\xe3\x02\n\x0bSylkPackage\x12\x32\n\x08messages\x18\x04 \x03(\x0b\x32 .sylk.SylkMessage.v1.SylkMessage\x12\x44\n\nextensions\x18\t \x03(\x0b\x32\x30.sylk.SylkPackage.v1.SylkPackage.ExtensionsEntry\x12\x0c\n\x04type\x18\x07 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x06 \x01(\t\x12)\n\x05\x65nums\x18\x05 \x03(\x0b\x32\x1a.sylk.SylkEnum.v1.SylkEnum\x12\x0f\n\x07package\x18\x03 \x01(\t\x12\x14\n\x0c\x64\x65pendencies\x18\x08 \x03(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x1aJ\n\x0f\x45xtensionsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12&\n\x05value\x18\x02 \x01(\x0b\x32\x17.google.protobuf.Struct:\x02\x38\x01\"\xa7\x01\n\x12SylkPackageDisplay\x12\x31\n\x07package\x18\x01 \x01(\x0b\x32 .sylk.SylkPackage.v1.SylkPackage\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestampb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkPackage.v1.SylkPackage_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZCgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkPackage/v1'
   _SYLKPACKAGE_EXTENSIONSENTRY._options = None
   _SYLKPACKAGE_EXTENSIONSENTRY._serialized_options = b'8\001'
-  _globals['_SYLKPACKAGEDISPLAY']._serialized_start=198
-  _globals['_SYLKPACKAGEDISPLAY']._serialized_end=365
-  _globals['_SYLKPACKAGE']._serialized_start=368
-  _globals['_SYLKPACKAGE']._serialized_end=723
-  _globals['_SYLKPACKAGE_EXTENSIONSENTRY']._serialized_start=649
-  _globals['_SYLKPACKAGE_EXTENSIONSENTRY']._serialized_end=723
+  _globals['_SYLKPACKAGE']._serialized_start=198
+  _globals['_SYLKPACKAGE']._serialized_end=553
+  _globals['_SYLKPACKAGE_EXTENSIONSENTRY']._serialized_start=479
+  _globals['_SYLKPACKAGE_EXTENSIONSENTRY']._serialized_end=553
+  _globals['_SYLKPACKAGEDISPLAY']._serialized_start=556
+  _globals['_SYLKPACKAGEDISPLAY']._serialized_end=723
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkProject/v1/SylkProject_pb2.py

```diff
@@ -14,25 +14,24 @@
 from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2
 from sylk.commons.protos.sylk.SylkUser.v1 import SylkUser_pb2 as sylk_dot_SylkUser_dot_v1_dot_SylkUser__pb2
 from sylk.commons.protos.sylk.SylkClient.v1 import SylkClient_pb2 as sylk_dot_SylkClient_dot_v1_dot_SylkClient__pb2
 from sylk.commons.protos.sylk.SylkServer.v1 import SylkServer_pb2 as sylk_dot_SylkServer_dot_v1_dot_SylkServer__pb2
 from google.protobuf import any_pb2 as google_dot_protobuf_dot_any__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n%sylk/SylkProject/v1/SylkProject.proto\x12\x13sylk.SylkProject.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1fsylk/SylkUser/v1/SylkUser.proto\x1a#sylk/SylkClient/v1/SylkClient.proto\x1a#sylk/SylkServer/v1/SylkServer.proto\x1a\x19google/protobuf/any.proto\"\xa1\x03\n\x12SylkProjectDisplay\x12\r\n\x05owner\x18\x04 \x01(\t\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x12\n\nnumMethods\x18\x06 \x01(\x05\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x45\n\x07members\x18\x05 \x03(\x0b\x32\x34.sylk.SylkProject.v1.SylkProjectDisplay.MembersEntry\x12\x13\n\x0bnumServices\x18\x07 \x01(\x05\x12\x13\n\x0bnumMessages\x18\t \x01(\x05\x12\x13\n\x0bnumPackages\x18\x08 \x01(\x05\x12\x31\n\x07project\x18\x01 \x01(\x0b\x32 .sylk.SylkProject.v1.SylkProject\x1aO\n\x0cMembersEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12.\n\x05value\x18\x02 \x01(\x0e\x32\x1f.sylk.SylkUser.v1.SylkUserRoles:\x02\x38\x01\"\x88\x02\n\x0bSylkProject\x12\x13\n\x0b\x64\x65scription\x18\x08 \x01(\t\x12\x14\n\x0cjava_package\x18\x06 \x01(\t\x12\x12\n\ngo_package\x18\x05 \x01(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12/\n\x07\x63lients\x18\x04 \x03(\x0b\x32\x1e.sylk.SylkClient.v1.SylkClient\x12.\n\x06server\x18\x07 \x01(\x0b\x32\x1e.sylk.SylkServer.v1.SylkServer\x12\x14\n\x0cpackage_name\x18\x03 \x01(\t\x12(\n\nextensions\x18\t \x03(\x0b\x32\x14.google.protobuf.AnyBEZCgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkProject/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n%sylk/SylkProject/v1/SylkProject.proto\x12\x13sylk.SylkProject.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1fsylk/SylkUser/v1/SylkUser.proto\x1a#sylk/SylkClient/v1/SylkClient.proto\x1a#sylk/SylkServer/v1/SylkServer.proto\x1a\x19google/protobuf/any.proto\"\x88\x02\n\x0bSylkProject\x12\x13\n\x0b\x64\x65scription\x18\x08 \x01(\t\x12\x14\n\x0cjava_package\x18\x06 \x01(\t\x12\x12\n\ngo_package\x18\x05 \x01(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12/\n\x07\x63lients\x18\x04 \x03(\x0b\x32\x1e.sylk.SylkClient.v1.SylkClient\x12.\n\x06server\x18\x07 \x01(\x0b\x32\x1e.sylk.SylkServer.v1.SylkServer\x12\x14\n\x0cpackage_name\x18\x03 \x01(\t\x12(\n\nextensions\x18\t \x03(\x0b\x32\x14.google.protobuf.Any\"\xa1\x03\n\x12SylkProjectDisplay\x12\r\n\x05owner\x18\x04 \x01(\t\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x12\n\nnumMethods\x18\x06 \x01(\x05\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x45\n\x07members\x18\x05 \x03(\x0b\x32\x34.sylk.SylkProject.v1.SylkProjectDisplay.MembersEntry\x12\x13\n\x0bnumServices\x18\x07 \x01(\x05\x12\x13\n\x0bnumMessages\x18\t \x01(\x05\x12\x13\n\x0bnumPackages\x18\x08 \x01(\x05\x12\x31\n\x07project\x18\x01 \x01(\x0b\x32 .sylk.SylkProject.v1.SylkProject\x1aO\n\x0cMembersEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12.\n\x05value\x18\x02 \x01(\x0e\x32\x1f.sylk.SylkUser.v1.SylkUserRoles:\x02\x38\x01\x62\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkProject.v1.SylkProject_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZCgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkProject/v1'
   _SYLKPROJECTDISPLAY_MEMBERSENTRY._options = None
   _SYLKPROJECTDISPLAY_MEMBERSENTRY._serialized_options = b'8\001'
-  _globals['_SYLKPROJECTDISPLAY']._serialized_start=230
-  _globals['_SYLKPROJECTDISPLAY']._serialized_end=647
-  _globals['_SYLKPROJECTDISPLAY_MEMBERSENTRY']._serialized_start=568
-  _globals['_SYLKPROJECTDISPLAY_MEMBERSENTRY']._serialized_end=647
-  _globals['_SYLKPROJECT']._serialized_start=650
-  _globals['_SYLKPROJECT']._serialized_end=914
+  _globals['_SYLKPROJECT']._serialized_start=230
+  _globals['_SYLKPROJECT']._serialized_end=494
+  _globals['_SYLKPROJECTDISPLAY']._serialized_start=497
+  _globals['_SYLKPROJECTDISPLAY']._serialized_end=914
+  _globals['_SYLKPROJECTDISPLAY_MEMBERSENTRY']._serialized_start=835
+  _globals['_SYLKPROJECTDISPLAY_MEMBERSENTRY']._serialized_end=914
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkServer/v1/SylkServer_pb2.py

```diff
@@ -9,21 +9,20 @@
 # @@protoc_insertion_point(imports)
 
 _sym_db = _symbol_database.Default()
 
 
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n#sylk/SylkServer/v1/SylkServer.proto\x12\x12sylk.SylkServer.v1\"G\n\nSylkServer\x12\x39\n\x08language\x18\x01 \x01(\x0e\x32\'.sylk.SylkServer.v1.SylkServerLanguages*f\n\x13SylkServerLanguages\x12\x1f\n\x1b\x44\x45\x46\x41ULT_SYLKSERVERLANGUAGES\x10\x00\x12\n\n\x06python\x10\x01\x12\n\n\x06nodejs\x10\x02\x12\x0e\n\ntypescript\x10\x03\x12\x06\n\x02go\x10\x04\x42\x44ZBgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkServer/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n#sylk/SylkServer/v1/SylkServer.proto\x12\x12sylk.SylkServer.v1\"G\n\nSylkServer\x12\x39\n\x08language\x18\x01 \x01(\x0e\x32\'.sylk.SylkServer.v1.SylkServerLanguages*f\n\x13SylkServerLanguages\x12\x1f\n\x1b\x44\x45\x46\x41ULT_SYLKSERVERLANGUAGES\x10\x00\x12\n\n\x06python\x10\x01\x12\n\n\x06nodejs\x10\x02\x12\x0e\n\ntypescript\x10\x03\x12\x06\n\x02go\x10\x04\x62\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkServer.v1.SylkServer_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZBgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkServer/v1'
   _globals['_SYLKSERVERLANGUAGES']._serialized_start=132
   _globals['_SYLKSERVERLANGUAGES']._serialized_end=234
   _globals['_SYLKSERVER']._serialized_start=59
   _globals['_SYLKSERVER']._serialized_end=130
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkService/v1/SylkService_pb2.py

```diff
@@ -12,25 +12,24 @@
 
 
 from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2
 from sylk.commons.protos.sylk.SylkMethod.v1 import SylkMethod_pb2 as sylk_dot_SylkMethod_dot_v1_dot_SylkMethod__pb2
 from google.protobuf import struct_pb2 as google_dot_protobuf_dot_struct__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n%sylk/SylkService/v1/SylkService.proto\x12\x13sylk.SylkService.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a#sylk/SylkMethod/v1/SylkMethod.proto\x1a\x1cgoogle/protobuf/struct.proto\"\xa7\x01\n\x12SylkServiceDisplay\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x31\n\x07service\x18\x01 \x01(\x0b\x32 .sylk.SylkService.v1.SylkService\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\"\xb7\x02\n\x0bSylkService\x12\x14\n\x0c\x64\x65pendencies\x18\x07 \x03(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x11\n\tfull_name\x18\x03 \x01(\t\x12\x0c\n\x04type\x18\x06 \x01(\t\x12/\n\x07methods\x18\x05 \x03(\x0b\x32\x1e.sylk.SylkMethod.v1.SylkMethod\x12\x44\n\nextensions\x18\x08 \x03(\x0b\x32\x30.sylk.SylkService.v1.SylkService.ExtensionsEntry\x1aJ\n\x0f\x45xtensionsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12&\n\x05value\x18\x02 \x01(\x0b\x32\x17.google.protobuf.Struct:\x02\x38\x01\x42\x45ZCgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkService/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n%sylk/SylkService/v1/SylkService.proto\x12\x13sylk.SylkService.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a#sylk/SylkMethod/v1/SylkMethod.proto\x1a\x1cgoogle/protobuf/struct.proto\"\xb7\x02\n\x0bSylkService\x12\x14\n\x0c\x64\x65pendencies\x18\x07 \x03(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x0b\n\x03uri\x18\x01 \x01(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x11\n\tfull_name\x18\x03 \x01(\t\x12\x0c\n\x04type\x18\x06 \x01(\t\x12/\n\x07methods\x18\x05 \x03(\x0b\x32\x1e.sylk.SylkMethod.v1.SylkMethod\x12\x44\n\nextensions\x18\x08 \x03(\x0b\x32\x30.sylk.SylkService.v1.SylkService.ExtensionsEntry\x1aJ\n\x0f\x45xtensionsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12&\n\x05value\x18\x02 \x01(\x0b\x32\x17.google.protobuf.Struct:\x02\x38\x01\"\xa7\x01\n\x12SylkServiceDisplay\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x31\n\x07service\x18\x01 \x01(\x0b\x32 .sylk.SylkService.v1.SylkService\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestampb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkService.v1.SylkService_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'ZCgithub.com/sylk-build/sylk-core/services/protos/sylk/SylkService/v1'
   _SYLKSERVICE_EXTENSIONSENTRY._options = None
   _SYLKSERVICE_EXTENSIONSENTRY._serialized_options = b'8\001'
-  _globals['_SYLKSERVICEDISPLAY']._serialized_start=163
-  _globals['_SYLKSERVICEDISPLAY']._serialized_end=330
-  _globals['_SYLKSERVICE']._serialized_start=333
-  _globals['_SYLKSERVICE']._serialized_end=644
-  _globals['_SYLKSERVICE_EXTENSIONSENTRY']._serialized_start=570
-  _globals['_SYLKSERVICE_EXTENSIONSENTRY']._serialized_end=644
+  _globals['_SYLKSERVICE']._serialized_start=163
+  _globals['_SYLKSERVICE']._serialized_end=474
+  _globals['_SYLKSERVICE_EXTENSIONSENTRY']._serialized_start=400
+  _globals['_SYLKSERVICE_EXTENSIONSENTRY']._serialized_end=474
+  _globals['_SYLKSERVICEDISPLAY']._serialized_start=477
+  _globals['_SYLKSERVICEDISPLAY']._serialized_end=644
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/SylkUser/v1/SylkUser_pb2.py

```diff
@@ -10,31 +10,30 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fsylk/SylkUser/v1/SylkUser.proto\x12\x10sylk.SylkUser.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\xcb\x01\n\x13PersonalAccessToken\x12\r\n\x05token\x18\x01 \x01(\t\x12\x0e\n\x06org_id\x18\x06 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x05 \x01(\t\x12.\n\nexpires_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x0f\n\x07revoked\x18\x04 \x01(\x08\x12\x0f\n\x07user_id\x18\x07 \x01(\t\"\xcc\x01\n\x0fSylkUserDisplay\x12(\n\x04user\x18\x01 \x01(\x0b\x32\x1a.sylk.SylkUser.v1.SylkUser\x12/\n\x0blast_active\x18\x04 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\"\xf2\x02\n\x08SylkUser\x12\r\n\x05\x65mail\x18\x02 \x01(\t\x12\x39\n\x08orgs_ids\x18\x0b \x03(\x0b\x32\'.sylk.SylkUser.v1.SylkUser.OrgsIdsEntry\x12\x0e\n\x06locale\x18\x06 \x01(\t\x12\x12\n\ngiven_name\x18\x05 \x01(\t\x12\x10\n\x08nickname\x18\x07 \x01(\t\x12\x32\n\x06status\x18\n \x01(\x0e\x32\".sylk.SylkUser.v1.SylkUserStatuses\x12\x0f\n\x07picture\x18\x08 \x01(\t\x12\x12\n\nconnection\x18\t \x01(\t\x12\x0f\n\x07user_id\x18\x01 \x01(\t\x12\x16\n\x0e\x65mail_verified\x18\x03 \x01(\x08\x12\x13\n\x0b\x66\x61mily_name\x18\x04 \x01(\t\x1aO\n\x0cOrgsIdsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12.\n\x05value\x18\x02 \x01(\x0e\x32\x1f.sylk.SylkUser.v1.SylkUserRoles:\x02\x38\x01*W\n\x10SylkUserStatuses\x12\x1c\n\x18\x44\x45\x46\x41ULT_SYLKUSERSTATUSES\x10\x00\x12\n\n\x06\x41\x43TIVE\x10\x01\x12\x0c\n\x08INACTIVE\x10\x02\x12\x0b\n\x07PENDING\x10\x03*R\n\rSylkUserRoles\x12\x19\n\x15\x44\x45\x46\x41ULT_SYLKUSERROLES\x10\x00\x12\t\n\x05\x41\x44MIN\x10\x01\x12\x0f\n\x0b\x43ONTRIBUTER\x10\x02\x12\n\n\x06READER\x10\x03\x42\x42Z@github.com/sylk-build/sylk-core/services/protos/sylk/SylkUser/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fsylk/SylkUser/v1/SylkUser.proto\x12\x10sylk.SylkUser.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\xcb\x01\n\x13PersonalAccessToken\x12\r\n\x05token\x18\x01 \x01(\t\x12\x0e\n\x06org_id\x18\x06 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x05 \x01(\t\x12.\n\nexpires_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x0f\n\x07revoked\x18\x04 \x01(\x08\x12\x0f\n\x07user_id\x18\x07 \x01(\t\"\xf2\x02\n\x08SylkUser\x12\r\n\x05\x65mail\x18\x02 \x01(\t\x12\x39\n\x08orgs_ids\x18\x0b \x03(\x0b\x32\'.sylk.SylkUser.v1.SylkUser.OrgsIdsEntry\x12\x0e\n\x06locale\x18\x06 \x01(\t\x12\x12\n\ngiven_name\x18\x05 \x01(\t\x12\x10\n\x08nickname\x18\x07 \x01(\t\x12\x32\n\x06status\x18\n \x01(\x0e\x32\".sylk.SylkUser.v1.SylkUserStatuses\x12\x0f\n\x07picture\x18\x08 \x01(\t\x12\x12\n\nconnection\x18\t \x01(\t\x12\x0f\n\x07user_id\x18\x01 \x01(\t\x12\x16\n\x0e\x65mail_verified\x18\x03 \x01(\x08\x12\x13\n\x0b\x66\x61mily_name\x18\x04 \x01(\t\x1aO\n\x0cOrgsIdsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12.\n\x05value\x18\x02 \x01(\x0e\x32\x1f.sylk.SylkUser.v1.SylkUserRoles:\x02\x38\x01\"\xcc\x01\n\x0fSylkUserDisplay\x12(\n\x04user\x18\x01 \x01(\x0b\x32\x1a.sylk.SylkUser.v1.SylkUser\x12/\n\x0blast_active\x18\x04 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12.\n\ncreated_at\x18\x02 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12.\n\nupdated_at\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.Timestamp*W\n\x10SylkUserStatuses\x12\x1c\n\x18\x44\x45\x46\x41ULT_SYLKUSERSTATUSES\x10\x00\x12\n\n\x06\x41\x43TIVE\x10\x01\x12\x0c\n\x08INACTIVE\x10\x02\x12\x0b\n\x07PENDING\x10\x03*R\n\rSylkUserRoles\x12\x19\n\x15\x44\x45\x46\x41ULT_SYLKUSERROLES\x10\x00\x12\t\n\x05\x41\x44MIN\x10\x01\x12\x0f\n\x0b\x43ONTRIBUTER\x10\x02\x12\n\n\x06READER\x10\x03\x62\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.SylkUser.v1.SylkUser_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'Z@github.com/sylk-build/sylk-core/services/protos/sylk/SylkUser/v1'
   _SYLKUSER_ORGSIDSENTRY._options = None
   _SYLKUSER_ORGSIDSENTRY._serialized_options = b'8\001'
   _globals['_SYLKUSERSTATUSES']._serialized_start=872
   _globals['_SYLKUSERSTATUSES']._serialized_end=959
   _globals['_SYLKUSERROLES']._serialized_start=961
   _globals['_SYLKUSERROLES']._serialized_end=1043
   _globals['_PERSONALACCESSTOKEN']._serialized_start=87
   _globals['_PERSONALACCESSTOKEN']._serialized_end=290
-  _globals['_SYLKUSERDISPLAY']._serialized_start=293
-  _globals['_SYLKUSERDISPLAY']._serialized_end=497
-  _globals['_SYLKUSER']._serialized_start=500
-  _globals['_SYLKUSER']._serialized_end=870
-  _globals['_SYLKUSER_ORGSIDSENTRY']._serialized_start=791
-  _globals['_SYLKUSER_ORGSIDSENTRY']._serialized_end=870
+  _globals['_SYLKUSER']._serialized_start=293
+  _globals['_SYLKUSER']._serialized_end=663
+  _globals['_SYLKUSER_ORGSIDSENTRY']._serialized_start=584
+  _globals['_SYLKUSER_ORGSIDSENTRY']._serialized_end=663
+  _globals['_SYLKUSERDISPLAY']._serialized_start=666
+  _globals['_SYLKUSERDISPLAY']._serialized_end=870
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/Users/v1/Users_pb2.py

```diff
@@ -10,19 +10,18 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from sylk.commons.protos.sylk.SylkApi.v1 import SylkApi_pb2 as sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x19sylk/Users/v1/Users.proto\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xa7\x05\n\x05Users\x12U\n\nCreateUser\x12\".sylk.SylkApi.v1.CreateUserRequest\x1a#.sylk.SylkApi.v1.CreateUserResponse\x12\x61\n\x0eGetAccessToken\x12&.sylk.SylkApi.v1.GetAccessTokenRequest\x1a\'.sylk.SylkApi.v1.GetAccessTokenResponse\x12j\n\x11\x43reateAccessToken\x12).sylk.SylkApi.v1.CreateAccessTokenRequest\x1a*.sylk.SylkApi.v1.CreateAccessTokenResponse\x12L\n\x07GetUser\x12\x1f.sylk.SylkApi.v1.GetUserRequest\x1a .sylk.SylkApi.v1.GetUserResponse\x12g\n\x10ListAccessTokens\x12(.sylk.SylkApi.v1.ListAccessTokensRequest\x1a\'.sylk.SylkApi.v1.GetAccessTokenResponse0\x01\x12j\n\x11RevokeAccessToken\x12).sylk.SylkApi.v1.RevokeAccessTokenRequest\x1a*.sylk.SylkApi.v1.RevokeAccessTokenResponse\x12U\n\nUpdateUser\x12\".sylk.SylkApi.v1.UpdateUserRequest\x1a#.sylk.SylkApi.v1.UpdateUserResponseB?Z=github.com/sylk-build/sylk-core/services/protos/sylk/Users/v1b\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x19sylk/Users/v1/Users.proto\x12\rsylk.Users.v1\x1a\x1dsylk/SylkApi/v1/SylkApi.proto2\xa7\x05\n\x05Users\x12U\n\nCreateUser\x12\".sylk.SylkApi.v1.CreateUserRequest\x1a#.sylk.SylkApi.v1.CreateUserResponse\x12\x61\n\x0eGetAccessToken\x12&.sylk.SylkApi.v1.GetAccessTokenRequest\x1a\'.sylk.SylkApi.v1.GetAccessTokenResponse\x12j\n\x11\x43reateAccessToken\x12).sylk.SylkApi.v1.CreateAccessTokenRequest\x1a*.sylk.SylkApi.v1.CreateAccessTokenResponse\x12L\n\x07GetUser\x12\x1f.sylk.SylkApi.v1.GetUserRequest\x1a .sylk.SylkApi.v1.GetUserResponse\x12g\n\x10ListAccessTokens\x12(.sylk.SylkApi.v1.ListAccessTokensRequest\x1a\'.sylk.SylkApi.v1.GetAccessTokenResponse0\x01\x12j\n\x11RevokeAccessToken\x12).sylk.SylkApi.v1.RevokeAccessTokenRequest\x1a*.sylk.SylkApi.v1.RevokeAccessTokenResponse\x12U\n\nUpdateUser\x12\".sylk.SylkApi.v1.UpdateUserRequest\x1a#.sylk.SylkApi.v1.UpdateUserResponseb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.Users.v1.Users_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'Z=github.com/sylk-build/sylk-core/services/protos/sylk/Users/v1'
-  _globals['_USERS']._serialized_start=61
-  _globals['_USERS']._serialized_end=740
+  _globals['_USERS']._serialized_start=76
+  _globals['_USERS']._serialized_end=755
 # @@protoc_insertion_point(module_scope)
```

## sylk/commons/protos/sylk/Users/v1/Users_pb2_grpc.py

```diff
@@ -11,45 +11,45 @@
     def __init__(self, channel):
         """Constructor.
 
         Args:
             channel: A grpc.Channel.
         """
         self.CreateUser = channel.unary_unary(
-                '/Users/CreateUser',
+                '/sylk.Users.v1.Users/CreateUser',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateUserRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateUserResponse.FromString,
                 )
         self.GetAccessToken = channel.unary_unary(
-                '/Users/GetAccessToken',
+                '/sylk.Users.v1.Users/GetAccessToken',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetAccessTokenRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetAccessTokenResponse.FromString,
                 )
         self.CreateAccessToken = channel.unary_unary(
-                '/Users/CreateAccessToken',
+                '/sylk.Users.v1.Users/CreateAccessToken',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateAccessTokenRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateAccessTokenResponse.FromString,
                 )
         self.GetUser = channel.unary_unary(
-                '/Users/GetUser',
+                '/sylk.Users.v1.Users/GetUser',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetUserRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetUserResponse.FromString,
                 )
         self.ListAccessTokens = channel.unary_stream(
-                '/Users/ListAccessTokens',
+                '/sylk.Users.v1.Users/ListAccessTokens',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.ListAccessTokensRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetAccessTokenResponse.FromString,
                 )
         self.RevokeAccessToken = channel.unary_unary(
-                '/Users/RevokeAccessToken',
+                '/sylk.Users.v1.Users/RevokeAccessToken',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.RevokeAccessTokenRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.RevokeAccessTokenResponse.FromString,
                 )
         self.UpdateUser = channel.unary_unary(
-                '/Users/UpdateUser',
+                '/sylk.Users.v1.Users/UpdateUser',
                 request_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRequest.SerializeToString,
                 response_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserResponse.FromString,
                 )
 
 
 class UsersServicer(object):
     """Missing associated documentation comment in .proto file."""
@@ -139,15 +139,15 @@
             'UpdateUser': grpc.unary_unary_rpc_method_handler(
                     servicer.UpdateUser,
                     request_deserializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRequest.FromString,
                     response_serializer=sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserResponse.SerializeToString,
             ),
     }
     generic_handler = grpc.method_handlers_generic_handler(
-            'Users', rpc_method_handlers)
+            'sylk.Users.v1.Users', rpc_method_handlers)
     server.add_generic_rpc_handlers((generic_handler,))
 
 
  # This class is part of an EXPERIMENTAL API.
 class Users(object):
     """Missing associated documentation comment in .proto file."""
 
@@ -158,15 +158,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Users/CreateUser',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Users.v1.Users/CreateUser',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateUserRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateUserResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def GetAccessToken(request,
@@ -175,15 +175,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Users/GetAccessToken',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Users.v1.Users/GetAccessToken',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetAccessTokenRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetAccessTokenResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def CreateAccessToken(request,
@@ -192,15 +192,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Users/CreateAccessToken',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Users.v1.Users/CreateAccessToken',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateAccessTokenRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.CreateAccessTokenResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def GetUser(request,
@@ -209,15 +209,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Users/GetUser',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Users.v1.Users/GetUser',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetUserRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetUserResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def ListAccessTokens(request,
@@ -226,15 +226,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_stream(request, target, '/Users/ListAccessTokens',
+        return grpc.experimental.unary_stream(request, target, '/sylk.Users.v1.Users/ListAccessTokens',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.ListAccessTokensRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.GetAccessTokenResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def RevokeAccessToken(request,
@@ -243,15 +243,15 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Users/RevokeAccessToken',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Users.v1.Users/RevokeAccessToken',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.RevokeAccessTokenRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.RevokeAccessTokenResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
 
     @staticmethod
     def UpdateUser(request,
@@ -260,12 +260,12 @@
             channel_credentials=None,
             call_credentials=None,
             insecure=False,
             compression=None,
             wait_for_ready=None,
             timeout=None,
             metadata=None):
-        return grpc.experimental.unary_unary(request, target, '/Users/UpdateUser',
+        return grpc.experimental.unary_unary(request, target, '/sylk.Users.v1.Users/UpdateUser',
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserRequest.SerializeToString,
             sylk_dot_SylkApi_dot_v1_dot_SylkApi__pb2.UpdateUserResponse.FromString,
             options, channel_credentials,
             insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
```

## sylk/types/google/longrunning/operations_pb2.py

```diff
@@ -14,24 +14,24 @@
 from google.protobuf import any_pb2 as google_dot_protobuf_dot_any__pb2
 from google.protobuf import duration_pb2 as google_dot_protobuf_dot_duration__pb2
 from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2
 from sylk.types.google.rpc import status_pb2 as google_dot_rpc_dot_status__pb2
 from google.protobuf import descriptor_pb2 as google_dot_protobuf_dot_descriptor__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n#google/longrunning/operations.proto\x12\x12google.longrunning\x1a\x19google/protobuf/any.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x17google/rpc/status.proto\x1a google/protobuf/descriptor.proto\"\xa8\x01\n\tOperation\x12\x0c\n\x04name\x18\x01 \x01(\t\x12&\n\x08metadata\x18\x02 \x01(\x0b\x32\x14.google.protobuf.Any\x12\x0c\n\x04\x64one\x18\x03 \x01(\x08\x12#\n\x05\x65rror\x18\x04 \x01(\x0b\x32\x12.google.rpc.StatusH\x00\x12(\n\x08response\x18\x05 \x01(\x0b\x32\x14.google.protobuf.AnyH\x00\x42\x08\n\x06result\"#\n\x13GetOperationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t\"\\\n\x15ListOperationsRequest\x12\x0c\n\x04name\x18\x04 \x01(\t\x12\x0e\n\x06\x66ilter\x18\x01 \x01(\t\x12\x11\n\tpage_size\x18\x02 \x01(\x05\x12\x12\n\npage_token\x18\x03 \x01(\t\"d\n\x16ListOperationsResponse\x12\x31\n\noperations\x18\x01 \x03(\x0b\x32\x1d.google.longrunning.Operation\x12\x17\n\x0fnext_page_token\x18\x02 \x01(\t\"&\n\x16\x43\x61ncelOperationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t\"&\n\x16\x44\x65leteOperationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t\"P\n\x14WaitOperationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t\x12*\n\x07timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.Duration\"=\n\rOperationInfo\x12\x15\n\rresponse_type\x18\x01 \x01(\t\x12\x15\n\rmetadata_type\x18\x02 \x01(\t2\xd5\x03\n\nOperations\x12g\n\x0eListOperations\x12).google.longrunning.ListOperationsRequest\x1a*.google.longrunning.ListOperationsResponse\x12V\n\x0cGetOperation\x12\'.google.longrunning.GetOperationRequest\x1a\x1d.google.longrunning.Operation\x12U\n\x0f\x44\x65leteOperation\x12*.google.longrunning.DeleteOperationRequest\x1a\x16.google.protobuf.Empty\x12U\n\x0f\x43\x61ncelOperation\x12*.google.longrunning.CancelOperationRequest\x1a\x16.google.protobuf.Empty\x12X\n\rWaitOperation\x12(.google.longrunning.WaitOperationRequest\x1a\x1d.google.longrunning.Operation:Z\n\x0eoperation_info\x12\x1e.google.protobuf.MethodOptions\x18\x99\x08 \x01(\x0b\x32!.google.longrunning.OperationInfoB\x9d\x01\n\x16\x63om.google.longrunningB\x0fOperationsProtoP\x01ZCcloud.google.com/go/longrunning/autogen/longrunningpb;longrunningpb\xf8\x01\x01\xaa\x02\x12Google.LongRunning\xca\x02\x12Google\\LongRunningb\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n#google/longrunning/operations.proto\x12\x12google.longrunning\x1a\x19google/protobuf/any.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x17google/rpc/status.proto\x1a google/protobuf/descriptor.proto\"\xa8\x01\n\tOperation\x12\x0c\n\x04name\x18\x01 \x01(\t\x12&\n\x08metadata\x18\x02 \x01(\x0b\x32\x14.google.protobuf.Any\x12\x0c\n\x04\x64one\x18\x03 \x01(\x08\x12#\n\x05\x65rror\x18\x04 \x01(\x0b\x32\x12.google.rpc.StatusH\x00\x12(\n\x08response\x18\x05 \x01(\x0b\x32\x14.google.protobuf.AnyH\x00\x42\x08\n\x06result\"#\n\x13GetOperationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t\"\\\n\x15ListOperationsRequest\x12\x0c\n\x04name\x18\x04 \x01(\t\x12\x0e\n\x06\x66ilter\x18\x01 \x01(\t\x12\x11\n\tpage_size\x18\x02 \x01(\x05\x12\x12\n\npage_token\x18\x03 \x01(\t\"d\n\x16ListOperationsResponse\x12\x31\n\noperations\x18\x01 \x03(\x0b\x32\x1d.google.longrunning.Operation\x12\x17\n\x0fnext_page_token\x18\x02 \x01(\t\"&\n\x16\x43\x61ncelOperationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t\"&\n\x16\x44\x65leteOperationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t\"P\n\x14WaitOperationRequest\x12\x0c\n\x04name\x18\x01 \x01(\t\x12*\n\x07timeout\x18\x02 \x01(\x0b\x32\x19.google.protobuf.Duration\"=\n\rOperationInfo\x12\x15\n\rresponse_type\x18\x01 \x01(\t\x12\x15\n\rmetadata_type\x18\x02 \x01(\t2\xd5\x03\n\nOperations\x12g\n\x0eListOperations\x12).google.longrunning.ListOperationsRequest\x1a*.google.longrunning.ListOperationsResponse\x12V\n\x0cGetOperation\x12\'.google.longrunning.GetOperationRequest\x1a\x1d.google.longrunning.Operation\x12U\n\x0f\x44\x65leteOperation\x12*.google.longrunning.DeleteOperationRequest\x1a\x16.google.protobuf.Empty\x12U\n\x0f\x43\x61ncelOperation\x12*.google.longrunning.CancelOperationRequest\x1a\x16.google.protobuf.Empty\x12X\n\rWaitOperation\x12(.google.longrunning.WaitOperationRequest\x1a\x1d.google.longrunning.Operation:Z\n\x0eoperation_info\x12\x1e.google.protobuf.MethodOptions\x18\x99\x08 \x01(\x0b\x32!.google.longrunning.OperationInfoB\x9c\x01\n\x14\x63om.sylk.longrunningB\x0fOperationsProtoP\x01ZHgithub.com/sylk-build/go/longrunning/autogen/longrunningpb;longrunningpb\xf8\x01\x01\xaa\x02\x10Sylk.LongRunning\xca\x02\x10Sylk\\LongRunningb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'google.longrunning.operations_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
   google_dot_protobuf_dot_descriptor__pb2.MethodOptions.RegisterExtension(operation_info)
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'\n\026com.google.longrunningB\017OperationsProtoP\001ZCcloud.google.com/go/longrunning/autogen/longrunningpb;longrunningpb\370\001\001\252\002\022Google.LongRunning\312\002\022Google\\LongRunning'
+  DESCRIPTOR._serialized_options = b'\n\024com.sylk.longrunningB\017OperationsProtoP\001ZHgithub.com/sylk-build/go/longrunning/autogen/longrunningpb;longrunningpb\370\001\001\252\002\020Sylk.LongRunning\312\002\020Sylk\\LongRunning'
   _globals['_OPERATION']._serialized_start=207
   _globals['_OPERATION']._serialized_end=375
   _globals['_GETOPERATIONREQUEST']._serialized_start=377
   _globals['_GETOPERATIONREQUEST']._serialized_end=412
   _globals['_LISTOPERATIONSREQUEST']._serialized_start=414
   _globals['_LISTOPERATIONSREQUEST']._serialized_end=506
   _globals['_LISTOPERATIONSRESPONSE']._serialized_start=508
```

## sylk/types/google/longrunning/operations_pb2_grpc.py

```diff
@@ -1,12 +1,12 @@
 # Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
 """Client and server classes corresponding to protobuf-defined services."""
 import grpc
 
-from sylk.types.google.longrunning import operations_pb2 as google_dot_longrunning_dot_operations__pb2
+from google.longrunning import operations_pb2 as google_dot_longrunning_dot_operations__pb2
 from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2
 
 
 class OperationsStub(object):
     """Manages long-running operations with an API service.
 
     When an API method normally takes long time to complete, it can be designed
```

## sylk/types/google/rpc/code_pb2.py

```diff
@@ -9,19 +9,19 @@
 # @@protoc_insertion_point(imports)
 
 _sym_db = _symbol_database.Default()
 
 
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x15google/rpc/code.proto\x12\ngoogle.rpc*\xb7\x02\n\x04\x43ode\x12\x06\n\x02OK\x10\x00\x12\r\n\tCANCELLED\x10\x01\x12\x0b\n\x07UNKNOWN\x10\x02\x12\x14\n\x10INVALID_ARGUMENT\x10\x03\x12\x15\n\x11\x44\x45\x41\x44LINE_EXCEEDED\x10\x04\x12\r\n\tNOT_FOUND\x10\x05\x12\x12\n\x0e\x41LREADY_EXISTS\x10\x06\x12\x15\n\x11PERMISSION_DENIED\x10\x07\x12\x13\n\x0fUNAUTHENTICATED\x10\x10\x12\x16\n\x12RESOURCE_EXHAUSTED\x10\x08\x12\x17\n\x13\x46\x41ILED_PRECONDITION\x10\t\x12\x0b\n\x07\x41\x42ORTED\x10\n\x12\x10\n\x0cOUT_OF_RANGE\x10\x0b\x12\x11\n\rUNIMPLEMENTED\x10\x0c\x12\x0c\n\x08INTERNAL\x10\r\x12\x0f\n\x0bUNAVAILABLE\x10\x0e\x12\r\n\tDATA_LOSS\x10\x0f\x42X\n\x0e\x63om.google.rpcB\tCodeProtoP\x01Z3google.golang.org/genproto/googleapis/rpc/code;code\xa2\x02\x03RPCb\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x15google/rpc/code.proto\x12\ngoogle.rpc*\xb7\x02\n\x04\x43ode\x12\x06\n\x02OK\x10\x00\x12\r\n\tCANCELLED\x10\x01\x12\x0b\n\x07UNKNOWN\x10\x02\x12\x14\n\x10INVALID_ARGUMENT\x10\x03\x12\x15\n\x11\x44\x45\x41\x44LINE_EXCEEDED\x10\x04\x12\r\n\tNOT_FOUND\x10\x05\x12\x12\n\x0e\x41LREADY_EXISTS\x10\x06\x12\x15\n\x11PERMISSION_DENIED\x10\x07\x12\x13\n\x0fUNAUTHENTICATED\x10\x10\x12\x16\n\x12RESOURCE_EXHAUSTED\x10\x08\x12\x17\n\x13\x46\x41ILED_PRECONDITION\x10\t\x12\x0b\n\x07\x41\x42ORTED\x10\n\x12\x10\n\x0cOUT_OF_RANGE\x10\x0b\x12\x11\n\rUNIMPLEMENTED\x10\x0c\x12\x0c\n\x08INTERNAL\x10\r\x12\x0f\n\x0bUNAVAILABLE\x10\x0e\x12\r\n\tDATA_LOSS\x10\x0f\x42V\n\x0c\x63om.sylk.rpcB\tCodeProtoP\x01Z3google.golang.org/genproto/googleapis/rpc/code;code\xa2\x02\x03RPCb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'google.rpc.code_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'\n\016com.google.rpcB\tCodeProtoP\001Z3google.golang.org/genproto/googleapis/rpc/code;code\242\002\003RPC'
+  DESCRIPTOR._serialized_options = b'\n\014com.sylk.rpcB\tCodeProtoP\001Z3google.golang.org/genproto/googleapis/rpc/code;code\242\002\003RPC'
   _globals['_CODE']._serialized_start=38
   _globals['_CODE']._serialized_end=349
 # @@protoc_insertion_point(module_scope)
```

## sylk/types/google/rpc/error_details_pb2.py

```diff
@@ -10,23 +10,23 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from google.protobuf import duration_pb2 as google_dot_protobuf_dot_duration__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1egoogle/rpc/error_details.proto\x12\ngoogle.rpc\x1a\x1egoogle/protobuf/duration.proto\"\x93\x01\n\tErrorInfo\x12\x0e\n\x06reason\x18\x01 \x01(\t\x12\x0e\n\x06\x64omain\x18\x02 \x01(\t\x12\x35\n\x08metadata\x18\x03 \x03(\x0b\x32#.google.rpc.ErrorInfo.MetadataEntry\x1a/\n\rMetadataEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\";\n\tRetryInfo\x12.\n\x0bretry_delay\x18\x01 \x01(\x0b\x32\x19.google.protobuf.Duration\"2\n\tDebugInfo\x12\x15\n\rstack_entries\x18\x01 \x03(\t\x12\x0e\n\x06\x64\x65tail\x18\x02 \x01(\t\"y\n\x0cQuotaFailure\x12\x36\n\nviolations\x18\x01 \x03(\x0b\x32\".google.rpc.QuotaFailure.Violation\x1a\x31\n\tViolation\x12\x0f\n\x07subject\x18\x01 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x02 \x01(\t\"\x95\x01\n\x13PreconditionFailure\x12=\n\nviolations\x18\x01 \x03(\x0b\x32).google.rpc.PreconditionFailure.Violation\x1a?\n\tViolation\x12\x0c\n\x04type\x18\x01 \x01(\t\x12\x0f\n\x07subject\x18\x02 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x03 \x01(\t\"\x83\x01\n\nBadRequest\x12?\n\x10\x66ield_violations\x18\x01 \x03(\x0b\x32%.google.rpc.BadRequest.FieldViolation\x1a\x34\n\x0e\x46ieldViolation\x12\r\n\x05\x66ield\x18\x01 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x02 \x01(\t\"7\n\x0bRequestInfo\x12\x12\n\nrequest_id\x18\x01 \x01(\t\x12\x14\n\x0cserving_data\x18\x02 \x01(\t\"`\n\x0cResourceInfo\x12\x15\n\rresource_type\x18\x01 \x01(\t\x12\x15\n\rresource_name\x18\x02 \x01(\t\x12\r\n\x05owner\x18\x03 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\"V\n\x04Help\x12$\n\x05links\x18\x01 \x03(\x0b\x32\x15.google.rpc.Help.Link\x1a(\n\x04Link\x12\x13\n\x0b\x64\x65scription\x18\x01 \x01(\t\x12\x0b\n\x03url\x18\x02 \x01(\t\"3\n\x10LocalizedMessage\x12\x0e\n\x06locale\x18\x01 \x01(\t\x12\x0f\n\x07message\x18\x02 \x01(\tBl\n\x0e\x63om.google.rpcB\x11\x45rrorDetailsProtoP\x01Z?google.golang.org/genproto/googleapis/rpc/errdetails;errdetails\xa2\x02\x03RPCb\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1egoogle/rpc/error_details.proto\x12\ngoogle.rpc\x1a\x1egoogle/protobuf/duration.proto\"\x93\x01\n\tErrorInfo\x12\x0e\n\x06reason\x18\x01 \x01(\t\x12\x0e\n\x06\x64omain\x18\x02 \x01(\t\x12\x35\n\x08metadata\x18\x03 \x03(\x0b\x32#.google.rpc.ErrorInfo.MetadataEntry\x1a/\n\rMetadataEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\";\n\tRetryInfo\x12.\n\x0bretry_delay\x18\x01 \x01(\x0b\x32\x19.google.protobuf.Duration\"2\n\tDebugInfo\x12\x15\n\rstack_entries\x18\x01 \x03(\t\x12\x0e\n\x06\x64\x65tail\x18\x02 \x01(\t\"y\n\x0cQuotaFailure\x12\x36\n\nviolations\x18\x01 \x03(\x0b\x32\".google.rpc.QuotaFailure.Violation\x1a\x31\n\tViolation\x12\x0f\n\x07subject\x18\x01 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x02 \x01(\t\"\x95\x01\n\x13PreconditionFailure\x12=\n\nviolations\x18\x01 \x03(\x0b\x32).google.rpc.PreconditionFailure.Violation\x1a?\n\tViolation\x12\x0c\n\x04type\x18\x01 \x01(\t\x12\x0f\n\x07subject\x18\x02 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x03 \x01(\t\"\x83\x01\n\nBadRequest\x12?\n\x10\x66ield_violations\x18\x01 \x03(\x0b\x32%.google.rpc.BadRequest.FieldViolation\x1a\x34\n\x0e\x46ieldViolation\x12\r\n\x05\x66ield\x18\x01 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x02 \x01(\t\"7\n\x0bRequestInfo\x12\x12\n\nrequest_id\x18\x01 \x01(\t\x12\x14\n\x0cserving_data\x18\x02 \x01(\t\"`\n\x0cResourceInfo\x12\x15\n\rresource_type\x18\x01 \x01(\t\x12\x15\n\rresource_name\x18\x02 \x01(\t\x12\r\n\x05owner\x18\x03 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\"V\n\x04Help\x12$\n\x05links\x18\x01 \x03(\x0b\x32\x15.google.rpc.Help.Link\x1a(\n\x04Link\x12\x13\n\x0b\x64\x65scription\x18\x01 \x01(\t\x12\x0b\n\x03url\x18\x02 \x01(\t\"3\n\x10LocalizedMessage\x12\x0e\n\x06locale\x18\x01 \x01(\t\x12\x0f\n\x07message\x18\x02 \x01(\tBj\n\x0c\x63om.sylk.rpcB\x11\x45rrorDetailsProtoP\x01Z?google.golang.org/genproto/googleapis/rpc/errdetails;errdetails\xa2\x02\x03RPCb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'google.rpc.error_details_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'\n\016com.google.rpcB\021ErrorDetailsProtoP\001Z?google.golang.org/genproto/googleapis/rpc/errdetails;errdetails\242\002\003RPC'
+  DESCRIPTOR._serialized_options = b'\n\014com.sylk.rpcB\021ErrorDetailsProtoP\001Z?google.golang.org/genproto/googleapis/rpc/errdetails;errdetails\242\002\003RPC'
   _ERRORINFO_METADATAENTRY._options = None
   _ERRORINFO_METADATAENTRY._serialized_options = b'8\001'
   _globals['_ERRORINFO']._serialized_start=79
   _globals['_ERRORINFO']._serialized_end=226
   _globals['_ERRORINFO_METADATAENTRY']._serialized_start=179
   _globals['_ERRORINFO_METADATAENTRY']._serialized_end=226
   _globals['_RETRYINFO']._serialized_start=228
```

## sylk/types/google/rpc/http_pb2.py

```diff
@@ -9,23 +9,23 @@
 # @@protoc_insertion_point(imports)
 
 _sym_db = _symbol_database.Default()
 
 
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x15google/rpc/http.proto\x12\ngoogle.rpc\"a\n\x0bHttpRequest\x12\x0e\n\x06method\x18\x01 \x01(\t\x12\x0b\n\x03uri\x18\x02 \x01(\t\x12\'\n\x07headers\x18\x03 \x03(\x0b\x32\x16.google.rpc.HttpHeader\x12\x0c\n\x04\x62ody\x18\x04 \x01(\x0c\"e\n\x0cHttpResponse\x12\x0e\n\x06status\x18\x01 \x01(\x05\x12\x0e\n\x06reason\x18\x02 \x01(\t\x12\'\n\x07headers\x18\x03 \x03(\x0b\x32\x16.google.rpc.HttpHeader\x12\x0c\n\x04\x62ody\x18\x04 \x01(\x0c\"(\n\nHttpHeader\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\tBX\n\x0e\x63om.google.rpcB\tHttpProtoP\x01Z3google.golang.org/genproto/googleapis/rpc/http;http\xa2\x02\x03RPCb\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x15google/rpc/http.proto\x12\ngoogle.rpc\"a\n\x0bHttpRequest\x12\x0e\n\x06method\x18\x01 \x01(\t\x12\x0b\n\x03uri\x18\x02 \x01(\t\x12\'\n\x07headers\x18\x03 \x03(\x0b\x32\x16.google.rpc.HttpHeader\x12\x0c\n\x04\x62ody\x18\x04 \x01(\x0c\"e\n\x0cHttpResponse\x12\x0e\n\x06status\x18\x01 \x01(\x05\x12\x0e\n\x06reason\x18\x02 \x01(\t\x12\'\n\x07headers\x18\x03 \x03(\x0b\x32\x16.google.rpc.HttpHeader\x12\x0c\n\x04\x62ody\x18\x04 \x01(\x0c\"(\n\nHttpHeader\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\tBV\n\x0c\x63om.sylk.rpcB\tHttpProtoP\x01Z3google.golang.org/genproto/googleapis/rpc/http;http\xa2\x02\x03RPCb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'google.rpc.http_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'\n\016com.google.rpcB\tHttpProtoP\001Z3google.golang.org/genproto/googleapis/rpc/http;http\242\002\003RPC'
+  DESCRIPTOR._serialized_options = b'\n\014com.sylk.rpcB\tHttpProtoP\001Z3google.golang.org/genproto/googleapis/rpc/http;http\242\002\003RPC'
   _globals['_HTTPREQUEST']._serialized_start=37
   _globals['_HTTPREQUEST']._serialized_end=134
   _globals['_HTTPRESPONSE']._serialized_start=136
   _globals['_HTTPRESPONSE']._serialized_end=237
   _globals['_HTTPHEADER']._serialized_start=239
   _globals['_HTTPHEADER']._serialized_end=279
 # @@protoc_insertion_point(module_scope)
```

## sylk/types/google/rpc/status_pb2.py

```diff
@@ -10,19 +10,19 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from google.protobuf import any_pb2 as google_dot_protobuf_dot_any__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x17google/rpc/status.proto\x12\ngoogle.rpc\x1a\x19google/protobuf/any.proto\"N\n\x06Status\x12\x0c\n\x04\x63ode\x18\x01 \x01(\x05\x12\x0f\n\x07message\x18\x02 \x01(\t\x12%\n\x07\x64\x65tails\x18\x03 \x03(\x0b\x32\x14.google.protobuf.AnyBa\n\x0e\x63om.google.rpcB\x0bStatusProtoP\x01Z7google.golang.org/genproto/googleapis/rpc/status;status\xf8\x01\x01\xa2\x02\x03RPCb\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x17google/rpc/status.proto\x12\ngoogle.rpc\x1a\x19google/protobuf/any.proto\"N\n\x06Status\x12\x0c\n\x04\x63ode\x18\x01 \x01(\x05\x12\x0f\n\x07message\x18\x02 \x01(\t\x12%\n\x07\x64\x65tails\x18\x03 \x03(\x0b\x32\x14.google.protobuf.AnyB_\n\x0c\x63om.sylk.rpcB\x0bStatusProtoP\x01Z7google.golang.org/genproto/googleapis/rpc/status;status\xf8\x01\x01\xa2\x02\x03RPCb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'google.rpc.status_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'\n\016com.google.rpcB\013StatusProtoP\001Z7google.golang.org/genproto/googleapis/rpc/status;status\370\001\001\242\002\003RPC'
+  DESCRIPTOR._serialized_options = b'\n\014com.sylk.rpcB\013StatusProtoP\001Z7google.golang.org/genproto/googleapis/rpc/status;status\370\001\001\242\002\003RPC'
   _globals['_STATUS']._serialized_start=66
   _globals['_STATUS']._serialized_end=144
 # @@protoc_insertion_point(module_scope)
```

## sylk/types/sylk/io/service_config_pb2.py

```diff
@@ -10,15 +10,15 @@
 
 _sym_db = _symbol_database.Default()
 
 
 from sylk.types.google.rpc import code_pb2 as google_dot_rpc_dot_code__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1csylk/io/service_config.proto\x12\x07sylk.io\x1a\x15google/rpc/code.proto\"\\\n\rServiceConfig\x12\x1d\n\x15load_balancing_policy\x18\x01 \x01(\t\x12,\n\rmethod_config\x18\x02 \x03(\x0b\x32\x15.sylk.io.MethodConfig\"\xb5\x04\n\x0cMethodConfig\x12.\n\x04name\x18\x01 \x01(\x0b\x32 .sylk.io.MethodConfig.MethodPath\x12\x37\n\x0cretry_policy\x18\x02 \x01(\x0b\x32!.sylk.io.MethodConfig.RetryPolicy\x12\x16\n\x0ewait_for_ready\x18\x03 \x01(\x08\x12\x0f\n\x07timeout\x18\x04 \x01(\t\x12!\n\x19max_request_message_bytes\x18\x05 \x01(\x05\x12\"\n\x1amax_response_message_bytes\x18\x06 \x01(\x05\x12?\n\x10retry_throttling\x18\x07 \x01(\x0b\x32%.sylk.io.MethodConfig.RetryThrottling\x1a-\n\nMethodPath\x12\x0f\n\x07service\x18\x01 \x01(\t\x12\x0e\n\x06method\x18\x02 \x01(\t\x1a\x9f\x01\n\x0bRetryPolicy\x12\x14\n\x0cmax_attempts\x18\x01 \x01(\x05\x12\x17\n\x0finitial_backoff\x18\x02 \x01(\t\x12\x13\n\x0bmax_backoff\x18\x03 \x01(\t\x12\x1a\n\x12\x62\x61\x63koff_multiplier\x18\x04 \x01(\x01\x12\x30\n\x16retryable_status_codes\x18\x05 \x03(\x0e\x32\x10.google.rpc.Code\x1a:\n\x0fRetryThrottling\x12\x12\n\nmax_tokens\x18\x01 \x01(\x01\x12\x13\n\x0btoken_ratio\x18\x02 \x01(\x01\x42\x43ZAgithub.com/sylk-build/sylk-io/types/service_config;service_configb\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1csylk/io/service_config.proto\x12\x07sylk.io\x1a\x15google/rpc/code.proto\"\\\n\rServiceConfig\x12\x1d\n\x15load_balancing_policy\x18\x01 \x01(\t\x12,\n\rmethod_config\x18\x02 \x03(\x0b\x32\x15.sylk.io.MethodConfig\"\xb5\x04\n\x0cMethodConfig\x12.\n\x04name\x18\x01 \x03(\x0b\x32 .sylk.io.MethodConfig.MethodPath\x12\x37\n\x0cretry_policy\x18\x02 \x01(\x0b\x32!.sylk.io.MethodConfig.RetryPolicy\x12\x16\n\x0ewait_for_ready\x18\x03 \x01(\x08\x12\x0f\n\x07timeout\x18\x04 \x01(\t\x12!\n\x19max_request_message_bytes\x18\x05 \x01(\x05\x12\"\n\x1amax_response_message_bytes\x18\x06 \x01(\x05\x12?\n\x10retry_throttling\x18\x07 \x01(\x0b\x32%.sylk.io.MethodConfig.RetryThrottling\x1a-\n\nMethodPath\x12\x0f\n\x07service\x18\x01 \x01(\t\x12\x0e\n\x06method\x18\x02 \x01(\t\x1a\x9f\x01\n\x0bRetryPolicy\x12\x14\n\x0cmax_attempts\x18\x01 \x01(\x05\x12\x17\n\x0finitial_backoff\x18\x02 \x01(\t\x12\x13\n\x0bmax_backoff\x18\x03 \x01(\t\x12\x1a\n\x12\x62\x61\x63koff_multiplier\x18\x04 \x01(\x01\x12\x30\n\x16retryable_status_codes\x18\x05 \x03(\x0e\x32\x10.google.rpc.Code\x1a:\n\x0fRetryThrottling\x12\x12\n\nmax_tokens\x18\x01 \x01(\x01\x12\x13\n\x0btoken_ratio\x18\x02 \x01(\x01\x42\x43ZAgithub.com/sylk-build/sylk-io/types/service_config;service_configb\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'sylk.io.service_config_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
 
   DESCRIPTOR._options = None
```

## Comparing `sylk-0.2.0.dist-info/LICENSE` & `sylk-0.3.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `sylk-0.2.0.dist-info/METADATA` & `sylk-0.3.0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: sylk
-Version: 0.2.0
+Version: 0.3.0
 Summary: sylk CLI build, deploy and manage gRPC microservices.
 Author-email: Sylk Developers <contact@sylk.build>
 License: Copyright (c) 2023 sylk.build
         
         Permission is hereby granted, free of charge, to any person obtaining
         a copy of this software and associated documentation files (the
         "Software"), to deal in the Software without restriction, including
@@ -136,25 +136,28 @@
 
 After you are under the new project directory you can go ahead and [create sylk.build resources](./docs/source/commands/commands.md#sylk-generate) with those simple commands:
 
 > __Note__ Please note that every sub-command of `generate` and `new` can be shortend with the first letter e.g : `sylk g p` is equivalent to `sylk generate package`
 
 ```sh
 # Generate new package to hold messages
-sylk generate package
+sylk generate package foo.bar.v1
 # Generate new service to hold RPC's (Methods)
-sylk generate service
+sylk generate service foo.bar.v1.SomeService
 # Generate message under specified package
-sylk generate message
+sylk generate message foo.bar.v1.SomeMessage
 # Generate RPC (Method) under specified service
-# Same as running `sylk g r`
-sylk generate rpc
+# Same as running `sylk g r foo/bar/v1/SomeService/GetSomething`
+sylk generate rpc foo.bar.v1.SomeService.GetSomething
 ```
-> __Note__ Make sure before creating new RPC on service that you have imported at least 1 package to be used by the service. for more information visit -> [Package Docs](https://docs.sylk.build/cli/resources/package)
+<!-- > __Note__ Make sure before creating new RPC on service that you have imported at least 1 package to be used by the service. for more information visit -> [Package Docs](https://docs.sylk.build/cli/resources/package) -->
 
+> __Note__ Passing full resource paths can be used with __'/'__ to resamble the filesystem paths or __'.'__ seperators as native protobuf syntax, both act the same.
+
+> __Note__ You can create resource with thier full paths or just with passing the resource name itself, the CLI prompter will ask you which parent you want to attach the new resource.
 
 After you had generated your resources for the project and modified the code (See the docs for more explanation on how to develop your project and make changes [Sample Project](https://docs.sylk.build/cli/quick-start)).
 
 You can now [build your project](https://docs.sylk.build/cli/commands#build) and [run your server](https://docs.sylk.build/cli/commands#run) with those simple commands:
 
 ```sh
 # First build your project
```

## Comparing `sylk-0.2.0.dist-info/RECORD` & `sylk-0.3.0.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -6,180 +6,238 @@
 docs/build/_downloads/9a3170560eff0e8080a7006943761820/PubSubTs.template.py,sha256=TUJptneqPJjpVyPhVwyoIaabjiQ6LWdTLksIdhn3JiY,42938
 docs/build/_downloads/a8af61e20b3888c79a5cc6ff79c43632/HelloWorldPy.template.py,sha256=BbjFjDPs3uerhPSknBuXLICVBwa2VqZScZjJ8_qhnek,13027
 docs/build/_downloads/cb75f7c5c4638fa0c1e352dc3e3ce4c7/HelloWorldTs.template.py,sha256=_Vj2A-pra8qCZr2WBUvVz3XGcAk7EEFV5e_ORY8A2hw,13715
 docs/build/html/_downloads/29a3c68eabc4dfce3cc2b8f28cbf7499/test.py,sha256=wr6fFQdeXx1JQleaLLWg5kNTD44WgAk4kHDz2DwFOm0,8617
 docs/build/html/_downloads/9a3170560eff0e8080a7006943761820/PubSubTs.template.py,sha256=TUJptneqPJjpVyPhVwyoIaabjiQ6LWdTLksIdhn3JiY,42938
 docs/build/html/_downloads/a8af61e20b3888c79a5cc6ff79c43632/HelloWorldPy.template.py,sha256=BbjFjDPs3uerhPSknBuXLICVBwa2VqZScZjJ8_qhnek,13027
 docs/build/html/_downloads/cb75f7c5c4638fa0c1e352dc3e3ce4c7/HelloWorldTs.template.py,sha256=6AY6jx7Ye77B9q7Zya_uVALqqErHrB3CXifUOCTHI9Y,13711
-docs/source/conf.py,sha256=hWbspWPW-VypJf8Qia7k3T_iZrkfGsjFJwXv3SsdKqc,1274
+docs/source/conf.py,sha256=rW7xnUdiVappdEd7iMhXmr3tlZvydXCuPL1pb93-o4w,1274
 sylk/__init__.py,sha256=BRWkL28TZbJ_ofHDXI3uOAae63Tnd58kJmGyFqP3v68,339
-sylk/__version__.py,sha256=clN3TnyYyt5T_wUJLVBmutS2kYLLBET4JFB2QXnRm2Q,21
-sylk/config.py,sha256=DrIcs5bIeqYeNP0ICWj-028kUSKhngTxRq3NPo63Wx0,708
-sylk/architect/__init__.py,sha256=GQQN9brS2XXx0FGCnBi0MUGoyc4MuKBUl-mwn7SF1WQ,10921
+sylk/__version__.py,sha256=gTggO06fb2c9XKEwlQYUSPlUfy82yVlM9pzLMOUqVcY,21
+sylk/config.py,sha256=xwD94uC-xq64U0byaZWJahQVoGrva1KdOt2u5Zj-jLc,758
+sylk/architect/__init__.py,sha256=zW3ZBXUyVXMYK9O-VSC3svQiV3diFhJJX-1EaDN5rMw,14295
 sylk/architect/commands.py,sha256=32gLlEsuDQAiGUfxbsJiM3Ah1QyXKUXnAJAt8UezBds,3059
 sylk/architect/hooks.py,sha256=K_aoreSwTsNINBrWVdQqAOR1p64DfNjf0oYviT1WZlk,1226
-sylk/architect/invoker.py,sha256=tp4dmWLWYSZpmJS6CXzt9IJ92dtQDSH-XIVLQtxT7P4,13049
+sylk/architect/invoker.py,sha256=umlfFv94zAv_pTdNdK_D6mvqHc4PJYczC-irGTIaTqo,13525
 sylk/architect/interfaces/__init__.py,sha256=e3Xgq335FGWafgtQxjR0Yw3CTlQhO5Sjq-0y5wyjaSk,1677
-sylk/architect/recievers/__init__.py,sha256=51ZbM8gtD9KfefXPdCY91rBSK5ZSnTdZ9D2Jk9IBQOw,12201
+sylk/architect/recievers/__init__.py,sha256=EmN3neUcDudRGSuHk_QX6nigS11cz3iF2H15cvKA7tE,13656
 sylk/builder/__init__.py,sha256=FeqErUd6s-eKvFvbM5jsarqgDku2fX_pnQcl0HB7nZU,186
-sylk/builder/plugins/SylkBase.py,sha256=_OWx4x5yFR_bfTNmhTTH3zYRjYBinAlrJ8uzW5_QZ6Y,4843
-sylk/builder/plugins/SylkGoClient.py,sha256=iJR2pLjf2ECOEgrAQjdJN8wLvXAh6XAXBmcnE7hBhGY,8117
-sylk/builder/plugins/SylkGoServer.py,sha256=cb78-KJMICMF33CDwig0BE5R6ni8l8f5-iXejj9WfiA,9117
-sylk/builder/plugins/SylkJsClient.py,sha256=AScl09JAKYIl0CWny-1V7xViyNWcxVKcgdlYkLvPBn4,8512
-sylk/builder/plugins/SylkJsServer.py,sha256=YKCQGmVd-iv2wDTIyOPrU1yNDLiFpyLU5BudzEs2mqI,6605
-sylk/builder/plugins/SylkMigrate.py,sha256=YcAoaENNXHVchu8-qX0oCZ4O_rbqEbnKAWxWbl_L-SM,20000
-sylk/builder/plugins/SylkPlugins.py,sha256=3xQntpSDgBU7N8BYRI36k-ZCmxRn8y3GGTZqC_W_bQY,2042
-sylk/builder/plugins/SylkProto.py,sha256=YWRWQiVByyu098hwNXqTSSDw3rAFVkmHz6sAMQNSNJE,6962
-sylk/builder/plugins/SylkPyClient.py,sha256=7iUXF_8OYoPjE3Wk3ORBVIJZnrJcRXrNRh71vZZ2SSU,18111
-sylk/builder/plugins/SylkPyServer.py,sha256=I3bzvrLFl20ZwX9Ioas6Xa2JKAOH5Uenngcec5mTMos,22473
-sylk/builder/plugins/SylkReadme.py,sha256=OzU7k3JmiUr3PXlwk_xlfn6Z_QS-5YZycRVGuN184Zw,8729
-sylk/builder/plugins/SylkTsClient.py,sha256=V0hPELSFhLDzVor3EoHXtGKL0vP6nXModj9sOAgj-Vk,10496
-sylk/builder/plugins/SylkTsServer.py,sha256=8DbAsmEHoVxN6hb6tos8n4b9PwLEUQ-grR3uU8oR9xU,17277
+sylk/builder/plugins/SylkBase.py,sha256=iOPEpdKhE1C-IwFArbU-6qOp5reoyFLXCnMQiUdax94,4870
+sylk/builder/plugins/SylkGoClient.py,sha256=6UOSsRt2i6m4eKcM9eao5jjohiWEYV9dZKlbAZkIu44,8509
+sylk/builder/plugins/SylkGoServer.py,sha256=ly-R6YMw8ZBh0SSI1f9ZwCc7ciS8PZnMm-YgpsUli60,10833
+sylk/builder/plugins/SylkJsClient.py,sha256=MVi3X51g3VMjf9qx6KQ0DLz92jGHFcYuOanANK9uiaI,9940
+sylk/builder/plugins/SylkJsServer.py,sha256=A--oUILzT8X61nLv-nSuyAEScUretq3Y-HqY__8-nxA,7071
+sylk/builder/plugins/SylkMigrate.py,sha256=qRktoWaQagz_4RbrAW3rPPWgvq9ayLtmGUJ35WvjFx4,25917
+sylk/builder/plugins/SylkPlugins.py,sha256=pi1xq8abIWM0coBL7Ey_rWU93fezjg-s9xk75CdeApw,2039
+sylk/builder/plugins/SylkProto.py,sha256=Mn9-uVCqoTvfl4REPzHbahTnV02OROuCas9oYgakzMY,15394
+sylk/builder/plugins/SylkPyClient.py,sha256=70kWyeRAuGi9Yp6u4O9j-ufP0Wx6t0uNyIeYQJfG-Wc,23411
+sylk/builder/plugins/SylkPyServer.py,sha256=Z0oRCrtIPJ0cz-dFsDMVJ2C2SxE6snrOifOXGYqBzhI,24221
+sylk/builder/plugins/SylkReadme.py,sha256=L8RbtcwxQr9lajCiqSemMgbXjQVQ--B4PY3xCup4jjo,9288
+sylk/builder/plugins/SylkTsClient.py,sha256=8rZWqFt0uRoR2Bfj3Vk_IeeKeoPAGfU_l4FzqrqSCsw,12058
+sylk/builder/plugins/SylkTsServer.py,sha256=sXbHgT_Uy3cOpuzaJemziTysP_ElrvQGGKi9gAKoXeI,18541
 sylk/builder/plugins/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/builder/plugins/static.py,sha256=LiY_4OsWR3hro3kc_mi1VedFnEW1hQzKVkLWCARdoTw,25419
+sylk/builder/plugins/static.py,sha256=mjW8FkWflQarIfhX22eBebmRSif7aigqqVBDdK3IytQ,26758
 sylk/builder/src/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/builder/src/hookspecs.py,sha256=PSp0SPqlSJg8OVUxxP5y3tnd3sW9AuO0aTLI8OHP7bE,4747
 sylk/builder/src/lru.py,sha256=WEKTvoRB0gtXCreFKQgVp7bC40o2qjlHlE5mgLZNsqU,967
 sylk/builder/src/main.py,sha256=TK1jhMhzg_FBjErEA3ivJi0sKKuWSEJDLP2lGnCZodw,19326
 sylk/cli/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/cli/__main__.py,sha256=FCIui7OdkZGrp95YHXePW4cl0a4FKniljB0YlS1kJ9M,1140
-sylk/cli/main.py,sha256=j1SQWokyyG0gqNlj_xqbD0rtlv0xxrf1t21jQunPBsA,48204
+sylk/cli/main.py,sha256=I4IbmbPl8nXqDIGMXplzBVOFFf8bf5HTk9lFTeTb3W8,60277
 sylk/cli/prompter.py,sha256=WRQXRtE1TgzjEI5uAHfvqDXrEBUsuVMsBLQ9rF5hjLI,13242
 sylk/cli/theme.py,sha256=uMGuZ8ntcxj2e2cuJFXtpHf8WeOs_l-Aig03jKFD92Q,2226
 sylk/cli/commands/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/cli/commands/build.py,sha256=Jof3id-SVV2gjCSC9rwsfrcgacyUbBqGYdhC6h2Dzwk,1935
-sylk/cli/commands/call.py,sha256=XIgys9iF5YTC7OE2omra1OlA7VbSBwQHBpcf8rj64sk,9482
-sylk/cli/commands/cloud.py,sha256=LHjIaFJ2xFUc7Q7idRpwi3PebXkEMB5PDlWMea2gkFA,10048
+sylk/cli/commands/call.py,sha256=Mq5vrGi7WEnsPp5QIDK358KBZUkBqPyk5y1JGiL1578,10142
+sylk/cli/commands/cloud.py,sha256=ySv-3e2uAoE0joa6OSI0W7vCBxQeayfM3HRa-aAa52c,11930
 sylk/cli/commands/config.py,sha256=wDiRRazkTSEGYqZ3r0XeV5OnBLH824Tzv3NrFCfTVkM,1983
-sylk/cli/commands/edit.py,sha256=rivbLODohO5ceTQU1g62zJKxhbUhq2KDnEgWrtE1PTg,52542
+sylk/cli/commands/edit.py,sha256=SQyJ-HMgjAfUmCIp4VBT31hNUnRUWQlomT04CI_pdjw,55267
 sylk/cli/commands/extend.py,sha256=SoBSWrZfv432E6oBHsFzTDukhof5GOx-Xe7qZ-Bt8JM,21960
-sylk/cli/commands/generate.py,sha256=jWYNWxsGNLb--FPeJLm5gPZpUwv6v-8CutUE7FMSrp0,28166
-sylk/cli/commands/ls.py,sha256=T1K1eZFiMgMAJRFELGEvLTCFs5RHI4Rw4nft4hTtc2Y,20355
+sylk/cli/commands/generate.py,sha256=pr06WPZgN8a4Fq9y6OO7h7XBpHAhj9RVqX1aFIdSLe0,41708
+sylk/cli/commands/ls.py,sha256=iF58Tl90SuvfVnpzRT_7iAsX9dhK0AcJK1b3YBoWUP0,20520
 sylk/cli/commands/migrate.py,sha256=zac618LkLPUaC2hAuR2wGjN-i7kW0gL_9eva9sa_SsM,2257
-sylk/cli/commands/new.py,sha256=USZITkQYDForA8aejFzJO9gL2m43GW_MApG9OD4RCEc,12496
-sylk/cli/commands/package.py,sha256=L3pWKoxowfsz6RmltSYE7yZK9KrH6tGKDq6YulB92Iw,5718
-sylk/cli/commands/plugin.py,sha256=LrdGazXV4tELlbyq4674vWHLhIq51sA7OXPJOR325d8,2946
-sylk/cli/commands/run.py,sha256=uTTo8oz0pIBDApUOyC4nR38skN9oVgWcmFgunlkXl4A,1506
+sylk/cli/commands/new.py,sha256=o_3b6cnHotFlkCY5bHeHUjg3S702yeQCg8vWuJD9D8k,15923
+sylk/cli/commands/package.py,sha256=T-U1dj4mdMnu0-gQKaws5Qed8xCORXZ68WA6A-mOCvo,6923
+sylk/cli/commands/plugin.py,sha256=NYSvIF-IdrDz0hLVLYNwPKp4RmW-Z__4Q4Sy5gjdanc,3689
+sylk/cli/commands/run.py,sha256=5I4wir4wcSpk64QzPS7KUtLK5VGMH9iOARjmxFQiB9M,1498
 sylk/cli/commands/template.py,sha256=-ITffseYqu4lOkPPjbLdjsiVqZjRl6Ue-QHeG1MzOaI,28044
 sylk/commons/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/client_wrapper.py,sha256=lu6qtvshqLz2oSiUBuyButuYMsQb_cRODdZzGGaiW5k,2158
-sylk/commons/config.py,sha256=zLi-pd8dIC7QKsjpnxYzVyrRD7E1mWzDC5_tWYuTPDQ,10568
-sylk/commons/errors.py,sha256=A_5LTNbUWCXxypCfUqVlD47URtHHr0ac70sZghF3RAg,2312
-sylk/commons/file_system.py,sha256=UHwq42RLrJ65oI78h8bTW6L7U8IoLB2iXiol8HYIhJ0,4370
-sylk/commons/helpers.py,sha256=VS-0PYseIFqGL4vijAD1a-CD2FoOkii6n1TTqMr0gag,124286
-sylk/commons/interceptors.py,sha256=TMoVbA_GvBh_7Q1TRilVke70Apg7APzLdyLwequNg5M,8125
+sylk/commons/config.py,sha256=9i4aalt6acKowaavOk6p3JEcR-EPiYD47YfxUOKu4bc,10725
+sylk/commons/errors.py,sha256=4PopwtMC0GJH9mfShPreM_Z-OP3CA4f1HQy9f_wulUI,2315
+sylk/commons/file_system.py,sha256=YqZ1vO9nTOyzgHxdR35xMcYSvVMCUMH_TVhpGtHuku4,4882
+sylk/commons/helpers.py,sha256=ui4vkFpovAkGM-xNM59BPuS8sKkQbaL5E5vwoyHDO7U,207688
+sylk/commons/interceptors.py,sha256=hHNkZVIToQnJdZHnMJTVkzi6VK9EXz2FCqD4532rQ-4,9426
 sylk/commons/parser.py,sha256=zYJY3MaLZX_3aI6-6UVO5bpSTQb6g8JH9i-mMwaFXL8,2711
 sylk/commons/pretty.py,sha256=VZXtTak3cqSk1V7sSiZryHDfePJF9RT_YJ3XCDivrDY,2665
-sylk/commons/resources.py,sha256=nKzfWpsEMkaGF11iYq6WgssOZiG5X8rmtEw6YwOagtY,38542
-sylk/commons/sylk.py,sha256=dJILIBqhCZbA90KfUJuWuBi1q0Hq_jC8Hw2s2qfwdso,543
-sylk/commons/protos/__init__.py,sha256=x4_ta-UvmMpL2Exz15HDmYHNsXJMfdiOL89qOmUUE6I,31998
+sylk/commons/resources.py,sha256=b89vdfhpiNKPai4c1K3AltkWTT_ofU1d0wwAhFH3M9k,46086
+sylk/commons/sylk.py,sha256=bqOvBSsbXHuhBW_H7K4oEu1ZUPScqNG015nXvTk_uHU,33801
+sylk/commons/modules/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/modules/google/__init__.py,sha256=E8y50_PqsVlJ1L76bXZgR-DeZNTxxl9ju643IsqsRkc,1812
+sylk/commons/protos/__init__.py,sha256=q2B6BiwCUvFvYhwcFobYvkTRvCHxDfCCklMwHOvquvY,73411
 sylk/commons/protos/sylk/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Activities/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Activities/v1/Activities_pb2.py,sha256=va3S7wz5cj0NrTlH0vE7uMBkhOJhagTcO_Ym3NAAEOI,1443
+sylk/commons/protos/sylk/Activities/v1/Activities_pb2_grpc.py,sha256=fx7FENhhOcMh4jiZVS7pa6_G4ljdUGnUlS45qCy5Up4,4570
+sylk/commons/protos/sylk/Activities/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/ActivityLog/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/ActivityLog/v1/ActivityLog_pb2.py,sha256=FBbQQ5y_AA5xjQg6APS3vmC4rqY0_z2njtsgl_7S6HE,4837
+sylk/commons/protos/sylk/ActivityLog/v1/ActivityLog_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
+sylk/commons/protos/sylk/ActivityLog/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/EnumValues/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/EnumValues/v1/EnumValues_pb2.py,sha256=vNOSx6tlyJstN4mxNvaI3v-OWPKO-GYPDYI4qSlkxls,1800
-sylk/commons/protos/sylk/EnumValues/v1/EnumValues_pb2_grpc.py,sha256=PVQjF0A-iQMzRcmcbr6-i08spz4fb98OpKJ-FUSADRI,7744
+sylk/commons/protos/sylk/EnumValues/v1/EnumValues_pb2.py,sha256=lDBu-Lkbm-JWPobeF9Yo7EErI0ai8LI7ztFjh2J2LxA,1649
+sylk/commons/protos/sylk/EnumValues/v1/EnumValues_pb2_grpc.py,sha256=6prWAXyQLKbFBmuaNqkZefGqSD-loA7PFVZorm9YYiQ,7915
 sylk/commons/protos/sylk/EnumValues/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/EnumValues/v2/EnumValues_pb2.py,sha256=T6Pj4v_0LAPaJC4KYy4d73I8jw6gkAyKscVtjHCgXT0,3749
+sylk/commons/protos/sylk/EnumValues/v2/EnumValues_pb2_grpc.py,sha256=ynuzjnpzFS7l8n-z6oCpSfjzzgLobgDikmVsym8kvzU,8057
+sylk/commons/protos/sylk/EnumValues/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/Enums/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/Enums/v1/Enums_pb2.py,sha256=DaJnnq2O1zAzpj7rra9KV7etQ475qlDYmRozWHEHr-g,1672
-sylk/commons/protos/sylk/Enums/v1/Enums_pb2_grpc.py,sha256=z1oLjXBRpfPIQBuDw6JK3I8oVANYTe4Yj3p9ECVU6Go,7419
+sylk/commons/protos/sylk/Enums/v1/Enums_pb2.py,sha256=eZpI-yQ5Fl2sIfjvy42qhZN2YF_A3RYPlMsxxoTj3Qk,1524
+sylk/commons/protos/sylk/Enums/v1/Enums_pb2_grpc.py,sha256=B6-xkEXG_U3rv7ys6WMBqcJo9Qi8Ws4QvsJcwr8-dJM,7545
 sylk/commons/protos/sylk/Enums/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Enums/v2/Enums_pb2.py,sha256=w58WVkMJZlfeJFZvU-KAiiV3NwleIYZsmRm9vbqoTxU,3409
+sylk/commons/protos/sylk/Enums/v2/Enums_pb2_grpc.py,sha256=yO2mf5pUJ_T9M4vET78Mi_XLF0E_qRwiMclZWq_ATSs,7472
+sylk/commons/protos/sylk/Enums/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/Fields/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/Fields/v1/Fields_pb2.py,sha256=uXKkPnvKS4--5txD_l3P7vk1fhLc_h2Wji7zgiItwgQ,1704
-sylk/commons/protos/sylk/Fields/v1/Fields_pb2_grpc.py,sha256=lLjrk6483pyrERXiAX7Zr_Bf4rUstRMH_fQXUJ978fY,7484
+sylk/commons/protos/sylk/Fields/v1/Fields_pb2.py,sha256=_w_Y0TGUhmauc6C4ylNzRszb11UzeuLdIMFgetxKWt8,1557
+sylk/commons/protos/sylk/Fields/v1/Fields_pb2_grpc.py,sha256=G0C0rl7-Mn_TO0mcJ8sfTxGNGyp8voeE7mCnBYDVH0E,7619
 sylk/commons/protos/sylk/Fields/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Fields/v2/Fields_pb2.py,sha256=STShfSwlhMH37vaI4mfLPItAttD_pX7oC3Xc1IFBSSk,3542
+sylk/commons/protos/sylk/Fields/v2/Fields_pb2_grpc.py,sha256=h735pb12NGuMB1wW7mu-mTfCekngpGxQLVzVn2AEE5g,7589
+sylk/commons/protos/sylk/Fields/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Folders/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Folders/v2/Folders_pb2.py,sha256=FIUYwMRyHYKmIizWehgWu4A_SmflrETeMXdiV_k0VeU,3548
+sylk/commons/protos/sylk/Folders/v2/Folders_pb2_grpc.py,sha256=bLII0qAs1OnMe8vCOOKiviDuy4r7ilz8UrKX9gExleY,9227
+sylk/commons/protos/sylk/Folders/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Integrations/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Integrations/v2/Integrations_pb2.py,sha256=XW2bjERR1Uc1jp0wtkyurJtV3FGSeBwQy2pJlVA3BYs,1991
+sylk/commons/protos/sylk/Integrations/v2/Integrations_pb2_grpc.py,sha256=2bAboySoyqVidf5MuBnFuegOo_VlQhR69HI5IwlVNaY,2827
+sylk/commons/protos/sylk/Integrations/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/Messages/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/Messages/v1/Messages_pb2.py,sha256=mZveihdCiOWxU-7LgPasjK6mPM8A-bRcLlzTHE7vqnE,1731
-sylk/commons/protos/sylk/Messages/v1/Messages_pb2_grpc.py,sha256=U8qnHAFbJKv5_rziZgJ-pu1uJOYtENSXvU1CdtupfgA,7614
+sylk/commons/protos/sylk/Messages/v1/Messages_pb2.py,sha256=bLmjPGbyiFxSQ3HASDKSesL-Kf7M8V5izZysCTUSivk,1582
+sylk/commons/protos/sylk/Messages/v1/Messages_pb2_grpc.py,sha256=24mWd-9z3L0sIjIYW1hkaPhocXcISqduMlOfLNaVYcU,7767
 sylk/commons/protos/sylk/Messages/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Messages/v2/Messages_pb2.py,sha256=CJkszw085-tB6X6mCXQfabTDQMywUEP--EEPp9oCB1w,3726
+sylk/commons/protos/sylk/Messages/v2/Messages_pb2_grpc.py,sha256=aJsAehpZAAgI_GxMbSqmVYuONdJ_jvNvaIcZpBRa-uE,7823
+sylk/commons/protos/sylk/Messages/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/Methods/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/Methods/v1/Methods_pb2.py,sha256=lfEWWhdUiQ3_yqTRBrGW-WCMS9m6WzCOL-dT8Wx01gY,1723
-sylk/commons/protos/sylk/Methods/v1/Methods_pb2_grpc.py,sha256=bdnnTcrydo2Hh2H72VgzrHFea7G5qAl4cGReAzfGfKQ,7549
+sylk/commons/protos/sylk/Methods/v1/Methods_pb2.py,sha256=x8Xs_Ry7mZ1tJmgla913uYqmVRLhCdbjtD418lV4xTY,1575
+sylk/commons/protos/sylk/Methods/v1/Methods_pb2_grpc.py,sha256=-gcC79R4f6J8OOPirUHNMFTzb65SIk6A4aH-GBySLkM,7693
 sylk/commons/protos/sylk/Methods/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Methods/v2/Methods_pb2.py,sha256=kwWJITPQSB3DBB2Uv8dDvlOqHtpo-2LSJUYf4gdCYYk,3394
+sylk/commons/protos/sylk/Methods/v2/Methods_pb2_grpc.py,sha256=aE1D2dTVihcd42ZP-okvBKu1GonEnV-v7pDValjLAB4,7706
+sylk/commons/protos/sylk/Methods/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/Organizations/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/Organizations/v1/Organizations_pb2.py,sha256=3VqEQvv0mDr79ZSBM-emS8DX8mxHuzm4MCMtCRw_j2c,2294
-sylk/commons/protos/sylk/Organizations/v1/Organizations_pb2_grpc.py,sha256=pih1lOQHj-fRKVsotKwXFTFRoJGcHP3Ry0J0zohBo9c,14552
+sylk/commons/protos/sylk/Organizations/v1/Organizations_pb2.py,sha256=VkoUBQwjUq2gAQokUnDFrfaRBVBWZ8ZOaQH1Hx6IrPs,2141
+sylk/commons/protos/sylk/Organizations/v1/Organizations_pb2_grpc.py,sha256=VclYI_TtlmF6Cy3a9b8hk9kqQcvDUawxnQrX9F-LiFw,14926
 sylk/commons/protos/sylk/Organizations/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/Packages/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/Packages/v1/Packages_pb2.py,sha256=ex_6EoPnk5uMEB2TP2REwP-W4pBOUB0ruMWuELrRnAI,1846
-sylk/commons/protos/sylk/Packages/v1/Packages_pb2_grpc.py,sha256=Ddufk63ZK9itWhyz68vISYV_Mola3hFiL5MSZuGhZXo,9268
+sylk/commons/protos/sylk/Packages/v1/Packages_pb2.py,sha256=WCkmP7ta2YHh3yX4RBHsYQYrE_5j9mxmhYVfOe7QUMg,1694
+sylk/commons/protos/sylk/Packages/v1/Packages_pb2_grpc.py,sha256=l9C4hVoiWPjM30MPZlT3-gQC_U_QIkd6uwQmMuIrPPk,9455
 sylk/commons/protos/sylk/Packages/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Packages/v2/Packages_pb2.py,sha256=bboJmV3Fi0r6cOgu6z2AbFNLQFTFSuuBpyv4keOr7Gk,3526
+sylk/commons/protos/sylk/Packages/v2/Packages_pb2_grpc.py,sha256=YmOlAQROP93b0ZlxsN0n3caEUmKg6eWSUetukTfJPEs,7823
+sylk/commons/protos/sylk/Packages/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/Projects/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/Projects/v1/Projects_pb2.py,sha256=ZiMMSyeClHwi6q7w9ma9pEHEmaA--IYvq0ZAOKjdRis,2304
-sylk/commons/protos/sylk/Projects/v1/Projects_pb2_grpc.py,sha256=N2CYbV-SDS6XdK13GGaczOwmGjjGJKNHRmpVkxNUCeM,16079
+sylk/commons/protos/sylk/Projects/v1/Projects_pb2.py,sha256=im2C_ZDJuu_YQYvJAMvuo1ja4BEfpnY9w1Tp2bokLH8,2155
+sylk/commons/protos/sylk/Projects/v1/Projects_pb2_grpc.py,sha256=17NzFXch5XGr2V_JQYaUT2uOk4PXxzB4IQLNtVtlNNQ,16402
 sylk/commons/protos/sylk/Projects/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/Services/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/Services/v1/Services_pb2.py,sha256=kVBeuh7HdeGrlzzJVpkgCkEPvCt2S35kAebsrzdNGVY,1840
-sylk/commons/protos/sylk/Services/v1/Services_pb2_grpc.py,sha256=YT-xsO_dwl1t4KBPxGnP_9XQcwNV_o5V-RpQLhpBYB4,9268
+sylk/commons/protos/sylk/Services/v1/Services_pb2.py,sha256=PGYoQBWUtos0-gNECjR0baeMBcGtnS_3uVno96UHN7g,1691
+sylk/commons/protos/sylk/Services/v1/Services_pb2_grpc.py,sha256=Lho2CVEhwkDul20gyKEI5qbsk1XO0XXGRcNuIvBkr14,9455
 sylk/commons/protos/sylk/Services/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Services/v2/Services_pb2.py,sha256=CT7gK5O0idlTBr1UaOVu031nk7b3grnaDI782owpkOU,3454
+sylk/commons/protos/sylk/Services/v2/Services_pb2_grpc.py,sha256=5_mlv49DGVGPIYzqmmbxCKdCYVBAflIFBUZSORiYXEY,7823
+sylk/commons/protos/sylk/Services/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/Sylk/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/Sylk/v1/Sylk_pb2.py,sha256=D2YAWfV_Xqy5y3RDDvDhhBke7PSOAP4f5ZOGLnPe0u4,3170
+sylk/commons/protos/sylk/Sylk/v1/Sylk_pb2.py,sha256=JDGlzRkKzicZaMEcnzhqQKfDB3ieE5gvJMLlsUz7IMM,3005
 sylk/commons/protos/sylk/Sylk/v1/Sylk_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/Sylk/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Sylk/v2/Sylk_pb2.py,sha256=MfOnvVG0YCSfi7U2mNLmakNLBpUwHjMCR2kGuD0ReiM,2730
+sylk/commons/protos/sylk/Sylk/v2/Sylk_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
+sylk/commons/protos/sylk/Sylk/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkApi/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkApi/v1/SylkApi_pb2.py,sha256=s4ug8o4pkIoydbCGB42_FJvOyEDGV3zWSqaXQqZwgL0,26682
+sylk/commons/protos/sylk/SylkApi/v1/SylkApi_pb2.py,sha256=smNaYzOGR71KR757P3ESteYzaMgDt5VVbDFUnL7rXMo,26511
 sylk/commons/protos/sylk/SylkApi/v1/SylkApi_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkApi/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkClient/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkClient/v1/SylkClient_pb2.py,sha256=tp5MY__YAbjbV2TRzF5xh3a2_BxICVwPzXRUXMUjufI,1641
+sylk/commons/protos/sylk/SylkClient/v1/SylkClient_pb2.py,sha256=N0GwCe2Y9Axi0Km7vS5T2K_P57yAqcOVH_uSawsc6uE,1461
 sylk/commons/protos/sylk/SylkClient/v1/SylkClient_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkClient/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkCommons/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkCommons/v1/SylkCommons_pb2.py,sha256=CGt-_uz7gC7X4QN0wxz4V9-0UvIvn39QdYzTdBTT45M,2198
+sylk/commons/protos/sylk/SylkCommons/v1/SylkCommons_pb2.py,sha256=o23j-vz_lIrypxtnneMuz0jGdh4oVuCXwEdsLRf1Ggc,2016
 sylk/commons/protos/sylk/SylkCommons/v1/SylkCommons_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkCommons/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkConfigs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkConfigs/v1/SylkConfigs_pb2.py,sha256=YtuTxcyCyDyUMFkDmVow6cJt-aVVlRVu5SS84435MRo,2447
+sylk/commons/protos/sylk/SylkConfigs/v1/SylkConfigs_pb2.py,sha256=RCYSz13x_8alZT6SbGvMArr9ZkumMXn9l7ItNo6I3X4,2440
 sylk/commons/protos/sylk/SylkConfigs/v1/SylkConfigs_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkConfigs/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkEnum/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkEnum/v1/SylkEnum_pb2.py,sha256=0vZmeR9HSskd63gC7I_jCgJ1wMimuZS4MDMvjY6n6PA,2138
+sylk/commons/protos/sylk/SylkEnum/v1/SylkEnum_pb2.py,sha256=02cCNZBxiZROnURzAOHALUtfBkA4Ur0UkeQz5VxraL4,1965
 sylk/commons/protos/sylk/SylkEnum/v1/SylkEnum_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkEnum/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/SylkEnum/v2/SylkEnum_pb2.py,sha256=Pn3ASLsCnY7k9yi7WJObCR2_CKKlEaDKfvgaXTMoe4I,2028
+sylk/commons/protos/sylk/SylkEnum/v2/SylkEnum_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
+sylk/commons/protos/sylk/SylkEnum/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkEnumValue/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkEnumValue/v1/SylkEnumValue_pb2.py,sha256=voKet_yugiURlxuAM28dhw_ww9QsaZ9329eOEeeGgmk,2039
+sylk/commons/protos/sylk/SylkEnumValue/v1/SylkEnumValue_pb2.py,sha256=MOhGloER4yaI7nxbt5oPPJLMCbN3JLH1iMVpjv9CdPs,1856
 sylk/commons/protos/sylk/SylkEnumValue/v1/SylkEnumValue_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkEnumValue/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkField/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkField/v1/SylkField_pb2.py,sha256=75-zr_zDXVCtrFPm0lKmy_6djBQ8KC5tdUHbOe0XDq8,4599
+sylk/commons/protos/sylk/SylkField/v1/SylkField_pb2.py,sha256=YYwGd3KZHN9fniNudwkcCUHi8KMYZo7XS-cMyk15Kgw,4516
 sylk/commons/protos/sylk/SylkField/v1/SylkField_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkField/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkMessage/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkMessage/v1/SylkMessage_pb2.py,sha256=zZWBJlrJXv_EU_r2b5PYNZF8cEU0MWEDpWawiXzwKY8,2996
+sylk/commons/protos/sylk/SylkMessage/v1/SylkMessage_pb2.py,sha256=bVTPWAwlkE3nOSbQOtJpkKUCdfKw6FS-pucvT0A4_No,2811
 sylk/commons/protos/sylk/SylkMessage/v1/SylkMessage_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkMessage/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/SylkMessage/v2/SylkMessage_pb2.py,sha256=XneFWHwJZ3Wl_jRiyMZO5n8EbSdtmUZer2g-vO4WRAA,3041
+sylk/commons/protos/sylk/SylkMessage/v2/SylkMessage_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
+sylk/commons/protos/sylk/SylkMessage/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkMethod/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkMethod/v1/SylkMethod_pb2.py,sha256=IsXJg3tZG2_IBUyiOxwYJEZnLRHPm5XAqUrXgl_NR8Q,2671
+sylk/commons/protos/sylk/SylkMethod/v1/SylkMethod_pb2.py,sha256=XxbmDj6Efz1LgZbmgZI7rdidXlRgJWRUEix2gnu70Dc,2518
 sylk/commons/protos/sylk/SylkMethod/v1/SylkMethod_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkMethod/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkOrganization/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkOrganization/v1/SylkOrganization_pb2.py,sha256=qhUm3X69wNXUGRlgsuxn64LqTjYR96FwWETtKGswSfQ,2137
+sylk/commons/protos/sylk/SylkOrganization/v1/SylkOrganization_pb2.py,sha256=ju6X9_L3d4s7VW1icTTPnW0nT5ul8sOikKAalzY9oEk,1948
 sylk/commons/protos/sylk/SylkOrganization/v1/SylkOrganization_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkOrganization/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkPackage/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkPackage/v1/SylkPackage_pb2.py,sha256=OTf5MNtE6PmKDJ-0auzCfXRP73Gkp59DxT5oaZQpH5Y,2995
+sylk/commons/protos/sylk/SylkPackage/v1/SylkPackage_pb2.py,sha256=fUkPT5V94VuLhCQckdLap_Qv0kfV12-IaSC1xUsZ5B8,2810
 sylk/commons/protos/sylk/SylkPackage/v1/SylkPackage_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkPackage/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/SylkPackage/v2/SylkPackage_pb2.py,sha256=mvsKF7pxd6337XyDxEMJ8LVVnq9iIQCN5UgPueGKDyM,3047
+sylk/commons/protos/sylk/SylkPackage/v2/SylkPackage_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
+sylk/commons/protos/sylk/SylkPackage/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkProject/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkProject/v1/SylkProject_pb2.py,sha256=Bh-0HKH4ZVkbvrh57QDC1nY86GakDTOCDtvbWJsrr9Y,3421
+sylk/commons/protos/sylk/SylkProject/v1/SylkProject_pb2.py,sha256=4N-QrAPK1-34q_1Pvw1is0Wbg8-1tBeOVWYrjkre7nA,3245
 sylk/commons/protos/sylk/SylkProject/v1/SylkProject_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkProject/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkServer/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkServer/v1/SylkServer_pb2.py,sha256=lJePCjQ3HXm54E4N8QjvF44FChfanv1BRw572VOZcvM,1604
+sylk/commons/protos/sylk/SylkServer/v1/SylkServer_pb2.py,sha256=sWAbcs5aM0ekS4HeXl198PqchgdSv0tubKepn4C4yTM,1424
 sylk/commons/protos/sylk/SylkServer/v1/SylkServer_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkServer/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkService/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkService/v1/SylkService_pb2.py,sha256=-bQlJb9KUdl6Sn7-nfe3dHXG2fNq2NgmAL4WLcV74UY,2770
+sylk/commons/protos/sylk/SylkService/v1/SylkService_pb2.py,sha256=l5pdsqmQnC-MJvCGnGrv7T7NCA0X04rU1mGR3wvyJHg,2585
 sylk/commons/protos/sylk/SylkService/v1/SylkService_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkService/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/SylkService/v2/SylkService_pb2.py,sha256=h5JCsTZ7V31Cc4Aid6cud2_EOdJd1dn1ff8Sv54Yj2k,2616
+sylk/commons/protos/sylk/SylkService/v2/SylkService_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
+sylk/commons/protos/sylk/SylkService/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/SylkUser/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/SylkUser/v1/SylkUser_pb2.py,sha256=hpE2E1ShXVWq2miZYYqNQ7Wj_S-l6gpryYDDPiAcLds,3640
+sylk/commons/protos/sylk/SylkUser/v1/SylkUser_pb2.py,sha256=GQxechQKWRBGtuUX-4EIH8wIko_axgqrRvHrl73cBns,3464
 sylk/commons/protos/sylk/SylkUser/v1/SylkUser_pb2_grpc.py,sha256=1oboBPFxaTEXt9Aw7EAj8gXHDCNMhZD2VXqocC9l_gk,159
 sylk/commons/protos/sylk/SylkUser/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Tags/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+sylk/commons/protos/sylk/Tags/v2/Tags_pb2.py,sha256=tUbqiF9YLvngsy5oz0M0sl3Pk_5kC1Xc2Y6yN-QAP98,3636
+sylk/commons/protos/sylk/Tags/v2/Tags_pb2_grpc.py,sha256=ls5nHEgloWAWsmB1go7LTXv6q5dhqEIffKDYAtHRENA,11977
+sylk/commons/protos/sylk/Tags/v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/protos/sylk/Users/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/commons/protos/sylk/Users/v1/Users_pb2.py,sha256=pfhOzLoRWeB9SZY9qpn2E74hWQCpmqUbLsLyfdNZDqw,2053
-sylk/commons/protos/sylk/Users/v1/Users_pb2_grpc.py,sha256=ewwkVuLEmiPM6B6XTeYYfjK5Lwo3Dic95AG4t6BGYpw,12603
+sylk/commons/protos/sylk/Users/v1/Users_pb2.py,sha256=TbJj0xsU4QPmVnifURsCWrEN3qz_lCIBeJOE_eYqxvE,1905
+sylk/commons/protos/sylk/Users/v1/Users_pb2_grpc.py,sha256=752oMPDW52Qlkpk1-KC8aJ90zm7mRW1phAGlGsFENZc,12813
 sylk/commons/protos/sylk/Users/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/commons/templates/sylk/TodoAppPy.template.py,sha256=MEpYNfqfuKScI75SYmN42_b1xcVWSA_uBKAlk6wkusw,28738
 sylk/helpers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/helpers/pretty.py,sha256=VZXtTak3cqSk1V7sSiZryHDfePJF9RT_YJ3XCDivrDY,2665
 sylk/helpers/prompter.py,sha256=jV4XWK1YlfukMe_ew5qVxtHg6dLXTzY3zOhUUR-lk3I,11392
 sylk/helpers/theme.py,sha256=TS9zu0mu5RpgUbE0sqfAGWUksdcFNoeejLdkWjpdp1Y,2561
 sylk/tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
@@ -193,24 +251,25 @@
 sylk/tools/sylkprotoc/protos/sylk/Protoc/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/tools/sylkprotoc/protos/sylk/Protoc/v1/Protoc_pb2.py,sha256=J3P0vzqb10wsDC9igjApzlaq9chUp42H20NZcDaq-ZI,1404
 sylk/tools/sylkprotoc/protos/sylk/Protoc/v1/Protoc_pb2_grpc.py,sha256=ltM-ZCiKPndepm_LhIB7ymHES2S3RVpc8rAl4hrMN38,4141
 sylk/tools/sylkprotoc/protos/sylk/Protoc/v1/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/types/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/types/google/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/types/google/longrunning/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/types/google/longrunning/operations_pb2.py,sha256=4SWbUuCHHs6jw8NhoLtiS1S97unXwl3pEz6PvnhRxGU,4782
-sylk/types/google/longrunning/operations_pb2_grpc.py,sha256=8omi1_09StxOiYY2zIY--hFSuAcgxJNce_LUwvAI5xo,13653
+sylk/types/google/longrunning/operations_pb2.py,sha256=Bk5kgvmS3eaIOLEpRqnB0LRRy23t2vsSukI1scSQzls,4780
+sylk/types/google/longrunning/operations_pb2_grpc.py,sha256=ZVZboLJcv22cS0vK5Z0JKzc_3JoVhgWmXKsB8DReDoE,13642
 sylk/types/google/rpc/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sylk/types/google/rpc/code_pb2.py,sha256=fkcingix3rjXUR3xBZBnUtF0gh7-zAicoDuTIx_w6is,1815
-sylk/types/google/rpc/error_details_pb2.py,sha256=YmzZqq0Q1dzkbpdctt1Qmkg8a8QeGfQ_RSS8VfPVv-U,4675
-sylk/types/google/rpc/http_pb2.py,sha256=qKUkuCyfW4YssZ84XuFHib_XAlAhLl-8-PXHDwE53d4,1891
-sylk/types/google/rpc/status_pb2.py,sha256=eNvhnqQ6vVCpo9rKKGI9OE1RNeM-pze4Q9qtUSV_OhI,1522
+sylk/types/google/rpc/code_pb2.py,sha256=tMg0IJ63IHxcdqFKCCr8HGEHao6OS-ubO8kmCuSCOqk,1811
+sylk/types/google/rpc/error_details_pb2.py,sha256=JqyyBJeaTubRAMMginEZoHl0U-RifS8peFMdScVHyag,4671
+sylk/types/google/rpc/http_pb2.py,sha256=aCZTE0-VTrZckYQXNk4aUx_LGn9RnSelBm7F87VOIsI,1887
+sylk/types/google/rpc/status_pb2.py,sha256=QFo3Hn-qRiWoK4KhN_7GsLgGgE616tl6dl3Q-xFqHe8,1518
 sylk/types/sylk/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/types/sylk/io/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sylk/types/sylk/io/pagination_pb2.py,sha256=yuQ3cRcRZqA5_aQrRuKXuYUJqMc0At6d_MxIExecGK8,1428
-sylk/types/sylk/io/service_config_pb2.py,sha256=st4J7f1GutoyNutwR7I1mMHlmCsXvycKTLVzzXJlOdY,2843
-sylk-0.2.0.dist-info/LICENSE,sha256=0JS9uaUEyrP4yzU9ppuPDZscLUYApOQG_CuW1UoWx-o,1053
-sylk-0.2.0.dist-info/METADATA,sha256=FRqSBbebk_LBtFZyKBKw7di_T-iepHYU2pKg9BBC9Xw,9750
-sylk-0.2.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-sylk-0.2.0.dist-info/entry_points.txt,sha256=vxjWbM3KS9KzZfBor1wDhJEYbZV8EEMK75EpQukeonU,48
-sylk-0.2.0.dist-info/top_level.txt,sha256=tFTC4QIYWyyJ5e6PsxTDIMYXnmBCtAHnsQdct48k5_s,10
-sylk-0.2.0.dist-info/RECORD,,
+sylk/types/sylk/io/service_config_pb2.py,sha256=q0_gJA_IN1kbqDT-cafbVUQpa--JLIs2PJgf9dtcfMY,2843
+tests/test.py,sha256=oMwnYhKQ9oQhgyzxCM6_ONsCvv42e1o2MLbGRhv13pk,1678
+sylk-0.3.0.dist-info/LICENSE,sha256=0JS9uaUEyrP4yzU9ppuPDZscLUYApOQG_CuW1UoWx-o,1053
+sylk-0.3.0.dist-info/METADATA,sha256=uYra4F26CwCFo_-dPUtSfNdQt502E_ryVWsvmesNSwc,10238
+sylk-0.3.0.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
+sylk-0.3.0.dist-info/entry_points.txt,sha256=vxjWbM3KS9KzZfBor1wDhJEYbZV8EEMK75EpQukeonU,48
+sylk-0.3.0.dist-info/top_level.txt,sha256=oIr0vt2dCTzxQr-6Ar_gHBX_1X1YjN-yEdZ_MvTm2n0,16
+sylk-0.3.0.dist-info/RECORD,,
```

