# Comparing `tmp/netron-7.0.9-py3-none-any.whl.zip` & `tmp/netron-7.1.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,146 +1,146 @@
-Zip file size: 1588643 bytes, number of entries: 144
--rw-r--r--  2.0 unx     1526 b- defN 23-Jul-29 03:03 netron/__init__.py
--rw-r--r--  2.0 unx    57889 b- defN 23-Jul-29 03:03 netron/acuity-metadata.json
--rw-r--r--  2.0 unx    24150 b- defN 23-Jul-29 03:03 netron/acuity.js
--rw-r--r--  2.0 unx    11340 b- defN 23-Jul-29 03:03 netron/armnn-metadata.json
--rw-r--r--  2.0 unx   108710 b- defN 23-Jul-29 03:03 netron/armnn-schema.js
--rw-r--r--  2.0 unx    13793 b- defN 23-Jul-29 03:03 netron/armnn.js
--rwxr-xr-x  2.0 unx    16571 b- defN 23-Jul-29 03:03 netron/barracuda.js
--rw-r--r--  2.0 unx    38139 b- defN 23-Jul-29 03:03 netron/base.js
--rw-r--r--  2.0 unx     2017 b- defN 23-Jul-29 03:03 netron/bigdl-metadata.json
--rw-r--r--  2.0 unx    24356 b- defN 23-Jul-29 03:03 netron/bigdl-proto.js
--rw-r--r--  2.0 unx    12745 b- defN 23-Jul-29 03:03 netron/bigdl.js
--rw-r--r--  2.0 unx    34678 b- defN 23-Jul-29 03:03 netron/browser.js
--rw-r--r--  2.0 unx     9505 b- defN 23-Jul-29 03:03 netron/caffe-metadata.json
--rw-r--r--  2.0 unx   188897 b- defN 23-Jul-29 03:03 netron/caffe-proto.js
--rw-r--r--  2.0 unx    25529 b- defN 23-Jul-29 03:03 netron/caffe.js
--rw-r--r--  2.0 unx   863689 b- defN 23-Jul-29 03:03 netron/caffe2-metadata.json
--rw-r--r--  2.0 unx    61210 b- defN 23-Jul-29 03:03 netron/caffe2-proto.js
--rw-r--r--  2.0 unx    22617 b- defN 23-Jul-29 03:03 netron/caffe2.js
--rw-r--r--  2.0 unx      889 b- defN 23-Jul-29 03:03 netron/cambricon.js
--rw-r--r--  2.0 unx    13245 b- defN 23-Jul-29 03:03 netron/circle-metadata.json
--rw-r--r--  2.0 unx    99313 b- defN 23-Jul-29 03:03 netron/circle-schema.js
--rw-r--r--  2.0 unx    24420 b- defN 23-Jul-29 03:03 netron/circle.js
--rw-r--r--  2.0 unx    14193 b- defN 23-Jul-29 03:03 netron/cntk-metadata.json
--rw-r--r--  2.0 unx    11578 b- defN 23-Jul-29 03:03 netron/cntk-proto.js
--rw-r--r--  2.0 unx    43790 b- defN 23-Jul-29 03:03 netron/cntk.js
--rw-r--r--  2.0 unx    15775 b- defN 23-Jul-29 03:03 netron/coreml-metadata.json
--rw-r--r--  2.0 unx   415701 b- defN 23-Jul-29 03:03 netron/coreml-proto.js
--rw-r--r--  2.0 unx    68028 b- defN 23-Jul-29 03:03 netron/coreml.js
--rw-r--r--  2.0 unx   102117 b- defN 23-Jul-29 03:03 netron/dagre.js
--rw-r--r--  2.0 unx    20570 b- defN 23-Jul-29 03:03 netron/darknet-metadata.json
--rw-r--r--  2.0 unx    54886 b- defN 23-Jul-29 03:03 netron/darknet.js
--rw-r--r--  2.0 unx     1417 b- defN 23-Jul-29 03:03 netron/dl4j-metadata.json
--rw-r--r--  2.0 unx    16955 b- defN 23-Jul-29 03:03 netron/dl4j.js
--rw-r--r--  2.0 unx      735 b- defN 23-Jul-29 03:03 netron/dlc-metadata.json
--rw-r--r--  2.0 unx     3277 b- defN 23-Jul-29 03:03 netron/dlc-schema.js
--rw-r--r--  2.0 unx    17870 b- defN 23-Jul-29 03:03 netron/dlc.js
--rw-r--r--  2.0 unx     1777 b- defN 23-Jul-29 03:03 netron/dnn-metadata.json
--rw-r--r--  2.0 unx    11533 b- defN 23-Jul-29 03:03 netron/dnn-proto.js
--rw-r--r--  2.0 unx    10594 b- defN 23-Jul-29 03:03 netron/dnn.js
--rw-r--r--  2.0 unx    34494 b- defN 23-Jul-29 03:03 netron/favicon.ico
--rw-r--r--  2.0 unx    11358 b- defN 23-Jul-29 03:03 netron/flatbuffers.js
--rw-r--r--  2.0 unx     7734 b- defN 23-Jul-29 03:03 netron/flax.js
--rw-r--r--  2.0 unx     7568 b- defN 23-Jul-29 03:03 netron/flexbuffers.js
--rw-r--r--  2.0 unx        3 b- defN 23-Jul-29 03:03 netron/flux-metadata.json
--rw-r--r--  2.0 unx     2409 b- defN 23-Jul-29 03:03 netron/flux.js
--rw-r--r--  2.0 unx     6061 b- defN 23-Jul-29 03:03 netron/grapher.css
--rw-r--r--  2.0 unx    25528 b- defN 23-Jul-29 03:03 netron/grapher.js
--rw-r--r--  2.0 unx    29456 b- defN 23-Jul-29 03:03 netron/hailo-metadata.json
--rw-r--r--  2.0 unx    11521 b- defN 23-Jul-29 03:03 netron/hailo.js
--rwxr-xr-x  2.0 unx    57289 b- defN 23-Jul-29 03:03 netron/hdf5.js
--rw-r--r--  2.0 unx     6789 b- defN 23-Jul-29 03:03 netron/hickle.js
--rw-r--r--  2.0 unx    58106 b- defN 23-Jul-29 03:03 netron/icon.png
--rw-r--r--  2.0 unx     1392 b- defN 23-Jul-29 03:03 netron/imgdnn.js
--rw-r--r--  2.0 unx    44057 b- defN 23-Jul-29 03:05 netron/index.html
--rw-r--r--  2.0 unx     4113 b- defN 23-Jul-29 03:03 netron/index.js
--rwxr-xr-x  2.0 unx    18643 b- defN 23-Jul-29 03:03 netron/json.js
--rw-r--r--  2.0 unx   254682 b- defN 23-Jul-29 03:03 netron/keras-metadata.json
--rw-r--r--  2.0 unx    54531 b- defN 23-Jul-29 03:03 netron/keras.js
--rw-r--r--  2.0 unx    64052 b- defN 23-Jul-29 03:03 netron/kmodel.js
--rw-r--r--  2.0 unx      244 b- defN 23-Jul-29 03:03 netron/lasagne-metadata.json
--rw-r--r--  2.0 unx     7050 b- defN 23-Jul-29 03:03 netron/lasagne.js
--rw-r--r--  2.0 unx     5172 b- defN 23-Jul-29 03:03 netron/lightgbm.js
--rw-r--r--  2.0 unx    10385 b- defN 23-Jul-29 03:03 netron/mediapipe.js
--rw-r--r--  2.0 unx    91710 b- defN 23-Jul-29 03:03 netron/megengine-metadata.json
--rw-r--r--  2.0 unx    82284 b- defN 23-Jul-29 03:03 netron/megengine-schema.js
--rw-r--r--  2.0 unx    30574 b- defN 23-Jul-29 03:03 netron/megengine.js
--rw-r--r--  2.0 unx    44765 b- defN 23-Jul-29 03:03 netron/mlir.js
--rw-r--r--  2.0 unx     3423 b- defN 23-Jul-29 03:03 netron/mlnet-metadata.json
--rw-r--r--  2.0 unx    78350 b- defN 23-Jul-29 03:03 netron/mlnet.js
--rw-r--r--  2.0 unx    10058 b- defN 23-Jul-29 03:03 netron/mnn-metadata.json
--rw-r--r--  2.0 unx    62342 b- defN 23-Jul-29 03:03 netron/mnn-schema.js
--rw-r--r--  2.0 unx    17641 b- defN 23-Jul-29 03:03 netron/mnn.js
--rw-r--r--  2.0 unx    85458 b- defN 23-Jul-29 03:03 netron/mslite-metadata.json
--rw-r--r--  2.0 unx   171745 b- defN 23-Jul-29 03:03 netron/mslite-schema.js
--rw-r--r--  2.0 unx    14997 b- defN 23-Jul-29 03:03 netron/mslite.js
--rw-r--r--  2.0 unx    11884 b- defN 23-Jul-29 03:03 netron/mxnet-metadata.json
--rw-r--r--  2.0 unx    37803 b- defN 23-Jul-29 03:03 netron/mxnet.js
--rw-r--r--  2.0 unx    30899 b- defN 23-Jul-29 03:03 netron/ncnn-metadata.json
--rw-r--r--  2.0 unx    37976 b- defN 23-Jul-29 03:03 netron/ncnn.js
--rw-r--r--  2.0 unx   290482 b- defN 23-Jul-29 03:03 netron/nnabla-metadata.json
--rw-r--r--  2.0 unx   434215 b- defN 23-Jul-29 03:03 netron/nnabla-proto.js
--rw-r--r--  2.0 unx    11418 b- defN 23-Jul-29 03:03 netron/nnabla.js
--rw-r--r--  2.0 unx     2224 b- defN 23-Jul-29 03:03 netron/nnef.js
--rw-r--r--  2.0 unx    15163 b- defN 23-Jul-29 03:03 netron/numpy.js
--rw-r--r--  2.0 unx    53079 b- defN 23-Jul-29 03:03 netron/om-metadata.json
--rw-r--r--  2.0 unx    37006 b- defN 23-Jul-29 03:03 netron/om-proto.js
--rw-r--r--  2.0 unx    29164 b- defN 23-Jul-29 03:03 netron/om.js
--rw-r--r--  2.0 unx     6818 b- defN 23-Jul-29 03:03 netron/onednn-metadata.json
--rw-r--r--  2.0 unx    11961 b- defN 23-Jul-29 03:03 netron/onednn.js
--rw-r--r--  2.0 unx  2903929 b- defN 23-Jul-29 03:03 netron/onnx-metadata.json
--rw-r--r--  2.0 unx    59899 b- defN 23-Jul-29 03:03 netron/onnx-proto.js
--rw-r--r--  2.0 unx    15717 b- defN 23-Jul-29 03:03 netron/onnx-schema.js
--rw-r--r--  2.0 unx    88981 b- defN 23-Jul-29 03:03 netron/onnx.js
--rw-r--r--  2.0 unx     9053 b- defN 23-Jul-29 03:03 netron/onnx.py
--rw-r--r--  2.0 unx    84585 b- defN 23-Jul-29 03:03 netron/openvino-metadata.json
--rw-r--r--  2.0 unx    44560 b- defN 23-Jul-29 03:03 netron/openvino.js
--rw-r--r--  2.0 unx     2894 b- defN 23-Jul-29 03:03 netron/paddle-metadata.json
--rw-r--r--  2.0 unx    60111 b- defN 23-Jul-29 03:03 netron/paddle-proto.js
--rw-r--r--  2.0 unx    19797 b- defN 23-Jul-29 03:03 netron/paddle-schema.js
--rw-r--r--  2.0 unx    37551 b- defN 23-Jul-29 03:03 netron/paddle.js
--rw-r--r--  2.0 unx     5527 b- defN 23-Jul-29 03:03 netron/pickle.js
--rw-r--r--  2.0 unx    42713 b- defN 23-Jul-29 03:03 netron/protobuf.js
--rw-r--r--  2.0 unx   303716 b- defN 23-Jul-29 03:03 netron/python.js
--rwxr-xr-x  2.0 unx   411132 b- defN 23-Jul-29 03:03 netron/pytorch-metadata.json
--rw-r--r--  2.0 unx    13170 b- defN 23-Jul-29 03:03 netron/pytorch-schema.js
--rw-r--r--  2.0 unx   182294 b- defN 23-Jul-29 03:03 netron/pytorch.js
--rw-r--r--  2.0 unx    24259 b- defN 23-Jul-29 03:03 netron/pytorch.py
--rw-r--r--  2.0 unx     5473 b- defN 23-Jul-29 03:03 netron/rknn-metadata.json
--rw-r--r--  2.0 unx     4263 b- defN 23-Jul-29 03:03 netron/rknn-schema.js
--rw-r--r--  2.0 unx    24805 b- defN 23-Jul-29 03:03 netron/rknn.js
--rw-r--r--  2.0 unx     4571 b- defN 23-Jul-29 03:03 netron/safetensors.js
--rw-r--r--  2.0 unx     5865 b- defN 23-Jul-29 03:03 netron/server.js
--rw-r--r--  2.0 unx    11874 b- defN 23-Jul-29 03:05 netron/server.py
--rw-r--r--  2.0 unx   160693 b- defN 23-Jul-29 03:03 netron/sklearn-metadata.json
--rw-r--r--  2.0 unx    14746 b- defN 23-Jul-29 03:03 netron/sklearn.js
--rw-r--r--  2.0 unx     4901 b- defN 23-Jul-29 03:03 netron/tar.js
--rwxr-xr-x  2.0 unx    27914 b- defN 23-Jul-29 03:03 netron/tengine-metadata.json
--rwxr-xr-x  2.0 unx    28094 b- defN 23-Jul-29 03:03 netron/tengine.js
--rw-r--r--  2.0 unx     5304 b- defN 23-Jul-29 03:03 netron/tensorrt.js
--rw-r--r--  2.0 unx    11077 b- defN 23-Jul-29 03:03 netron/text.js
--rw-r--r--  2.0 unx  2221556 b- defN 23-Jul-29 03:03 netron/tf-metadata.json
--rw-r--r--  2.0 unx   363531 b- defN 23-Jul-29 03:03 netron/tf-proto.js
--rw-r--r--  2.0 unx   106578 b- defN 23-Jul-29 03:03 netron/tf.js
--rw-r--r--  2.0 unx    29824 b- defN 23-Jul-29 03:03 netron/tflite-metadata.json
--rw-r--r--  2.0 unx   110995 b- defN 23-Jul-29 03:03 netron/tflite-schema.js
--rw-r--r--  2.0 unx    25098 b- defN 23-Jul-29 03:03 netron/tflite.js
--rw-r--r--  2.0 unx    20380 b- defN 23-Jul-29 03:03 netron/tnn-metadata.json
--rw-r--r--  2.0 unx    26868 b- defN 23-Jul-29 03:03 netron/tnn.js
--rw-r--r--  2.0 unx    12510 b- defN 23-Jul-29 03:03 netron/torch-metadata.json
--rw-r--r--  2.0 unx    41535 b- defN 23-Jul-29 03:03 netron/torch.js
--rw-r--r--  2.0 unx     2333 b- defN 23-Jul-29 03:03 netron/uff-metadata.json
--rw-r--r--  2.0 unx    30910 b- defN 23-Jul-29 03:03 netron/uff-proto.js
--rw-r--r--  2.0 unx    12710 b- defN 23-Jul-29 03:03 netron/uff.js
--rw-r--r--  2.0 unx   236381 b- defN 23-Jul-29 03:03 netron/view.js
--rw-r--r--  2.0 unx     8023 b- defN 23-Jul-29 03:03 netron/weka.js
--rw-r--r--  2.0 unx    64034 b- defN 23-Jul-29 03:03 netron/xml.js
--rw-r--r--  2.0 unx    55685 b- defN 23-Jul-29 03:03 netron/xmodel-proto.js
--rw-r--r--  2.0 unx    13916 b- defN 23-Jul-29 03:03 netron/xmodel.js
--rw-r--r--  2.0 unx    30921 b- defN 23-Jul-29 03:03 netron/zip.js
--rw-r--r--  2.0 unx     1447 b- defN 23-Jul-29 03:05 netron-7.0.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-29 03:05 netron-7.0.9.dist-info/WHEEL
--rw-r--r--  2.0 unx       39 b- defN 23-Jul-29 03:05 netron-7.0.9.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        7 b- defN 23-Jul-29 03:05 netron-7.0.9.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    11131 b- defN 23-Jul-29 03:05 netron-7.0.9.dist-info/RECORD
-144 files, 12938072 bytes uncompressed, 1571951 bytes compressed:  87.9%
+Zip file size: 1591254 bytes, number of entries: 144
+-rw-r--r--  2.0 unx     1526 b- defN 23-Aug-01 04:04 netron/__init__.py
+-rw-r--r--  2.0 unx    57889 b- defN 23-Aug-01 04:04 netron/acuity-metadata.json
+-rw-r--r--  2.0 unx    24150 b- defN 23-Aug-01 04:04 netron/acuity.js
+-rw-r--r--  2.0 unx    11340 b- defN 23-Aug-01 04:04 netron/armnn-metadata.json
+-rw-r--r--  2.0 unx   108710 b- defN 23-Aug-01 04:04 netron/armnn-schema.js
+-rw-r--r--  2.0 unx    13793 b- defN 23-Aug-01 04:04 netron/armnn.js
+-rwxr-xr-x  2.0 unx    16571 b- defN 23-Aug-01 04:04 netron/barracuda.js
+-rw-r--r--  2.0 unx    38139 b- defN 23-Aug-01 04:04 netron/base.js
+-rw-r--r--  2.0 unx     2017 b- defN 23-Aug-01 04:04 netron/bigdl-metadata.json
+-rw-r--r--  2.0 unx    24356 b- defN 23-Aug-01 04:04 netron/bigdl-proto.js
+-rw-r--r--  2.0 unx    12745 b- defN 23-Aug-01 04:04 netron/bigdl.js
+-rw-r--r--  2.0 unx    34678 b- defN 23-Aug-01 04:04 netron/browser.js
+-rw-r--r--  2.0 unx     9505 b- defN 23-Aug-01 04:04 netron/caffe-metadata.json
+-rw-r--r--  2.0 unx   188897 b- defN 23-Aug-01 04:04 netron/caffe-proto.js
+-rw-r--r--  2.0 unx    25529 b- defN 23-Aug-01 04:04 netron/caffe.js
+-rw-r--r--  2.0 unx   863689 b- defN 23-Aug-01 04:04 netron/caffe2-metadata.json
+-rw-r--r--  2.0 unx    61210 b- defN 23-Aug-01 04:04 netron/caffe2-proto.js
+-rw-r--r--  2.0 unx    22617 b- defN 23-Aug-01 04:04 netron/caffe2.js
+-rw-r--r--  2.0 unx      889 b- defN 23-Aug-01 04:04 netron/cambricon.js
+-rw-r--r--  2.0 unx    13245 b- defN 23-Aug-01 04:04 netron/circle-metadata.json
+-rw-r--r--  2.0 unx    99313 b- defN 23-Aug-01 04:04 netron/circle-schema.js
+-rw-r--r--  2.0 unx    24420 b- defN 23-Aug-01 04:04 netron/circle.js
+-rw-r--r--  2.0 unx    14193 b- defN 23-Aug-01 04:04 netron/cntk-metadata.json
+-rw-r--r--  2.0 unx    11578 b- defN 23-Aug-01 04:04 netron/cntk-proto.js
+-rw-r--r--  2.0 unx    43790 b- defN 23-Aug-01 04:04 netron/cntk.js
+-rw-r--r--  2.0 unx    15775 b- defN 23-Aug-01 04:04 netron/coreml-metadata.json
+-rw-r--r--  2.0 unx   415701 b- defN 23-Aug-01 04:04 netron/coreml-proto.js
+-rw-r--r--  2.0 unx    68028 b- defN 23-Aug-01 04:04 netron/coreml.js
+-rw-r--r--  2.0 unx   102117 b- defN 23-Aug-01 04:04 netron/dagre.js
+-rw-r--r--  2.0 unx    20570 b- defN 23-Aug-01 04:04 netron/darknet-metadata.json
+-rw-r--r--  2.0 unx    54886 b- defN 23-Aug-01 04:04 netron/darknet.js
+-rw-r--r--  2.0 unx     1417 b- defN 23-Aug-01 04:04 netron/dl4j-metadata.json
+-rw-r--r--  2.0 unx    16955 b- defN 23-Aug-01 04:04 netron/dl4j.js
+-rw-r--r--  2.0 unx     2309 b- defN 23-Aug-01 04:04 netron/dlc-metadata.json
+-rw-r--r--  2.0 unx     8706 b- defN 23-Aug-01 04:04 netron/dlc-schema.js
+-rw-r--r--  2.0 unx    26954 b- defN 23-Aug-01 04:04 netron/dlc.js
+-rw-r--r--  2.0 unx     1777 b- defN 23-Aug-01 04:04 netron/dnn-metadata.json
+-rw-r--r--  2.0 unx    11533 b- defN 23-Aug-01 04:04 netron/dnn-proto.js
+-rw-r--r--  2.0 unx    10594 b- defN 23-Aug-01 04:04 netron/dnn.js
+-rw-r--r--  2.0 unx    34494 b- defN 23-Aug-01 04:04 netron/favicon.ico
+-rw-r--r--  2.0 unx    11358 b- defN 23-Aug-01 04:04 netron/flatbuffers.js
+-rw-r--r--  2.0 unx     7734 b- defN 23-Aug-01 04:04 netron/flax.js
+-rw-r--r--  2.0 unx     7568 b- defN 23-Aug-01 04:04 netron/flexbuffers.js
+-rw-r--r--  2.0 unx        3 b- defN 23-Aug-01 04:04 netron/flux-metadata.json
+-rw-r--r--  2.0 unx     2409 b- defN 23-Aug-01 04:04 netron/flux.js
+-rw-r--r--  2.0 unx     6061 b- defN 23-Aug-01 04:04 netron/grapher.css
+-rw-r--r--  2.0 unx    25602 b- defN 23-Aug-01 04:04 netron/grapher.js
+-rw-r--r--  2.0 unx    29456 b- defN 23-Aug-01 04:04 netron/hailo-metadata.json
+-rw-r--r--  2.0 unx    11521 b- defN 23-Aug-01 04:04 netron/hailo.js
+-rwxr-xr-x  2.0 unx    57289 b- defN 23-Aug-01 04:04 netron/hdf5.js
+-rw-r--r--  2.0 unx     6789 b- defN 23-Aug-01 04:04 netron/hickle.js
+-rw-r--r--  2.0 unx    58106 b- defN 23-Aug-01 04:04 netron/icon.png
+-rw-r--r--  2.0 unx     1392 b- defN 23-Aug-01 04:04 netron/imgdnn.js
+-rw-r--r--  2.0 unx    44057 b- defN 23-Aug-01 04:07 netron/index.html
+-rw-r--r--  2.0 unx     4113 b- defN 23-Aug-01 04:04 netron/index.js
+-rwxr-xr-x  2.0 unx    18643 b- defN 23-Aug-01 04:04 netron/json.js
+-rw-r--r--  2.0 unx   254682 b- defN 23-Aug-01 04:04 netron/keras-metadata.json
+-rw-r--r--  2.0 unx    54531 b- defN 23-Aug-01 04:04 netron/keras.js
+-rw-r--r--  2.0 unx    64052 b- defN 23-Aug-01 04:04 netron/kmodel.js
+-rw-r--r--  2.0 unx      244 b- defN 23-Aug-01 04:04 netron/lasagne-metadata.json
+-rw-r--r--  2.0 unx     7050 b- defN 23-Aug-01 04:04 netron/lasagne.js
+-rw-r--r--  2.0 unx     5172 b- defN 23-Aug-01 04:04 netron/lightgbm.js
+-rw-r--r--  2.0 unx    10385 b- defN 23-Aug-01 04:04 netron/mediapipe.js
+-rw-r--r--  2.0 unx    91710 b- defN 23-Aug-01 04:04 netron/megengine-metadata.json
+-rw-r--r--  2.0 unx    82284 b- defN 23-Aug-01 04:04 netron/megengine-schema.js
+-rw-r--r--  2.0 unx    30574 b- defN 23-Aug-01 04:04 netron/megengine.js
+-rw-r--r--  2.0 unx    44765 b- defN 23-Aug-01 04:04 netron/mlir.js
+-rw-r--r--  2.0 unx     3423 b- defN 23-Aug-01 04:04 netron/mlnet-metadata.json
+-rw-r--r--  2.0 unx    78350 b- defN 23-Aug-01 04:04 netron/mlnet.js
+-rw-r--r--  2.0 unx    10058 b- defN 23-Aug-01 04:04 netron/mnn-metadata.json
+-rw-r--r--  2.0 unx    62342 b- defN 23-Aug-01 04:04 netron/mnn-schema.js
+-rw-r--r--  2.0 unx    17641 b- defN 23-Aug-01 04:04 netron/mnn.js
+-rw-r--r--  2.0 unx    85458 b- defN 23-Aug-01 04:04 netron/mslite-metadata.json
+-rw-r--r--  2.0 unx   171745 b- defN 23-Aug-01 04:04 netron/mslite-schema.js
+-rw-r--r--  2.0 unx    14997 b- defN 23-Aug-01 04:04 netron/mslite.js
+-rw-r--r--  2.0 unx    11884 b- defN 23-Aug-01 04:04 netron/mxnet-metadata.json
+-rw-r--r--  2.0 unx    37803 b- defN 23-Aug-01 04:04 netron/mxnet.js
+-rw-r--r--  2.0 unx    30899 b- defN 23-Aug-01 04:04 netron/ncnn-metadata.json
+-rw-r--r--  2.0 unx    37976 b- defN 23-Aug-01 04:04 netron/ncnn.js
+-rw-r--r--  2.0 unx   290482 b- defN 23-Aug-01 04:04 netron/nnabla-metadata.json
+-rw-r--r--  2.0 unx   434215 b- defN 23-Aug-01 04:04 netron/nnabla-proto.js
+-rw-r--r--  2.0 unx    11418 b- defN 23-Aug-01 04:04 netron/nnabla.js
+-rw-r--r--  2.0 unx     2224 b- defN 23-Aug-01 04:04 netron/nnef.js
+-rw-r--r--  2.0 unx    15163 b- defN 23-Aug-01 04:04 netron/numpy.js
+-rw-r--r--  2.0 unx    53079 b- defN 23-Aug-01 04:04 netron/om-metadata.json
+-rw-r--r--  2.0 unx    37006 b- defN 23-Aug-01 04:04 netron/om-proto.js
+-rw-r--r--  2.0 unx    29164 b- defN 23-Aug-01 04:04 netron/om.js
+-rw-r--r--  2.0 unx     6818 b- defN 23-Aug-01 04:04 netron/onednn-metadata.json
+-rw-r--r--  2.0 unx    11961 b- defN 23-Aug-01 04:04 netron/onednn.js
+-rw-r--r--  2.0 unx  2912056 b- defN 23-Aug-01 04:04 netron/onnx-metadata.json
+-rw-r--r--  2.0 unx    59899 b- defN 23-Aug-01 04:04 netron/onnx-proto.js
+-rw-r--r--  2.0 unx    15717 b- defN 23-Aug-01 04:04 netron/onnx-schema.js
+-rw-r--r--  2.0 unx    88981 b- defN 23-Aug-01 04:04 netron/onnx.js
+-rw-r--r--  2.0 unx     9053 b- defN 23-Aug-01 04:04 netron/onnx.py
+-rw-r--r--  2.0 unx    84585 b- defN 23-Aug-01 04:04 netron/openvino-metadata.json
+-rw-r--r--  2.0 unx    44560 b- defN 23-Aug-01 04:04 netron/openvino.js
+-rw-r--r--  2.0 unx     2894 b- defN 23-Aug-01 04:04 netron/paddle-metadata.json
+-rw-r--r--  2.0 unx    60111 b- defN 23-Aug-01 04:04 netron/paddle-proto.js
+-rw-r--r--  2.0 unx    19797 b- defN 23-Aug-01 04:04 netron/paddle-schema.js
+-rw-r--r--  2.0 unx    37551 b- defN 23-Aug-01 04:04 netron/paddle.js
+-rw-r--r--  2.0 unx     5527 b- defN 23-Aug-01 04:04 netron/pickle.js
+-rw-r--r--  2.0 unx    42713 b- defN 23-Aug-01 04:04 netron/protobuf.js
+-rw-r--r--  2.0 unx   303716 b- defN 23-Aug-01 04:04 netron/python.js
+-rwxr-xr-x  2.0 unx   411132 b- defN 23-Aug-01 04:04 netron/pytorch-metadata.json
+-rw-r--r--  2.0 unx    13170 b- defN 23-Aug-01 04:04 netron/pytorch-schema.js
+-rw-r--r--  2.0 unx   182294 b- defN 23-Aug-01 04:04 netron/pytorch.js
+-rw-r--r--  2.0 unx    24259 b- defN 23-Aug-01 04:04 netron/pytorch.py
+-rw-r--r--  2.0 unx     5473 b- defN 23-Aug-01 04:04 netron/rknn-metadata.json
+-rw-r--r--  2.0 unx     4263 b- defN 23-Aug-01 04:04 netron/rknn-schema.js
+-rw-r--r--  2.0 unx    24805 b- defN 23-Aug-01 04:04 netron/rknn.js
+-rw-r--r--  2.0 unx     4571 b- defN 23-Aug-01 04:04 netron/safetensors.js
+-rw-r--r--  2.0 unx     5865 b- defN 23-Aug-01 04:04 netron/server.js
+-rw-r--r--  2.0 unx    11874 b- defN 23-Aug-01 04:07 netron/server.py
+-rw-r--r--  2.0 unx   160693 b- defN 23-Aug-01 04:04 netron/sklearn-metadata.json
+-rw-r--r--  2.0 unx    14746 b- defN 23-Aug-01 04:04 netron/sklearn.js
+-rw-r--r--  2.0 unx     4901 b- defN 23-Aug-01 04:04 netron/tar.js
+-rwxr-xr-x  2.0 unx    27914 b- defN 23-Aug-01 04:04 netron/tengine-metadata.json
+-rwxr-xr-x  2.0 unx    28094 b- defN 23-Aug-01 04:04 netron/tengine.js
+-rw-r--r--  2.0 unx     5278 b- defN 23-Aug-01 04:04 netron/tensorrt.js
+-rw-r--r--  2.0 unx    11077 b- defN 23-Aug-01 04:04 netron/text.js
+-rw-r--r--  2.0 unx  2221556 b- defN 23-Aug-01 04:04 netron/tf-metadata.json
+-rw-r--r--  2.0 unx   363531 b- defN 23-Aug-01 04:04 netron/tf-proto.js
+-rw-r--r--  2.0 unx   106578 b- defN 23-Aug-01 04:04 netron/tf.js
+-rw-r--r--  2.0 unx    29824 b- defN 23-Aug-01 04:04 netron/tflite-metadata.json
+-rw-r--r--  2.0 unx   110995 b- defN 23-Aug-01 04:04 netron/tflite-schema.js
+-rw-r--r--  2.0 unx    25098 b- defN 23-Aug-01 04:04 netron/tflite.js
+-rw-r--r--  2.0 unx    20380 b- defN 23-Aug-01 04:04 netron/tnn-metadata.json
+-rw-r--r--  2.0 unx    26868 b- defN 23-Aug-01 04:04 netron/tnn.js
+-rw-r--r--  2.0 unx    12510 b- defN 23-Aug-01 04:04 netron/torch-metadata.json
+-rw-r--r--  2.0 unx    41535 b- defN 23-Aug-01 04:04 netron/torch.js
+-rw-r--r--  2.0 unx     2333 b- defN 23-Aug-01 04:04 netron/uff-metadata.json
+-rw-r--r--  2.0 unx    30910 b- defN 23-Aug-01 04:04 netron/uff-proto.js
+-rw-r--r--  2.0 unx    12710 b- defN 23-Aug-01 04:04 netron/uff.js
+-rw-r--r--  2.0 unx   237224 b- defN 23-Aug-01 04:04 netron/view.js
+-rw-r--r--  2.0 unx     8023 b- defN 23-Aug-01 04:04 netron/weka.js
+-rw-r--r--  2.0 unx    64034 b- defN 23-Aug-01 04:04 netron/xml.js
+-rw-r--r--  2.0 unx    55685 b- defN 23-Aug-01 04:04 netron/xmodel-proto.js
+-rw-r--r--  2.0 unx    13916 b- defN 23-Aug-01 04:04 netron/xmodel.js
+-rw-r--r--  2.0 unx    30921 b- defN 23-Aug-01 04:04 netron/zip.js
+-rw-r--r--  2.0 unx     1447 b- defN 23-Aug-01 04:07 netron-7.1.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Aug-01 04:07 netron-7.1.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       39 b- defN 23-Aug-01 04:07 netron-7.1.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        7 b- defN 23-Aug-01 04:07 netron-7.1.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    11132 b- defN 23-Aug-01 04:07 netron-7.1.0.dist-info/RECORD
+144 files, 12963178 bytes uncompressed, 1574562 bytes compressed:  87.9%
```

## zipnote {}

```diff
@@ -411,23 +411,23 @@
 
 Filename: netron/xmodel.js
 Comment: 
 
 Filename: netron/zip.js
 Comment: 
 
-Filename: netron-7.0.9.dist-info/METADATA
+Filename: netron-7.1.0.dist-info/METADATA
 Comment: 
 
-Filename: netron-7.0.9.dist-info/WHEEL
+Filename: netron-7.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: netron-7.0.9.dist-info/entry_points.txt
+Filename: netron-7.1.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: netron-7.0.9.dist-info/top_level.txt
+Filename: netron-7.1.0.dist-info/top_level.txt
 Comment: 
 
-Filename: netron-7.0.9.dist-info/RECORD
+Filename: netron-7.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## netron/dlc-metadata.json

### Pretty-printed

 * *Similarity: 0.29761904761904756%*

 * *Differences: {'0': "{'name': 'Convolutional:v3'}",*

 * * '1': "{'name': 'Deconvolution:v3'}",*

 * * '13': "{'name': 'Pool:v4'}",*

 * * '2': "{'name': 'BatchNorm:v3'}",*

 * * '22': "{'name': 'Neuron:v4'}",*

 * * '24': "{'name': 'StridedSlice:v4'}",*

 * * '3': "{'name': 'Concat:v3'}",*

 * * '5': "{'name': 'FullyConnected:v3'}",*

 * * '6': "{'name': 'Neuron:v3'}",*

 * * '7': "{'name': 'Reshape:v3'}",*

 * * '8': "{'name': 'Permute:v3'}",*

 * * 'insert': "[(4, OrderedDict([('name', 'Gather:v3'), ('category', 'Transform')])), (9, "*

 * *           "OrderedDict([('name', 'Pooling:v3'), […]*

```diff
@@ -1,52 +1,172 @@
 [
     {
         "category": "Layer",
-        "name": "Convolutional"
+        "name": "Convolutional:v3"
     },
     {
         "category": "Layer",
-        "name": "Deconvolution"
+        "name": "Deconvolution:v3"
     },
     {
         "category": "Normalization",
-        "name": "BatchNorm"
+        "name": "BatchNorm:v3"
     },
     {
         "category": "Tensor",
-        "name": "Concat"
+        "name": "Concat:v3"
+    },
+    {
+        "category": "Transform",
+        "name": "Gather:v3"
     },
     {
         "category": "Layer",
-        "name": "FullyConnected"
+        "name": "FullyConnected:v3"
     },
     {
         "attributes": [
             {
                 "name": "type",
                 "type": "Activation"
             }
         ],
         "category": "Activation",
-        "name": "Neuron"
+        "name": "Neuron:v3"
     },
     {
         "category": "Shape",
-        "name": "Reshape"
+        "name": "Reshape:v3"
     },
     {
         "category": "Shape",
-        "name": "Permute"
+        "name": "Permute:v3"
+    },
+    {
+        "category": "Pool",
+        "name": "Pooling:v3"
+    },
+    {
+        "category": "Activation",
+        "name": "SoftMax:v3"
+    },
+    {
+        "category": "Tensor",
+        "name": "StridedSlice:v3"
+    },
+    {
+        "category": "Tensor",
+        "name": "Slice:v3"
     },
     {
         "category": "Pool",
-        "name": "Pooling"
+        "name": "Pool:v4"
+    },
+    {
+        "category": "Activation",
+        "name": "Softmax:v4"
+    },
+    {
+        "category": "Activation",
+        "name": "Sigmoid:v4"
+    },
+    {
+        "category": "Layer",
+        "inputs": [
+            {
+                "name": "input"
+            },
+            {
+                "name": "weight"
+            },
+            {
+                "name": "bias"
+            }
+        ],
+        "name": "Conv2d:v4"
+    },
+    {
+        "category": "Layer",
+        "inputs": [
+            {
+                "name": "input"
+            },
+            {
+                "name": "weight"
+            },
+            {
+                "name": "bias"
+            }
+        ],
+        "name": "DepthWiseConv2d:v4"
+    },
+    {
+        "category": "Layer",
+        "inputs": [
+            {
+                "name": "input"
+            },
+            {
+                "name": "weight"
+            },
+            {
+                "name": "bias"
+            }
+        ],
+        "name": "FullyConnected:v4"
+    },
+    {
+        "category": "Tensor",
+        "name": "Concat:v4"
+    },
+    {
+        "category": "Tensor",
+        "name": "Split:v4"
+    },
+    {
+        "category": "Shape",
+        "name": "Reshape:v4"
     },
     {
         "category": "Activation",
-        "name": "SoftMax"
+        "name": "Neuron:v4"
+    },
+    {
+        "category": "Transform",
+        "name": "Transpose:v4"
     },
     {
         "category": "Tensor",
-        "name": "StridedSlice"
+        "name": "StridedSlice:v4"
+    },
+    {
+        "category": "Shape",
+        "name": "Pad:v4"
+    },
+    {
+        "category": "Transform",
+        "inputs": [
+            {
+                "name": "input"
+            },
+            {
+                "name": "indices"
+            }
+        ],
+        "name": "Gather:v4"
+    },
+    {
+        "category": "Normalization",
+        "inputs": [
+            {
+                "name": "input"
+            },
+            {
+                "name": "mean"
+            },
+            {
+                "name": "variance"
+            }
+        ],
+        "name": "Batchnorm:v4"
     }
 ]
```

## netron/dlc-schema.js

### js-beautify {}

```diff
@@ -1,98 +1,267 @@
 var $root = flatbuffers.get('dlc');
 
 $root.dlc = $root.dlc || {};
 
-$root.dlc.NetDef = class NetDef {
+$root.dlc.v3 = $root.dlc.v3 || {};
+
+$root.dlc.v3.Model = class Model {
 
     static decode(reader, position) {
-        const $ = new $root.dlc.NetDef();
+        const $ = new $root.dlc.v3.Model();
         $.unk1 = reader.int32_(position, 4, 0);
-        $.nodes = reader.tableArray(position, 6, $root.dlc.Node.decode);
+        $.nodes = reader.tableArray(position, 6, $root.dlc.v3.Node.decode);
         $.unk2 = reader.typedArray(position, 8, Int32Array);
         $.unk3 = reader.typedArray(position, 10, Int32Array);
-        $.attributes = reader.tableArray(position, 12, $root.dlc.Attribute.decode);
-        return $;
-    }
-};
-
-$root.dlc.NetParam = class NetParam {
-
-    static decode(reader, position) {
-        const $ = new $root.dlc.NetParam();
-        $.weights = reader.tableArray(position, 4, $root.dlc.Weights.decode);
+        $.attributes = reader.tableArray(position, 12, $root.dlc.v3.Attribute.decode);
         return $;
     }
 };
 
-$root.dlc.Node = class Node {
+$root.dlc.v3.Node = class Node {
 
     static decode(reader, position) {
-        const $ = new $root.dlc.Node();
+        const $ = new $root.dlc.v3.Node();
         $.index = reader.int32_(position, 4, 0);
         $.name = reader.string_(position, 6, null);
         $.type = reader.string_(position, 8, null);
         $.inputs = reader.strings_(position, 10);
         $.outputs = reader.strings_(position, 12);
-        $.attributes = reader.tableArray(position, 14, $root.dlc.Attribute.decode);
-        return $;
-    }
-};
-
-$root.dlc.Weights = class Weights {
-
-    static decode(reader, position) {
-        const $ = new $root.dlc.Weights();
-        $.name = reader.string_(position, 4, null);
-        $.tensors = reader.tableArray(position, 6, $root.dlc.Tensor.decode);
+        $.attributes = reader.tableArray(position, 14, $root.dlc.v3.Attribute.decode);
         return $;
     }
 };
 
-$root.dlc.Tensor = class Tensor {
+$root.dlc.v3.Tensor = class Tensor {
 
     static decode(reader, position) {
-        const $ = new $root.dlc.Tensor();
+        const $ = new $root.dlc.v3.Tensor();
         $.name = reader.string_(position, 4, null);
         $.shape = reader.typedArray(position, 6, Int32Array);
-        $.data = reader.table(position, 8, $root.dlc.TensorData.decode);
-        $.attributes = reader.tableArray(position, 10, $root.dlc.Attribute.decode);
+        $.data = reader.table(position, 8, $root.dlc.v3.TensorData.decode);
+        $.attributes = reader.tableArray(position, 10, $root.dlc.v3.Attribute.decode);
         return $;
     }
 };
 
-$root.dlc.TensorData = class TensorData {
+$root.dlc.v3.TensorData = class TensorData {
 
     static decode(reader, position) {
-        const $ = new $root.dlc.TensorData();
-        $.data_type = reader.uint8_(position, 4, 0);
+        const $ = new $root.dlc.v3.TensorData();
+        $.dtype = reader.uint8_(position, 4, 0);
         $.bytes = reader.typedArray(position, 6, Uint8Array);
         $.floats = reader.typedArray(position, 8, Float32Array);
         return $;
     }
 };
 
-$root.dlc.Attribute = class Attribute {
+$root.dlc.v3.Attribute = class Attribute {
 
     static decode(reader, position) {
-        const $ = new $root.dlc.Attribute();
+        const $ = new $root.dlc.v3.Attribute();
         $.name = reader.string_(position, 4, null);
         $.type = reader.uint8_(position, 6, 0);
         $.bool_value = reader.bool_(position, 8, false);
         $.int32_value = reader.int32_(position, 10, 0);
         $.uint32_value = reader.uint32_(position, 12, 0);
         $.float32_value = reader.float32_(position, 14, 0);
         $.string_value = reader.string_(position, 16, null);
         $.unk6 = reader.typedArray(position, 18, Int8Array);
         $.byte_list = reader.typedArray(position, 20, Int8Array);
         $.int32_list = reader.typedArray(position, 22, Int32Array);
         $.float32_list = reader.typedArray(position, 24, Float32Array);
         $.unk10 = reader.typedArray(position, 26, Int8Array);
-        $.attributes = reader.tableArray(position, 28, $root.dlc.Attribute.decode);
+        $.attributes = reader.tableArray(position, 28, $root.dlc.v3.Attribute.decode);
         return $;
     }
 };
 
-$root.dlc.Activation = {
+$root.dlc.v3.Activation = {
     ReLU: 1,
     Sigmoid: 3
+};
+
+$root.dlc.v3.ModelParameters = class ModelParameters {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v3.ModelParameters();
+        $.nodes = reader.tableArray(position, 4, $root.dlc.v3.NodeParameters.decode);
+        return $;
+    }
+};
+
+$root.dlc.v3.NodeParameters = class NodeParameters {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v3.NodeParameters();
+        $.name = reader.string_(position, 4, null);
+        $.weights = reader.tableArray(position, 6, $root.dlc.v3.Tensor.decode);
+        return $;
+    }
+};
+
+$root.dlc = $root.dlc || {};
+
+$root.dlc.v4 = $root.dlc.v4 || {};
+
+$root.dlc.v4.Model = class Model {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.Model();
+        $.graphs = reader.tableArray(position, 4, $root.dlc.v4.Graph.decode);
+        return $;
+    }
+};
+
+$root.dlc.v4.Graph = class Graph {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.Graph();
+        $.name = reader.string_(position, 4, null);
+        $.nodes = reader.tableArray(position, 6, $root.dlc.v4.Node.decode);
+        $.tensors = reader.tableArray(position, 8, $root.dlc.v4.Tensor.decode);
+        return $;
+    }
+};
+
+$root.dlc.v4.Node = class Node {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.Node();
+        $.name = reader.string_(position, 4, null);
+        $.type = reader.string_(position, 6, null);
+        $.inputs = reader.strings_(position, 8);
+        $.outputs = reader.strings_(position, 10);
+        $.attributes = reader.tableArray(position, 12, $root.dlc.v4.Attribute.decode);
+        return $;
+    }
+};
+
+$root.dlc.v4.Attribute = class Attribute {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.Attribute();
+        $.name = reader.string_(position, 4, null);
+        $.kind = reader.int32_(position, 6, 0);
+        $.flag = reader.uint8_(position, 8, 0);
+        $.value = reader.table(position, 10, $root.dlc.v4.Value.decode);
+        $.tensor = reader.table(position, 12, $root.dlc.v4.Tensor.decode);
+        return $;
+    }
+};
+
+$root.dlc.v4.Value = class Value {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.Value();
+        $.kind = reader.int32_(position, 4, 0);
+        $.int32_value = reader.int32_(position, 6, 0);
+        $.float32_value = reader.float32_(position, 8, 0);
+        $.string_value = reader.string_(position, 10, null);
+        return $;
+    }
+};
+
+$root.dlc.v4.Tensor = class Tensor {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.Tensor();
+        $.unk1 = reader.uint32_(position, 4, 0);
+        $.name = reader.string_(position, 6, null);
+        $.location = reader.int32_(position, 8, 0);
+        $.shape = reader.typedArray(position, 10, Int32Array);
+        $.unk2 = reader.int32_(position, 12, 0);
+        $.info = reader.table(position, 14, $root.dlc.v4.TensorInfo.decode);
+        $.dtype = reader.int32_(position, 16, 0);
+        $.output_dtype = reader.int32_(position, 18, 0);
+        $.unk6 = reader.uint8_(position, 20, 0);
+        return $;
+    }
+};
+
+$root.dlc.v4.TensorInfo = class TensorInfo {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.TensorInfo();
+        $.i1 = reader.int32_(position, 4, 0);
+        $.b1 = reader.uint8_(position, 6, 0);
+        $.a = reader.table(position, 8, $root.dlc.v4.TensorInfo1.decode);
+        $.b = reader.table(position, 10, $root.dlc.v4.TensorInfo2.decode);
+        return $;
+    }
+};
+
+$root.dlc.v4.TensorInfo1 = class TensorInfo1 {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.TensorInfo1();
+        $.i1 = reader.int32_(position, 4, 0);
+        $.f1 = reader.float32_(position, 6, 0);
+        $.f2 = reader.float32_(position, 8, 0);
+        $.f3 = reader.float32_(position, 10, 0);
+        $.i2 = reader.int32_(position, 12, 0);
+        return $;
+    }
+};
+
+$root.dlc.v4.TensorInfo2 = class TensorInfo2 {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.TensorInfo2();
+        $.i1 = reader.int32_(position, 4, 0);
+        $.l = reader.tableArray(position, 6, $root.dlc.v4.TensorInfo3.decode);
+        return $;
+    }
+};
+
+$root.dlc.v4.TensorInfo3 = class TensorInfo3 {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.TensorInfo3();
+        $.i1 = reader.int32_(position, 4, 0);
+        $.f1 = reader.float32_(position, 6, 0);
+        $.f2 = reader.float32_(position, 8, 0);
+        $.f3 = reader.float32_(position, 10, 0);
+        $.i2 = reader.int32_(position, 12, 0);
+        $.b1 = reader.uint8_(position, 14, 0);
+        return $;
+    }
+};
+
+$root.dlc.v4.ModelParameters = class ModelParameters {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.ModelParameters();
+        $.graphs = reader.tableArray(position, 4, $root.dlc.v4.GraphParameters.decode);
+        return $;
+    }
+};
+
+$root.dlc.v4.GraphParameters = class GraphParameters {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.GraphParameters();
+        $.name = reader.string_(position, 4, null);
+        $.tensors = reader.tableArray(position, 6, $root.dlc.v4.TensorData.decode);
+        $.nodes = reader.tableArray(position, 8, $root.dlc.v4.NodeParameters.decode);
+        return $;
+    }
+};
+
+$root.dlc.v4.NodeParameters = class NodeParameters {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.NodeParameters();
+        $.tensors = reader.tableArray(position, 4, $root.dlc.v4.TensorData.decode);
+        return $;
+    }
+};
+
+$root.dlc.v4.TensorData = class TensorData {
+
+    static decode(reader, position) {
+        const $ = new $root.dlc.v4.TensorData();
+        $.name = reader.string_(position, 4, null);
+        $.bytes = reader.typedArray(position, 6, Uint8Array);
+        return $;
+    }
 };
```

## netron/dlc.js

### js-beautify {}

```diff
@@ -6,518 +6,576 @@
     match(context) {
         return dlc.Container.open(context);
     }
 
     async open(context, target) {
         await context.require('./dlc-schema');
         dlc.schema = flatbuffers.get('dlc').dlc;
-        const container = target;
-        let model = null;
-        let params = null;
-        const metadata_props = container.metadata;
-        container.validate();
-        try {
-            model = container.model;
-        } catch (error) {
-            const message = error && error.message ? error.message : error.toString();
-            throw new dlc.Error('File format is not dlc.NetDef (' + message.replace(/\.$/, '') + ').');
-        }
-        try {
-            params = container.params;
-        } catch (error) {
-            const message = error && error.message ? error.message : error.toString();
-            throw new dlc.Error('File format is not dlc.NetParam (' + message.replace(/\.$/, '') + ').');
-        }
+        const format = target.entries.has('model') ? 'DLC' : 'DLC Weights';
+        target.read();
         const metadata = await context.metadata('dlc-metadata.json');
-        return new dlc.Model(metadata, model, params, metadata_props);
+        return new dlc.Model(metadata, format, target);
     }
 };
 
 dlc.Model = class {
 
-    constructor(metadata, model, params, metadata_props) {
-        this._format = model ? 'DLC' : 'DLC Weights';
-        this._metadata = [];
-        if (metadata_props.size > 0) {
-            const version = metadata_props.get('model-version');
+    constructor(metadata, format, target) {
+        this.format = format;
+        this.metadata = [];
+        if (target.metadata.size > 0) {
+            const version = target.metadata.get('model-version');
             if (version) {
-                this._version = version;
+                this.version = version;
             }
-            const converter = metadata_props.get('converter-command');
+            const converter = target.metadata.get('converter-command');
             if (converter) {
                 const source = converter.split(' ').shift().trim();
                 if (source.length > 0) {
-                    const version = metadata_props.get('converter-version');
-                    this._metadata.push({
+                    const version = target.metadata.get('converter-version');
+                    this.metadata.push({
                         name: 'source',
                         value: version ? source + ' v' + version : source
                     });
                 }
             }
         }
-        this._graphs = [new dlc.Graph(metadata, model, params)];
-    }
-
-    get format() {
-        return this._format;
-    }
-
-    get version() {
-        return this._version;
-    }
-
-    get metadata() {
-        return this._metadata;
-    }
-
-    get graphs() {
-        return this._graphs;
+        for (const graph of target.graphs) {
+            this.graphs = [new dlc.Graph(metadata, target.version, graph)];
+        }
     }
 };
 
 dlc.Graph = class {
 
-    constructor(metadata, model, params) {
-        this._inputs = [];
-        this._outputs = [];
+    constructor(metadata, version, graph) {
+        this.inputs = [];
+        this.outputs = [];
         const values = new Map();
-        const value = (name) => {
-            if (!values.has(name)) {
-                values.set(name, new dlc.Value(name));
-            }
-            return values.get(name);
-        };
-        if (model) {
-            for (const node of model.nodes) {
-                for (const input of node.inputs) {
-                    if (!values.has(input)) {
-                        values.set(input, {});
+        switch (version) {
+            case 3: {
+                for (const node of graph.nodes) {
+                    for (const name of node.inputs) {
+                        if (!values.has(name)) {
+                            values.set(name, {});
+                        }
                     }
-                }
-                const shapes = new Array(node.outputs.length);
-                for (const attr of node.attributes) {
-                    if (attr.name === 'OutputDims') {
-                        for (const entry of Object.entries(attr.attributes)) {
-                            const index = parseInt(entry[0], 10);
-                            shapes[index] = Array.from(entry[1].int32_list);
+                    for (const name of node.outputs) {
+                        if (!values.has(name)) {
+                            values.set(name, {});
                         }
-                        break;
                     }
-                }
-                for (let i = 0; i < node.outputs.length; i++) {
-                    const output = node.outputs[i];
-                    if (!values.has(output)) {
-                        values.set(output, {});
-                    }
-                    const value = values.get(output);
-                    if (i < shapes.length) {
-                        value.shape = shapes[i];
+                    let shapes = new Array(node.outputs.length);
+                    for (const attribute of node.attributes) {
+                        if (attribute.name === 'OutputDims' &&
+                            Array.isArray(attribute.attributes) && attribute.attributes.length > 0) {
+                            shapes = attribute.data;
+                            break;
+                        }
+                    }
+                    for (let i = 0; i < node.outputs.length; i++) {
+                        const name = node.outputs[i];
+                        const value = values.get(name);
+                        if (!value.shape && i < shapes.length) {
+                            value.shape = shapes[i];
+                        }
                     }
                 }
+                break;
             }
-            for (const entry of values) {
-                const type = entry[1].shape ? new dlc.TensorType(null, entry[1].shape) : null;
-                const value = new dlc.Value(entry[0], type);
-                values.set(entry[0], value);
-            }
-            this._nodes = [];
-            const weights = new Map(params ? params.weights.map((weights) => [weights.name, weights]) : []);
-            for (const node of model.nodes) {
-                if (node.type === 'Input') {
-                    this._inputs.push(new dlc.Argument(node.name, node.inputs.map((input) => value(input))));
-                    continue;
+            case 4: {
+                for (const tensor of graph.tensors) {
+                    values.set(tensor.name, tensor);
                 }
-                this._nodes.push(new dlc.Node(metadata, node, weights.get(node.name), value));
+                break;
+            }
+            default: {
+                break;
             }
-        } else {
-            this._nodes = params.weights.map((weights) => new dlc.Node(metadata, null, weights, value));
         }
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
+        for (const entry of values) {
+            const name = entry[0];
+            const tensor = entry[1];
+            const type = tensor.shape ? new dlc.TensorType(tensor.dtype, tensor.shape) : null;
+            const initializer = tensor.data && tensor.data ? new dlc.Tensor(type, tensor.data) : null;
+            const value = new dlc.Value(name, type, initializer);
+            values.set(name, value);
+        }
+        const value = (name) => {
+            if (!values.has(name)) {
+                values.set(name, new dlc.Value(name));
+            }
+            return values.get(name);
+        };
+        this.nodes = [];
+        for (const node of graph.nodes) {
+            if (node.type === 'Input') {
+                this.inputs.push(new dlc.Argument(node.name, node.inputs.map((input) => value(input))));
+                continue;
+            }
+            this.nodes.push(new dlc.Node(metadata, version, node, value));
+        }
     }
 };
 
 dlc.Argument = class {
 
     constructor(name, value) {
-        this._name = name;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
+        this.name = name;
+        this.value = value;
     }
 };
 
 dlc.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
             throw new dlc.Error("Invalid value identifier '" + JSON.stringify(name) + "'.");
         }
-        this._name = name;
-        this._type = type;
-        this._initializer = initializer;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get initializer() {
-        return this._initializer;
+        this.name = name;
+        this.type = type;
+        this.initializer = initializer;
     }
 };
 
 dlc.Node = class {
 
-    constructor(metadata, node, weights, value) {
-        if (node) {
-            this._type = metadata.type(node.type);
-            this._name = node.name;
-            const inputs = Array.from(node.inputs).map((input) => value(input));
-            this._inputs = inputs.length === 0 ? [] : [new dlc.Argument(inputs.length === 1 ? 'input' : 'inputs', inputs)];
-            const outputs = Array.from(node.outputs).map((output) => value(output));
-            this._outputs = outputs.length === 0 ? [] : [new dlc.Argument(outputs.length === 1 ? 'output' : 'outputs', outputs)];
-            this._attributes = [];
+    constructor(metadata, version, node, value) {
+        const type = node.type + ':v' + version.toString();
+        this.type = Object.assign({}, metadata.type(type));
+        this.type.name = node.type;
+        this.name = node.name;
+        this.inputs = [];
+        this.outputs = [];
+        this.attributes = [];
+        const inputs = Array.isArray(node.inputs) ? Array.from(node.inputs).map((input) => value(input)) : [];
+        if (Array.isArray(this.type.inputs) && inputs.length === this.type.inputs.length) {
+            for (let i = 0; i < inputs.length; i++) {
+                const argument = new dlc.Argument(this.type.inputs[i].name, [inputs[i]]);
+                this.inputs.push(argument);
+            }
+        } else if (inputs.length > 0) {
+            const argument = new dlc.Argument(inputs.length === 1 ? 'input' : 'inputs', inputs);
+            this.inputs.push(argument);
+        }
+        const outputs = Array.isArray(node.outputs) ? Array.from(node.outputs).map((output) => value(output)) : [];
+        if (Array.isArray(this.type.outputs) && outputs.length === this.type.outputs.length) {
+            for (let i = 0; i < outputs.length; i++) {
+                const argument = new dlc.Argument(this.type.outputs[i].name, [outputs[i]]);
+                this.outputs.push(argument);
+            }
+        } else if (outputs.length > 0) {
+            const argument = new dlc.Argument(outputs.length === 1 ? 'output' : 'outputs', outputs);
+            this.outputs.push(argument);
+        }
+        if (node.attributes) {
             for (const attr of node.attributes) {
                 if (attr.name === 'OutputDims') {
                     continue;
                 }
-                const attribute = new dlc.Attribute(metadata.attribute(node.type, attr.name), attr);
-                this._attributes.push(attribute);
+                const attribute = new dlc.Attribute(metadata.attribute(type, attr.name), version, attr);
+                this.attributes.push(attribute);
             }
-            if (weights) {
-                for (const tensor of weights.tensors) {
-                    const type = new dlc.TensorType(tensor.data.data_type, tensor.shape);
-                    const value = new dlc.Value('', type, new dlc.Tensor(type, tensor.data));
-                    this._inputs.push(new dlc.Argument(tensor.name, [value]));
-                }
-            }
-        } else {
-            this._type = {
-                name: 'Weights'
-            };
-            this._name = weights.name;
-            this._inputs = weights.tensors.map((tensor) => {
-                const type = new dlc.TensorType(tensor.data.data_type, tensor.shape);
+        }
+        if (node.weights) {
+            for (const tensor of node.weights) {
+                const type = new dlc.TensorType(tensor.data.dtype, tensor.shape);
                 const value = new dlc.Value('', type, new dlc.Tensor(type, tensor.data));
-                return new dlc.Argument(tensor.name, [value]);
-            });
-            this._outputs = [];
-            this._attributes = [];
+                this.inputs.push(new dlc.Argument(tensor.name, [value]));
+            }
         }
     }
-
-    get type() {
-        return this._type;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
 };
 
 dlc.Attribute = class {
 
-    constructor(metadata, attr) {
-        this._name = attr.name;
-        const read = (attr) => {
-            switch (attr.type) {
-                case 1:
-                    return ['boolean', attr.bool_value];
-                case 2:
-                    return ['int32', attr.int32_value];
-                case 3:
-                    return ['uint32', attr.uint32_value];
-                case 4:
-                    return ['float32', attr.float32_value];
-                case 5:
-                    return ['string', attr.string_value];
-                case 7:
-                    return ['byte[]', Array.from(attr.byte_list)];
-                case 8:
-                    return ['int32[]', Array.from(attr.int32_list)];
-                case 9:
-                    return ['float32[]', Array.from(attr.float32_list)];
-                case 11: {
-                    const obj = {};
-                    for (const attribute of attr.attributes) {
-                        const entry = read(attribute);
-                        obj[attribute.name] = entry[1];
-                    }
-                    return ['', obj];
-                }
-                default:
-                    throw new dlc.Error("Unsupported attribute type '" + attr.type + "'.");
+    constructor(metadata, version, attribute) {
+        this.name = attribute.name;
+        this.type = attribute.type;
+        switch (this.type) {
+            case 'tensor': {
+                const tensor = attribute.data;
+                const type = new dlc.TensorType(tensor.dtype, tensor.shape);
+                const data = tensor.data;
+                this.value = new dlc.Tensor(type, data);
+                break;
+            }
+            default: {
+                this.value = attribute.data;
             }
-        };
-        const entry = read(attr);
-        if (entry) {
-            this._type = entry[0];
-            this._value = entry[1];
         }
         if (metadata && metadata.type) {
-            this._type = metadata.type;
-            this._value = dlc.Utility.enum(this._type, this._value);
+            this.type = metadata.type;
+            this.value = dlc.Utility.enum(version, this.type, this.value);
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get value() {
-        return this._value;
-    }
 };
 
 dlc.TensorType = class {
 
     constructor(dataType, shape) {
-        switch (dataType) {
-            case null:
-                this._dataType = '?';
-                break;
-            case 6:
-                this._dataType = 'uint8';
-                break;
-            case 9:
-                this._dataType = 'float32';
-                break;
-            default:
-                throw new dlc.Error("Unsupported data type '" + JSON.stringify(dataType) + "'.");
-        }
-        this._shape = new dlc.TensorShape(shape);
-    }
-
-    get dataType() {
-        return this._dataType;
-    }
-
-    get shape() {
-        return this._shape;
+        this.dataType = dataType || '?';
+        this.shape = new dlc.TensorShape(shape);
     }
 
     toString() {
-        return this.dataType + this._shape.toString();
+        return this.dataType + this.shape.toString();
     }
 };
 
 dlc.TensorShape = class {
 
     constructor(dimensions) {
-        this._dimensions = Array.from(dimensions);
-    }
-
-    get dimensions() {
-        return this._dimensions;
+        this.dimensions = Array.from(dimensions);
     }
 
     toString() {
-        if (!this._dimensions || this._dimensions.length == 0) {
-            return '';
+        if (Array.isArray(this.dimensions) && this.dimensions.length > 0) {
+            return '[' + this.dimensions.map((dimension) => dimension.toString()).join(',') + ']';
         }
-        return '[' + this._dimensions.map((dimension) => dimension.toString()).join(',') + ']';
+        return '';
     }
 };
 
 dlc.Tensor = class {
 
     constructor(type, data) {
-        this._type = type;
-        switch (type.dataType) {
-            case 'uint8':
-                this._values = data.bytes;
-                break;
-            case 'float32':
-                this._values = data.floats;
-                break;
-            default:
-                throw new dlc.Error("Unsupported tensor data type '" + type.dataType + "'.");
+        this.type = type;
+        if (data instanceof Uint8Array) {
+            this.layout = '<';
+            this.values = data;
+        } else {
+            this.layout = '|';
+            switch (type.dataType) {
+                case 'uint8':
+                    this.values = data.bytes;
+                    break;
+                case 'float32':
+                    this.values = data.floats;
+                    break;
+                default:
+                    throw new dlc.Error("Unsupported tensor data type '" + type.dataType + "'.");
+            }
         }
     }
-
-    get type() {
-        return this._type;
-    }
-
-    get layout() {
-        return '|';
-    }
-
-    get values() {
-        return this._values;
-    }
 };
 
 dlc.Container = class {
 
     static open(context) {
         const entries = context.entries('zip');
         if (entries.size > 0) {
-            const model = entries.get('model');
-            const params = entries.get('model.params');
-            const metadata = entries.get('dlc.metadata');
-            if (model || params) {
-                return new dlc.Container(model, params, metadata);
+            if (entries.has('model') || entries.has('model.params')) {
+                return new dlc.Container(entries);
             }
         }
         const stream = context.stream;
         switch (dlc.Container._signature(stream).split('.').pop()) {
             case 'NETD':
-                return new dlc.Container(stream, null, null);
+                return new dlc.Container(new Map([
+                    ['model', stream]
+                ]));
             case 'NETP':
-                return new dlc.Container(null, stream, null);
+                return new dlc.Container(new Map([
+                    ['model.params', stream]
+                ]));
             default:
                 return null;
         }
     }
 
-    constructor(model, params, metadata) {
-        this._model = {
-            stream: model || null
-        };
-        this._params = {
-            stream: params || null
-        };
-        this._metadata = {
-            stream: metadata || null,
-            value: new Map()
-        };
-    }
-
-    validate() {
-        this._model.signature = dlc.Container._signature(this._model.stream);
-        this._params.signature = dlc.Container._signature(this._params.stream);
-        if (this._model.signature == '2' || this._params.signature == '2') {
-            throw new dlc.Error("File contains undocumented DLC v2 data.");
-        }
-        if (this._model.signature.startsWith('4.') || this._params.signature.startsWith('4.')) {
-            throw new dlc.Error("File contains undocumented DLC v4 data.");
-        }
-    }
-
-    get model() {
-        if (this._model && this._model.stream) {
-            const stream = this._model.stream;
-            delete this._model.stream;
-            switch (dlc.Container._signature(stream)) {
-                case '4.NETD': {
-                    throw new dlc.Error("File contains undocumented DLC v4 data.");
-                }
-                case '3.NETD': {
-                    const buffer = new Uint8Array(stream.peek().subarray(8));
-                    const reader = flatbuffers.BinaryReader.open(buffer);
-                    this._model.value = dlc.schema.NetDef.decode(reader, reader.root);
-                    break;
-                }
-                case 'NETD': {
-                    const buffer = stream.peek();
-                    const reader = flatbuffers.BinaryReader.open(buffer);
-                    this._model.value = dlc.schema.NetDef.decode(reader, reader.root);
-                    break;
-                }
-                default: {
-                    const buffer = stream.peek(Math.min(stream.length, 16));
-                    const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
-                    throw new dlc.Error("File contains undocumented '" + content + "' data.");
+    constructor(entries) {
+        this.entries = entries;
+        this.graphs = [];
+        this.metadata = new Map();
+    }
+
+    read() {
+        if (this.entries) {
+            const entries = this.entries;
+            delete this.entries;
+            if (entries.has('model')) {
+                const stream = entries.get('model');
+                const signature = dlc.Container._signature(stream);
+                switch (signature) {
+                    case '2': {
+                        throw new dlc.Error("File contains undocumented DLC v2 data.");
+                    }
+                    case '3.NETD':
+                    case 'NETD': {
+                        this.version = 3;
+                        let model = null;
+                        try {
+                            const buffer = new Uint8Array(signature === 'NETD' ? stream.peek() : stream.peek().subarray(8));
+                            const reader = flatbuffers.BinaryReader.open(buffer);
+                            model = dlc.schema.v3.Model.decode(reader, reader.root);
+                            model.version = 3;
+                        } catch (error) {
+                            const message = error && error.message ? error.message : error.toString();
+                            throw new dlc.Error('File format is not dlc.v1.NETD (' + message.replace(/\.$/, '') + ').');
+                        }
+                        model.tensors = [];
+                        this.graphs.push(model);
+                        const updateAttribute = (attr) => {
+                            switch (attr.type) {
+                                case 1:
+                                    return ['boolean', attr.bool_value];
+                                case 2:
+                                    return ['int32', attr.int32_value];
+                                case 3:
+                                    return ['uint32', attr.uint32_value];
+                                case 4:
+                                    return ['float32', attr.float32_value];
+                                case 5:
+                                    return ['string', attr.string_value];
+                                case 7:
+                                    return ['byte[]', Array.from(attr.byte_list)];
+                                case 8:
+                                    return ['int32[]', Array.from(attr.int32_list)];
+                                case 9:
+                                    return ['float32[]', Array.from(attr.float32_list)];
+                                case 11: {
+                                    const list = [];
+                                    for (const attribute of attr.attributes) {
+                                        const entry = updateAttribute(attribute);
+                                        list.push(entry[1]);
+                                    }
+                                    return ['object[]', list];
+                                }
+                                default:
+                                    throw new dlc.Error("Unsupported attribute type '" + attr.type + "'.");
+                            }
+                        };
+                        for (const node of model.nodes) {
+                            for (const attribute of node.attributes) {
+                                const entry = updateAttribute(attribute);
+                                attribute.type = entry[0];
+                                attribute.data = entry[1];
+                            }
+                        }
+                        break;
+                    }
+                    case '4.NETD': {
+                        this.version = 4;
+                        let model = null;
+                        try {
+                            const buffer = new Uint8Array(stream.peek().subarray(8));
+                            const reader = flatbuffers.BinaryReader.open(buffer);
+                            model = dlc.schema.v4.Model.decode(reader, reader.root);
+                        } catch (error) {
+                            const message = error && error.message ? error.message : error.toString();
+                            throw new dlc.Error('File format is not dlc.v2.NETD (' + message.replace(/\.$/, '') + ').');
+                        }
+                        this.graphs = model.graphs;
+                        const dataType = (value) => {
+                            switch (value) {
+                                case 0x0032:
+                                    return 'int32';
+                                case 0x0108:
+                                    return 'int8';
+                                case 0x0132:
+                                    return 'int32';
+                                case 0x0232:
+                                    return 'float32';
+                                case 0x0308:
+                                    return 'qint8';
+                                case 0x0332:
+                                    return 'qint32';
+                                case 0x0408:
+                                    return 'uint8';
+                                case 0x0508:
+                                    return 'boolean';
+                                default:
+                                    throw new dlc.Error("Unsupported data type '" + JSON.stringify(value) + "'.");
+                            }
+                        };
+                        const updateTensor = (tensor) => {
+                            tensor.dtype = dataType(tensor.dtype);
+                            tensor.output_dtype = dataType(tensor.output_dtype);
+                        };
+                        for (const graph of this.graphs) {
+                            for (const node of graph.nodes) {
+                                for (const attribute of node.attributes) {
+                                    switch (attribute.kind) {
+                                        case 0: {
+                                            const value = attribute.value;
+                                            switch (value.kind) {
+                                                case 0x7fffffff:
+                                                    attribute.data = value.string_value;
+                                                    attribute.type = 'string';
+                                                    break;
+                                                case 0x0032:
+                                                    attribute.data = value.int32_value;
+                                                    break;
+                                                case 0x0108:
+                                                    attribute.data = value.int32_value;
+                                                    attribute.type = 'int8';
+                                                    break;
+                                                case 0x0132:
+                                                    attribute.data = value.int32_value;
+                                                    attribute.type = 'int32';
+                                                    break;
+                                                case 0x0232:
+                                                    attribute.data = value.float32_value;
+                                                    attribute.type = 'float32';
+                                                    break;
+                                                case 0x0508:
+                                                    attribute.data = value.int32_value !== 0;
+                                                    attribute.type = 'boolean';
+                                                    break;
+                                                default:
+                                                    throw new dlc.Error("Unknown attribute value kind '" + value.kind + "'.");
+                                            }
+                                            break;
+                                        }
+                                        case 1: {
+                                            const tensor = attribute.tensor;
+                                            updateTensor(tensor);
+                                            attribute.type = 'tensor';
+                                            attribute.data = tensor;
+                                            break;
+                                        }
+                                        default: {
+                                            throw new dlc.Error("Unknown attribute kind '" + attribute.kind + "'.");
+                                        }
+                                    }
+                                }
+                            }
+                            for (const tensor of graph.tensors) {
+                                updateTensor(tensor);
+                            }
+                        }
+                        break;
+                    }
+                    default: {
+                        const buffer = stream.peek(Math.min(stream.length, 16));
+                        const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
+                        throw new dlc.Error("File contains undocumented '" + content + "' data.");
+                    }
                 }
             }
-        }
-        return this._model.value;
-    }
-
-    get params() {
-        if (this._params && this._params.stream) {
-            const stream = this._params.stream;
-            delete this._params.stream;
-            switch (dlc.Container._signature(stream)) {
-                case '4.NETP': {
-                    throw new dlc.Error("File contains undocumented DLC v4 data.");
-                }
-                case '3.NETP': {
-                    const buffer = new Uint8Array(stream.peek().subarray(8));
-                    const reader = flatbuffers.BinaryReader.open(buffer);
-                    this._params.value = dlc.schema.NetParam.decode(reader, reader.root);
-                    break;
-                }
-                case '2': {
-                    throw new dlc.Error("File contains undocumented DLC v2 data.");
-                }
-                case 'NETP': {
-                    const buffer = stream.peek();
-                    const reader = flatbuffers.BinaryReader.open(buffer);
-                    this._params.value = dlc.schema.NetParam.decode(reader, reader.root);
-                    break;
-                }
-                default: {
-                    const buffer = stream.peek(Math.min(stream.length, 16));
-                    const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
-                    throw new dlc.Error("File contains undocumented '" + content + "' data.");
+            if (entries.has('model.params')) {
+                const stream = entries.get('model.params');
+                const signature = dlc.Container._signature(stream);
+                switch (signature) {
+                    case '2': {
+                        throw new dlc.Error("File contains undocumented DLC v2 data.");
+                    }
+                    case '3.NETP':
+                    case 'NETP': {
+                        let params = null;
+                        try {
+                            const buffer = new Uint8Array(signature === 'NETP' ? stream.peek() : stream.peek().subarray(8));
+                            const reader = flatbuffers.BinaryReader.open(buffer);
+                            params = dlc.schema.v3.ModelParameters.decode(reader, reader.root);
+                        } catch (error) {
+                            const message = error && error.message ? error.message : error.toString();
+                            throw new dlc.Error('File format is not dlc.v1.NETP (' + message.replace(/\.$/, '') + ').');
+                        }
+                        if (this.graphs.length === 0) {
+                            this.version = 3;
+                            const graph = new dlc.schema.v3.ModelParameters();
+                            graph.nodes = new Array(params.nodes.length);
+                            graph.tensors = [];
+                            for (let i = 0; i < graph.nodes.length; i++) {
+                                const node = new dlc.schema.v3.Node();
+                                node.type = 'Weights';
+                                node.name = params.nodes[i].name;
+                                node.inputs = [];
+                                node.outputs = [];
+                                node.attributes = [];
+                                graph.nodes[i] = node;
+                            }
+                            this.graphs.push(graph);
+                        }
+                        const graph = this.graphs[0];
+                        const dataType = (value) => {
+                            switch (value) {
+                                case null:
+                                    return '?';
+                                case 6:
+                                    return 'uint8';
+                                case 9:
+                                    return 'float32';
+                                default:
+                                    throw new dlc.Error("Unsupported data type '" + JSON.stringify(value) + "'.");
+                            }
+                        };
+                        const weights = new Map(params.nodes.map((node) => [node.name, node.weights]));
+                        for (const node of graph.nodes) {
+                            if (weights.has(node.name)) {
+                                const tensors = weights.get(node.name);
+                                for (const tensor of tensors) {
+                                    tensor.data.dtype = dataType(tensor.data.dtype);
+                                }
+                                node.weights = tensors;
+                            }
+                        }
+                        break;
+                    }
+                    case '4.NETP': {
+                        let params = null;
+                        try {
+                            const buffer = new Uint8Array(stream.peek().subarray(8));
+                            const reader = flatbuffers.BinaryReader.open(buffer);
+                            params = dlc.schema.v4.ModelParameters.decode(reader, reader.root);
+                        } catch (error) {
+                            const message = error && error.message ? error.message : error.toString();
+                            throw new dlc.Error('File format is not dlc.v2.NETP (' + message.replace(/\.$/, '') + ').');
+                        }
+                        if (this.graphs.length === 0) {
+                            throw new dlc.Error('Model definition not available.');
+                        }
+                        const weights = new Map(params.graphs.map((graph) => [graph.name, graph]));
+                        for (const graph of this.graphs) {
+                            const params = weights.get(graph.name);
+                            const tensors = new Map(params.tensors.map((tensor) => [tensor.name, tensor]));
+                            for (const tensor of graph.tensors) {
+                                if (tensor.location === 4) {
+                                    tensor.data = tensors.get(tensor.name).bytes;
+                                }
+                            }
+                            for (let i = 0; i < graph.nodes.length; i++) {
+                                const node = graph.nodes[i];
+                                const tensors = new Map(params.nodes[i].tensors.map((tensor) => [tensor.name, tensor]));
+                                for (const attribute of node.attributes) {
+                                    const tensor = attribute.tensor;
+                                    if (tensor) {
+                                        tensor.data = tensors.get(tensor.name).bytes;
+                                    }
+                                }
+                            }
+                        }
+                        break;
+                    }
+                    default: {
+                        const buffer = stream.peek(Math.min(stream.length, 16));
+                        const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
+                        throw new dlc.Error("File contains undocumented '" + content + "' data.");
+                    }
                 }
             }
-        }
-        return this._params.value;
-    }
-
-    get metadata() {
-        if (this._metadata.stream) {
-            const stream = this._metadata.stream;
-            delete this._metadata.stream;
-            const reader = text.Reader.open(stream);
-            for (;;) {
-                const line = reader.read();
-                if (line === undefined) {
-                    break;
-                }
-                const index = line.indexOf('=');
-                if (index === -1) {
-                    break;
+            if (entries.has('dlc.metadata')) {
+                const stream = entries.get('dlc.metadata');
+                const reader = text.Reader.open(stream);
+                for (;;) {
+                    const line = reader.read();
+                    if (line === undefined) {
+                        break;
+                    }
+                    const index = line.indexOf('=');
+                    if (index === -1) {
+                        break;
+                    }
+                    const key = line.substring(0, index);
+                    const value = line.substring(index + 1);
+                    this.metadata.set(key, value);
                 }
-                const key = line.substring(0, index);
-                const value = line.substring(index + 1);
-                this._metadata.value.set(key, value);
             }
         }
-        return this._metadata.value;
     }
 
     static _signature(stream) {
         if (stream) {
             const buffer = stream.peek(Math.min(stream.length, 16));
             const match = (signature) => buffer.length >= signature.length && signature.every((value, index) => value === buffer[index]);
             if (match([0xD5, 0x0A, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00]) && buffer.length >= 16) {
@@ -538,25 +596,39 @@
         }
         return '';
     }
 };
 
 dlc.Utility = class {
 
-    static enum(name, value) {
-        const type = name && dlc.schema ? dlc.schema[name] : undefined;
-        if (type) {
-            dlc.Utility._enums = dlc.Utility._enums || new Map();
-            if (!dlc.Utility._enums.has(name)) {
-                const map = new Map(Object.keys(type).map((key) => [type[key], key]));
-                dlc.Utility._enums.set(name, map);
-            }
-            const map = dlc.Utility._enums.get(name);
-            if (map.has(value)) {
-                return map.get(value);
+    static enum(version, name, value) {
+        switch (version) {
+            case 3:
+                version = 'v3';
+                break;
+            case 4:
+                version = 'v4';
+                break;
+            default:
+                version = '';
+        }
+        const schema = dlc.schema[version];
+        if (schema && name) {
+            const type = schema[name];
+            if (type) {
+                dlc.Utility[version] = dlc.Utility[version] || new Map();
+                const enums = dlc.Utility[version];
+                if (!enums.has(name)) {
+                    const map = new Map(Object.keys(type).map((key) => [type[key], key]));
+                    enums.set(name, map);
+                }
+                const values = enums.get(name);
+                if (values.has(value)) {
+                    return values.get(value);
+                }
             }
         }
         return value;
     }
 };
 
 dlc.Error = class extends Error {
```

## netron/grapher.js

### js-beautify {}

```diff
@@ -557,14 +557,15 @@
         }
         this.element.setAttribute('class', this.class ? 'edge-path ' + this.class : 'edge-path');
         edgePathGroupElement.appendChild(this.element);
         this.hitTest = createElement('path');
         this.hitTest.setAttribute('class', 'edge-path-hit-test');
         this.hitTest.addEventListener('pointerover', () => this.emit('pointerover'));
         this.hitTest.addEventListener('pointerleave', () => this.emit('pointerleave'));
+        this.hitTest.addEventListener('click', () => this.emit('click'));
         edgePathGroupElement.appendChild(this.hitTest);
         if (this.label) {
             const tspan = createElement('tspan');
             tspan.setAttribute('xml:space', 'preserve');
             tspan.setAttribute('dy', '1em');
             tspan.setAttribute('x', '1');
             tspan.appendChild(document.createTextNode(this.label));
```

## netron/index.html

```diff
@@ -1,15 +1,15 @@
 <!DOCTYPE html>
 <html lang="en">
 <head>
 <meta charset="utf-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
 <meta http-equiv="Content-Security-Policy" content="script-src 'self' www.google-analytics.com;">
-<meta name="version" content="7.0.9">
-<meta name="date" content="2023-07-29 03:02:43">
+<meta name="version" content="7.1.0">
+<meta name="date" content="2023-08-01 04:04:15">
 <title>Netron</title>
 <link rel="stylesheet" type="text/css" href="grapher.css">
 <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
 <link rel="icon" type="image/png" href="icon.png">
 <link rel="apple-touch-icon" type="image/png" href="icon.png">
 <link rel="apple-touch-icon-precomposed" type="image/png" href="icon.png">
 <link rel="fluid-icon" type="image/png" href="icon.png">
```

## netron/onnx-metadata.json

### Pretty-printed

 * *Similarity: 0.9978807749387018%*

 * *Differences: {'96': "{'examples': {2: {'code': 'node = onnx.helper.make_node(\\n    "*

 * *       '"DequantizeLinear",\\n    inputs=["x", "x_scale"],\\n    outputs=["y"],\\n    '*

 * *       'axis=0,\\n)\\n\\n# scalar zero point and scale\\nx = make_tensor("x", '*

 * *       'TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, -104])\\nx_scale = np.float32(2)\\ny = '*

 * *       'np.array([0.0, 1.0, 2.0, 896.0, -208.0], dtype=np.float32)\\n\\nexpect(\\n    node,\\n    '*

 * *       'inputs=[x, x_scale],\\n    outputs=[y],\\n    name="test_dequantiz […]*

```diff
@@ -768,14 +768,81 @@
             }
         ],
         "version": 14
     },
     {
         "attributes": [
             {
+                "description": "if align_corners=1, consider -1 and 1 to refer to the centers of the corner pixels. if align_corners=0, consider -1 and 1 to refer to the outer edge the corner pixels.",
+                "name": "align_corners",
+                "required": false,
+                "type": "int64"
+            }
+        ],
+        "description": "Generates a 2D or 3D flow field (sampling grid), given a batch of affine matrices theta\n(https://pytorch.org/docs/stable/generated/torch.nn.functional.affine_grid.html).\nAn affine matrix `theta` is applied to a position tensor represented in its homogeneous expression. Here is an example in 3D:\n```\n[r00, r01, r02, t0]   [x]   [x']\n[r10, r11, r12, t1] * [y] = [y']\n[r20, r21, r22, t2]   [z]   [z']\n[0,   0,   0,   1 ]   [1]   [1 ]\n```\nwhere `(x, y, z)` is the position in the original space, `(x', y', z')` is the position in the output space.\nThe last row is always `[0, 0, 0, 1]` and is not stored in the affine matrix. Therefore we have `theta` of shape `(N, 2, 3)` for 2D or `(N, 3, 4)` for 3D.\n\nInput `size` is used to define grid of positions evenly spaced in the original 2D or 3D space, with dimensions ranging from `-1` to `1`.\nThe output `grid` contains positions in the output space.\n\nWhen `align_corners=1`, consider `-1` and `1` to refer to the centers of the corner pixels (mark `v` in illustration).\n```\nv            v            v            v\n|-------------------|------------------|\n-1                  0                  1\n```\nWhen `align_corners=0`, consider `-1` and `1` to refer to the outer edge of the corner pixels.\n```\n    v        v         v         v\n|------------------|-------------------|\n-1                 0                   1\n```\n",
+        "examples": [
+            {
+                "code": "theta_2d = create_theta_2d()\nN, C, W, H = len(theta_2d), 3, 5, 6\ndata_size = (W, H)\nfor align_corners in (0, 1):\n    node = onnx.helper.make_node(\n        \"AffineGrid\",\n        inputs=[\"theta\", \"size\"],\n        outputs=[\"grid\"],\n        align_corners=align_corners,\n    )\n\n    original_grid = construct_original_grid(data_size, align_corners)\n    grid = apply_affine_transform(theta_2d, original_grid)\n\n    test_name = \"test_affine_grid_2d\"\n    if align_corners == 1:\n        test_name += \"_align_corners\"\n    expect(\n        node,\n        inputs=[theta_2d, np.array([N, C, W, H], dtype=np.int64)],\n        outputs=[grid],\n        name=test_name,\n    )",
+                "summary": "2d_no_reference_evaluator"
+            },
+            {
+                "code": "theta_3d = create_theta_3d()\nN, C, D, W, H = len(theta_3d), 3, 4, 5, 6\ndata_size = (D, W, H)\nfor align_corners in (0, 1):\n    node = onnx.helper.make_node(\n        \"AffineGrid\",\n        inputs=[\"theta\", \"size\"],\n        outputs=[\"grid\"],\n        align_corners=align_corners,\n    )\n\n    original_grid = construct_original_grid(data_size, align_corners)\n    grid = apply_affine_transform(theta_3d, original_grid)\n\n    test_name = \"test_affine_grid_3d\"\n    if align_corners == 1:\n        test_name += \"_align_corners\"\n    expect(\n        node,\n        inputs=[theta_3d, np.array([N, C, D, W, H], dtype=np.int64)],\n        outputs=[grid],\n        name=test_name,\n    )",
+                "summary": "3d_no_reference_evaluator"
+            }
+        ],
+        "inputs": [
+            {
+                "description": "input batch of affine matrices with shape (N, 2, 3) for 2D or (N, 3, 4) for 3D",
+                "name": "theta",
+                "type": "T1"
+            },
+            {
+                "description": "the target output image size (N, C, H, W) for 2D or (N, C, D, H, W) for 3D",
+                "name": "size",
+                "type": "T2"
+            }
+        ],
+        "max_input": 2,
+        "max_output": 1,
+        "min_input": 2,
+        "min_output": 1,
+        "module": "ai.onnx",
+        "name": "AffineGrid",
+        "outputs": [
+            {
+                "description": "output tensor of shape (N, C, H, W, 2) of 2D sample coordinates or (N, C, D, H, W, 3) of 3D sample coordinates.",
+                "name": "grid",
+                "type": "T1"
+            }
+        ],
+        "support_level": "common",
+        "type_constraints": [
+            {
+                "allowed_type_strs": [
+                    "tensor(bfloat16)",
+                    "tensor(float16)",
+                    "tensor(float)",
+                    "tensor(double)"
+                ],
+                "description": "Constrain grid types to float tensors.",
+                "type_param_str": "T1"
+            },
+            {
+                "allowed_type_strs": [
+                    "tensor(int64)"
+                ],
+                "description": "Constrain size's type to int64 tensors.",
+                "type_param_str": "T2"
+            }
+        ],
+        "version": 20
+    },
+    {
+        "attributes": [
+            {
                 "description": "If set, defines the broadcast dimensions.",
                 "name": "axis",
                 "required": false,
                 "type": "int64"
             },
             {
                 "description": "Enable broadcasting",
@@ -7617,19 +7684,27 @@
                 "summary": "axis"
             },
             {
                 "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\", \"x_zero_point\"],\n    outputs=[\"y\"],\n)\n\n# scalar zero point and scale\nx = np.array([0, 3, 128, 255]).astype(np.uint8)\nx_scale = np.float32(2)\nx_zero_point = np.uint8(128)\ny = np.array([-256, -250, 0, 254], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale, x_zero_point],\n    outputs=[y],\n    name=\"test_dequantizelinear\",\n)",
                 "summary": "dequantizelinear"
             },
             {
-                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, 104])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 896.0, 208.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e4m3fn\",\n)",
+                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n    axis=0,\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, -104])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 896.0, -208.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e4m3fn\",\n)",
                 "summary": "e4m3fn"
             },
             {
-                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E5M2, [5], [0, 0.5, 1, 49152, 96])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 98304.0, 192.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e5m2\",\n)",
+                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n    axis=0,\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, -104])\nx_scale = np.float16(2)\ny = np.array([0.0, 1.0, 2.0, 896.0, -208.0], dtype=np.float16)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e4m3fn_float16\",\n)",
+                "summary": "e4m3fn_float16"
+            },
+            {
+                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\", \"zero_point\"],\n    outputs=[\"y\"],\n    axis=0,\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, -104])\nzero_point = make_tensor(\"zero_point\", TensorProto.FLOAT8E4M3FN, [1], [0])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 896.0, -208.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale, zero_point],\n    outputs=[y],\n    name=\"test_dequantizelinear_e4m3fn_zero_point\",\n)",
+                "summary": "e4m3fn_zero_point"
+            },
+            {
+                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n    axis=0,\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E5M2, [5], [0, 0.5, 1, 49152, -96])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 98304.0, -192.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e5m2\",\n)",
                 "summary": "e5m2"
             }
         ],
         "inputs": [
             {
                 "description": "N-D quantized input tensor to be de-quantized.",
                 "name": "x",
@@ -7692,19 +7767,27 @@
                 "summary": "axis"
             },
             {
                 "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\", \"x_zero_point\"],\n    outputs=[\"y\"],\n)\n\n# scalar zero point and scale\nx = np.array([0, 3, 128, 255]).astype(np.uint8)\nx_scale = np.float32(2)\nx_zero_point = np.uint8(128)\ny = np.array([-256, -250, 0, 254], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale, x_zero_point],\n    outputs=[y],\n    name=\"test_dequantizelinear\",\n)",
                 "summary": "dequantizelinear"
             },
             {
-                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, 104])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 896.0, 208.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e4m3fn\",\n)",
+                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n    axis=0,\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, -104])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 896.0, -208.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e4m3fn\",\n)",
                 "summary": "e4m3fn"
             },
             {
-                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E5M2, [5], [0, 0.5, 1, 49152, 96])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 98304.0, 192.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e5m2\",\n)",
+                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n    axis=0,\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, -104])\nx_scale = np.float16(2)\ny = np.array([0.0, 1.0, 2.0, 896.0, -208.0], dtype=np.float16)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e4m3fn_float16\",\n)",
+                "summary": "e4m3fn_float16"
+            },
+            {
+                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\", \"zero_point\"],\n    outputs=[\"y\"],\n    axis=0,\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, -104])\nzero_point = make_tensor(\"zero_point\", TensorProto.FLOAT8E4M3FN, [1], [0])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 896.0, -208.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale, zero_point],\n    outputs=[y],\n    name=\"test_dequantizelinear_e4m3fn_zero_point\",\n)",
+                "summary": "e4m3fn_zero_point"
+            },
+            {
+                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n    axis=0,\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E5M2, [5], [0, 0.5, 1, 49152, -96])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 98304.0, -192.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e5m2\",\n)",
                 "summary": "e5m2"
             }
         ],
         "inputs": [
             {
                 "description": "N-D quantized input tensor to be de-quantized.",
                 "name": "x",
@@ -7767,19 +7850,27 @@
                 "summary": "axis"
             },
             {
                 "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\", \"x_zero_point\"],\n    outputs=[\"y\"],\n)\n\n# scalar zero point and scale\nx = np.array([0, 3, 128, 255]).astype(np.uint8)\nx_scale = np.float32(2)\nx_zero_point = np.uint8(128)\ny = np.array([-256, -250, 0, 254], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale, x_zero_point],\n    outputs=[y],\n    name=\"test_dequantizelinear\",\n)",
                 "summary": "dequantizelinear"
             },
             {
-                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, 104])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 896.0, 208.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e4m3fn\",\n)",
+                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n    axis=0,\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, -104])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 896.0, -208.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e4m3fn\",\n)",
                 "summary": "e4m3fn"
             },
             {
-                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E5M2, [5], [0, 0.5, 1, 49152, 96])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 98304.0, 192.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e5m2\",\n)",
+                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n    axis=0,\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, -104])\nx_scale = np.float16(2)\ny = np.array([0.0, 1.0, 2.0, 896.0, -208.0], dtype=np.float16)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e4m3fn_float16\",\n)",
+                "summary": "e4m3fn_float16"
+            },
+            {
+                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\", \"zero_point\"],\n    outputs=[\"y\"],\n    axis=0,\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E4M3FN, [5], [0, 0.5, 1, 448, -104])\nzero_point = make_tensor(\"zero_point\", TensorProto.FLOAT8E4M3FN, [1], [0])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 896.0, -208.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale, zero_point],\n    outputs=[y],\n    name=\"test_dequantizelinear_e4m3fn_zero_point\",\n)",
+                "summary": "e4m3fn_zero_point"
+            },
+            {
+                "code": "node = onnx.helper.make_node(\n    \"DequantizeLinear\",\n    inputs=[\"x\", \"x_scale\"],\n    outputs=[\"y\"],\n    axis=0,\n)\n\n# scalar zero point and scale\nx = make_tensor(\"x\", TensorProto.FLOAT8E5M2, [5], [0, 0.5, 1, 49152, -96])\nx_scale = np.float32(2)\ny = np.array([0.0, 1.0, 2.0, 98304.0, -192.0], dtype=np.float32)\n\nexpect(\n    node,\n    inputs=[x, x_scale],\n    outputs=[y],\n    name=\"test_dequantizelinear_e5m2\",\n)",
                 "summary": "e5m2"
             }
         ],
         "inputs": [
             {
                 "description": "N-D quantized input tensor to be de-quantized.",
                 "name": "x",
```

## netron/server.py

```diff
@@ -11,15 +11,15 @@
 import socketserver
 import sys
 import threading
 import time
 import webbrowser
 import urllib.parse
 
-__version__ = '7.0.9'
+__version__ = '7.1.0'
 
 class _ContentProvider: # pylint: disable=too-few-public-methods
     data = bytearray()
     base_dir = ''
     base = ''
     identifier = ''
     def __init__(self, data, path, file):
```

## netron/tensorrt.js

### js-beautify {}

```diff
@@ -149,17 +149,17 @@
 
     get format() {
         this._read();
         return 'TensorRT FlatBuffers';
     }
 
     _read() {
-        const buffer = this._stream.peek(Math.min(24, this._stream.length));
-        const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
-        throw new tensorrt.Error('Invalid file content. File contains undocumented TensorRT data (' + content.substring(16) + ').');
+        // const buffer = this._stream.peek(Math.min(24, this._stream.length));
+        // const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
+        throw new tensorrt.Error('Invalid file content. File contains undocumented TensorRT data.');
     }
 };
 
 tensorrt.BinaryReader = class extends base.BinaryReader {
 
     string() {
         const length = this.uint64();
```

## netron/view.js

### js-beautify {}

```diff
@@ -1047,15 +1047,15 @@
                     error.context = this._model.identifier;
                 }
                 this.error(error, 'Error showing model properties.', null);
             }
         }
     }
 
-    showNodeProperties(node, input) {
+    showNodeProperties(node) {
         if (node) {
             try {
                 if (this._menu) {
                     this._menu.close();
                 }
                 const nodeSidebar = new view.NodeSidebar(this._host, node);
                 nodeSidebar.on('show-documentation', ( /* sender, e */ ) => {
@@ -1095,27 +1095,45 @@
                 });
                 nodeSidebar.on('activate', (sender, argument) => {
                     this._graph.select([argument]);
                 });
                 nodeSidebar.on('deactivate', () => {
                     this._graph.select(null);
                 });
-                if (input) {
-                    nodeSidebar.toggleInput(input.name);
-                }
                 this._sidebar.open(nodeSidebar.render(), 'Node Properties');
             } catch (error) {
                 if (error) {
                     error.context = this._model.identifier;
                 }
                 this.error(error, 'Error showing node properties.', null);
             }
         }
     }
 
+    showConnectionProperties(argument) {
+        try {
+            if (this._menu) {
+                this._menu.close();
+            }
+            const connectionSidebar = new view.ConnectionSidebar(this._host, argument);
+            connectionSidebar.on('error', (sender, error) => {
+                if (this._model) {
+                    error.context = this._model.identifier;
+                }
+                this.error(error, null, null);
+            });
+            this._sidebar.open(connectionSidebar.render(), 'Connection Properties');
+        } catch (error) {
+            if (error) {
+                error.context = this._model.identifier;
+            }
+            this.error(error, 'Error showing connection properties.', null);
+        }
+    }
+
     showDocumentation(type) {
         if (type && (type.description || type.inputs || type.outputs || type.attributes)) {
             if (type.nodes && type.nodes.length > 0) {
                 this.pushGraph(type);
             }
             const documentationSidebar = new view.DocumentationSidebar(this._host, type);
             documentationSidebar.on('navigate', (sender, e) => {
@@ -1907,15 +1925,15 @@
                 error.context = this.context.model.identifier;
             }
             throw error;
         }
         const content = this.context.view.options.names && (node.name || node.location) ? (node.name || node.location) : type.name.split('.').pop();
         const tooltip = this.context.view.options.names && (node.name || node.location) ? type.name : (node.name || node.location);
         const title = header.add(null, styles, content, tooltip);
-        title.on('click', () => this.context.view.showNodeProperties(node, null));
+        title.on('click', () => this.context.view.showNodeProperties(node));
         if (node.type.nodes && node.type.nodes.length > 0) {
             const definition = header.add(null, styles, '\u0192', 'Show Function Definition');
             definition.on('click', () => this.context.view.pushGraph(node.type));
         }
         if (node.nodes) {
             // this._expand = header.add(null, styles, '+', null);
             // this._expand.on('click', () => this.toggle());
@@ -2146,33 +2164,36 @@
             edge.deselect();
         }
     }
 };
 
 view.Edge = class extends grapher.Edge {
 
-    constructor(argument, from, to) {
+    constructor(value, from, to) {
         super(from, to);
-        this.argument = argument;
+        this.value = value;
     }
 
     get minlen() {
-        if (this.from.inputs.every((parameter) => parameter.value.every((argument) => argument.initializer))) {
+        if (this.from.inputs.every((argument) => argument.value.every((value) => value.initializer))) {
             return 2;
         }
         return 1;
     }
 
     emit(event) {
         switch (event) {
             case 'pointerover':
-                this.argument.context.focus([this.argument.value]);
+                this.value.context.focus([this.value.value]);
                 break;
             case 'pointerleave':
-                this.argument.context.blur([this.argument.value]);
+                this.value.context.blur([this.value.value]);
+                break;
+            case 'click':
+                // this.value.context.view.showConnectionProperties(this.value.value);
                 break;
             default:
                 break;
         }
     }
 };
 
@@ -2401,21 +2422,27 @@
             value.on('activate', (sender, value) => this.emit('activate', value));
             value.on('deactivate', (sender, value) => this.emit('deactivate', value));
             const item = new view.NameValueView(this._host, name, value);
             this._outputs.push(item);
             this._elements[0].appendChild(item.render());
         }
     }
+};
 
-    toggleInput(name) {
-        for (const input of this._inputs) {
-            if (name == input.name) {
-                input.toggle();
-            }
-        }
+view.ConnectionSidebar = class extends view.Control {
+
+    constructor(host, argument) {
+        super();
+        this._host = host;
+        this._argument = argument;
+        this._elements = [];
+    }
+
+    render() {
+        return this._elements;
     }
 };
 
 view.NameValueView = class {
 
     constructor(host, name, value) {
         this._host = host;
```

## Comparing `netron-7.0.9.dist-info/METADATA` & `netron-7.1.0.dist-info/METADATA`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: netron
-Version: 7.0.9
+Version: 7.1.0
 Summary: Viewer for neural network, deep learning, and machine learning models
 Home-page: https://github.com/lutzroeder/netron
 Author: Lutz Roeder
 Author-email: lutzroeder@users.noreply.github.com
 License: MIT
 Keywords: onnx,keras,tensorflow,tflite,coreml,mxnet,caffe,caffe2,torchscript,pytorch,ncnn,mnn,openvino,darknet,paddlepaddle,chainer,artificial intelligence,machine learning,deep learning,neural network,visualizer,viewer
 Classifier: Intended Audience :: Developers
```

## Comparing `netron-7.0.9.dist-info/RECORD` & `netron-7.1.0.dist-info/RECORD`

 * *Files 19% similar despite different names*

```diff
@@ -27,35 +27,35 @@
 netron/coreml-proto.js,sha256=3tC_Q_sup8cSzgHzdflSKVz97Ghrkzr1BJAbvCU0HYA,415701
 netron/coreml.js,sha256=lfpLJO7J6VeyFhHn1QoQgX4Mz6h15AY9Eh1f28_4-Ks,68028
 netron/dagre.js,sha256=mpY-dfNmzuFCrna4ld50bSM31xd9EhxEohZFG2X8KYI,102117
 netron/darknet-metadata.json,sha256=dw1vThEJwGVlV74G2cvyzQ6v7LWoGdF_LAnUM77JfXk,20570
 netron/darknet.js,sha256=ZGevgBNQdtdzGLpuzpKH83Ow8iNngVtl3RXK5LBo2tc,54886
 netron/dl4j-metadata.json,sha256=wh1OJVSWT2PQtQRq35NanPXfNF8s0bspM2Ww573U8To,1417
 netron/dl4j.js,sha256=5RCP4eaRqHlV8k9M7aO3puMrKcHlrzS6rjNM3oaS96I,16955
-netron/dlc-metadata.json,sha256=XIWHz1A0Wvi65Nh5ztVtilFUwZCdxjrGv-0XRTUzQdQ,735
-netron/dlc-schema.js,sha256=5fIESjqcEXdAWfJQGEfJ7nqAvkRcZ3OIEvKG_VZh998,3277
-netron/dlc.js,sha256=damZ9NWQDolzGt_GogyZW97We3d1lhoQtP1HYqNeNJ8,17870
+netron/dlc-metadata.json,sha256=VKrDC_pYt3IvHyUMmBb3Rvw6W_UZVl9UV5A3k_FSJqE,2309
+netron/dlc-schema.js,sha256=M2wD-2CaEGkoxwv4-ivwNayP3HLLGsmhnRbpAKG497I,8706
+netron/dlc.js,sha256=etIbzhNNiPs9t_VZW9pw2cZwH_sPxbl8hunT99ERdqA,26954
 netron/dnn-metadata.json,sha256=5-48ChRcuDJQ5WA6_c5xOYs66J3XjsPYbrz7LyH_d9E,1777
 netron/dnn-proto.js,sha256=vpoxH8Jw21cerjYxea6AL1EAfcnO-lhqEjAbJWYu5L0,11533
 netron/dnn.js,sha256=qkpCsurI6f-Q2gsCjj3_dmLDKFFJ5rOqrihNuc8XxA0,10594
 netron/favicon.ico,sha256=o3hrI04KVfImdrgo9Ucs1f27tMPVjCiJzGogjeR8pHg,34494
 netron/flatbuffers.js,sha256=2IFTatwF8YRtHR-0dO69W5gGxmKgZMc7L8qzPB7zIzI,11358
 netron/flax.js,sha256=8bNiqG8IluO0Sg3P-eo0X6juZn44kTVceL5SK2XFfeE,7734
 netron/flexbuffers.js,sha256=djGSf33a0wTn_3Ux2i7ZO5kJwESfB7WqnEcS2eXRiEI,7568
 netron/flux-metadata.json,sha256=lK6y0flbBJakM3nkhtmqqPtuJrN4D2n9pM_k0MPDR0c,3
 netron/flux.js,sha256=wk8auutcR8pX2X1EeGEYiQWI8bIn_r77O6qYo2tj1OI,2409
 netron/grapher.css,sha256=SEFVqi9GiIiYiZ-HN6vzxoqhBKk14uJrwJaARcvBca4,6061
-netron/grapher.js,sha256=MYfStDExyjpBUDXbP8-LABRUnN-lCQxsIH_cyyGPqyY,25528
+netron/grapher.js,sha256=PYuEgUOBzt9lSuaY4KPHHV3LS3gPJKYKwZ2hfWKtgzo,25602
 netron/hailo-metadata.json,sha256=RVG-oCGnGid9UOHRdIQ_BINS-GkvG7uyTenguCiKdMs,29456
 netron/hailo.js,sha256=6z49tAAkjcNuV_Uo1BmpmPsZLIEZDjUlVJ-lYyI_1lA,11521
 netron/hdf5.js,sha256=-iS1B7LVP_ogiXwyz0GlKh5rxScT8HWSsHl5YakMNK4,57289
 netron/hickle.js,sha256=R1V48MTME8WhYOTYJa6ijS2tpvbWMeqBRX7qJZO51bw,6789
 netron/icon.png,sha256=8PZX7X6-sLBgonyQTGelX60C661x3YZ13eIGcuXQcHc,58106
 netron/imgdnn.js,sha256=qhg0atOv43eoRVT8d6hIkPgEQOu8Fsu3ANb6QVttQWc,1392
-netron/index.html,sha256=YOskN57byJucWZiFNlfJ4eKsCy6NKsmr1Mj-MDerQus,44057
+netron/index.html,sha256=Rmp5x5dJmRGhwLXAJcbaCqJndemirW_EhPWX6-YUedQ,44057
 netron/index.js,sha256=NDSySEu8DFQ0mN00nDOJZXQdXP7nG90INtJ1f6sYx_Q,4113
 netron/json.js,sha256=cor_V2_vWltKePIM5OQMvmZRwyl4wsn9vkejf2i4G2c,18643
 netron/keras-metadata.json,sha256=PExbUAIA4PpP35ARwz8Lp66EKfgIuAEY1b2_yWTZzLQ,254682
 netron/keras.js,sha256=HHJxewX74eI-crOS3IYnYrIdpWf1bGyQonHncjlkH5Y,54531
 netron/kmodel.js,sha256=l0zlbLQY2chZCGbQKQpEomsQo3tD7Vv3j7RsRBQAckA,64052
 netron/lasagne-metadata.json,sha256=UAy5q6DnjJWEav_Vo-G-OncwvHVuytNlTStpDJ8MB2U,244
 netron/lasagne.js,sha256=YMDnlOtC8cqHh_SICDF4E_gRsXJNBnTRnkGHcAZdC4g,7050
@@ -83,15 +83,15 @@
 netron/nnef.js,sha256=gOoqFv531ftHkGbC_otlXYE79qAnzkDjDXkCFSGbnt8,2224
 netron/numpy.js,sha256=rFVSNsdTf5NjTCyagrvLgkGhq1Z8X4ElDPf-aZPOn0E,15163
 netron/om-metadata.json,sha256=nWz35Zjqfe_JqM9F9mydQnso0k4j3D1YuKgMJpS8_4Y,53079
 netron/om-proto.js,sha256=1SbZHKiX3S0r98-rX8dGl4bsF7x-DrQDbNxseeunpks,37006
 netron/om.js,sha256=BGiqgu75KFRTHSkBLgGqgAJbzbff9F4F5bQxVLMfdRE,29164
 netron/onednn-metadata.json,sha256=ZzCrrVEwXx36AWZ_TbOLa6PM-VL4LpEit0u35yj_-LU,6818
 netron/onednn.js,sha256=GN22Xi5q2pKMPxMoIfV9vjojpiRhaz8f0LU5jZedZuM,11961
-netron/onnx-metadata.json,sha256=wDQ3VV3BQRDmkugz9MBK6FylFd9r37Hp9bNlKsvQGgw,2903929
+netron/onnx-metadata.json,sha256=9CqZ-2b9qbmcGHeOS6V7zUZdCqpCnyuAZc5DLQiuwrA,2912056
 netron/onnx-proto.js,sha256=l35_Dhs_wpLvGTuSmWuHsRfXBiJU97JdCA7PzzsvV_s,59899
 netron/onnx-schema.js,sha256=bCJy80ZVAxcNbsa60fBbpJCzOoapMZjf4TnAutaBzqU,15717
 netron/onnx.js,sha256=B5hzPPUE31MlB8B6Qe1nkE7UlALQDjT3HDuneGnDR5o,88981
 netron/onnx.py,sha256=GkNnqLXIZjHMviBblu_XorcDKrNcvmVZ0A-Yxg5l2Hg,9053
 netron/openvino-metadata.json,sha256=heC0fS0DL26NLrlVXcEcs4GldF_LYWDBJp2iI1G8_zo,84585
 netron/openvino.js,sha256=jlRGDsNzIHgcdt9vgT0llqZehJGbPQ0f9UGvssy0wH4,44560
 netron/paddle-metadata.json,sha256=iyV8jUl7AhSOMTVcWLrChsBqS1l8iqGYl99KLYFl93w,2894
@@ -106,39 +106,39 @@
 netron/pytorch.js,sha256=-bumsIBab2IDf_9pr9Vee4NzUmpeYOQbiSvKlZEHouw,182294
 netron/pytorch.py,sha256=gkEnA4OGqooxARhnsEZfzDYmAsycMSTkLXIB1hMJm9Y,24259
 netron/rknn-metadata.json,sha256=KaVXz6q_TPrAFBaOaSvHhNDU2m-rmeyIl2NThAa7lxY,5473
 netron/rknn-schema.js,sha256=i5gzD6mHjr1jFjTv30mHJk13KErOdaX3O4xSWabkLzE,4263
 netron/rknn.js,sha256=7sCaiyVpOvHJspBq0H4-gZ0SLosDa3DLplwj0hAzyik,24805
 netron/safetensors.js,sha256=sNrm4dJlfj5cPKOzMH_IknrxS3juImytbC_2Pl-l9xI,4571
 netron/server.js,sha256=uo-0Btwxwc2h9E91ANSjwx5YT0Q36FPN5RXP2M9LlDM,5865
-netron/server.py,sha256=BaxvSudA_Xdg_jKWU-wxcOjyKPBrz0C69uEJWNnxFyA,11874
+netron/server.py,sha256=ZCWthynMu_W_DTzs6udDhAksGcjMhOz6-OdGSGIiCuU,11874
 netron/sklearn-metadata.json,sha256=L9UWeoEfqkFzZOT4WiupFpVwdDvcuwlXiesuChzqIwc,160693
 netron/sklearn.js,sha256=a_yRJGsbcy67pBI-T6Y9mF2VWTtCrNlPLSyQEZwvfMo,14746
 netron/tar.js,sha256=ivL2nPokTaMqz9X763EoNzDOS802A4hH2HkLjJYFLoU,4901
 netron/tengine-metadata.json,sha256=v4dIwOf9t_f1bhYkJBORa71SBWlYuwi3LuZZJQjcYGY,27914
 netron/tengine.js,sha256=ZLNFxRmPo4hNLJaFQbBa5ZRIkZxvUnPj7eq9DbkeYiQ,28094
-netron/tensorrt.js,sha256=g_95J0_u3AvdSb8W17UbwOn1RqtGVpUL3UKSmEnOXRQ,5304
+netron/tensorrt.js,sha256=yi8c89zuTvk_rfHdzgCi0FwALclKWUe0u8KiKABmtGY,5278
 netron/text.js,sha256=RtcaVwGuG3uC0zGcc4MOjV3pqBNG8e3ZVSqtsO_fUKU,11077
 netron/tf-metadata.json,sha256=voCEpb8UnnWZ8LG9MDgbDaMZ3YL3FwBhuv1RfWri6wY,2221556
 netron/tf-proto.js,sha256=MWEi1dbXh0uxz6-yNUvF93YaJaXW-M8nQ6o2oNpK2qE,363531
 netron/tf.js,sha256=1pA_ADwOWO1mmbU5h_KC1A-u8Ng6E2v9stGA7ceipDA,106578
 netron/tflite-metadata.json,sha256=4m1DYqLQIdjRr_Uc2As8fHnEESlfTq2JsRsOt7RFskQ,29824
 netron/tflite-schema.js,sha256=jNEC9GMvUsKb2alsDWKtrgaTuNXb6CsDI_P41Ah13i4,110995
 netron/tflite.js,sha256=S18nbCeCNE22JdX_unKbPR3MnVT5CxfLPvlLE3Qqtmg,25098
 netron/tnn-metadata.json,sha256=Je5JnWH0t4gWsSkj9YbWIzzbcYEoP3XXwVMa7sAH3_A,20380
 netron/tnn.js,sha256=sBCYEleRWan_kJg_r3p8qalT3JM3Xacv9JIv13LpvMo,26868
 netron/torch-metadata.json,sha256=fj2b1n_Ih7eZdst4ohdUEAL5T3XmjTMlkUBmUo3Ogng,12510
 netron/torch.js,sha256=WcrV81ntqURliC20t3YHpd_iF3f_omGyprl1OOUNsns,41535
 netron/uff-metadata.json,sha256=kVCe02DZKfSoTgwqfjh18jQcImre1KcYkg76_WNOagI,2333
 netron/uff-proto.js,sha256=U7-KLsLgvBdSeBEclHE8-xaWMqMN_PjoziTOmH7EK9Y,30910
 netron/uff.js,sha256=lgq1pojhH6rClTEL88hgntJwG6-TrXoW6z4WjcRC5HY,12710
-netron/view.js,sha256=zYpbPHe7lUr_jWL2qO0tr3vGGKU7FIIbtYmYh8TE39g,236381
+netron/view.js,sha256=pJgK3fKDV8DrshbNS6SkXfRDPBGsSBKpahn3qoj9YAo,237224
 netron/weka.js,sha256=TAiwO3z0KhjtfbHOZrfVSidJlJKy538Uu2aCmyyF3aM,8023
 netron/xml.js,sha256=_zng3WkOrLR4OvBYMs0aD04pbmUq6Q2QJQxtETbi2Rw,64034
 netron/xmodel-proto.js,sha256=mFk07nBgAyXBOWllxg-fw-2EGEaIxF231wXlNLK6v5A,55685
 netron/xmodel.js,sha256=FYHJt1B-Ony6vPc_GiGoq9YIkXZyNqrgCfGD3RQTIHg,13916
 netron/zip.js,sha256=Ji6a_L_wsrMJWJm6xyL-Ld_JFFjFB-e2D8plcW-5GQg,30921
-netron-7.0.9.dist-info/METADATA,sha256=hGbbGxtU4CApTM26NhUENzHk5z52iZBSZT0fuAkhb1Y,1447
-netron-7.0.9.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
-netron-7.0.9.dist-info/entry_points.txt,sha256=3fHM6H_AIEjt21838iCMZ72hmRqtnNTuL66UnCIOSpU,39
-netron-7.0.9.dist-info/top_level.txt,sha256=qt4XhfLsmugdsjAczetcmraULS1GexprL8Ruo2YQubU,7
-netron-7.0.9.dist-info/RECORD,,
+netron-7.1.0.dist-info/METADATA,sha256=WTa2y5OQzAQXJAvqybTbj-JZ-kWKPF-6ZdoSa9EjjlA,1447
+netron-7.1.0.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
+netron-7.1.0.dist-info/entry_points.txt,sha256=3fHM6H_AIEjt21838iCMZ72hmRqtnNTuL66UnCIOSpU,39
+netron-7.1.0.dist-info/top_level.txt,sha256=qt4XhfLsmugdsjAczetcmraULS1GexprL8Ruo2YQubU,7
+netron-7.1.0.dist-info/RECORD,,
```

