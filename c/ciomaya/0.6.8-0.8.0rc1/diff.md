# Comparing `tmp/ciomaya-0.6.8-py2.py3-none-any.whl.zip` & `tmp/ciomaya-0.8.0rc1-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,88 +1,89 @@
-Zip file size: 132673 bytes, number of entries: 86
--rw-r--r--  2.0 unx        5 b- defN 22-Jul-28 18:23 ciomaya/VERSION
--rw-r--r--  2.0 unx        1 b- defN 22-Jul-28 18:22 ciomaya/__init__.py
--rw-r--r--  2.0 unx       36 b- defN 22-Jul-28 18:23 ciomaya/conductor.mod
--rw-r--r--  2.0 unx     2571 b- defN 22-Jul-28 18:22 ciomaya/post_install.py
--rw-r--r--  2.0 unx      939 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorConnect_18x18.png
--rw-r--r--  2.0 unx     1254 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorConnect_24x24.png
--rw-r--r--  2.0 unx     1585 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorConnect_30x30.png
--rw-r--r--  2.0 unx     1815 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorConnect_36x36.png
--rw-r--r--  2.0 unx     1137 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorError_18x18.png
--rw-r--r--  2.0 unx     1553 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorError_24x24.png
--rw-r--r--  2.0 unx     1832 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorError_30x30.png
--rw-r--r--  2.0 unx     2265 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorError_36x36.png
--rw-r--r--  2.0 unx      932 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorHelp_18x18.png
--rw-r--r--  2.0 unx     1053 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorHelp_24x24.png
--rw-r--r--  2.0 unx     1223 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorHelp_30x30.png
--rw-r--r--  2.0 unx     1366 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorHelp_36x36.png
--rw-r--r--  2.0 unx      748 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorInfo_18x18.png
--rw-r--r--  2.0 unx      892 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorInfo_24x24.png
--rw-r--r--  2.0 unx      972 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorInfo_30x30.png
--rw-r--r--  2.0 unx     1151 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorInfo_36x36.png
--rw-r--r--  2.0 unx     1047 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorShow_18x18.png
--rw-r--r--  2.0 unx     1392 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorShow_24x24.png
--rw-r--r--  2.0 unx     1762 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorShow_30x30.png
--rw-r--r--  2.0 unx     2160 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorShow_36x36.png
--rw-r--r--  2.0 unx      716 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorSubmit_18x18.png
--rw-r--r--  2.0 unx      886 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorSubmit_24x24.png
--rw-r--r--  2.0 unx     1023 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorSubmit_30x30.png
--rw-r--r--  2.0 unx     1142 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorSubmit_36x36.png
--rw-r--r--  2.0 unx      932 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorWarning_18x18.png
--rw-r--r--  2.0 unx     1177 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorWarning_24x24.png
--rw-r--r--  2.0 unx     1403 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorWarning_30x30.png
--rw-r--r--  2.0 unx     1668 b- defN 22-Jul-28 18:23 ciomaya/icons/ConductorWarning_36x36.png
--rw-r--r--  2.0 unx      776 b- defN 22-Jul-28 18:23 ciomaya/icons/conductorRender.png
--rw-r--r--  2.0 unx    30014 b- defN 22-Jul-28 18:22 ciomaya/icons/conductor_logo_white.png
--rw-r--r--  2.0 unx      344 b- defN 22-Jul-28 18:23 ciomaya/icons/out_conductorRender.png
--rw-r--r--  2.0 unx        1 b- defN 22-Jul-28 18:22 ciomaya/lib/__init__.py
--rw-r--r--  2.0 unx     1116 b- defN 22-Jul-28 18:22 ciomaya/lib/asset_cache.py
--rw-r--r--  2.0 unx     3771 b- defN 22-Jul-28 18:22 ciomaya/lib/conductor_menu.py
--rw-r--r--  2.0 unx      990 b- defN 22-Jul-28 18:22 ciomaya/lib/const.py
--rw-r--r--  2.0 unx     3079 b- defN 22-Jul-28 18:22 ciomaya/lib/context.py
--rw-r--r--  2.0 unx     1009 b- defN 22-Jul-28 18:22 ciomaya/lib/layer_utils.py
--rw-r--r--  2.0 unx     1033 b- defN 22-Jul-28 18:22 ciomaya/lib/node_utils.py
--rw-r--r--  2.0 unx     3449 b- defN 22-Jul-28 18:22 ciomaya/lib/renderman_path_utils.py
--rw-r--r--  2.0 unx     1148 b- defN 22-Jul-28 18:22 ciomaya/lib/scraper.py
--rw-r--r--  2.0 unx     7457 b- defN 22-Jul-28 18:22 ciomaya/lib/scraper_utils.py
--rw-r--r--  2.0 unx     2067 b- defN 22-Jul-28 18:22 ciomaya/lib/software.py
--rw-r--r--  2.0 unx     6060 b- defN 22-Jul-28 18:22 ciomaya/lib/submit.py
--rw-r--r--  2.0 unx    28042 b- defN 22-Jul-28 18:22 ciomaya/lib/validation.py
--rw-r--r--  2.0 unx     5929 b- defN 22-Jul-28 18:22 ciomaya/lib/window.py
--rw-r--r--  2.0 unx     4095 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEactions.py
--rw-r--r--  2.0 unx     3444 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEcommon.py
--rw-r--r--  2.0 unx     3442 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEdestination.py
--rw-r--r--  2.0 unx     3580 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEemails.py
--rw-r--r--  2.0 unx     4305 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEenvironment.py
--rw-r--r--  2.0 unx     4402 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEextraAssets.py
--rw-r--r--  2.0 unx     2769 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEframes.py
--rw-r--r--  2.0 unx     5801 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEinstanceType.py
--rw-r--r--  2.0 unx     1188 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AElayers.py
--rw-r--r--  2.0 unx     3201 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEmetadata.py
--rw-r--r--  2.0 unx      976 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEoutput.py
--rw-r--r--  2.0 unx     2459 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEproject.py
--rw-r--r--  2.0 unx    13697 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEscrapers.py
--rw-r--r--  2.0 unx    12710 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEsoftware.py
--rw-r--r--  2.0 unx     1293 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/AEtaskTemplate.py
--rw-r--r--  2.0 unx        0 b- defN 22-Jul-28 18:22 ciomaya/lib/ae/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 22-Jul-28 18:22 ciomaya/lib/nodes/__init__.py
--rw-r--r--  2.0 unx    37047 b- defN 22-Jul-28 18:22 ciomaya/lib/nodes/conductorRender.py
--rw-r--r--  2.0 unx     2971 b- defN 22-Jul-28 18:23 ciomaya/plug-ins/Conductor.py
--rw-r--r--  2.0 unx    10125 b- defN 22-Jul-28 18:22 ciomaya/scripts/AEconductorRenderTemplate.mel
--rw-r--r--  2.0 unx      972 b- defN 22-Jul-28 18:22 ciomaya/scripts/glob_scrape_image_planes.py
--rw-r--r--  2.0 unx      706 b- defN 22-Jul-28 18:22 ciomaya/scripts/old_scrape_xgen.py
--rw-r--r--  2.0 unx     1846 b- defN 22-Jul-28 18:22 ciomaya/scripts/scrape_bifrost.py
--rw-r--r--  2.0 unx     2385 b- defN 22-Jul-28 18:22 ciomaya/scripts/scrape_image_planes.py
--rw-r--r--  2.0 unx     4046 b- defN 22-Jul-28 18:22 ciomaya/scripts/scrape_maya.py
--rw-r--r--  2.0 unx     3236 b- defN 22-Jul-28 18:22 ciomaya/scripts/scrape_mtoa.py
--rw-r--r--  2.0 unx     4362 b- defN 22-Jul-28 18:22 ciomaya/scripts/scrape_mtoa_standins.py
--rw-r--r--  2.0 unx     1318 b- defN 22-Jul-28 18:22 ciomaya/scripts/scrape_ocio.py
--rw-r--r--  2.0 unx     2128 b- defN 22-Jul-28 18:22 ciomaya/scripts/scrape_redshift.py
--rw-r--r--  2.0 unx      535 b- defN 22-Jul-28 18:22 ciomaya/scripts/scrape_renderman.py
--rw-r--r--  2.0 unx      806 b- defN 22-Jul-28 18:22 ciomaya/scripts/scrape_vray.py
--rw-r--r--  2.0 unx     4153 b- defN 22-Jul-28 18:22 ciomaya/scripts/scrape_xgen.py
--rw-r--r--  2.0 unx     4865 b- defN 22-Jul-28 18:22 ciomaya/scripts/scrape_yeti.py
--rw-r--r--  2.0 unx    19913 b- defN 22-Jul-28 18:23 ciomaya-0.6.8.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 22-Jul-28 18:23 ciomaya-0.6.8.dist-info/WHEEL
--rw-r--r--  2.0 unx        8 b- defN 22-Jul-28 18:23 ciomaya-0.6.8.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     7576 b- defN 22-Jul-28 18:23 ciomaya-0.6.8.dist-info/RECORD
-86 files, 311393 bytes uncompressed, 120599 bytes compressed:  61.3%
+Zip file size: 138601 bytes, number of entries: 87
+-rw-r--r--  2.0 unx       10 b- defN 23-Jul-06 04:22 ciomaya/VERSION
+-rw-r--r--  2.0 unx        1 b- defN 23-Jul-06 04:22 ciomaya/__init__.py
+-rw-r--r--  2.0 unx       41 b- defN 23-Jul-06 04:22 ciomaya/conductor.mod
+-rw-r--r--  2.0 unx     2571 b- defN 23-Jul-06 04:22 ciomaya/post_install.py
+-rw-r--r--  2.0 unx      939 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorConnect_18x18.png
+-rw-r--r--  2.0 unx     1254 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorConnect_24x24.png
+-rw-r--r--  2.0 unx     1585 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorConnect_30x30.png
+-rw-r--r--  2.0 unx     1815 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorConnect_36x36.png
+-rw-r--r--  2.0 unx     1137 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorError_18x18.png
+-rw-r--r--  2.0 unx     1553 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorError_24x24.png
+-rw-r--r--  2.0 unx     1832 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorError_30x30.png
+-rw-r--r--  2.0 unx     2265 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorError_36x36.png
+-rw-r--r--  2.0 unx      932 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorHelp_18x18.png
+-rw-r--r--  2.0 unx     1053 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorHelp_24x24.png
+-rw-r--r--  2.0 unx     1223 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorHelp_30x30.png
+-rw-r--r--  2.0 unx     1366 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorHelp_36x36.png
+-rw-r--r--  2.0 unx      748 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorInfo_18x18.png
+-rw-r--r--  2.0 unx      892 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorInfo_24x24.png
+-rw-r--r--  2.0 unx      972 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorInfo_30x30.png
+-rw-r--r--  2.0 unx     1151 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorInfo_36x36.png
+-rw-r--r--  2.0 unx     1047 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorShow_18x18.png
+-rw-r--r--  2.0 unx     1392 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorShow_24x24.png
+-rw-r--r--  2.0 unx     1762 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorShow_30x30.png
+-rw-r--r--  2.0 unx     2160 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorShow_36x36.png
+-rw-r--r--  2.0 unx      716 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorSubmit_18x18.png
+-rw-r--r--  2.0 unx      886 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorSubmit_24x24.png
+-rw-r--r--  2.0 unx     1023 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorSubmit_30x30.png
+-rw-r--r--  2.0 unx     1142 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorSubmit_36x36.png
+-rw-r--r--  2.0 unx      932 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorWarning_18x18.png
+-rw-r--r--  2.0 unx     1177 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorWarning_24x24.png
+-rw-r--r--  2.0 unx     1403 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorWarning_30x30.png
+-rw-r--r--  2.0 unx     1668 b- defN 23-Jul-06 04:22 ciomaya/icons/ConductorWarning_36x36.png
+-rw-r--r--  2.0 unx      776 b- defN 23-Jul-06 04:22 ciomaya/icons/conductorRender.png
+-rw-r--r--  2.0 unx    30014 b- defN 23-Jul-06 04:22 ciomaya/icons/conductor_logo_white.png
+-rw-r--r--  2.0 unx      344 b- defN 23-Jul-06 04:22 ciomaya/icons/out_conductorRender.png
+-rw-r--r--  2.0 unx        1 b- defN 23-Jul-06 04:22 ciomaya/lib/__init__.py
+-rw-r--r--  2.0 unx     2819 b- defN 23-Jul-06 04:22 ciomaya/lib/about_window.py
+-rw-r--r--  2.0 unx     1116 b- defN 23-Jul-06 04:22 ciomaya/lib/asset_cache.py
+-rw-r--r--  2.0 unx     4176 b- defN 23-Jul-06 04:22 ciomaya/lib/conductor_menu.py
+-rw-r--r--  2.0 unx      990 b- defN 23-Jul-06 04:22 ciomaya/lib/const.py
+-rw-r--r--  2.0 unx     3079 b- defN 23-Jul-06 04:22 ciomaya/lib/context.py
+-rw-r--r--  2.0 unx     1009 b- defN 23-Jul-06 04:22 ciomaya/lib/layer_utils.py
+-rw-r--r--  2.0 unx     1033 b- defN 23-Jul-06 04:22 ciomaya/lib/node_utils.py
+-rw-r--r--  2.0 unx     3488 b- defN 23-Jul-06 04:22 ciomaya/lib/renderman_path_utils.py
+-rw-r--r--  2.0 unx     2868 b- defN 23-Jul-06 04:22 ciomaya/lib/scrape_runner.py
+-rw-r--r--  2.0 unx     8141 b- defN 23-Jul-06 04:22 ciomaya/lib/scraper_utils.py
+-rw-r--r--  2.0 unx     2107 b- defN 23-Jul-06 04:22 ciomaya/lib/software.py
+-rw-r--r--  2.0 unx     2033 b- defN 23-Jul-06 04:22 ciomaya/lib/submission_progress.py
+-rw-r--r--  2.0 unx     6138 b- defN 23-Jul-06 04:22 ciomaya/lib/submit.py
+-rw-r--r--  2.0 unx    28470 b- defN 23-Jul-06 04:22 ciomaya/lib/validation.py
+-rw-r--r--  2.0 unx     1297 b- defN 23-Jul-06 04:22 ciomaya/lib/window_utils.py
+-rw-r--r--  2.0 unx     4095 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEactions.py
+-rw-r--r--  2.0 unx     3484 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEcommon.py
+-rw-r--r--  2.0 unx     3482 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEdestination.py
+-rw-r--r--  2.0 unx     3620 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEemails.py
+-rw-r--r--  2.0 unx     4305 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEenvironment.py
+-rw-r--r--  2.0 unx     4402 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEextraAssets.py
+-rw-r--r--  2.0 unx     2809 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEframes.py
+-rw-r--r--  2.0 unx     9033 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEinstanceType.py
+-rw-r--r--  2.0 unx     1188 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AElayers.py
+-rw-r--r--  2.0 unx     3201 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEmetadata.py
+-rw-r--r--  2.0 unx      976 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEoutput.py
+-rw-r--r--  2.0 unx     2459 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEproject.py
+-rw-r--r--  2.0 unx    14726 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEscrapers.py
+-rw-r--r--  2.0 unx    12750 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEsoftware.py
+-rw-r--r--  2.0 unx     2231 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/AEtaskTemplate.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-06 04:22 ciomaya/lib/ae/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-06 04:22 ciomaya/lib/nodes/__init__.py
+-rw-r--r--  2.0 unx    37105 b- defN 23-Jul-06 04:22 ciomaya/lib/nodes/conductorRender.py
+-rw-r--r--  2.0 unx     2981 b- defN 23-Jul-06 04:22 ciomaya/plug-ins/Conductor.py
+-rw-r--r--  2.0 unx    10125 b- defN 23-Jul-06 04:22 ciomaya/scripts/AEconductorRenderTemplate.mel
+-rw-r--r--  2.0 unx     1982 b- defN 23-Jul-06 04:22 ciomaya/scripts/scrape_bifrost.py
+-rw-r--r--  2.0 unx     2417 b- defN 23-Jul-06 04:22 ciomaya/scripts/scrape_image_planes.py
+-rw-r--r--  2.0 unx     4090 b- defN 23-Jul-06 04:22 ciomaya/scripts/scrape_maya.py
+-rw-r--r--  2.0 unx     8687 b- defN 23-Jul-06 04:22 ciomaya/scripts/scrape_maya_tight.py
+-rw-r--r--  2.0 unx     3319 b- defN 23-Jul-06 04:22 ciomaya/scripts/scrape_mtoa.py
+-rw-r--r--  2.0 unx     4427 b- defN 23-Jul-06 04:22 ciomaya/scripts/scrape_mtoa_standins.py
+-rw-r--r--  2.0 unx     1389 b- defN 23-Jul-06 04:22 ciomaya/scripts/scrape_ocio.py
+-rw-r--r--  2.0 unx     2206 b- defN 23-Jul-06 04:22 ciomaya/scripts/scrape_redshift.py
+-rw-r--r--  2.0 unx      613 b- defN 23-Jul-06 04:22 ciomaya/scripts/scrape_renderman.py
+-rw-r--r--  2.0 unx      883 b- defN 23-Jul-06 04:22 ciomaya/scripts/scrape_vray.py
+-rw-r--r--  2.0 unx     4228 b- defN 23-Jul-06 04:22 ciomaya/scripts/scrape_xgen.py
+-rw-r--r--  2.0 unx     4879 b- defN 23-Jul-06 04:22 ciomaya/scripts/scrape_yeti.py
+-rw-r--r--  2.0 unx    20597 b- defN 23-Jul-06 04:22 ciomaya-0.8.0rc1.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 23-Jul-06 04:22 ciomaya-0.8.0rc1.dist-info/WHEEL
+-rw-r--r--  2.0 unx        8 b- defN 23-Jul-06 04:22 ciomaya-0.8.0rc1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     7680 b- defN 23-Jul-06 04:22 ciomaya-0.8.0rc1.dist-info/RECORD
+87 files, 329034 bytes uncompressed, 126363 bytes compressed:  61.6%
```

## zipnote {}

```diff
@@ -102,14 +102,17 @@
 
 Filename: ciomaya/icons/out_conductorRender.png
 Comment: 
 
 Filename: ciomaya/lib/__init__.py
 Comment: 
 
+Filename: ciomaya/lib/about_window.py
+Comment: 
+
 Filename: ciomaya/lib/asset_cache.py
 Comment: 
 
 Filename: ciomaya/lib/conductor_menu.py
 Comment: 
 
 Filename: ciomaya/lib/const.py
@@ -123,30 +126,33 @@
 
 Filename: ciomaya/lib/node_utils.py
 Comment: 
 
 Filename: ciomaya/lib/renderman_path_utils.py
 Comment: 
 
-Filename: ciomaya/lib/scraper.py
+Filename: ciomaya/lib/scrape_runner.py
 Comment: 
 
 Filename: ciomaya/lib/scraper_utils.py
 Comment: 
 
 Filename: ciomaya/lib/software.py
 Comment: 
 
+Filename: ciomaya/lib/submission_progress.py
+Comment: 
+
 Filename: ciomaya/lib/submit.py
 Comment: 
 
 Filename: ciomaya/lib/validation.py
 Comment: 
 
-Filename: ciomaya/lib/window.py
+Filename: ciomaya/lib/window_utils.py
 Comment: 
 
 Filename: ciomaya/lib/ae/AEactions.py
 Comment: 
 
 Filename: ciomaya/lib/ae/AEcommon.py
 Comment: 
@@ -201,29 +207,26 @@
 
 Filename: ciomaya/plug-ins/Conductor.py
 Comment: 
 
 Filename: ciomaya/scripts/AEconductorRenderTemplate.mel
 Comment: 
 
-Filename: ciomaya/scripts/glob_scrape_image_planes.py
-Comment: 
-
-Filename: ciomaya/scripts/old_scrape_xgen.py
-Comment: 
-
 Filename: ciomaya/scripts/scrape_bifrost.py
 Comment: 
 
 Filename: ciomaya/scripts/scrape_image_planes.py
 Comment: 
 
 Filename: ciomaya/scripts/scrape_maya.py
 Comment: 
 
+Filename: ciomaya/scripts/scrape_maya_tight.py
+Comment: 
+
 Filename: ciomaya/scripts/scrape_mtoa.py
 Comment: 
 
 Filename: ciomaya/scripts/scrape_mtoa_standins.py
 Comment: 
 
 Filename: ciomaya/scripts/scrape_ocio.py
@@ -240,20 +243,20 @@
 
 Filename: ciomaya/scripts/scrape_xgen.py
 Comment: 
 
 Filename: ciomaya/scripts/scrape_yeti.py
 Comment: 
 
-Filename: ciomaya-0.6.8.dist-info/METADATA
+Filename: ciomaya-0.8.0rc1.dist-info/METADATA
 Comment: 
 
-Filename: ciomaya-0.6.8.dist-info/WHEEL
+Filename: ciomaya-0.8.0rc1.dist-info/WHEEL
 Comment: 
 
-Filename: ciomaya-0.6.8.dist-info/top_level.txt
+Filename: ciomaya-0.8.0rc1.dist-info/top_level.txt
 Comment: 
 
-Filename: ciomaya-0.6.8.dist-info/RECORD
+Filename: ciomaya-0.8.0rc1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## ciomaya/VERSION

```diff
@@ -1 +1 @@
-0.6.8
+0.8.0-rc.1
```

## ciomaya/conductor.mod

```diff
@@ -1,2 +1,2 @@
-+ conductor 0.6.8 .
++ conductor 0.8.0-rc.1 .
 PYTHONPATH+:=../
```

## ciomaya/post_install.py

```diff
@@ -12,15 +12,15 @@
 PKGNAME = os.path.basename(PKG_DIR)  # ciomaya
 MODULE_FILENAME = "conductor.mod"
 PLATFORM = sys.platform
 with open(os.path.join(PKG_DIR, "VERSION")) as version_file:
     VERSION = version_file.read().strip()
 WIN_MY_DOCUMENTS = 5
 WIN_TYPE_CURRENT = 0
-SUPPORTED_MAYA_VERSIONS = range(2017, 2024)
+SUPPORTED_MAYA_VERSIONS = range(2017, 2026)
 
 def main():
     if not PLATFORM.startswith(("darwin", "win", "linux")):
         sys.stderr.write("Unsupported platform: {}".format(PLATFORM))
         sys.exit(1)
 
     module_dir = get_maya_module_dir()
```

## ciomaya/lib/conductor_menu.py

```diff
@@ -1,23 +1,23 @@
 
-
+from __future__ import unicode_literals
 import pymel.core as pm
 
 import os
 import glob
 import webbrowser
-
+import importlib
 import ciocore.loggeria
 
 # Setup logging
 ciocore.loggeria.setup_conductor_logging(
     logger_level =  ciocore.loggeria.LEVEL_MAP.get(ciocore.config.get()['log_level']),
  )
 
-from ciomaya.lib import window
+from ciomaya.lib import about_window
 from ciomaya.lib import software
 from ciomaya.lib import const as k
 from ciomaya.lib import node_utils
 
 MAYA_PARENT_WINDOW = "MayaWindow"
 CONDUCTOR_MENU = "ConductorMenu"
 CONDUCTOR_DOCS = "https://docs.conductortech.com/"
@@ -56,15 +56,15 @@
             pm.setParent(self.menu, menu=True)
 
             pm.menuItem(divider=True)
 
             self.help_menu = pm.menuItem(
                 label="Help", command=pm.Callback(webbrowser.open, CONDUCTOR_DOCS, new=2)
             )
-            self.about_menu = pm.menuItem(label="About", command=pm.Callback(window.show_about))
+            self.about_menu = pm.menuItem(label="About", command=pm.Callback(about_window.show))
 
 
     def post_menu_command(self):
         """
         Build the Select/Create submenu just before the menu is opened.
         """
         pm.setParent(self.jobs_menu, menu=True)
@@ -124,8 +124,15 @@
 
     # asset scrapers
     script_path = os.path.join(pm.moduleInfo(path=True, moduleName="conductor"), "scripts")
 
     files = sorted(glob.glob("{}/scrape_*.py".format(script_path)))
     for i, scraper in enumerate(files):
         scraper_name = os.path.splitext(os.path.basename(scraper))[0]
-        node.attr("assetScrapers[{:d}].assetScraperName".format(i)).set(scraper_name)
+        nodeattr =  node.attr("assetScrapers")[i]
+        nodeattr.attr("assetScraperName").set(scraper_name)
+        try:
+            scraper_module = importlib.import_module(scraper_name)
+            if hasattr(scraper_module, "EXPERIMENTAL") and scraper_module.EXPERIMENTAL:
+                nodeattr.attr("assetScraperActive").set(False)
+        except BaseException:
+            nodeattr.attr("assetScraperActive").set(False)
```

## ciomaya/lib/renderman_path_utils.py

```diff
@@ -1,8 +1,8 @@
-
+from __future__ import unicode_literals
 import re
 import sys
 from contextlib import contextmanager
 
 import pymel.core as pm
 from ciomaya.lib import scraper_utils
 from ciomaya.lib.ae import AEcommon
```

## ciomaya/lib/scraper_utils.py

```diff
@@ -1,11 +1,12 @@
-
+from __future__ import unicode_literals
 import os
 import re
 import sys
+from cioseq.sequence import Sequence
 
 from ciopath.gpath import Path
 
 import maya.api.OpenMaya as om
 import pymel.core as pm
 
 PLATFORM = sys.platform
@@ -28,24 +29,47 @@
     while not plug_iter.isDone():
         plug = plug_iter.getPlug()
         plug_iter.next()
 
         if plug.isArray:
             for index in range(plug.numElements()):
                 child_plug = plug.elementByPhysicalIndex(index)
-                value = _get_value(child_plug)
-                if value:
-                    result.append(_get_value(child_plug))
+                obj = _get_value(child_plug)
+                if obj:
+                    result.append(obj)
         else:
-            value = _get_value(plug)
-            if value:
-                result.append(_get_value(plug))
+            obj = _get_value(plug)
+            if obj:
+                result.append(obj)
+                
     return result
 
 
+def get_sequence(node):
+    node = pm.PyNode(node) # just in case
+    use_custom_range = node.attr("useCustomRange").get()
+    sequence = None
+    if use_custom_range:
+        custom_range = node.attr("frameSpec").get()
+        return Sequence.create(custom_range)
+
+    if  node.attr("animation").get():
+        start_frame = node.attr("startFrame").get()
+        end_frame = node.attr("endFrame").get()
+        by_frame = node.attr("byFrame").get()
+        return Sequence.create(
+            int(start_frame),
+            int(end_frame),
+            by_frame
+        )
+
+    return Sequence.create(int(pm.currentTime(q=True)))
+
+
+
 def _get_plugs(attrs):
     """
     Return a SelectionList that contains the actual existing plugs.
 
     When we get a node's plug from the att name, it may be a child of a compound
     array plug (or nested several levels). In this case the plug name will be of
     the form node_name.parentPlug[-1].childPlug This (-1) is a nonexistent plug.
```

## ciomaya/lib/software.py

```diff
@@ -1,7 +1,8 @@
+from __future__ import unicode_literals
 """
 Software data as a singleton.
 
 Software is converted to a PackageTree containing only maya packages and
 supported plugins.
 
 Also has the ability to use fixtures for dev purposes.
```

## ciomaya/lib/submit.py

```diff
@@ -1,24 +1,25 @@
 """
 Submit.
 
 """
+from __future__ import unicode_literals
 import json
 import os
 import sys
 import traceback
 from contextlib import contextmanager
 
 import pymel.core as pm
 from ciocore import conductor_submit
 from ciotemplate.expander import Expander
 from ciomaya.lib import const as k
-from ciomaya.lib import layer_utils, validation, window, renderman_path_utils
+from ciomaya.lib import layer_utils, validation, renderman_path_utils
 from ciocore.validator import ValidationError
-
+from ciomaya.lib import submission_progress
 
 @contextmanager
 def full_output(node):
     task_limit = node.attr("taskLimit").get()
     do_scrape = node.attr("doScrape").get()
     node.attr("taskLimit").set(-1)
     node.attr("doScrape").set(True)
@@ -62,14 +63,15 @@
     return True
 
 
 def submit(node):
     """
     Submit job based on either an autoaved file or a manually saved file.
     """
+
     filepath = pm.sceneName()
     if filepath and node.attr("autosave").get():
         filepath = _resolve_autosave_template(node)
         if filepath:
             cleanup = should_cleanup_autosave(node)
             if valid(node):
                 with transient_save(filepath, cleanup=cleanup):
@@ -103,15 +105,15 @@
     if autosave_template and autosave_template.lower().strip() == "<scene>":
         return False
     return True
 
 def handle_submissions(node):
     submissions = get_submissions(node)
     responses = do_submissions(submissions, node)
-    window.show_submission_responses(responses)
+    submission_progress.show_responses(responses)
 
 
 def get_submissions(node):
 
     submissions = []
     layer_policy = node.attr("renderLayers").get()
```

## ciomaya/lib/validation.py

```diff
@@ -1,11 +1,11 @@
+from __future__ import unicode_literals
 import sys
 import os
 
-
 import traceback
 
 
 import pymel.core as pm
 from ciopath.gpath import Path
 from ciopath.gpath_list import GLOBBABLE_REGEX, PathList
 from ciocore.validator import Validator, ValidationError
@@ -169,51 +169,44 @@
             self.add_warning(msg)
 
 
 class ValidateInstanceType(Validator):
     def run(self, layername):
 
         instance_type_name = self._submitter.attr("instanceTypeName").get()
-        instance_type = next(
-            (it for it in coredata.data()["instance_types"] if it["name"] == instance_type_name),
-            None,
-        )
-        if not instance_type:
+        if not coredata.data()["instance_types"].find(instance_type_name):
             self.add_error("No instance type. Please make sure a valid instance type is selected.")
 
 
 class ValidateGPU(Validator):
     def run(self, layername):
         """
         Validate the suitability of the chosen instance type.
 
         If the renderer configuration requires a GPU but no GPU-enabled instance type is selected, add a validation error.
         If a GPU instance type is selected, but the renderer doesn't require it, add a validation warning.
         """
         current_renderer = pm.PyNode("defaultRenderGlobals").attr("currentRenderer").get()
         instance_type_name = self._submitter.attr("instanceTypeName").get()
-        instance_type = next(
-            (it for it in coredata.data()["instance_types"] if it["name"] == instance_type_name),
-            None,
-        )
+        instance_type = coredata.data()["instance_types"].find(instance_type_name)
         if not instance_type:
             return
 
         if "redshift" == current_renderer:
             self.validate_redshift(instance_type)
             return
         if "arnold" == current_renderer:
             self.validate_arnold(instance_type)
             return
         if "vray" == current_renderer:
             self.validate_vray(instance_type)
             return
-       
+
         self.validate_other(instance_type)
-        
+
 
     def validate_redshift(self, instance_type):
 
         description = instance_type.get("description")
 
         if not instance_type["gpu"]:
             msg = "The Redshift renderer is not compatible with the instance type: '{}' as it has no graphics card.".format(
@@ -302,31 +295,46 @@
 
 
 class ValidateArnoldRenderOptions(Validator):
     def run(self, _):
         if not pm.PyNode("defaultRenderGlobals").attr("currentRenderer").get() == "arnold":
             return
 
+        instance_type_name = self._submitter.attr("instanceTypeName").get()
+        instance_type = coredata.data()["instance_types"].find(instance_type_name)
+
         try:
             render_options = pm.PyNode("defaultArnoldRenderOptions")
         except pm.MayaNodeError:
             self.add_warning(
                 "Current renderer is set to Arnold, but there's no defaultArnoldRenderOptions node"
             )
             return
 
         if not render_options.attr("threads_autodetect").get():
             self.add_warning(
                 "Autodetect-Threads is turned off which could cause suboptimal machine usage and incur unnecessary costs. You may want to switch it back on in the Render Settings window, System tab."
             )
 
-        if render_options.attr("denoiseBeauty").get():
-            self.add_error(
-                'You have the Optix denoiser turned on. This will not work unless you also select a machine with a capable GPU. Also note, the Optix denoiser is not temporally coherent. To turn off Optix denoiser, enter the following in the MEL script editor: setAttr "defaultArnoldRenderOptions.denoiseBeauty" 0;'
-            )
+
+        denoiserImagers = pm.PyNode("defaultArnoldRenderOptions").listHistory(levels=0, type = "aiImagerDenoiserOptix")
+        if not instance_type["gpu"]:
+            if denoiserImagers:
+                self.add_error(
+                    "The Optix Denoiser is not compatible with the instance type: '{}' as it has no graphics card. Please remove Optix imagers".format(
+                        instance_type.get("description")
+                    )
+                )
+
+            if render_options.attr("denoiseBeauty").get():
+                self.add_error(
+                    "The Optix Denoiser is not compatible with the instance type: '{}' as it has no graphics card. Please disable Optix denoiser in Arnold Render Settings".format(
+                        instance_type.get("description")
+                    )
+                )
 
 
 class ValidateRendermanWindowsPaths(Validator):
     def run(self, _):
 
         if not sys.platform == "win32":
             return
```

## ciomaya/lib/ae/AEcommon.py

```diff
@@ -1,7 +1,8 @@
+from __future__ import unicode_literals
 from contextlib import contextmanager
 import pymel.core as pm
 
 
 def print_setAttr_cmd(attr):
     try:
         attr = pm.Attribute(attr)
```

## ciomaya/lib/ae/AEdestination.py

```diff
@@ -1,7 +1,8 @@
+from __future__ import unicode_literals
 """
 Handle the UI for extra assets:
 """
 
 import pymel.core as pm
 from ciomaya.lib import const as k
 from ciopath.gpath import Path
```

## ciomaya/lib/ae/AEemails.py

```diff
@@ -1,7 +1,8 @@
+from __future__ import unicode_literals
 """
 Handle the UI for emails:
 """
 
 import pymel.core as pm
 from ciomaya.lib import const as k
```

## ciomaya/lib/ae/AEframes.py

```diff
@@ -1,7 +1,8 @@
+from __future__ import unicode_literals
 """
 Handle the UI for custom frames and use scout frames:
 
 In both cases, when the use<Attrname> checkbox is unchecked,
 the field is hidden.
 
 """
```

## ciomaya/lib/ae/AEinstanceType.py

```diff
@@ -1,201 +1,272 @@
+from __future__ import unicode_literals
+
 """
 Handle the UI for instanceTypes:
 
 """
 
 import maya.app.renderSetup.model.renderSetup as rs
 import maya.app.renderSetup.views.overrideUtils as ov_utils
 import pymel.core as pm
 from ciocore import data as coredata
 
 from ciomaya.lib import const as k
 from ciomaya.lib.ae import AEcommon
- 
+
+
 def create_ui(node_attr):
-    """Build static UI"""
-    with AEcommon.ae_template():
+    """Build static UI
 
+    Components:
+
+    1. Category menu - for example: "CPU", "GPU", "High Tier", "Low Tier"
+    2. Content menu is efectively as submenu of categories - for example: "c4.8xlarge", "g2.2xlarge", "m4.2xlarge"
+    3. Popup menu - contains: "Create Absolute Override for Visible Layer"
+    """
+    with AEcommon.ae_template():
         pm.rowLayout(
-            numberOfColumns=2,
-            columnWidth2=(k.AE_TEXT_WIDTH, 400),
-            columnAttach=((1, "both", 0), (2, "both", 0)),
+            numberOfColumns=3,
+            columnWidth3=(k.AE_TEXT_WIDTH, 100, 300),
+            columnAttach=((1, "both", 0), (2, "both", 0), (3, "both", 0)),
         )
 
-        label = pm.text("instanceTypesLabel",label="Instance Type Name")
-        pm.optionMenu("instanceTypesMenu", acc=True)
+        label = pm.text("instanceTypesLabel", label="Instance Type")
+        pm.optionMenu("instanceTypesCategoryMenu", acc=True)
+        pm.optionMenu("instanceTypesContentMenu", acc=True)
+
         popup = pm.popupMenu(parent=label)
         pm.setParent(popup, menu=True)
         pm.menuItem(label="Create Absolute Override for Visible Layer")
-
         pm.setParent("..")  # out of rowLayout
 
         populate_ui(node_attr)
 
 
 def populate_ui(node_attr):
-    """Reconfigure UI for the current node"""
+    """Rehydrate the UI for the current node.attribute.
+
+    This is called when the UI is first created, and when switching to a different submitter.
+    """
     attr = pm.Attribute(node_attr)
     widgets = _get_widgets()
- 
-    if not  coredata.valid():
-        for item in pm.optionMenu(widgets["menu"], q=True, itemListLong=True):
+
+    if not coredata.valid():
+        for item in pm.optionMenu(widgets["contentmenu"], q=True, itemListLong=True):
             pm.deleteUI(item)
-        pm.setParent(widgets["menu"], menu=True)
+        pm.setParent(widgets["contentmenu"], menu=True)
         pm.menuItem(label="Not connected")
-
+        for item in pm.optionMenu(widgets["catmenu"], q=True, itemListLong=True):
+            pm.deleteUI(item)
+        pm.setParent(widgets["catmenu"], menu=True)
+        pm.menuItem(label="---")
     # update popup menu items
     _configure_popup_menu(attr, widgets)
 
-    pm.optionMenu(widgets["menu"], edit=True, changeCommand=pm.Callback(
-        _set_instance_type_value, attr, widgets["menu"]))
+    pm.optionMenu(
+        widgets["catmenu"],
+        edit=True,
+        changeCommand=pm.Callback(_on_category_menu_change, attr, widgets),
+    )
+    pm.optionMenu(
+        widgets["contentmenu"],
+        edit=True,
+        changeCommand=pm.Callback(_on_content_menu_change, attr, widgets["contentmenu"]),
+    )
+
     # Update this UI if the attribute changes by some other means
     # For example: setAttr, or another instance of the attribute editor.
     _setup_script_jobs(attr, widgets)
-
     _set_label_color(attr, widgets["label"])
 
     pm.evalDeferred(pm.Callback(_ensure_connection, attr, widgets))
 
+### Private
 
 def _configure_popup_menu(attr, widgets):
-    override_item = pm.popupMenu(
-        widgets["popup_menu"], q=True, itemArray=True)[0]
+    override_item = pm.popupMenu(widgets["popup_menu"], q=True, itemArray=True)[0]
 
     enable_override = (
         pm.editRenderLayerGlobals(query=True, currentRenderLayer=True)
         != "defaultRenderLayer"
     )
-    pm.menuItem(override_item, edit=True, en=enable_override, 
-      command=pm.Callback(_create_layer_override, attr, widgets["label"]) )
- 
+    pm.menuItem(
+        override_item,
+        edit=True,
+        en=enable_override,
+        command=pm.Callback(_create_layer_override, attr, widgets["label"]),
+    )
+
 
 def _get_widgets(parent=None):
     if not parent:
         parent = pm.setParent(q=True)
     label = AEcommon.find_ui("instanceTypesLabel", parent),
     return {
-        "label" :label,
-        "menu": AEcommon.find_ui("instanceTypesMenu", parent),
-        "popup_menu": pm.control( label, q=True, popupMenuArray=True)[0]
+        "label": label,
+        "catmenu": AEcommon.find_ui("instanceTypesCategoryMenu", parent),
+        "contentmenu": AEcommon.find_ui("instanceTypesContentMenu", parent),
+        "popup_menu": pm.control(label, q=True, popupMenuArray=True)[0],
     }
 
 
-
 def _setup_script_jobs(attr, widgets):
-    menu = widgets["menu"]
+    """
+    Update the UI based on events.
+
+    1. When the attribute changes - sync the menu to the attribute value.
+    2. When the render layer manager changes - sync the menu and update the label color.
+    """
+    menu = widgets["contentmenu"]
 
     pm.scriptJob(
         attributeChange=(
             attr,
             pm.Callback(_sync_menu_to_attr, attr, widgets),
         ),
         parent=menu,
-        replacePrevious=True
+        replacePrevious=True,
     )
 
     pm.scriptJob(
         event=(
             "renderLayerManagerChange",
             pm.Callback(_on_render_layer_manager_change, attr, widgets),
         ),
         parent=menu,
     )
 
 
 def _on_render_layer_manager_change(attr, widgets):
-
     _sync_menu_to_attr(attr, widgets)
     _set_label_color(attr, widgets["label"])
 
 
 def _ensure_connection(attr, widgets):
-    """Fetch a fresh list of inst types from Conductor (or the cache)."""
+    """Fetch a fresh list of inst types from Conductor (or the cache)
 
-    instance_type_data = coredata.data()["instance_types"]
-    descriptions =  [t["description"] for t in instance_type_data]
-    if len(descriptions) and isinstance(descriptions[0], list):
-        descriptions = [v[0] for v in descriptions]
+     hardware.categories are expected to be structured like this:
 
-    AEcommon.ensure_populate_menu(widgets["menu"], descriptions)
+    [
+        {
+            "label": "Category 1",
+            "content": [
+                {"description": "Content 1", "name": "content1", and-so-on ...},
+                {"description": "Content 2", "name": "content2", and-so-on ...},
+                {"description": "Content 3", "name": "content3", and-so-on ...}
+            ]
+        },
+        {
+            "label": "Category 2",
+            "content": [
+                {"description": "Content 4", "name": "content4", and-so-on ...},
+                {"description": "Content 5", "name": "content5", and-so-on ...},
+                {"description": "Content 6", "name": "content6", and-so-on ...}
+            ]
+        }
+    ]
+    """
 
-    values =  [it["name"] for it in instance_type_data]
-    AEcommon.sync_menu_to_attr(widgets["menu"], attr , values=values)
+    hardware = coredata.data().get("instance_types")
+    if not hardware:
+        return
+
+    category_labels = [item["label"] for item in hardware.categories]
+    if not category_labels:
+        return
+    AEcommon.ensure_populate_menu(widgets["catmenu"], category_labels)
+    _sync_menu_to_attr(attr, widgets)
 
 
 def _sync_menu_to_attr(attr, widgets):
     """
     Make sure menu item reflects the attribute value.
 
     If the attribute is invalid, set it to the first valid project.
-
-
     """
-    menu = widgets["menu"]
-    label = widgets["label"]
-    
-    items = pm.optionMenu(menu, q=True, itemListLong=True)
-    if not items:
-        return
 
-    name = attr.get()
-    index, instance_type = find_by_key("name", name)
+    attr_value = attr.get()
+    hardware = coredata.data()["instance_types"]
+    instance_type = hardware.find(attr_value)
+
     if not instance_type:
-        pm.displayWarning("Didn't find '{}' in instance types".format(name))
+        # list must have changed or attribute is invalid
+        instance_type = hardware.find_first(lambda x: x["cores"] > 2)
+        attr_value = instance_type["name"]
+        attr.set(attr_value)
+        AEcommon.print_setAttr_cmd(attr)
+    category_label = instance_type["categories"][0]["label"]
+    # set the category menu to the first category that contains the sku
+    pm.optionMenu(widgets["catmenu"], edit=True, value=category_label)
+    category = hardware.find_category(category_label)
+    if not category:
+        pm.displayWarning(
+            "Didn't find category '{}' in instance types".format(category_label)
+        )
         return
+    content_descriptions = [c["description"] for c in category["content"]]
+    AEcommon.ensure_populate_menu(widgets["contentmenu"], content_descriptions)
+    pm.optionMenu(widgets["contentmenu"], edit=True, value=instance_type["description"])
 
-    one_based_index = index+1
-    if one_based_index > len(items):
-        one_based_index = 1
-        attr.set(coredata.data()["instance_types"][0]["name"])
+    _set_label_color(attr, widgets["label"])
 
-    pm.optionMenu(menu, edit=True, sl=one_based_index)
 
-    _set_label_color(attr, label)
+def _on_category_menu_change(attr, widgets):
+    hardware = coredata.data()["instance_types"]
+    num_items = pm.optionMenu(widgets["catmenu"], q=True, numberOfItems=True)
+    if not num_items:
+        return
+    category_label = pm.optionMenu(widgets["catmenu"], q=True, value=True)
+    category = hardware.find_category(category_label)
+    if not category:
+        pm.displayWarning(
+            "Didn't find category '{}' in instance types".format(category_label)
+        )
+        return
+    content_labels = [c["description"] for c in category["content"]]
 
+    AEcommon.ensure_populate_menu(widgets["contentmenu"], content_labels)
+    attr_value = attr.get()
+    instance_type = hardware.find(attr_value)
+    if not category_label in [c["label"] for c in instance_type["categories"]]:
+        instance_type = category["content"][0]
+        attr_value = instance_type["name"]
+        attr.set(attr_value)
+        AEcommon.print_setAttr_cmd(attr)
 
-def _set_instance_type_value(attr, menu):
+    pm.optionMenu(widgets["contentmenu"], edit=True, value=instance_type["description"])
+
+
+def _on_content_menu_change(attr, menu):
     """
     Respond to menu change.
+
+    Set the value of the attribute to the selected item.
     """
+    hardware = coredata.data()["instance_types"]
     num_items = pm.optionMenu(menu, q=True, numberOfItems=True)
     if not num_items:
         return
-    description = pm.optionMenu(menu, q=True, value=True)
-    _, instance_type = find_by_key("description", description)
+    label = pm.optionMenu(menu, q=True, value=True)
+    instance_type = hardware.find_first(lambda x: x["description"] == label)
+
     if not instance_type:
-        pm.displayWarning("Didn't find '{}' in instance types".format(description))
+        pm.displayWarning("Didn't find '{}' in instance types".format(label))
         return
 
     name = instance_type["name"]
     if attr.get() != name:
         attr.set(name)
         AEcommon.print_setAttr_cmd(attr)
 
 
 def _create_layer_override(attr, label):
-    ov_utils.createAbsoluteOverride( attr.node().name(), attr.attrName(True) )
+    ov_utils.createAbsoluteOverride(attr.node().name(), attr.attrName(True))
     _set_label_color(attr, label)
 
 
-
 def _set_label_color(attr, label):
     """By convention, label is orange if attr has an override."""
-    has_override = rs.hasOverrideApplied(
-        attr.node().name(),  attr.attrName(True))
+    has_override = rs.hasOverrideApplied(attr.node().name(), attr.attrName(True))
     text = "Instance Type Name"
-    label_text = "<font color=#ec6a17>{}</font>".format(
-        text) if has_override else text
+    label_text = "<font color=#ec6a17>{}</font>".format(text) if has_override else text
     pm.text(label, edit=True, label=label_text)
-
-
-
-def find_by_key(key, value):
-    result = (None,None)
-    if not coredata.valid():
-        return result
-    try:
-        result = next(tup for tup in enumerate(coredata.data()["instance_types"]) if tup[1][key] == value)
-    except StopIteration:
-        pass
-    return result
-
```

## ciomaya/lib/ae/AEscrapers.py

```diff
@@ -1,22 +1,23 @@
+from __future__ import unicode_literals
 """
 Handle the UI for extra assets:
 """
 
 
 import importlib
 
 import os
 import glob
 import pymel.core as pm
 from ciomaya.lib import const as k
 from ciomaya.lib.ae import AEcommon
 import traceback
 from ciopath.gpath_list import PathList, GLOBBABLE_REGEX
-
+ 
 
 def has_letters(rhs):
     return rhs.lower().islower()
 
 
 def get_module_docstring(script):
     try:
@@ -200,15 +201,15 @@
                 attr).attr("assetScraperName").set(script)
 
 
 def _on_reset_btn(attr):
     """
     Reset the list of asset scrapers to factory defaults.
 
-    In other words, reset it to the list of sdcrapers that begin with "scrape_"
+    In other words, reset it to the list of scrapers that begin with "scrape_"
     in the scripts directory of the installation. 
 
     attr: is a compound multi attribute holding asset scraper scripts. 
 
     The children of each element are: 
     * assetScraperName
     * assetScraperActive
@@ -218,16 +219,22 @@
 
     script_path = os.path.join(
         pm.moduleInfo(
             path=True, moduleName="conductor"), "scripts"
     )
     files = sorted(glob.glob("{}/scrape_*.py".format(script_path)))
     for i, scraper in enumerate(files):
-        attr[i].attr("assetScraperName").set(
-            os.path.splitext(os.path.basename(scraper))[0])
+        basename =  os.path.splitext(os.path.basename(scraper))[0]
+        attr[i].attr("assetScraperName").set(basename)
+        try:
+            scraper_module = importlib.import_module(basename)
+            if hasattr(scraper_module, "EXPERIMENTAL") and scraper_module.EXPERIMENTAL:
+                attr[i].attr("assetScraperActive").set(False)
+        except BaseException:
+            attr[i].attr("assetScraperActive").set(False)
 
 
 def _on_browse_button(attr, path_field, active_checkbox):
     script = _browse_for_script()
     if script:
         script = os.path.splitext(os.path.basename(script))[0]
         attr.attr("assetScraperName").set(script)
@@ -284,14 +291,21 @@
     /Volumes/xtr/gd/duck/xgen/collections/foobar
      # Missing paths for scrapers: [u'scrape_xgen'] # 
     Volumes/xtr/gd/duck/xgen/collections/some_missing
     /Volumes/xtr/gd/duck/xgen/collections/foobar_some_missing
     """
     
     node = attr.node()
+
+    display_all_paths = False
+    try:
+        display_all_paths = node.attr("displayAllPaths").get()
+    except pm.MayaAttributeError:
+        pass
+
     if attr.isArray():
         scripts = [attr_element.attr("assetScraperName").get(
         ) for attr_element in attr if attr_element.attr("assetScraperActive").get()]
     else:
         scripts = [attr.attr("assetScraperName").get()]
     scripts_repr = repr(scripts)
     amendments = _run_scrapers(node, scripts)
@@ -304,51 +318,66 @@
             pm.displayInfo(path)
 
         pm.displayInfo("Resolved paths for scrapers: {}".format(scripts_repr))
         path_list = PathList()
         path_list.add(*[p["path"] for p in paths])
         path_list.remove_missing()
         path_list.glob()
-        for path in path_list:
-            pm.displayInfo(path.fslash())
+        num_paths = len(path_list)
+
+        if display_all_paths:
+            for path in path_list:
+                pm.displayInfo(path.fslash())
+        else:
+            for path in list(path_list)[:1000]:
+                pm.displayInfo(path.fslash())
+            pm.displayInfo("Too many paths to display: {}".format(num_paths))
+            pm.displayInfo("If you want to see all {} paths, create a boolean attribute \"displayAllPaths\" and set it to True".format(num_paths))
+
 
         pm.displayInfo("Paths that do not exist on disk for scrapers: {}".format(scripts_repr))
         some_exist = False
         for pathobj in paths:
             path = pathobj["path"]
             if not GLOBBABLE_REGEX.search(path) and not os.path.exists(path):
                 pm.displayWarning("Not on disk: {}".format(pathobj))
                 some_exist = True
         if not some_exist:
             pm.displayWarning("No missing files")
     else:
+        num_paths = 0
         pm.displayInfo(
             "Scrapers returned no filenames: {}".format(scripts_repr))
 
     if envs:
         pm.displayInfo("Env objects for scrapers: {}".format(scripts_repr))
         for env in envs:
             pm.displayInfo(repr(env))
     else:
         pm.displayInfo(
             "Scrapers returned no environment amendments: {}".format(scripts_repr))
 
+    pm.displayInfo("TOTAL NUMBER OF EXISTING SCRAPED ASSETS: {}".format(num_paths))
+
+
 
 def _run_scrapers(node, scripts):
+
     result = {"paths": [], "env": []}
     show_tracebacks = node.attr("showTracebacks").get()
     msg = "Please open the Asset scraper section and test individual scrapers. Remove any offending scraper entries."
-    for script in scripts:
+
+    for i,script in enumerate(scripts):
         try:
             scraper_module = importlib.import_module(script)
+          
             try:
                 reload(scraper_module)
             except:
                 importlib.reload(scraper_module)
-            print("script",script)
             scraper_result = scraper_module.run(node)
             if scraper_result:
                 result["paths"] += scraper_result["paths"]
                 result["env"] += scraper_result["env"]
         except SyntaxError:
             pm.displayError(
                 "Syntax error in the scraper script: '{}'.\n{}".format(script, msg))
@@ -363,14 +392,15 @@
             raise
         except BaseException:
             pm.displayError(
                 "Unknown problem with the script '{}'.\n{}".format(script, msg))
             if show_tracebacks:
                 pm.displayError(traceback.format_exc())
             raise
+
     return result
 
 
 def _set_docstring(attr, widget):
     script = attr.get()
     docstring = get_module_docstring(script)
     pm.control(widget, edit=True, ann=docstring)
```

## ciomaya/lib/ae/AEsoftware.py

```diff
@@ -1,7 +1,8 @@
+from __future__ import unicode_literals
 """
 Handle the UI for 2 attributes:
 
 1. hostSoftware (single value maya version)
 2. pluginSoftware (multi value plugin name and version)
 
 TODO: Try to move ALL the plugin/host compatibility logic out of this file.
```

## ciomaya/lib/ae/AEtaskTemplate.py

```diff
@@ -11,33 +11,54 @@
     """Build static UI"""
  
     with AEcommon.ae_template():
         grp = pm.textFieldGrp("taskTemplateGrp", label="Task Template")
         label = pm.layout(grp, q=True, childArray=True)[0]
         pm.popupMenu(parent=label)
         pm.menuItem(label="Reset")
+        pm.menuItem(label="Add Arnold logging args")
+        pm.menuItem(label="Add Arnold abort on license fail args")
+        
+        
         populate_ui(node_attr)
 
 def populate_ui(node_attr):
     """Populate / reconfigure UI for the current node"""
     attr = pm.Attribute(node_attr)
     widgets = _get_widgets()
     # index 2 is the field. (1 is the label) 
     pm.connectControl(widgets["field"], attr, index=2)
     # reconfigure the popup for this node.
-    item = pm.popupMenu(widgets["popup_menu"], q=True, itemArray=True)[0]
-    pm.menuItem(item, edit=True, command=pm.Callback(_on_reset, attr))
+    items = pm.popupMenu(widgets["popup_menu"], q=True, itemArray=True)
+    pm.menuItem(items[0], edit=True, command=pm.Callback(_on_reset, attr))
+    pm.menuItem(items[1], edit=True, command=pm.Callback(_on_insert_arnold_arg, attr, "lve", 1))
+    pm.menuItem(items[2], edit=True, command=pm.Callback(_on_insert_arnold_arg, attr, "alf", 1))
+    
 
 def _get_widgets(parent=None):
     if not parent:
         parent = pm.setParent(q=True)
     field_grp = AEcommon.find_ui("taskTemplateGrp", parent)
     label = pm.layout(field_grp, q=True, childArray=True)[0]
 
     return {
         "field": field_grp,
         "popup_menu": pm.control( label, q=True, popupMenuArray=True)[0]
     }
 
 def _on_reset(attribute):
     attribute.set(k.DEFAULT_TEMPLATE)
+ 
+def _on_insert_arnold_arg(attribute, arg, value):
+    """Insert the given arnold args into the task template"""
+    template = attribute.get()
+    if not template:
+        template = k.DEFAULT_TEMPLATE
+    template = template.partition("<Renderer>")
+    arnold_arg = "-ai:{}".format(arg)
+    if not arnold_arg in template[2]:
+        arnold_arg_val = "{} {}".format(arnold_arg, value)
+        template =[ template[0] , template[1] , arnold_arg_val , template[2]]
+        attribute.set(" ".join(template))
+    else:
+        pm.displayWarning("Arnold arg {} already in template".format(arnold_arg))
```

## ciomaya/lib/nodes/conductorRender.py

```diff
@@ -1,7 +1,8 @@
+from __future__ import unicode_literals
 import importlib
 import json
 import os
 import re
 import pymel.core as pm
 
 from ciocore import data as coredata
@@ -897,16 +898,16 @@
     @classmethod
     def get_notifiations(cls, data):
         result = []
         array_handle = data.inputArrayValue(cls.aEmailAddresses)
         while not array_handle.isDone():
             if array_handle.inputValue().child(cls.aEmailAddressActive).asBool():
                 value = array_handle.inputValue().child(cls.aEmailAddress).asString().strip()
-            if value:
-                result.append(value)
+                if value:
+                    result.append(value)
             array_handle.next()
         return {"notify": result}
 
     def get_upload_paths(self, data, path_amendments):
         path_list = PathList()
         path_list.add(*path_amendments)
         path_list.add(*self.get_cached_paths(data))
@@ -916,17 +917,20 @@
 
     @classmethod
     def get_amendments(cls, data, node):
         result = {"paths":[], "env":[]}
         if not data.inputValue(cls.aDoScrape).asBool():
             return result
         array_handle = data.inputArrayValue(cls.aAssetScrapers)
+
+ 
         while not array_handle.isDone():
             if array_handle.inputValue().child(cls.aAssetScraperActive).asBool():
                 script = array_handle.inputValue().child(cls.aAssetScraperName).asString()
+
                 try:
                     scraper_module = importlib.import_module(script)
                     try:
                         reload(scraper_module)
                     except:
                         importlib.reload(scraper_module)
 
@@ -945,14 +949,16 @@
                     )
                 except BaseException:
                     om.MGlobal.displayWarning(
                         "Unknown problem with scraper: '{}'. Skipping!!".format(script)
                     )
 
             array_handle.next()
+ 
+   
         return result
 
 
     @classmethod
     def get_cached_paths(cls, data):
         result = []
         array_handle = data.inputArrayValue(cls.aExtraAssets)
```

## ciomaya/plug-ins/Conductor.py

```diff
@@ -44,20 +44,20 @@
     return False
 
 def maya_useNewAPI():
     pass
 
 
 def initializePlugin(obj):
-    # Use "0.6.8 to cause the version to be replaced at build time."
+    # Use "0.8.0-rc.1 to cause the version to be replaced at build time."
  
     if not check_pymel():
         return
 
-    plugin = om.MFnPlugin(obj, "Conductor", "0.6.8", "Any")
+    plugin = om.MFnPlugin(obj, "Conductor", "0.8.0-rc.1", "Any")
     # ciomaya imports must come after check_pymel.
     from ciomaya.lib.nodes.conductorRender import conductorRender
     try:
         plugin.registerNode(
             "conductorRender",
             conductorRender.id,
             conductorRender.creator,
```

## ciomaya/scripts/scrape_bifrost.py

```diff
@@ -1,10 +1,11 @@
 """
 A basic scraper to collect paths from Bifrost nodes.
 """
+from __future__ import unicode_literals
 
 import os
 import pymel.core as pm
 from ciomaya.lib import scraper_utils
 from cioseq.sequence import Sequence
 
 ################## LEAVE HERE ###################
@@ -22,25 +23,32 @@
     # }
 # }
 
 def run(node):
     """
     Find paths in Bifrost nodes.
     """
+    sequence = scraper_utils.get_sequence(node)
+    return doit(sequence)
+
+def doit(sequence):
+    """
+    Find paths in Bifrost nodes.
+    """
     paths = scraper_utils.get_paths({"bifmeshio": { "BifMeshImportNode": ["bifMeshDirectory"] }})
 
     # we want to add all files in the directory for an explicit list of frames,
     # which we evaluate from the time attribute in the  BifMeshImportNode node.
     result = []
     for path in paths:
         cache_node =  pm.Attribute(path["plug"]).node()
         time_plug = cache_node.attr("time")
         start_time_plug = cache_node.attr("startFrame")
         end_time_plug = cache_node.attr("endFrame")
-        frames = [int(round(time_plug.get(time=x))) for x in Sequence.create(pm.PyNode(node).attr("frameSpec").get())]
+        frames = [int(round(time_plug.get(time=x))) for x in sequence]
         seq = Sequence.create(frames).intersection(Sequence.create(start_time_plug.get(),end_time_plug.get()))
         template = os.path.join(path["path"], "*.{frame:04d}.bif")
         result.extend([{"path": p, "plug": path["plug"]} for p in seq.expand_format(template)])
 
     result = scraper_utils.expand_workspace(result)
 
     return {"paths":result, "env":[]}
```

## ciomaya/scripts/scrape_image_planes.py

```diff
@@ -1,36 +1,43 @@
 """
 A scraper to collect image plane movies, stills, and sequences.
 
 It demonstrates how to use attr.get(time=t) to evaluate a sequence for a frame
 range without evaluating the whole DG. It means that if an image plane uses 10
 files from a folder of 5000, we only upload the 10 files.
 """
+from __future__ import unicode_literals
 
 import re
 import glob
 import pymel.core as pm
 from cioseq.sequence import Sequence
 from ciomaya.lib import scraper_utils
 
 IMAGE_PLANE_FILENAME_REGEX = re.compile(r"^(.*)\.(\d+)\.([a-z0-9]+$)")
 
+
 def run(node):
+    sequence = scraper_utils.get_sequence(node)
+    return doit(sequence)
+
+
+def doit(sequence):
     """
     Find image_plane sequences.
     """
 
     paths = []
-    sequence = Sequence.create(pm.PyNode(node).attr("frameSpec").get())
 
     for image_plane in pm.ls(type="imagePlane"):
         paths.extend(paths_for_image_plane(image_plane, sequence))
-    
+
     paths = scraper_utils.expand_workspace(paths)
-    return {"paths":paths, "env":[]}
+    return {"paths": paths, "env": []}
+
 
 def paths_for_image_plane(image_plane, sequence):
     """
     image_plane type may be image (possibly sequence), procedural textur, or movie
 
     If it's a movie, or sequence is off, return the path.
     For textures, there's no file so return empty list.
@@ -51,25 +58,22 @@
     plug_name = plug.name()
     path = ws.expandName(plug.get().strip())
 
     match = IMAGE_PLANE_FILENAME_REGEX.match(path)
 
     if iptype == 2 or (not image_plane.attr("useFrameExtension").get()) or (not match):
         # not sequence
-        return [{
-            "plug": plug_name,
-            "path": path
-        }]
+        return [{"plug": plug_name, "path": path}]
 
     root, _, ext = match.groups()
     existing = glob.glob("{}.*.{}".format(root, ext))
     if not existing:
         return []
     padding = min([len(fn.split(".")[-2]) for fn in existing])
 
     # By evaluating, we account for expressions. offsets, driven keys, timewarps etc.
-    frame_seq =  Sequence.create([image_plane.attr(
-        "frameExtension").get(time=f) for f in sequence])
+    frame_seq = Sequence.create(
+        [image_plane.attr("frameExtension").get(time=f) for f in sequence]
+    )
     path = "{}.<f{}>.{}".format(root, padding, ext)
     pathnames = scraper_utils.resolve_to_sequence(path, frame_seq)
-    return [{"plug": plug_name, "path": p} for p in pathnames ]
-
+    return [{"plug": plug_name, "path": p} for p in pathnames]
```

## ciomaya/scripts/scrape_maya.py

```diff
@@ -4,29 +4,30 @@
 Maya Attributes may contain token substitution patterns that are only valid in
 other renderers. We have to resolve them because the policy of each scraper is
 to scrape only those custom attributes that it implements. Other scrapers do NOT
 scape their tokens in attributes they do not implement, including Maya's
 file.computedFileTextureNamePattern.
 
 """
+from __future__ import unicode_literals
 import pymel.core as pm
 import re
 from ciomaya.lib import scraper_utils
 
 
 ATTRS = {
     "AbcImport": {"AlembicNode": ["abc_File"]},
     "MayaBuiltin": {
         "file": ["computedFileTextureNamePattern"],
         "cacheFile": ["cachePath"],
         "gpuCache": ["cacheFileName"],
         "assemblyReference": ["definition"],
     },
-    "Type":  {"svgToPoly": ["svgFilepath"]},
-    "Audio":  {"audio": ["filename"]},
+    "Type": {"svgToPoly": ["svgFilepath"]},
+    "Audio": {"audio": ["filename"]},
 }
 
 TOKENS = (
     r"#+",  # image.####.exr - hash
     r"_MAPID_",  # image_MAPID_.exr - mapid
     r"%0\d+d",  # image.%04d.exr - percent
     r"<UDIM>",  # image.<UDIM>.exr - udim_mari
@@ -40,14 +41,17 @@
     r"<f\d?>",  # image.<f>.exr or image.<f4>.exr - frame_seq
     r"<FrameNum>",  # image.<FrameNum>.ext - Redshift
     r"<Frame>",  # image.<Frame>.ext - Redshift
 )
 
 
 def run(_):
+    return doit()
+
+def doit(_=None):
     """
     Find paths in Maya attributes on Maya nodes.
 
     * Replace any of the above tokens with a "*"
     * Add workspace.mel ([] signifies not required)
     * Make relativbe paths absolute.
     * Add tx equivalents of image files ([] signifies not required)
@@ -65,14 +69,15 @@
     paths.extend(_get_scene_files())
 
     env = _get_env()
 
     return {"paths": paths, "env": env}
 
 
+
 def _get_scene_files():
     result = []
     for ref in pm.listReferences(recursive=True):
         result.append({"path": str(ref.path), "refNode": ref.refNode})
 
     scene_name = str(pm.sceneName())
     if scene_name:
@@ -88,37 +93,39 @@
     scraper_utils.get_paths()
 
     We make the value globbabl[e] so that if it's missing it doesn't complain.
 
     Returns: list(dict): list of (path/plug) pairs
     """
     result = []
-    for node in pm.ls(type=("assemblyDefinition", "assemblyReference")):
+    for node in pm.ls(type=("assembly")):
         data_plugs = [
-            node.attr(p) for p in pm.PyNode(node).attr("rep").elements() if p.endswith("repData")
+            node.attr(p)
+            for p in pm.PyNode(node).attr("rep").elements()
+            if p.endswith("repData")
         ]
         for plug in data_plugs:
             value = plug.get()
             if value:
                 value = "{}[{}]".format(value[:-1], value[-1])
                 result.append({"path": value, "plug": plug.name()})
     return result
 
 
 def _get_env():
-    """Add environment variables.
- 
+    """Get environment variables.
+
     Maya's includeAllLights setting can cause the scene to be rendered differently on a remote
     render node. (Bad design.) So we query the corresponding optionVar and set the env variable
     accordingly.
 
     Returns:
         list of dict: list of environment variables in Conductor package_env format.
     """
     setting = pm.optionVar.get("renderSetup_includeAllLights", 1)
-    return  [
-            {
-                "name": "MAYA_RENDER_SETUP_INCLUDE_ALL_LIGHTS",
-                "value":"{:d}".format(setting),
-                "merge_policy": "exclusive",
-            }
-        ]
+    return [
+        {
+            "name": "MAYA_RENDER_SETUP_INCLUDE_ALL_LIGHTS",
+            "value": "{:d}".format(setting),
+            "merge_policy": "exclusive",
+        }
+    ]
```

## ciomaya/scripts/scrape_mtoa.py

```diff
@@ -1,13 +1,14 @@
 """
 A scraper to collect paths from Arnold attributes except those on standins.
 
 We scrape path attributes that were added to Maya nodes by Arnold, but not maya
 native attributes that Arnold happensto use.
 """
+from __future__ import unicode_literals
 
 from ciomaya.lib import scraper_utils
 import pymel.core as pm
 ATTRS = {
     "mtoa":
     {
         "aiImage": ["filename"],
@@ -20,15 +21,19 @@
 }
 
 # See https://docs.arnoldrenderer.com/display/A5AFMUG/Tokens
 TOKENS = (r"<tile>", r"<udim>", r"<frame>", r"<f\d?>", r"<aov>", r"#+")
 
 
 def run(_):
+    return  doit()
 
+
+def doit(_=None):
+    
     paths = scraper_utils.get_paths(ATTRS)
     paths = scraper_utils.starize_tokens(paths, *TOKENS)
     paths = _resolve_attr_tokens(paths)
     paths = scraper_utils.expand_workspace(paths)
 
     paths = scraper_utils.extend_with_tx_paths(paths)
```

## ciomaya/scripts/scrape_mtoa_standins.py

```diff
@@ -1,10 +1,11 @@
 """
 A scraper to recursively collect paths from Arnold standin nodes.
 """
+from __future__ import unicode_literals
 from ciomaya.lib import scraper_utils
 import re
 
 import pymel.core as pm
 from cioseq.sequence import Sequence
 from contextlib import contextmanager
 
@@ -27,30 +28,35 @@
         arnold.AiEnd()
         
 # See https://docs.arnoldrenderer.com/display/A5AFMUG/Tokens
 TOKENS = (r"<tile>", r"<udim>", r"<frame>", r"<f\d?>", r"<aov>", r"#+")
 
 
 def run(node):
+    sequence = scraper_utils.get_sequence(node)
+    return doit(sequence)
+
+
+def doit(sequence):
     """
     Recursive ass scrape.
 
     Can be slow, so we optimize as much as possible.
     """ 
+
     if not ARNOLD_AVAILABLE:
         print("Arnold Python package is not available. Consider turning off this scraper.")
         return {"paths":[], "env":[]}
     paths = []
-    for path in list(set(
+    for path in   list(set(
         [p["path"] for p in scraper_utils.get_paths({"mtoa": {"aiStandIn": ["dso"]}})]
     )):
 
         # Since scanning ass files recursively is expensive, we try to use only
         # those reelevant for the frame range.
-        sequence = Sequence.create(pm.PyNode(node).attr("frameSpec").get())
         resolved_ass_filenames = scraper_utils.resolve_to_sequence(
             path, sequence)
 
         paths.extend(resolved_ass_filenames)
 
     paths = scraper_utils.expand_workspace(paths)
 
@@ -65,14 +71,16 @@
 
     found_files = scraper_utils.starize_tokens(found_files, *TOKENS)
 
     result_paths = [{"path": p} for p in found_files]
     
     return {"paths":result_paths, "env":[]}
 
+
+
 def _files_in(ass_file, seen, depth=0):
 
     if ass_file in seen:
         return []
     seen.add(ass_file)
 
     found_ass_files = []
```

## ciomaya/scripts/scrape_ocio.py

```diff
@@ -1,22 +1,26 @@
 """
-A scraper to collect paths from Yeti nodes.
+A scraper to collect OCIO amendments.
 """
+from __future__ import unicode_literals
 
 import os
 import sys
 
 import pymel.core as pm
 from ciopath.gpath import Path
 
 RESOURCES_TOKEN = "<MAYA_RESOURCES>"
 MAYA_LOCATION = os.environ.get("MAYA_LOCATION")
 
 
 def run(_):
+    return doit()
+
+def doit(_=None):
     """
     Find the ocio config file and set the OCIO variable
 
     If the config file is under MAYA_LOCATION then we assume it's available on the render node and
     ignore it. Since MAYA_RESOURCES token is in MAYA_LOCATION, we can also ignore it.
 
     TODO: This is a bare bones implementation, and does not yet scrape the config file itself for nested
```

## ciomaya/scripts/scrape_redshift.py

```diff
@@ -1,13 +1,14 @@
-from ciomaya.lib import scraper_utils
-import pymel.core as pm
-from ciomaya.lib import software
 """
 A scraper to collect paths from Redshift nodes.
 """
+from __future__ import unicode_literals
+from ciomaya.lib import scraper_utils
+import pymel.core as pm
+from ciomaya.lib import software
 
 
 ATTRS = {
     "redshift4Maya": {
         "RedshiftBokeh": [
             "dofBokehImage"
         ],
@@ -67,24 +68,28 @@
     }
 }
 
 TOKENS = (r"<UDIM>", r"<f\d?>",r"<Frame>" , r"#+")
 
 
 def run(_):
+    return doit()
+
+def doit(_=None):
     if not software.detect_redshift():
         return
 
     paths = scraper_utils.get_paths(ATTRS)
     paths += _scrape_proxies()
     paths = scraper_utils.starize_tokens(paths, *TOKENS)
     paths = scraper_utils.expand_env_vars(paths)
     paths = scraper_utils.expand_workspace(paths)
     return {"paths":paths, "env":[]}
 
+
 def _scrape_proxies():
     result = []
     for node in  pm.ls(type="RedshiftProxyMesh"):
         path = node.attr("computedFileNamePattern").get()
         if path:
             for contained_path in pm.mel.eval( 'rsProxy -q -dependencies "{}"'.format(path)) or []:
                 result.append({"path":contained_path, "proxy_node": node.name()})
```

## ciomaya/scripts/scrape_renderman.py

```diff
@@ -1,16 +1,20 @@
 """
 A scraper to collect paths from Renderman nodes.
 """
+from __future__ import unicode_literals
 
 from ciomaya.lib import scraper_utils, renderman_path_utils
 
 
 # See https://rmanwiki.pixar.com/display/RFM22/String+tokens+in+RfM
 TOKENS = (r"_MAPID_", r"<udim>", r"<frame>", r"<f\d?>", r"<aov>", r"#+")
 
 def run(_):
+    return doit()
+
+def doit(_=None):
     paths = scraper_utils.get_paths(renderman_path_utils.ATTRS)
     paths = scraper_utils.starize_tokens(paths, *TOKENS)
     paths = scraper_utils.expand_workspace(paths)
     paths = scraper_utils.extend_with_tx_paths(paths)
-    return {"paths":paths, "env":[]}
+    return {"paths":paths, "env":[]}
```

## ciomaya/scripts/scrape_vray.py

```diff
@@ -1,12 +1,13 @@
-from ciomaya.lib import scraper_utils
-
 """
 A scraper to collect paths for Vray.
 """
+from __future__ import unicode_literals
+from ciomaya.lib import scraper_utils
+
 
 
 ATTRS = {
     "vray": {
         "VRayMesh": [
             "fileName"
         ],
@@ -26,12 +27,15 @@
 
 # See https://docs.chaosgroup.com/display/VMAYA/File+Names+for+Bitmap+Textures
 TOKENS = (r"<UDIM>", r"<UVTILE>", r"<frameNum>", r"<TileRef>",
           r"\$\d*U.*\$\d*V", r"u<U>_v<V>", r"u<U>_v<V>_<f>", r"#+")
 
 
 def run(_):
+    return doit()
+
 
+def doit(_=None):
     paths = scraper_utils.get_paths(ATTRS)
     paths = scraper_utils.starize_tokens(paths, *TOKENS)
     paths = scraper_utils.expand_workspace(paths)
     return {"paths":paths, "env":[]}
```

## ciomaya/scripts/scrape_xgen.py

```diff
@@ -1,19 +1,21 @@
 """
 A scraper to collect xgen paths.
 
 This scraper deals with Xgen Description, not Xgen Interactive.
 """
+
+from __future__ import unicode_literals
+
 import os
 import re
 from ciomaya.lib import scraper_utils
 import pymel.core as pm
 from ciopath.gpath import Path
 
-
 # Extract values we are interested in from a collection file.
 COLLECTION_FIELD_RX = re.compile(
     r"^\s+(xgDataPath|xgDataPath|cacheFileName|mask|pointDir)\s+(.*)$")
 
 # Match the name value from a collection file.
 COLLECTION_NAME_RX = re.compile(r"^\s+name\s+(.*)$")
 
@@ -24,15 +26,18 @@
     "xgen": {
         "xgmSplineCache": ["fileName"],
         "xgmPalette": ["xgFileName"]
     }
 }
 
 
-def run(node):
+def run(_):
+    return doit()
+
+def doit(_=None):
     """
     Query xgmPalette nodes for xgen collection files.
 
     Scan those collection files for resources.
 
     Return the union of all paths found and the collection files themselves.
     """
```

## ciomaya/scripts/scrape_yeti.py

```diff
@@ -1,10 +1,11 @@
 """
 A scraper to collect paths from Yeti nodes.
 """
+from __future__ import unicode_literals
 
 import pymel.core as pm
 import re
 
 from ciopath.gpath_list import GLOBBABLE_REGEX,PathList
 from ciopath.gpath import Path
 from ciomaya.lib import scraper_utils
@@ -16,49 +17,51 @@
     "texture": ["file_name"],
     "reference": ["reference_file"]
 }
 
 PADDED_PRINTF_REGEX = r"%0\d+d"
 
 def run(_):
+    return doit()
+
+def doit(_=None):
+    
 
     if not software.detect_yeti():
         return
 
     paths = sum([_scrape_yeti_graph_node(yeti_graph_node)
                  for yeti_graph_node in pm.ls(type="pgYetiMaya")], [])
 
     paths = scraper_utils.starize_tokens(paths, PADDED_PRINTF_REGEX)
     return {"paths":paths, "env":[]}
 
 
+
 def _scrape_yeti_graph_node(graph_node):
     """
     Get the files
     """
     paths = []
     is_caching = graph_node.attr("fileMode").get()
     if is_caching:
         plug = graph_node.attr("cacheFileName")
         cache_path = plug.get()
         if cache_path:
             paths.append({"path": cache_path, "plug": plug})
 
     search_paths = _get_search_paths(graph_node)
-    for yeti_node_type in YETI_INTERNAL_NODE_TYPES:
-        attrs = YETI_INTERNAL_NODE_TYPES[yeti_node_type]
+    for yeti_node_type, attrs in YETI_INTERNAL_NODE_TYPES.items():
         yeti_nodes = pm.pgYetiGraph(
             graph_node, listNodes=True, type=yeti_node_type)
         for yeti_node in yeti_nodes:
             for attr in attrs:
-
-                possible_paths = _possible_asset_paths(graph_node,
-                                               yeti_node, attr, search_paths)
-
-                paths+= possible_paths
+                possible_paths = _possible_asset_paths(
+                    graph_node, yeti_node, attr, search_paths)
+                paths += possible_paths
 
     return paths
 
 
 def _possible_asset_paths(graph_node, yeti_node, attr, search_paths):
 
     asset_path = pm.pgYetiGraph(
```

## Comparing `ciomaya-0.6.8.dist-info/METADATA` & `ciomaya-0.8.0rc1.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,100 +1,97 @@
 Metadata-Version: 2.1
 Name: ciomaya
-Version: 0.6.8
+Version: 0.8.0rc1
 Summary: Maya plugin for Conductor Cloud Rendering Platform.
 Home-page: https://github.com/ConductorTechnologies/ciomaya
 Author: conductor
 Author-email: info@conductortech.com
-License: UNKNOWN
-Platform: UNKNOWN
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python
 Classifier: Topic :: Multimedia :: Graphics :: 3D Rendering
 Description-Content-Type: text/markdown
 Requires-Dist: certifi (==2019.11.28)
-Requires-Dist: ciocore (<6.0.0,>=5.2.0)
-Requires-Dist: ciopath (<1.0.0,>=0.1.7)
+Requires-Dist: ciocore (<7.0.0,>=6.3.0)
+Requires-Dist: ciopath (<2.0.0,>=1.0.2)
 Requires-Dist: cioseq (<1.0.0,>=0.1.14)
 Requires-Dist: ciotemplate (<1.0.0,>=0.1.2)
 
 # Conductor for Maya
 
 Maya plugin node to manage submissions to Conductor's cloud service. Supports Maya versions from 2017 to 2023. Requires PyMEL to be installed.
 
 ## Install
 
 **To install the latest version.**
 ```bash
-pip install --upgrade ciomaya --target=$HOME/Conductor
+pip install --upgrade ciomaya --target=$HOME/Conductor/maya
 ```
 
 **To install a specific version, for example 0.1.0.**
 ```bash
-pip install --upgrade --force-reinstall ciomaya==0.1.0 --target=$HOME/Conductor
+pip install --upgrade --force-reinstall ciomaya==0.1.0 --target=$HOME/Conductor/maya
 ```
 
 **Then setup the Maya module.** 
 
 ```bash
-python ~/Conductor/ciomaya/post_install.py
+python ~/Conductor/maya/ciomaya/post_install.py
 ```
 
 > **NOTE** An alternative is to install from the Plugins page in the [Conductor Companion app](https://docs.conductortech.com/getting_started/installation/#companion-app)
 
 ## Usage
 
 Open the Plugin Manager and load **Conductor.py**.
 
-Go to **Conductor->About** to check the version and other info.
-
 To set up a render, choose **Conductor->Submitter->Create** from the **Conductor** menu. 
 
 For detailed help, checkout the [tutorial](https://docs.conductortech.com/tutorials/maya_beta) and [reference](https://docs.conductortech.com/reference/maya_beta) documentation.
 
 
 ## Contributing
 
-Clone the repo.
+See [CONTRIBUTING](CONTRIBUTING.md)
 
-```
-git clone git@github.com:ConductorTechnologies/ciomaya.git
-cd ciomaya
-```
+## Changelog
 
-Set up a clean virtual envirionment with Python 2.7 for development (optional).
+## Version:0.8.0-rc.1 -- 05 Jul 2023
 
-```
-python -m virtualenv venv
-. ./venv/bin/activate
-```
+* Uses ciocore 6.3.0 which supports CoreWeave instance types and provides default categories for all instance types. This build implements dual combobox to house the catergories and the content.
 
-Install development dependencies
-```
-pip install -r requirements_dev.txt
-```
+### Version:0.7.1 -- 30 May 2023
 
-Build and install from this directory into to a convenient location for testing.
-```
+* Scrapers take named args as opposed to kwargs. [df3961b]
 
-pip install --upgrade -r requirements.txt --target=$HOME/ConductorDev
+### Version:0.7.0 -- 27 May 2023
 
-python $HOME/ConductorDev/ciomaya/post_install.py
-```
+* Add the ability to run the suite of scrapers, plus any customer-written scrapers, without knowing about the ConductorRender node. This enables users to call the scraper programatically from Deadline for example. [778e521]
 
-When you install from the file requirements.txt, the dependency on ciocore is specified as a local sibling of this project, meaning you can develop ciocore and ciomaya in parallel.
+### Version:0.6.14 -- 07 Dec 2022
 
-The post_install.py script writes the conductor.mod file to your Maya modules directory. Check the output of the command to see where this is.
+* Remove check for non-existent node types. [dea2fe8]
+* Fix bug where a variable was undefined when using email notifications. [38e01a1]
 
+### Version:0.6.11 -- 01 Dec 2022
 
+* Adds entries to the right-mouse menu to insert renderer args in the task template. [0a3316c]
+* Validation step now catches optix imager connections when no GPU selected. [f0f6bb0]
+* Fix a bug where the wrong version could be shown in the plugin manager. [73d5936]
 
-## License
-[MIT](https://choosealicense.com/licenses/mit)
+### Version:0.6.10 -- 11 Sep 2022
 
-## Changelog
+* Use faster ciopath. [667efac]
+* Added a feature to turn off experimental scrapers by default. [89a132e]
+* New efficient scraper "scrape_maya_tight" to scrape only those assets being used in the frame range, as opposed to all assets that match a glob pattern. [975459a]
+* Progress window to give some idea of scraper progress - still not quite right. [68e9faa]
+* Fix a bug where scraper docstrings did not show on mouseover. [189d17c]
+
+### Version:0.6.9 -- 08 Sep 2022
+
+* Hotfix for unicode character handling in Python 2.7. [19cd941]
 
 ### Version:0.6.8 -- 28 Jul 2022
 
 * Minor labeling change. [bf864ba]
 
 ### Version:0.6.7 -- 28 Jul 2022
 
@@ -113,15 +110,15 @@
 ### Version:0.6.4 -- 13 Jul 2022
 
 * Adds Maya 2023 support. [3a25997]
 
 ### Version:0.6.3 -- 30 Jun 2022
 
 * Plugin is now compatible with core version 5.x. [3a5ceef]
-
+  
 ### Version:0.5.43 -- 30 Jun 2022
 
 * This is a fix to mitigate the effects of Maya's includeAllLights optionVar, which should be a scene setting. We now ensure that the option travels with the scene to Conductor by setting the environment variable MAYA_RENDER_SETUP_INCLUDE_ALL_LIGHTS accordingly. [a6d67fb]
 
 ### Version:0.5.42 -- 15 Jun 2022
 
 * Freeze certifi version to be python 2.7 and python3 compatible. [e6c7a8a]
@@ -364,15 +361,15 @@
 * Scrapers can now accept node name or pynode. [cae8f04]
 
 ### Version:0.1.42 -- 04 Nov 2020
 
 * Adds a validation to warn about the Renumber Frames setting. [772cc91]
 * Fixed a bug in destination path and frames section due to buggy attrControlGrp in pymel. [31fa87d]
 * Adds a visible Add Software button. [2c117ae]
-
+  
 ### Version:0.1.41 -- 21 Oct 2020
 
 * Adds ability to expand env vars for redhift nodes. [5f28081]
 
 ### Version:0.1.40 -- 14 Oct 2020
 
 * Fix bug in presets to remove the output attribute so it doesn't barf on the json. [4968a82]
@@ -381,15 +378,15 @@
 
 * Generate combined readme and changelog for pypi. [75ccebd]
 
 ### Version:0.1.36 -- 07 Oct 2020
 
 * Fixed a bug where a Sequence could emit chunks that weren't progressions, and therefore could not be expressed as `start`, `end`, and `by` in the Render command. [ee65a28]
 * Some new scrapers are more efficient to work with as simple paths rather than objects containing a path. Therefore, handle both options when processing. [71312de]
-
+ 
 ### Version:0.1.35 -- 18 Sep 2020
 
 * Bifrost cache optimized to frame range. [c913b41]
 * Tidy standin scraper. [ae734ef]
 * Recursive ass scraping. [4727c9d]
 * Image planes evaluate for frame range. [4f11718]
 * Better messages when scrapers invalid. [13e63aa]
@@ -405,15 +402,15 @@
 
 
 ### Version:0.1.33 -- 01 Sep 2020
 
 * Fix missing chunk_size attributeAffects relationship. [216893a]
 * Guard against missing arnoldrRenderOptions in validations. [ea32a60]
 * Adds `<f4>` style scrape regex. [24120d9]
-
+  
 ### Version:0.1.32 -- 18 Aug 2020
 
 * Several validation and redshift improvements. Fixed a bug around software validation. Adds redshift scraping. Fixed some validation issues. [bec172b]
 
 ### Version:0.1.31 -- 11 Aug 2020
 
 Testing PyPi url preferences.
@@ -494,8 +491,7 @@
 * Adds connection progress bar and make errors red. [c13daec]
 * Notice window now differentiates between warnings and info with icons. [944a44e]
 * Renderer package validation. Warn if selected renderer not selected as a plugin. [67efa52]
 
 ### Version:0.1.18 -- 22 Jun 2020
 
 * Flattened the structure, remove namespaces, and simplified the version file.
-
```

## Comparing `ciomaya-0.6.8.dist-info/RECORD` & `ciomaya-0.8.0rc1.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,11 @@
-ciomaya/VERSION,sha256=lwquH_VXW5oYOfWpl5J3wpImwvyLAwIspFNlB7XnV4Y,5
+ciomaya/VERSION,sha256=wO_uQOhrzdmO9zREnzBhxD_5NbyC6KTnTBu9i5RpXC4,10
 ciomaya/__init__.py,sha256=Nqnn8clbgv-5l0PgxcTOldg8mkMKrFn4TvPL-rYUUGg,1
-ciomaya/conductor.mod,sha256=5VUSzOiQ1EJ_EjS78N2HFXeZHqfxsSxvf-HIH0Doqp4,36
-ciomaya/post_install.py,sha256=MoDAVn1C0nUbWhXWIx3hKswjTASz_914eyk-x47wOCo,2571
+ciomaya/conductor.mod,sha256=1-ufBV_HnfmIv5wqFvJp7BUs4TZDCrL7v5DuS01OZqg,41
+ciomaya/post_install.py,sha256=UTChBmfpU0xlDnpCWOK1yLeZaJWMXege42Ta4sXky-s,2571
 ciomaya/icons/ConductorConnect_18x18.png,sha256=DDsRg0l471tFQjJ3UYD2s4J6fvtUNjMCw5mlLqmQ30c,939
 ciomaya/icons/ConductorConnect_24x24.png,sha256=k-upvseBm7JW7iUHInTVIQmrNSCoLQzWQUQtubu433M,1254
 ciomaya/icons/ConductorConnect_30x30.png,sha256=l4Q4V1_HyhXrJeBJKKfI9cHsgT89Su5LMXa27sz7FqE,1585
 ciomaya/icons/ConductorConnect_36x36.png,sha256=gJFxuG2oZj9EqvYQf-x2Yeh4L-cRaumYjMl84heoPSg,1815
 ciomaya/icons/ConductorError_18x18.png,sha256=x-WnL6eKcUK4ILt-45PpDrwruZnuRpQFBVhZNx9Hfmo,1137
 ciomaya/icons/ConductorError_24x24.png,sha256=2RXEVtg1hh_gkmWwbWfbWAjqN8Z80yTb50HQkmYFybU,1553
 ciomaya/icons/ConductorError_30x30.png,sha256=YSJIy2CLowPbmx-ykPDR7TTiV_zK69v3cPwABvbKnzY,1832
@@ -30,57 +30,58 @@
 ciomaya/icons/ConductorWarning_24x24.png,sha256=cOT1e2Af5mEgmgeQu6E3WHuaHeOLbKy-vE4I-5OjN1E,1177
 ciomaya/icons/ConductorWarning_30x30.png,sha256=0Jvii_F5gVBu_6bRh-_15lvhxkoIHRQ7rdAWC4m7rwQ,1403
 ciomaya/icons/ConductorWarning_36x36.png,sha256=q653PCnZmLCok1lW0kpHRyY7JHiSkfEUq0S0yI_ikNQ,1668
 ciomaya/icons/conductorRender.png,sha256=HJQf3HOTqlpTcrzlSAWExFoPnCCka8kTa0e9haD-qAo,776
 ciomaya/icons/conductor_logo_white.png,sha256=nzxobsK-gf7xzxNWwRS2ZoEosI3q1RoN4gTt9MfEsjE,30014
 ciomaya/icons/out_conductorRender.png,sha256=YuuazBzQX-uDcQPtsm0OrO2Cf-3I02wxRBobqxFRmKk,344
 ciomaya/lib/__init__.py,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
+ciomaya/lib/about_window.py,sha256=DHz7iD0TT4D8wi84az0ZeRzBXTscknPywkmpvi2WmkY,2819
 ciomaya/lib/asset_cache.py,sha256=32j1fOJgg8KUB0E5GLn-z6eupo88-YOEUgsQqpAMZjQ,1116
-ciomaya/lib/conductor_menu.py,sha256=UpzKUX9qOgUrHGbObg_X6ph6rGqnAXh5T5LMIIZOndc,3771
+ciomaya/lib/conductor_menu.py,sha256=4VtGWRs7-bObiySVvc6_3boPaUeWBZ0CZyM-WOSbtK0,4176
 ciomaya/lib/const.py,sha256=EHmn2q7ywhNj-KcvsaxCRAfe6axyVVO3b9SN9asaq_M,990
 ciomaya/lib/context.py,sha256=9WAzLgUoYpz6JJRP_wrGXF3na7WP8roGXjHJ6yzJgio,3079
 ciomaya/lib/layer_utils.py,sha256=iHqJttGm0wlboc9VrsiWU8MmkqMYQOxO_ogIwwHQQCE,1009
 ciomaya/lib/node_utils.py,sha256=lKque1LTmAEfUies3rWGx80DOrPG4QmUbtrxmojekfw,1033
-ciomaya/lib/renderman_path_utils.py,sha256=X2aLb4xiaoXVxWL6MErwSiYjDdTyr4umcfRR3QLAS3w,3449
-ciomaya/lib/scraper.py,sha256=DceAa246YnhhVZPXM-p9Xsagb4VP0yt9P9U_Zg6V0As,1148
-ciomaya/lib/scraper_utils.py,sha256=cU8H2w5ceE5l4mbd0jDjPdAU2CQzItZWmRFTRBNwXZY,7457
-ciomaya/lib/software.py,sha256=oCWIQ7ze_k-t6mPz7w0H3hQneFpyz7mBSKjyuRTX7c8,2067
-ciomaya/lib/submit.py,sha256=nAfRuBffcC-eDPjHx33iKXdIEWb521HHb4MNKK6B0jU,6060
-ciomaya/lib/validation.py,sha256=s901KZZCvCtSulgu8lJKG1Oj8y8IJU8bYIwBsGixmcQ,28042
-ciomaya/lib/window.py,sha256=8N_N2tWo373oFA79hlABwioUUhT4emODATxtxpinuxU,5929
+ciomaya/lib/renderman_path_utils.py,sha256=h-_YHLx9rJurxucz5nOpCx2e09CJobjyNoz619IY-sg,3488
+ciomaya/lib/scrape_runner.py,sha256=4AxI2pTxrTyb1-0IvSqxFAjKVSNp1sOGON7VQiCnHIw,2868
+ciomaya/lib/scraper_utils.py,sha256=IJcIl0HMcGqdvV5CxuyzmWVk0uZxJ860ZnmRldPHMik,8141
+ciomaya/lib/software.py,sha256=_A2mSf19Lm2vC00xJMd7vQhYLrV4Dezcx26mccfBv14,2107
+ciomaya/lib/submission_progress.py,sha256=irEcLCMj4nc4gJ2TVvZSNfuIkBeKa8Rhj_nOlib3vHc,2033
+ciomaya/lib/submit.py,sha256=dWGWzXaGcW_F0vdKWjmo_ImRrShxxTc7Rb6Q-njA0zI,6138
+ciomaya/lib/validation.py,sha256=n9hZYY7AEaupKAegtE6amJj73OjZrx-MRl5tx077Dks,28470
+ciomaya/lib/window_utils.py,sha256=DWWCkADJI6P4N3saE8_hcUzb7SKE2qvJIpSLkvw8kUw,1297
 ciomaya/lib/ae/AEactions.py,sha256=g1KNZE4RsEDYVwxyTei9GihciMiCsVTgpG4l8eWh9DE,4095
-ciomaya/lib/ae/AEcommon.py,sha256=Pw469nn2Hp7WW5bN8aGfdNRxVu3GMfubMhtKXhOksHQ,3444
-ciomaya/lib/ae/AEdestination.py,sha256=Ln62BCx8GcZ3ZCl3sJm0UMGKe8fi0rTpsVehEkC3WuM,3442
-ciomaya/lib/ae/AEemails.py,sha256=QTfxPETTC4MTYImTStBbTTDOZUBsNe3Gtv5YuzTg6z4,3580
+ciomaya/lib/ae/AEcommon.py,sha256=6H4ByYRqaookzJ-nlF2iVsNoZPWeUJRUAx63y54RdgA,3484
+ciomaya/lib/ae/AEdestination.py,sha256=HeS6rM5vplH4_ypk6cpCdL5z_SPuo0RzY1pMhZvW0vE,3482
+ciomaya/lib/ae/AEemails.py,sha256=jjx-mDGrvR5Ho61gVxpbxH3-mqjLaPbFaITgcbREA7c,3620
 ciomaya/lib/ae/AEenvironment.py,sha256=tCCDlOubA9VzMi4eLo0MAQQi2GyQt4RlwNkT4k65euQ,4305
 ciomaya/lib/ae/AEextraAssets.py,sha256=oOw7Wj1zhehLlJB4eXzJOlv387V75w3s8qIgN127iQc,4402
-ciomaya/lib/ae/AEframes.py,sha256=gUb0JcqYgC07q00vVNv_FNgI2ePvxJDZW4hMU2L9QeY,2769
-ciomaya/lib/ae/AEinstanceType.py,sha256=d6_xR529xddSzI9-O289JJRcjObpBlvaKz95OE8wBo8,5801
+ciomaya/lib/ae/AEframes.py,sha256=0nVjkNYxYUDpDdUKr8Z4XhR530_bnUQzGFhUz0b7ghY,2809
+ciomaya/lib/ae/AEinstanceType.py,sha256=FUaTuXZXMWnGCT01gRgG_pC0UFv-9-B_RkZUI_9HGBg,9033
 ciomaya/lib/ae/AElayers.py,sha256=3x5DeKxRlVpPknWQ5U_nUXpoNF-mydIPY704ny5GFC0,1188
 ciomaya/lib/ae/AEmetadata.py,sha256=ML36VLoBlrcYcSjGzh9Ptn3j4nf1nrxxiJNuFKgMqvk,3201
 ciomaya/lib/ae/AEoutput.py,sha256=kHgMgl5eEDLnjNrJ3Ts-XttxzPzZG6MCjsk3rIqWIdI,976
 ciomaya/lib/ae/AEproject.py,sha256=V7CPRiJ9l10jXXleRirY2JIwEoeW0UQNYy6GkaZoQx8,2459
-ciomaya/lib/ae/AEscrapers.py,sha256=D0TYN9qmCEN8ee6dunFF8ur8dhcImEWrHfzjvlfcnC4,13697
-ciomaya/lib/ae/AEsoftware.py,sha256=Cw1L-jI2xLvkdt2fcM2zMNLApkKYz5kOMMrQWC6VH2M,12710
-ciomaya/lib/ae/AEtaskTemplate.py,sha256=-zK2H3vC5K6OvTxNtj8Fr8jXgTbMoA-NbqmrA1ER7a8,1293
+ciomaya/lib/ae/AEscrapers.py,sha256=bNvHmeNnqLGoVmcTcV0LDVZ5DlkZm-BV4kTXHzDmpJ8,14726
+ciomaya/lib/ae/AEsoftware.py,sha256=eMRjA6UZG0GX8dAoW3AnChOUKH2MTX8N2JLesP0XkQQ,12750
+ciomaya/lib/ae/AEtaskTemplate.py,sha256=PE1m8myEENQ8xjKvSFYsowg_4_hSbl_FsYGb6_iE6Pw,2231
 ciomaya/lib/ae/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ciomaya/lib/nodes/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-ciomaya/lib/nodes/conductorRender.py,sha256=_dJUjBM4N-p1DJHyirKcjYk240FUkVLk6J7mYehYiHI,37047
-ciomaya/plug-ins/Conductor.py,sha256=z8npIdi7PUW-SrjmGsSXdb-No23ubMZEPDKwuoCINfE,2971
+ciomaya/lib/nodes/conductorRender.py,sha256=UqdwatVdNIpPYAHE66QtAfkPhMykEObZW2xXmggqIec,37105
+ciomaya/plug-ins/Conductor.py,sha256=3IuD3tgGCmbQ9ZI1_Zm0U6UcuQ08LyPMhC1-NPJuBAc,2981
 ciomaya/scripts/AEconductorRenderTemplate.mel,sha256=f3K0U-SPD3BrYdHYgSEl1x11ArmwfaeDwW4yB1J6yRE,10125
-ciomaya/scripts/glob_scrape_image_planes.py,sha256=O_vYVhcWGUXJCO5bGNG3_DAyCEze54SRITvManhIGg0,972
-ciomaya/scripts/old_scrape_xgen.py,sha256=3RtN278P2V-9v6oRhdaZYBVksCw5zPEEKLJIkYRqsdg,706
-ciomaya/scripts/scrape_bifrost.py,sha256=z2aLm3nNg0MRcp378vp8QiO-WSVajkW8VzYlC9z5jcw,1846
-ciomaya/scripts/scrape_image_planes.py,sha256=iuCJ-q_lTaJKZ1K7DHIuIn4LoC9puSrleQaYGOZYoU8,2385
-ciomaya/scripts/scrape_maya.py,sha256=wNub3wqzpfbME8WDtfp0dCIX6-bHvfwyn2v8uEhgy3Q,4046
-ciomaya/scripts/scrape_mtoa.py,sha256=I8Zg5lmF2Umh-6HfOInzP7FtAMGnfaf9EzWEcLYr59k,3236
-ciomaya/scripts/scrape_mtoa_standins.py,sha256=syyCOFefOpJ027EWo29SsxrXXTG8JGfX8ViL7-vIkMw,4362
-ciomaya/scripts/scrape_ocio.py,sha256=KnI7jXBk3VKBflekcTOWQ-hmY2NTh5ANPvqxXrArJ3w,1318
-ciomaya/scripts/scrape_redshift.py,sha256=3UEieeRE36IhJm8J6KldvVN3-eqi7jcpxmArZiWCU-8,2128
-ciomaya/scripts/scrape_renderman.py,sha256=xM3dt_J_qcbOlAfP7YGc7R_YDv7LM40PElqdpmAh_KQ,535
-ciomaya/scripts/scrape_vray.py,sha256=sueNQskdXuSJ7ANpW7_qrJMWpFsOxuXJCDhIutHBz9o,806
-ciomaya/scripts/scrape_xgen.py,sha256=K-hXehjfAkvMTMCTThwbG5uVuQikFnJ6UZhk7bPh0l8,4153
-ciomaya/scripts/scrape_yeti.py,sha256=D4d5XJpzFYKLeod7HRtksa_V6Y8kaeJtGf1lvLmvA4s,4865
-ciomaya-0.6.8.dist-info/METADATA,sha256=XP4XF9hm2MAcdT7YLqAPseiI5B-Ys6YBG9iLWIHWwzY,19913
-ciomaya-0.6.8.dist-info/WHEEL,sha256=z9j0xAa_JmUKMpmz72K0ZGALSM_n-wQVmGbleXx2VHg,110
-ciomaya-0.6.8.dist-info/top_level.txt,sha256=3lKrvpPRh8Vf-h3HiywvxZQD_EZk67shNFb5P2yKTsg,8
-ciomaya-0.6.8.dist-info/RECORD,,
+ciomaya/scripts/scrape_bifrost.py,sha256=3dOGQgnCNVHlVg9ZtErNbgTu42W_HRVcxwT8zaST6XA,1982
+ciomaya/scripts/scrape_image_planes.py,sha256=g4KmAQjDjQBiJO05SquN9VUOTM930OD2bSJPTtOtikk,2417
+ciomaya/scripts/scrape_maya.py,sha256=gG-K_ZpMArEaITnBLEKK2JpUEGyfr6_bmx35jLSMG3A,4090
+ciomaya/scripts/scrape_maya_tight.py,sha256=8gU-hA6Nxv74aW9K09NdmYjcmSEfQ5L5Fek8i_fZbpQ,8687
+ciomaya/scripts/scrape_mtoa.py,sha256=M4IoI_yfKc2PWWoayfbeETfmi26TKrs4Ny0ZZRzgnxg,3319
+ciomaya/scripts/scrape_mtoa_standins.py,sha256=Sbi9mfc6IZ24ZV_1WiiCHjvuVw8gbq7vOVD4SxpPqlk,4427
+ciomaya/scripts/scrape_ocio.py,sha256=dQtj944RmJ8qs5Fgl2eJPu4xesmn2xm9eHz4tWZzigw,1389
+ciomaya/scripts/scrape_redshift.py,sha256=VxzHTAdKM1eg0Q9QrI3OMFVn_ZVE8orvj-K5I0ZbD5U,2206
+ciomaya/scripts/scrape_renderman.py,sha256=JAG2cBf7WHcpIwdm_jCtFTA539irg9U4-9wInRGl4kA,613
+ciomaya/scripts/scrape_vray.py,sha256=8D9DozweLEd-YTpoxnE9LVUR2uc7gBvcQtpfsV4qwGM,883
+ciomaya/scripts/scrape_xgen.py,sha256=UoRQ2HSmwlPgeglwSbYvV0nlfM8RClJGRRHmq_Phr8s,4228
+ciomaya/scripts/scrape_yeti.py,sha256=UVny1GRUnvzaItaIKcLDY8Q41W35iR0mmVp7SJ0JdVc,4879
+ciomaya-0.8.0rc1.dist-info/METADATA,sha256=-AOZ6lkItVS8jT-gplKQgob5_rE7Db0qO-8ANR9K24Y,20597
+ciomaya-0.8.0rc1.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+ciomaya-0.8.0rc1.dist-info/top_level.txt,sha256=3lKrvpPRh8Vf-h3HiywvxZQD_EZk67shNFb5P2yKTsg,8
+ciomaya-0.8.0rc1.dist-info/RECORD,,
```

