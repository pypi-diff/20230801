# Comparing `tmp/myqlm_interop-1.7.1-py3-none-any.whl.zip` & `tmp/myqlm_interop-1.9.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,28 +1,28 @@
-Zip file size: 64490 bytes, number of entries: 26
--rwxr-xr-x  2.0 unx     3308 b- defN 22-Nov-04 02:28 myqlm_interop-1.7.1.data/scripts/oqasm2circ
--rw-r--r--  2.0 unx     1412 b- defN 22-Nov-04 02:28 qat/interop/__init__.py
--rw-r--r--  2.0 unx     1042 b- defN 22-Nov-04 02:28 qat/interop/cirq/__init__.py
--rw-r--r--  2.0 unx    19045 b- defN 22-Nov-04 02:28 qat/interop/cirq/converters.py
--rw-r--r--  2.0 unx     3415 b- defN 22-Nov-04 02:28 qat/interop/cirq/providers.py
--rw-r--r--  2.0 unx      855 b- defN 22-Nov-04 02:28 qat/interop/openqasm/__init__.py
--rw-r--r--  2.0 unx     1553 b- defN 22-Nov-04 02:28 qat/interop/openqasm/oqasm_routine.py
--rw-r--r--  2.0 unx     4747 b- defN 22-Nov-04 02:28 qat/interop/openqasm/qasm_lexer.py
--rw-r--r--  2.0 unx    57779 b- defN 22-Nov-04 02:28 qat/interop/openqasm/qasm_parser.py
--rw-r--r--  2.0 unx     1056 b- defN 22-Nov-04 02:28 qat/interop/projectq/__init__.py
--rw-r--r--  2.0 unx     8719 b- defN 22-Nov-04 02:28 qat/interop/projectq/converters.py
--rw-r--r--  2.0 unx     1228 b- defN 22-Nov-04 02:28 qat/interop/pyquil/__init__.py
--rw-r--r--  2.0 unx    11100 b- defN 22-Nov-04 02:28 qat/interop/pyquil/algorithms.py
--rw-r--r--  2.0 unx     9621 b- defN 22-Nov-04 02:28 qat/interop/pyquil/converters.py
--rw-r--r--  2.0 unx     4591 b- defN 22-Nov-04 02:28 qat/interop/pyquil/providers.py
--rw-r--r--  2.0 unx     1199 b- defN 22-Nov-04 02:28 qat/interop/qiskit/__init__.py
--rw-r--r--  2.0 unx    25676 b- defN 22-Nov-04 02:28 qat/interop/qiskit/converters.py
--rw-r--r--  2.0 unx    30529 b- defN 22-Nov-04 02:28 qat/interop/qiskit/providers.py
--rw-r--r--  2.0 unx     6221 b- defN 22-Nov-04 02:28 qat/interop/qiskit/quantum_channels.py
--rw-r--r--  2.0 unx    10603 b- defN 22-Nov-04 02:28 qat/interop/qiskit/runtime.py
--rw-r--r--  2.0 unx    11340 b- defN 22-Nov-04 02:28 myqlm_interop-1.7.1.dist-info/LICENSE
--rw-r--r--  2.0 unx     1393 b- defN 22-Nov-04 02:28 myqlm_interop-1.7.1.dist-info/METADATA
--rw-r--r--  2.0 unx      161 b- defN 22-Nov-04 02:28 myqlm_interop-1.7.1.dist-info/NOTICE
--rw-r--r--  2.0 unx       92 b- defN 22-Nov-04 02:28 myqlm_interop-1.7.1.dist-info/WHEEL
--rw-r--r--  2.0 unx        4 b- defN 22-Nov-04 02:28 myqlm_interop-1.7.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2295 b- defN 22-Nov-04 02:28 myqlm_interop-1.7.1.dist-info/RECORD
-26 files, 218984 bytes uncompressed, 60758 bytes compressed:  72.3%
+Zip file size: 64972 bytes, number of entries: 26
+-rwxr-xr-x  2.0 unx     3308 b- defN 23-Jul-31 22:55 myqlm_interop-1.9.1.data/scripts/oqasm2circ
+-rw-r--r--  2.0 unx     1412 b- defN 23-Jul-31 22:54 qat/interop/__init__.py
+-rw-r--r--  2.0 unx     1042 b- defN 23-Jul-31 22:54 qat/interop/cirq/__init__.py
+-rw-r--r--  2.0 unx    19045 b- defN 23-Jul-31 22:54 qat/interop/cirq/converters.py
+-rw-r--r--  2.0 unx     3415 b- defN 23-Jul-31 22:54 qat/interop/cirq/providers.py
+-rw-r--r--  2.0 unx      855 b- defN 23-Jul-31 22:54 qat/interop/openqasm/__init__.py
+-rw-r--r--  2.0 unx     1553 b- defN 23-Jul-31 22:54 qat/interop/openqasm/oqasm_routine.py
+-rw-r--r--  2.0 unx     4034 b- defN 23-Jul-31 22:54 qat/interop/openqasm/qasm_lexer.py
+-rw-r--r--  2.0 unx    54247 b- defN 23-Jul-31 22:54 qat/interop/openqasm/qasm_parser.py
+-rw-r--r--  2.0 unx     1056 b- defN 23-Jul-31 22:54 qat/interop/projectq/__init__.py
+-rw-r--r--  2.0 unx     8719 b- defN 23-Jul-31 22:54 qat/interop/projectq/converters.py
+-rw-r--r--  2.0 unx     1228 b- defN 23-Jul-31 22:54 qat/interop/pyquil/__init__.py
+-rw-r--r--  2.0 unx    11101 b- defN 23-Jul-31 22:54 qat/interop/pyquil/algorithms.py
+-rw-r--r--  2.0 unx     9621 b- defN 23-Jul-31 22:54 qat/interop/pyquil/converters.py
+-rw-r--r--  2.0 unx     4594 b- defN 23-Jul-31 22:54 qat/interop/pyquil/providers.py
+-rw-r--r--  2.0 unx     1196 b- defN 23-Jul-31 22:54 qat/interop/qiskit/__init__.py
+-rw-r--r--  2.0 unx    25355 b- defN 23-Jul-31 22:54 qat/interop/qiskit/converters.py
+-rw-r--r--  2.0 unx    30521 b- defN 23-Jul-31 22:54 qat/interop/qiskit/providers.py
+-rw-r--r--  2.0 unx     6221 b- defN 23-Jul-31 22:54 qat/interop/qiskit/quantum_channels.py
+-rw-r--r--  2.0 unx    12159 b- defN 23-Jul-31 22:54 qat/interop/qiskit/runtime.py
+-rw-r--r--  2.0 unx    11340 b- defN 23-Jul-31 22:55 myqlm_interop-1.9.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1393 b- defN 23-Jul-31 22:55 myqlm_interop-1.9.1.dist-info/METADATA
+-rw-r--r--  2.0 unx      161 b- defN 23-Jul-31 22:55 myqlm_interop-1.9.1.dist-info/NOTICE
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-31 22:55 myqlm_interop-1.9.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx        4 b- defN 23-Jul-31 22:55 myqlm_interop-1.9.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2295 b- defN 23-Jul-31 22:55 myqlm_interop-1.9.1.dist-info/RECORD
+26 files, 215967 bytes uncompressed, 61240 bytes compressed:  71.6%
```

## zipnote {}

```diff
@@ -1,8 +1,8 @@
-Filename: myqlm_interop-1.7.1.data/scripts/oqasm2circ
+Filename: myqlm_interop-1.9.1.data/scripts/oqasm2circ
 Comment: 
 
 Filename: qat/interop/__init__.py
 Comment: 
 
 Filename: qat/interop/cirq/__init__.py
 Comment: 
@@ -54,26 +54,26 @@
 
 Filename: qat/interop/qiskit/quantum_channels.py
 Comment: 
 
 Filename: qat/interop/qiskit/runtime.py
 Comment: 
 
-Filename: myqlm_interop-1.7.1.dist-info/LICENSE
+Filename: myqlm_interop-1.9.1.dist-info/LICENSE
 Comment: 
 
-Filename: myqlm_interop-1.7.1.dist-info/METADATA
+Filename: myqlm_interop-1.9.1.dist-info/METADATA
 Comment: 
 
-Filename: myqlm_interop-1.7.1.dist-info/NOTICE
+Filename: myqlm_interop-1.9.1.dist-info/NOTICE
 Comment: 
 
-Filename: myqlm_interop-1.7.1.dist-info/WHEEL
+Filename: myqlm_interop-1.9.1.dist-info/WHEEL
 Comment: 
 
-Filename: myqlm_interop-1.7.1.dist-info/top_level.txt
+Filename: myqlm_interop-1.9.1.dist-info/top_level.txt
 Comment: 
 
-Filename: myqlm_interop-1.7.1.dist-info/RECORD
+Filename: myqlm_interop-1.9.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## qat/interop/openqasm/qasm_lexer.py

```diff
@@ -19,18 +19,14 @@
     specific language governing permissions and limitations
     under the License.
 """
 
 import ply.lex as lex
 
 
-#CORE_LIBS_PATH = os.path.join(os.path.dirname(__file__), 'libs')
-#CORE_LIBS = os.listdir(CORE_LIBS_PATH)
-
-
 class OqasmLexer(object):
     """OPENQASM Lexer.
 
     This is a wrapper around the PLY lexer to support the "include" statement
     by creating a stack of lexers.
     """
     # pylint: disable=invalid-name,missing-docstring,unused-argument
@@ -96,32 +92,19 @@
         #
         # Then push the current lexer onto the stack, create a new one from
         # the include file, and push it onto the stack.
         #
         # When we hit eof (the t_eof) rule, we pop.
         next_token = self.lexer.token()
         lineno = next_token.lineno
-        # print('NEXT', next, "next.value", next.value, type(next))
-        #if isinstance(next_token.value, str):
-         #   incfile = next_token.value.strip('"')
-        #else:
-         #   raise SyntaxError("Invalid include: must be a quoted string.")
-
-        #if incfile in CORE_LIBS:
-         #   incfile = os.path.join(CORE_LIBS_PATH, incfile)
-
         next_token = self.lexer.token()
+
         if next_token is None or next_token.value != ';':
             raise SyntaxError('Invalid syntax, missing ";" at line', str(lineno))
 
-        #if not os.path.exists(incfile):
-         #   raise IOError(
-          #      'Include file %s cannot be found, line %s, file %s' %
-           #     (incfile, str(next_token.lineno), self.filename))
-        #self.push(incfile)
         return self.lexer.token()
 
     def t_FORMAT(self, t):
         r'OPENQASM\s+(\d+)\.(\d+)'
         return t
 
     def t_COMMENT(self, t):
```

## qat/interop/openqasm/qasm_parser.py

```diff
@@ -27,14 +27,15 @@
 from qat.lang.parser.gates_ast import ASTCircuitBuilder, GateAST
 from qat.comm.datamodel.ttypes import OpType
 from qat.interop.openqasm.qasm_lexer import OqasmLexer
 from qat.interop.openqasm.oqasm_routine import Element, Routine, Gate
 
 from qat.lang.AQASM import AbstractGate
 from qat.core.circuit_builder.matrix_util import default_gate_set
+from qat.core.gate_set import UnknownGate
 
 
 class ParsingEOF(Exception):
     """
     Unexpected End Of File
     """
 
@@ -81,18 +82,30 @@
     def __str__(self):
         return "line {} : {} requires {} arguments ({} given)".format(
             self.lineno, self.name, self.expected, len(self.arg_list)
         )
 
 
 def gen_U(theta, phi, lamda):
-    m11 = (math.e ** (1j * (phi + lamda) / 2)) * math.cos(theta / 2)
-    m12 = (-1) * (math.e ** (1j * (phi - lamda) / 2)) * math.sin(theta / 2)
-    m21 = (math.e ** (1j * (phi - lamda) / 2)) * math.sin(theta / 2)
-    m22 = (math.e ** (1j * (phi + lamda) / 2)) * math.cos(theta / 2)
+    """
+    Generates the U / U3 gate matrix. The definition of this gate is based on:
+    https://qiskit.org/documentation/stubs/qiskit.circuit.library.U3Gate.html (Sept 08, 2022)
+
+    Args:
+        theta:
+        phi:
+        lamda: lambda parameter
+
+    Returns:
+        numpy.ndarray U gate matrix
+    """
+    m11 = np.cos(theta / 2)
+    m12 = -np.exp(1j * lamda) * np.sin(theta / 2)
+    m21 = np.exp(1j * phi) * np.sin(theta / 2)
+    m22 = np.exp(1j * (phi + lamda)) * np.cos(theta / 2)
     return np.array([[m11, m12], [m21, m22]], dtype=np.complex128)
 
 
 def gen_dummy():
     return np.matrix([[1, 0], [0, 1]], dtype=np.complex128)
 
 
@@ -241,21 +254,88 @@
 
 """
 OPENQASM parser.
 """
 
 
 class OqasmParser(object):
-    """OPENQASM Parser."""
+    """
+    Parser of OpenQASM 2.0 files. This class provides tools to translate a string object
+    (containing OpenQASM 2.0 source code) into a :class:`~qat.core.Circuit`
+
+    .. tab-set::
+
+        .. tab-item:: Basic example
+
+            .. run-block:: python
+
+                from qat.interop.openqasm import OqasmParser
+
+                # Define a dummy circuit
+                data = \"\"\"
+                OPENQASM 2.0;
+
+                // Allocate qubits and cbits
+                qreg q[1];
+                creg c[1];
+
+                // Apply gates and measure
+                x q[0];
+                measure q[0] -> c[0];
+                \"\"\"
+
+                # Translate into a myQLM circuit
+                parser = OqasmParser()
+                circuit = parser.compile(data)
+                print("The circuit is composed of gates",
+                      list(circuit.iterate_simple()))
+
+        .. tab-item:: Advanced example
+
+            .. run-block:: python
+
+                from qat.lang.AQASM import AbstractGate
 
-    def __init__(self):
+                # Define a circuit using OpenQASM
+                OPENQASM_CODE = \"\"\"
+                OPENQASM 2.0;
+
+                // Allocating registers
+                qreg q[1];
+                creg c[1];
+
+                // Dummy circuit
+                p(pi/4) q[0];
+                my_custom_gate q[0];
+                \"\"\"
+
+                # Register gates (i.e. "p" gate is an alias for "PH" gate, "my_custom_gate" is defined by an abstract gate)
+                custom_gate = AbstractGate("custom_gate", [], arity)
+                parser = OqasmParser(gates={"p": "PH", "my_custom_gate": custom_gate}, include_matrices=False)
+
+                # Compile circuit and display it
+                for gate, angles, qubits in parser.compile(OQASM_CODE).iterate_simple():
+                    if angles:
+                        print(f"Apply {gate}{angles} on qubits {qubits}")
+                    else:
+                        print(f"Apply {gate} on qubits {qubits}")
+
+    Args:
+        gates (dict[str, str or :class:`~qat.lang.AQASM.gates.Gate`], optional): definition of custom gates. These gates
+            are defined using a dictionary, a key corresponding to the OpenQASM gate identifier and the key being:
+             - a str: the name of the equivalent gate in myQLM (e.g. "PH", "X", "U", etc.)
+             - a :class:`~qat.lang.AQASM.gates.Gate`: a custom gate
+        include_matrices (bool, optional): include matrices in the generated circuit (default: True)
+    """
+
+    def __init__(self, gates: dict = None, include_matrices: bool = True):
         self.start = "main"
         self.format_version = False
         self.lineno = 0
-        self.compiler = ASTCircuitBuilder(include_matrices=True)
+        self.compiler = ASTCircuitBuilder(include_matrices=include_matrices)
         U = AbstractGate("U", [float, float, float], arity=1, matrix_generator=gen_U)
         u1 = AbstractGate("U1", [float], arity=1, matrix_generator=gen_u1)
         u2 = AbstractGate("U2", [float, float], arity=1, matrix_generator=gen_u2)
         u3 = AbstractGate("U3", [float, float, float], arity=1, matrix_generator=gen_U)
         gate_set = default_gate_set()
         gate_set.add_signature(U)
         gate_set.add_signature(u1)
@@ -318,14 +398,25 @@
         }
         self.routines = []
         self.nbcbits = 0
         self.nbqbits = 0
         self.cregs = []
         self.qregs = []
 
+        # Register gate translation
+        for gate_name, gate_definition in (gates or {}).items():
+            # If gate is a string -> register alias
+            if isinstance(gate_definition, str):
+                self.standard_gates[gate_name] = gate_definition
+
+            # If gate is a myQLM gate -> register gate
+            else:
+                self.standard_gates[gate_name] = gate_definition.name
+                self.compiler.gate_set.add_signature(gate_definition)
+
     def add_creg(self, elem):
         self.cregs.append(elem)
         self.nbcbits += elem.index
         self.compiler.nbcbits += elem.index
 
     def add_qreg(self, elem):
         self.qregs.append(elem)
@@ -419,14 +510,73 @@
         # print(str(len(self.routines)))
         for i in self.routines:
             # print("name is "+name+" but we got "+i.name)
             if i.name == name:
                 return True
         return False
 
+    def build_gate(self, name, params):
+        """
+        Build a quantum gate using a name and a set of parameters
+
+        Args:
+            name (str): gate name
+            params
+
+        Returns:
+            GateAST
+        """
+        # Get number of parameters of the corresponding AST gate
+        try:
+            ast_gate_nb_params = self.compiler.gate_set[self.standard_gates[name]].nb_args
+        except UnknownGate:
+            sub_gate = self.standard_gates[name]
+            if sub_gate.startswith("C"):
+                sub_gate = sub_gate[1:]
+            if sub_gate.endswith("DG"):
+                sub_gate = sub_gate[:-2]
+            ast_gate_nb_params = self.compiler.gate_set[sub_gate].nb_args
+
+        # If gate is called with the right number of parameters
+        if len(params) == ast_gate_nb_params:
+            if self.standard_gates[name] == "SDG":
+                ast = GateAST("S", params)
+                return GateAST("DAG", ast)
+            if self.standard_gates[name] == "TDG":
+                ast = GateAST("T", params)
+                return GateAST("DAG", ast)
+            if self.standard_gates[name] == "CU1":
+                ast = GateAST("U1", params)
+                return GateAST("CTRL", ast)
+            if self.standard_gates[name] == "CU2":
+                ast = GateAST("U2", params)
+                return GateAST("CTRL", ast)
+            if self.standard_gates[name] == "CU3":
+                ast = GateAST("U3", params)
+                return GateAST("CTRL", ast)
+            if self.standard_gates[name] == "CRZ":
+                ast = GateAST("RZ", params)
+                return GateAST("CTRL", ast)
+            if self.standard_gates[name] == "CH":
+                ast = GateAST("H", params)
+                return GateAST("CTRL", ast)
+            if self.standard_gates[name] == "CSWAP":
+                ast = GateAST("SWAP", params)
+                return GateAST("CTRL", ast)
+
+            return GateAST(self.standard_gates[name], params)
+
+        # Invalid number of parameters
+        raise InvalidParameterNumber(
+            self.standard_gates[name],
+            ast_gate_nb_params,
+            params,
+            self.lineno,
+        )
+
     def build_routine(self, routine_name, args, params):
         """
             Apply routine on function call
         Args:
             routine's name to apply
             routine's arguments (bit list)
             routine's parameters
@@ -477,66 +627,41 @@
                     self.compiler.build_measure(args_index[0], args_index[1])
                 )
             elif instr.name == "reset":
                 res_routines.append(
                     self.compiler.build_reset(args_index[0], args_index[0])
                 )
             else:
-                if (
-                    self.standard_gates[instr.name] == "SDG"
-                    or self.standard_gates[instr.name] == "TDG"
-                    or self.standard_gates[instr.name] == "CU1"
-                    or self.standard_gates[instr.name] == "CU2"
-                    or self.standard_gates[instr.name] == "CU3"
-                    or self.standard_gates[instr.name] == "CH"
-                    or self.standard_gates[instr.name] == "CRZ"
-                    or self.standard_gates[instr.name] == "CSWAP"
-                    or len(params_index)
-                    == self.compiler.gate_set[self.standard_gates[instr.name]].nb_args
-                ):
-                    if self.standard_gates[instr.name] == "SDG":
-                        ast = GateAST("S", params_index)
-                        ast = GateAST("DAG", ast)
-                    elif self.standard_gates[instr.name] == "TDG":
-                        ast = GateAST("T", params_index)
-                        ast = GateAST("DAG", ast)
-                    elif self.standard_gates[instr.name] == "CU1":
-                        ast = GateAST("U1", params_index)
-                        ast = GateAST("CTRL", ast)
-                    elif self.standard_gates[instr.name] == "CU2":
-                        ast = GateAST("U2", params_index)
-                        ast = GateAST("CTRL", ast)
-                    elif self.standard_gates[instr.name] == "CU3":
-                        ast = GateAST("U3", params_index)
-                        ast = GateAST("CTRL", ast)
-                    elif self.standard_gates[instr.name] == "CRZ":
-                        ast = GateAST("RZ", params_index)
-                        ast = GateAST("CTRL", ast)
-                    elif self.standard_gates[instr.name] == "CH":
-                        ast = GateAST("H", params_index)
-                        ast = GateAST("CTRL", ast)
-                    elif self.standard_gates[instr.name] == "CSWAP":
-                        ast = GateAST("SWAP", params_index)
-                        ast = GateAST("CTRL", ast)
-                    else:
-                        ast = GateAST(self.standard_gates[instr.name], params_index)
-                    # We have mapped the corresponding value
-                    # for each qubit in the params_index array
-                    res_routines.append(self.compiler.build_op_by_ast(ast, args_index))
-                else:
-                    raise InvalidParameterNumber(
-                        self.standard_gates[instr.name],
-                        self.compiler.gate_set[self.standard_gates[instr.name]].nb_args,
-                        params_index,
-                        self.lineno,
-                    )
-        # print("building ")
-        # print(res_routines)
+                ast = self.build_gate(instr.name, params_index)
+                res_routines.append(self.compiler.build_op_by_ast(ast, args_index))
+
         return res_routines
 
+    def build_gate_or_routine(self, name, qbit_list, params) -> list:
+        """
+        Build a gate or a routine based on a name, a list of qubits and a set of
+        parameters
+
+        Args:
+            name (str): gate or routine name
+            qbit_list (list): list of qubits
+            params (list): list of parameters
+
+        Returns:
+            list: list of gates
+        """
+        if name in self.standard_gates:
+            ast = self.build_gate(name, params)
+            return [self.compiler.build_op_by_ast(ast, qbit_list)]
+
+        if self.is_routine(name, len(qbit_list), len(params)):
+            return self.build_routine(name, qbit_list, params)
+
+        raise NameError(f"No such gate or routine {name!r} (or wrong number of arguments)")
+
     # ---- Begin the PLY parser ----
 
     # -----------------------------------------
     #  mainprogram : FORMAT ';' program
     # -----------------------------------------
     def p_main(self, t):
         """
@@ -1087,15 +1212,15 @@
         gate_op : ID id_list ';'
                 | ID '(' ')' id_list ';'
                 | ID '(' exp_list ')' id_list ';'
         """
         t[0] = Gate()
         try:
             self.standard_gates[t[1]]
-        except:
+        except KeyError:
             if t[1] not in self.tokens:
                 # not recognized by name_gate
                 if not self.is_routine(
                     t[1], len(t[len(t) - 2]), 0 if len(t) < 7 else len(t[3])
                 ):
                     # print(" params : "+str(len(t[3]))+ " and args "+str(len(t[len(t)-2])))
                     raise ValueError("No such gate or routine " + t[1])
@@ -1236,16 +1361,14 @@
             | IF '(' ID MATCHES NNINTEGER ')' barrier
             | IF '(' ID MATCHES NNINTEGER ')' reset
             | IF '(' ID error
             | IF '(' ID MATCHES error
             | IF '(' ID MATCHES NNINTEGER error
             | IF error
         """
-        new_op = None  # For cythonization errors
-        new_ops = None
         if len(t) == 3:
             raise SyntaxError("Ill-formed IF statement. Perhaps a" + " missing '('?")
         if len(t) == 5:
             raise SyntaxError(
                 "Ill-formed IF statement.  Expected '==', " + "received '" + str(t[4])
             )
         if len(t) == 6:
@@ -1292,88 +1415,22 @@
             # TODO might be better to change IF into a unitary_op/measure/etc
             # TODO since IF needs to know whether to apply the gates or not
             for op in t[7]:
                 if op.name == "measure":
                     raise ImplementationError("Conditional measures are not supported")
                 elif op.name == "reset":
                     raise ImplementationError("Conditional resets are not supported")
-                elif op.name in self.standard_gates:
-                    # print("gate standard "+ self.standard_gates[op.name])
-                    if (
-                        self.standard_gates[op.name] == "SDG"
-                        or self.standard_gates[op.name] == "TDG"
-                        or self.standard_gates[op.name] == "CU1"
-                        or self.standard_gates[op.name] == "CU2"
-                        or self.standard_gates[op.name] == "CU3"
-                        or self.standard_gates[op.name] == "CH"
-                        or self.standard_gates[op.name] == "CRZ"
-                        or self.standard_gates[op.name] == "CSWAP"
-                        or len(op.params)
-                        == self.compiler.gate_set[self.standard_gates[op.name]].nb_args
-                    ):
-                        if self.standard_gates[op.name] == "SDG":
-                            ast = GateAST("S", op.params)
-                            ast = GateAST("DAG", ast)
-                        elif self.standard_gates[op.name] == "TDG":
-                            ast = GateAST("T", op.params)
-                            ast = GateAST("DAG", ast)
-                        elif self.standard_gates[op.name] == "CU1":
-                            ast = GateAST("U1", op.params)
-                            ast = GateAST("CTRL", ast)
-                        elif self.standard_gates[op.name] == "CU2":
-                            ast = GateAST("U2", op.params)
-                            ast = GateAST("CTRL", ast)
-                        elif self.standard_gates[op.name] == "CU3":
-                            ast = GateAST("U3", op.params)
-                            ast = GateAST("CTRL", ast)
-                        elif self.standard_gates[op.name] == "CH":
-                            ast = GateAST("H", op.params)
-                            ast = GateAST("CTRL", ast)
-                        elif self.standard_gates[op.name] == "CRZ":
-                            ast = GateAST("RZ", op.params)
-                            ast = GateAST("CTRL", ast)
-                        elif self.standard_gates[op.name] == "CSWAP":
-                            ast = GateAST("SWAP", op.params)
-                            ast = GateAST("CTRL", ast)
-                        else:
-                            ast = GateAST(self.standard_gates[op.name], op.params)
-                        new_op = self.compiler.build_op_by_ast(ast, op.qblist)
-                    else:
-                        raise InvalidParameterNumber(
-                            self.standard_gates[op.name],
-                            self.compiler.gate_set[
-                                self.standard_gates[op.name]
-                            ].nb_args,
-                            op.params,
-                            self.lineno,
-                        )
                 else:
-                    # print(">>>>>>>>We got a gate called "+op.name)
-                    # print("is it true though ? "+str(self.is_routine(op.name)))
-                    if self.is_routine(op.name, len(op.qblist), len(op.params)):
-                        new_ops = self.build_routine(op.name, op.qblist, op.params)
-                    else:
-                        raise NameError(
-                            "No such gate or routine, '"
-                            + op.name
-                            + "' or wrong number of arguments or "
-                            "parameters\nSupported Clifford gates"
-                            + " are :\nh, cx, ccx, x, y, z, s, "
-                            + "swap, cz'"
-                        )
-                if new_ops is not None:
+                    new_ops = self.build_gate_or_routine(op.name, op.qblist, op.params)
+
                     # print("IF routine gives " + str(len(new_ops)))
-                    for o in new_ops:
-                        o.type = OpType.CLASSICCTRL
-                        o.formula = formula
-                        self.compiler.ops.append(o)
-                else:
-                    new_op.type = OpType.CLASSICCTRL
-                    new_op.formula = formula
-                    self.compiler.ops.append(new_op)
+                    for op in new_ops:
+                        op.type = OpType.CLASSICCTRL
+                        op.formula = formula
+                        self.compiler.ops.append(op)
 
     # ----------------------------------------
     # These are all the things you can have outside of a gate declaration
     #        quantum_op : unitary_op
     #                   | opaque
     #                   | measure
     #                   | reset
@@ -1396,81 +1453,17 @@
         for gat in t[1]:
             if gat.name == "measure":
                 op = self.compiler.build_measure(gat.qblist[0], gat.qblist[1])
                 t[0].append(op)
             elif gat.name == "reset":
                 op = self.compiler.build_reset([gat.qblist[0]], [gat.qblist[0]])
                 t[0].append(op)
-            elif gat.name in self.standard_gates:
-                if (
-                    self.standard_gates[gat.name] == "SDG"
-                    or self.standard_gates[gat.name] == "TDG"
-                    or self.standard_gates[gat.name] == "CU1"
-                    or self.standard_gates[gat.name] == "CU2"
-                    or self.standard_gates[gat.name] == "CU3"
-                    or self.standard_gates[gat.name] == "CH"
-                    or self.standard_gates[gat.name] == "CRZ"
-                    or self.standard_gates[gat.name] == "CSWAP"
-                    or len(gat.params)
-                    == self.compiler.gate_set[self.standard_gates[gat.name]].nb_args
-                ):
-                    if self.standard_gates[gat.name] == "SDG":
-                        ast = GateAST("S", gat.params)
-                        ast = GateAST("DAG", ast)
-                    elif self.standard_gates[gat.name] == "TDG":
-                        ast = GateAST("T", gat.params)
-                        ast = GateAST("DAG", ast)
-                    elif self.standard_gates[gat.name] == "CU1":
-                        ast = GateAST("U1", gat.params)
-                        ast = GateAST("CTRL", ast)
-                    elif self.standard_gates[gat.name] == "CU2":
-                        ast = GateAST("U2", gat.params)
-                        ast = GateAST("CTRL", ast)
-                    elif self.standard_gates[gat.name] == "CU3":
-                        ast = GateAST("U3", gat.params)
-                        ast = GateAST("CTRL", ast)
-                    elif self.standard_gates[gat.name] == "CH":
-                        ast = GateAST("H", gat.params)
-                        ast = GateAST("CTRL", ast)
-                    elif self.standard_gates[gat.name] == "CRZ":
-                        ast = GateAST("RZ", gat.params)
-                        ast = GateAST("CTRL", ast)
-                    elif self.standard_gates[gat.name] == "CSWAP":
-                        ast = GateAST("SWAP", gat.params)
-                        ast = GateAST("CTRL", ast)
-                    else:
-                        ast = GateAST(self.standard_gates[gat.name], gat.params)
-                    op = self.compiler.build_op_by_ast(ast, gat.qblist)
-                    t[0].append(op)
-                else:
-                    raise InvalidParameterNumber(
-                        self.standard_gates[gat.name],
-                        self.compiler.gate_set[self.standard_gates[gat.name]].nb_args,
-                        gat.params,
-                        self.lineno,
-                    )
             else:
-                # print(">>>>>>>>We got a gate called "+gat.name)
-                # print("is it true though ? "+str(self.is_routine(gat.name)))
-                if self.is_routine(gat.name, len(gat.qblist), len(gat.params)):
-                    ops = self.build_routine(gat.name, gat.qblist, gat.params)
-                    # print("routine yields " + str(len(ops)) + " ops")
-                    t[0].extend(ops)
-                else:
-                    raise NameError(
-                        "No such gate or routine, '"
-                        + gat.name
-                        + "' or wrong number of arguments or "
-                        "parameters\nSupported Clifford gates"
-                        + " are :\nh, cx, ccx, x, y, z, s, "
-                        + "swap, cz'"
-                    )
-            # print("Quantum op has ")
-            # for o in t[0]:
-            # print(o)
+                ops = self.build_gate_or_routine(gat.name, gat.qblist, gat.params)
+                t[0].extend(ops)
 
     # ----------------------------------------
     # unary : NNINTEGER
     #       | REAL
     #       | PI
     #       | ID
     #       | '(' expression ')'
```

## qat/interop/pyquil/algorithms.py

```diff
@@ -172,15 +172,15 @@
 
     return deutsch_jozsa_circuit, computational_qubits
 
 
 def _construct_deutsch_jozsa_circuit(
     qubits, computational_qubits, ancillas, unitary_matrix
 ):
-    """ Builds the Deutsch-Jozsa circuit. Which can determine
+    r""" Builds the Deutsch-Jozsa circuit. Which can determine
         whether a function f mapping
         `\{0,1\}^n \to \{0,1\}` is constant or balanced,
         provided that it is one of them.
 
     Args:
         qubits: list of qubits
         computational_qubits: list of qubits whose results matter
```

## qat/interop/pyquil/providers.py

```diff
@@ -65,25 +65,25 @@
     """
 
     # Pyquil encodes measures in a matrix, where line i is the measures
     # for trial i, and column j contains the measurements for qubit j
 
     # Build a list of states
 
-    #FIXME only works with PyquilQPU generated results right now!
-    #FIXME should work with native pyquil results also
+    # FIXME only works with PyquilQPU generated results right now!
+    # FIXME should work with native pyquil results also
     for register_result in pyquil_result.readout_data.values():
         nbshots = len(register_result)
         measurements = [
             sum([b << i for i, b in enumerate(entry)]) for entry in register_result
         ]
 
         counts = Counter(measurements)
         qlm_result = QlmRes()
-        #FIXME check that err is correct
+        # FIXME check that err is correct
         qlm_result.raw_data = [
             Sample(state=state,
                    probability=freq / nbshots,
                    err=np.sqrt(freq / nbshots * (1. - freq / nbshots) / (nbshots - 1))
                    if nbshots > 1 else None
                    )
             for state, freq in counts.items()
```

## qat/interop/qiskit/__init__.py

```diff
@@ -18,14 +18,17 @@
     KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations
     under the License.
 """
 
 from pkgutil import extend_path
 
-from .converters import qlm_to_qiskit, qiskit_to_qlm, U, U2, U3, \
-        RXX, RZZ, R, MS
-from .providers import QLMJob, QPUToBackend, BackendToQPU, \
-        QiskitJob, AsyncBackendToQPU, QiskitConnector
+from .converters import (
+    qlm_to_qiskit, qiskit_to_qlm, U, U2, U3, RXX, RZZ, R, MS
+)
+
+from .providers import (
+    QLMJob, QPUToBackend, BackendToQPU, QiskitJob, AsyncBackendToQPU, QiskitConnector
+)
 
 # Try to find other QAT packages in other folders
 __path__ = extend_path(__path__, __name__)
```

## qat/interop/qiskit/converters.py

```diff
@@ -129,38 +129,27 @@
                 arith_expr += arith_sub_expr
             elif isinstance(arg, Mul):
                 arith_expr *= arith_sub_expr
             elif isinstance(arg, Pow):
                 arith_expr **= arith_sub_expr
         return arith_expr
 
-    # if it is not an expression, but a single value, either abstract or not
+    # if it is not an expression, but a single value, which is a number
+    if arg.is_Number:
+        return float(arg)
+
+    # if it is not an expression, but a single value, which is abstract
     new_param_name = str(arg)
-    var = False
-    if isinstance(param, Parameter):
-        for x_param in param.expr.parameters:
+    if isinstance(param, (Parameter, ParameterExpression)):
+        for x_param in (param.expr if isinstance(param, Parameter) else param).parameters:
             if x_param.name == new_param_name:
                 # gets the variable or creates it
-                var = _qiskit_to_qlm_param(prog, variables, x_param)
-                break
-    elif isinstance(param, ParameterExpression):
-        for x_param in param.parameters:
-            if x_param.name == new_param_name:
-                # gets the variable or creates it
-                var = _qiskit_to_qlm_param(prog, variables, x_param)
-                break
+                return _qiskit_to_qlm_param(prog, variables, x_param)
 
-    # if the value is not abstract
-    if not var:
-        try:
-            var = float(new_param_name)
-        except ValueError as err:
-            string = "Unreliable variable expression in Qiskit Parameter"
-            raise KeyError(string) from err
-    return var
+    raise KeyError(f"Unreliable variable expression in Qiskit Parameter: {arg}")
 
 
 def _qiskit_to_qlm_param(prog, variables, param):
     """
     Converts a Qiskit Parameter or ParameterExpression into an object that can
     be passed as an argument to a QLM gate.
 
@@ -549,17 +538,19 @@
                 circuit translation
         variable: Variable object
         variable_name: String that is the name of a variable
 
     Returns:
         A Qiskit Parameter object
     """
-    if not(variable or variable_name):
-        raise Exception("_variable_to_parameter must either take a variable"
-                        + " or a variable_name argument")
+    if not (variable or variable_name):
+        raise AttributeError(
+            "_variable_to_parameter must either take a variable or a variable_name argument"
+        )
+
     param = None
     if variable_name:
         for x_param in param_list:
             if x_param.name == variable_name:
                 return x_param
         param = Parameter(variable_name)
         param_list.append(param)
```

## qat/interop/qiskit/providers.py

```diff
@@ -356,29 +356,29 @@
 
 
 class QPUToBackend(BackendV1):
     """
     Basic connector implementing a Qiskit Backend, plugable on a QLM QPU.
 
     Parameters:
-        qpu: :class:`~qat.core.qpu.QPUHandler` object
+        qpu: :class:`~qat.qpus.QPUHandler` object
         configuration: BackendConfiguration object, leave default value for
                 standard uses
         provider: Provider responsible for this backend
     """
 
     @classmethod
     def _default_options(cls):
         return Options(shots=0, qobj_id=str(uuid4()), qobj_header={},
                        parameter_binds={})
 
     def __init__(self, qpu=None, configuration=_QLM_BACKEND, provider=None):
         """
         Args:
-            qpu: :class:`~qat.core.qpu.QPUHandler` object
+            qpu: :class:`~qat.qpus.QPUHandler` object
             configuration: BackendConfiguration object, leave default value for
                     standard uses
             provider: Provider responsible for this backend
         """
         super().__init__(configuration, provider)
         self.id_counter = 0
         self._qpu = qpu
```

## qat/interop/qiskit/runtime.py

```diff
@@ -59,30 +59,81 @@
         # Save your credentials
         QiskitRuntimeService.save_account(channel="ibm_quantum", token=MY_IBM_TOKEN)
 """
 
 # Standard import
 import logging
 from math import sqrt
+from collections import namedtuple
 
 # Qiskit imports
 from qiskit.quantum_info import SparsePauliOp
-from qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Sampler
+from qiskit_ibm_runtime import QiskitRuntimeService, Session, Options, Estimator, Sampler
 
 # myQLM imports
 from qat.core import Result, BatchResult, Observable, Term
 from qat.core.qpu import QPUHandler
 from qat.comm.shared.ttypes import ProcessingType
 
 from .converters import job_to_qiskit_circuit
 
 MAX_SHOTS = 8096
 _LOGGER = logging.getLogger("qat.interop.qiskit.runtime")
 
 
+def _filter_sample_jobs(jobs_list: list):
+    """
+    Select SAMPLE and cast the jobs into a Qiksit object. This function returns
+    a tuple like objects composed of:
+     - a list of Qiskit circuit
+     - a list of integer (number of qubits of each circuit)
+     - a list of integer (index of the selected circuit in the original list)
+
+    Args:
+        jobs_list (list): list of myQLM
+
+    Returns:
+        namedtuple(["circuits", "nbqbits", "indices"]): Qiskit circuits and meta-data
+    """
+    qiskit_container = namedtuple("SampleCircuits", ["circuits", "nbqbits", "indices"])
+    qiskit_objects = [(job_to_qiskit_circuit(job), job.circuit.nbqbits, index)
+                      for index, job in enumerate(jobs_list) if job.type == ProcessingType.SAMPLE]
+
+    if qiskit_objects:
+        circuits, nbqbits, indices = zip(*qiskit_objects)
+        return qiskit_container(circuits, nbqbits, indices)
+
+    return qiskit_container(None, None, None)
+
+
+def _filter_observable_jobs(jobs_list: list):
+    """
+    Select OBSERVABLE and cast the jobs into a Qiksit object. This function returns
+    a tuple like objects composed of:
+     - a list of Qiskit circuit
+     - a list of Qiskit observable
+     - a list of integer (index of the selected circuit in the original list)
+
+    Args:
+        jobs_list (list): list of myQLM
+
+    Returns:
+        namedtuple(["circuits", "observables", "indices"]): Qiskit circuits and meta-data
+    """
+    qiskit_container = namedtuple("ObservablesCircuits", ["circuits", "observables", "indices"])
+    qiskit_objects = [(job_to_qiskit_circuit(job), _observable_to_qiskit(job.observable), index)
+                      for index, job in enumerate(jobs_list) if job.type == ProcessingType.OBSERVABLE]
+
+    if qiskit_objects:
+        circuits, observables, indices = zip(*qiskit_objects)
+        return qiskit_container(circuits, observables, indices)
+
+    return qiskit_container(None, None, None)
+
+
 def _parse_qiskit_sampling_result(qiskit_result: dict, list_nbqbits: list):
     """
     Parse Qiskit result (returned by Sampler). This function takes in argument
     the number of qubits composing each circuit
 
     Args:
         qiskit_result (dict): Qiskit result
@@ -99,15 +150,15 @@
     for samples, metadata, nbqbits in zip(qiskit_result.quasi_dists, qiskit_result.metadata, list_nbqbits):
         # Create result
         result = Result(lsb_first=True, nbqbits=nbqbits)
         result.meta_data = {"nbshots": str(metadata["shots"])}
 
         # Add sample
         for state, probability in samples.items():
-            result.add_sample(int(state, 2), probability=probability)
+            result.add_sample(state, probability=probability)
 
         # Yield result
         yield result
 
 
 def _parse_qiskit_observable_result(qiskit_result: dict):
     """
@@ -228,58 +279,51 @@
         Returns:
             list[qat.core.Result]: list of result
         """
         # Get number of shots
         nbshots = max((job.nbshots or MAX_SHOTS) for job in jobs_list)
 
         # Get circuits (SAMPLE and OBSERVABLE types are treated separatly) and observables
-        samp_circuits = [(job_to_qiskit_circuit(job), index) for index, job in enumerate(jobs_list)
-                         if job.type == ProcessingType.SAMPLE]
-        nbqbits = [job.circuit.nbqbits for job in jobs_list
-                   if job.type == ProcessingType.SAMPLE]
-
-        obs_circuits = [(job_to_qiskit_circuit(job), index) for index, job in enumerate(jobs_list)
-                        if job.type == ProcessingType.OBSERVABLE]
-        observables = [_observable_to_qiskit(job.observable) for job in jobs_list
-                       if job.type == ProcessingType.OBSERVABLE]
+        sample_container = _filter_sample_jobs(jobs_list)
+        sample_qiskit_job = None
+
+        observable_container = _filter_observable_jobs(jobs_list)
+        observable_qiskit_job = None
 
         # Create result list
         myqlm_results = [None] * len(jobs_list)
 
-        # Treat SAMPLE jobs
-        if samp_circuits:
-            # Get circuits and indexes
-            circuits, indexes = zip(*samp_circuits)
-
-            # Create sampler
-            with Sampler(circuits=circuits, skip_transpilation=self.skip_transpilation,
-                         service=self.service, options={"backend": self.backend}) as qpu:
-                # Send request to QPU
-                indices = [idx for idx, _ in enumerate(circuits)]
-                raw_result = qpu(circuit_indices=indices, shots=nbshots)
-
-            # Put each Qiskit result in the list of myQLM results
-            for index, parsed_result in zip(indexes, _parse_qiskit_sampling_result(raw_result, nbqbits)):
-                myqlm_results[index] = parsed_result
-
-        # Treat OBSERVABLE jobs
-        if obs_circuits:
-            # Get circuits and indexes
-            circuits, indexes = zip(*obs_circuits)
-
-            # Create estimator
-            with Estimator(circuits=circuits, observables=observables, skip_transpilation=self.skip_transpilation,
-                           service=self.service, options={"backend": self.backend}) as qpu:
-                # Send request to QPU
-                indices = [idx for idx, _ in enumerate(circuits)]
-                raw_result = qpu(circuit_indices=indices, observable_indices=indices, shots=nbshots)
-
-            # Put each Qiskit result in the list of myQLM results
-            for index, parsed_result in zip(indexes, _parse_qiskit_observable_result(raw_result)):
-                myqlm_results[index] = parsed_result
+        # Create Qiskit runtime session
+        with Session(service=self.service, backend=self.backend) as session:
+            # Execution options
+            options = Options()
+            options.execution.shots = nbshots
+            options.transpilation.skip_transpilation = self.skip_transpilation
+
+            # Submit SAMPLE and OBSERVABLE circuits
+            if sample_container.circuits:
+                qiskit_sampler = Sampler(session=session, options=options)
+                sample_qiskit_job = qiskit_sampler.run(circuits=sample_container.circuits)
+
+            if observable_container.circuits:
+                qiskit_estimator = Estimator(session=session, options=options)
+                observable_qiskit_job = qiskit_estimator.run(circuits=observable_container.circuits,
+                                                             observables=observable_container.observables)
+
+            # Get results
+            if sample_qiskit_job:
+                for index, parsed_result in zip(sample_container.indices, _parse_qiskit_sampling_result(sample_qiskit_job.result(), sample_container.nbqbits)):  # pylint: disable=line-too-long
+                    myqlm_results[index] = parsed_result
+
+            if observable_qiskit_job:
+                for index, parsed_result in zip(observable_container.indices, _parse_qiskit_observable_result(observable_qiskit_job.result())):  # pylint: disable=line-too-long
+                    myqlm_results[index] = parsed_result
+
+            # Close session
+            session.close()
 
         # Return list of myQLM results
         return myqlm_results
 
     def _submit_batch(self, batch):
         """
         Submits a batch to Qiskit runtime. This function use internally
```

## Comparing `myqlm_interop-1.7.1.data/scripts/oqasm2circ` & `myqlm_interop-1.9.1.data/scripts/oqasm2circ`

 * *Files identical despite different names*

## Comparing `myqlm_interop-1.7.1.dist-info/LICENSE` & `myqlm_interop-1.9.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `myqlm_interop-1.7.1.dist-info/METADATA` & `myqlm_interop-1.9.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: myqlm-interop
-Version: 1.7.1
+Version: 1.9.1
 Author: Atos Quantum Lab
 License: Atos myQLM EULA
 License-File: LICENSE
 License-File: NOTICE
 Requires-Dist: qat-lang (>=2.2.0)
 Requires-Dist: numpy
 Requires-Dist: ply
```

## Comparing `myqlm_interop-1.7.1.dist-info/RECORD` & `myqlm_interop-1.9.1.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-myqlm_interop-1.7.1.data/scripts/oqasm2circ,sha256=pO1Ju4E0u6jtp2Ri6hcvZ2OHu0g4rj3_O1tRIOsKQK0,3308
+myqlm_interop-1.9.1.data/scripts/oqasm2circ,sha256=pO1Ju4E0u6jtp2Ri6hcvZ2OHu0g4rj3_O1tRIOsKQK0,3308
 qat/interop/__init__.py,sha256=knxxFbTwJhumhQIGEdCQJ_5mi1MJbNtPD8wEBOTAno4,1412
 qat/interop/cirq/__init__.py,sha256=sbZt59GFHOPgjodUxIB36z1GzBXYD_xjtb8h6QFouIg,1042
 qat/interop/cirq/converters.py,sha256=9z0wxg10Q6iccLjMuNNE-8xi3Bph5khPRwtNwjEZn7E,19045
 qat/interop/cirq/providers.py,sha256=McvV5moOFVs4VjL4KAU97GPjLBNAQDUyJnBBUg5G3l8,3415
 qat/interop/openqasm/__init__.py,sha256=PQgkbuySpidJIIm0CNMPu4h9dSWKN1w2J4XypgrOoq0,855
 qat/interop/openqasm/oqasm_routine.py,sha256=GD1yCQ4iiCmsyNMv8zzZWFjCMFLvqUkrC3HgRYRjy6E,1553
-qat/interop/openqasm/qasm_lexer.py,sha256=8ULgjE3Nm3HUNONlzKl52Yc3QXb9pdJSIzkpA6WZ4V8,4747
-qat/interop/openqasm/qasm_parser.py,sha256=svPo6TT_rFDUAglFW9u6fhC5FTx2bHN3ygfU6o4KZ6M,57779
+qat/interop/openqasm/qasm_lexer.py,sha256=8ukGeJxFbmV909efHMJdpfzV4lbkzCmkaBXWcsSt3_s,4034
+qat/interop/openqasm/qasm_parser.py,sha256=Bxt6m9meRocqW11D-wBEk4u89Mkmv7keY61WvSVgQkc,54247
 qat/interop/projectq/__init__.py,sha256=W107SahW-Jh70NU9tJt1GXe_0s1_r19u9vZZjfxM2ow,1056
 qat/interop/projectq/converters.py,sha256=IUj3GDYPRsqK2UV5k1EnPCJF0NDOw-BUNFIlFC93XyY,8719
 qat/interop/pyquil/__init__.py,sha256=B8Hiql6-Ru3h_XkIi3eE0oZGXuIo6Ork-lf4Mdc0tDM,1228
-qat/interop/pyquil/algorithms.py,sha256=Kx7vbl6Ar1L-CD1W0E4tSP0pFTGl51Tg_41JHy_EBTE,11100
+qat/interop/pyquil/algorithms.py,sha256=lxRd4GVxr6tzLZQU0CKGEpE6NbPwBW6c0OW-B9cv7IU,11101
 qat/interop/pyquil/converters.py,sha256=WGqFfwIwKEIsl2K2rbCyg5x8Usufrg3DNwC9kYBKOqU,9621
-qat/interop/pyquil/providers.py,sha256=RS2PK76_ENxgy2_bhN1C35u_Z9mOcrMl09YGQSvL5O0,4591
-qat/interop/qiskit/__init__.py,sha256=ba8NDMDCVbN7T3r3eSfroubvECw8VAImJI3XE9d6a9w,1199
-qat/interop/qiskit/converters.py,sha256=9mhHdRgOusnTWH4wbmM9T2lfa5cWUvx5F8NktoWk-HU,25676
-qat/interop/qiskit/providers.py,sha256=NEjyXp9zQqID-wriIk3ltbKEsg6T8iPHhOr6BSwgpoY,30529
+qat/interop/pyquil/providers.py,sha256=zEEzaiScHPTffxyGuMc1xDkXgfYUYdp3A0mD0xeOLwE,4594
+qat/interop/qiskit/__init__.py,sha256=1Pzh-sW-Dzuh1_gRg90UdQEummSdLdIaW3YCcQIHwKQ,1196
+qat/interop/qiskit/converters.py,sha256=tJx376dUQwDPymkL6cJYa8h5MwBM7Iee0bgSCHVldlk,25355
+qat/interop/qiskit/providers.py,sha256=gzvOUHcKXcSxqmUlyFdtsgrgYiPKUu6ZjvUEXWPOGfs,30521
 qat/interop/qiskit/quantum_channels.py,sha256=C6PDho_zLEd3Weq1UoshMsj5xtxlDk2AunyUygYSDoY,6221
-qat/interop/qiskit/runtime.py,sha256=9vpqr9gXoq9kZotOOKencCeJquPvdzNsqxpZaXlahRQ,10603
-myqlm_interop-1.7.1.dist-info/LICENSE,sha256=V0jud3X0yASwWe9bl9ASbBx2hNtJg2sK9i1FBZOmp7Y,11340
-myqlm_interop-1.7.1.dist-info/METADATA,sha256=SNsWAO45NdiEIAQnzLklAJUACMuiLsGy8f91KzJtLVc,1393
-myqlm_interop-1.7.1.dist-info/NOTICE,sha256=-bWudyYM4mUZ9F50OinB-J_6M9BFU4y87JaKqk2RJbs,161
-myqlm_interop-1.7.1.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-myqlm_interop-1.7.1.dist-info/top_level.txt,sha256=EtiE-lzXpV6tDPK3leIRADd9p6cOal7g6fxvqQ-u_yc,4
-myqlm_interop-1.7.1.dist-info/RECORD,,
+qat/interop/qiskit/runtime.py,sha256=Z47NPOC0kiGLjqk7TFn4nHuDOdHw5zJdShye4UwedfA,12159
+myqlm_interop-1.9.1.dist-info/LICENSE,sha256=V0jud3X0yASwWe9bl9ASbBx2hNtJg2sK9i1FBZOmp7Y,11340
+myqlm_interop-1.9.1.dist-info/METADATA,sha256=GUxXu9QaZxP-0PID9e3apkO3N2KjWBe8bBTHGu_qXOs,1393
+myqlm_interop-1.9.1.dist-info/NOTICE,sha256=-bWudyYM4mUZ9F50OinB-J_6M9BFU4y87JaKqk2RJbs,161
+myqlm_interop-1.9.1.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
+myqlm_interop-1.9.1.dist-info/top_level.txt,sha256=EtiE-lzXpV6tDPK3leIRADd9p6cOal7g6fxvqQ-u_yc,4
+myqlm_interop-1.9.1.dist-info/RECORD,,
```

