# Comparing `tmp/myqlm_fermion-1.0.0-py3-none-any.whl.zip` & `tmp/myqlm_fermion-1.1.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,38 +1,38 @@
-Zip file size: 90029 bytes, number of entries: 36
--rw-r--r--  2.0 unx      357 b- defN 22-Nov-04 21:43 qat/fermion/__init__.py
--rw-r--r--  2.0 unx     5781 b- defN 22-Nov-04 21:43 qat/fermion/ansatz_generator.py
--rw-r--r--  2.0 unx    11031 b- defN 22-Nov-04 21:43 qat/fermion/circuits.py
--rw-r--r--  2.0 unx     7092 b- defN 22-Nov-04 21:43 qat/fermion/fermion_algebra.py
--rw-r--r--  2.0 unx      623 b- defN 22-Nov-04 21:43 qat/fermion/generator_tools.py
--rw-r--r--  2.0 unx    32385 b- defN 22-Nov-04 21:43 qat/fermion/hamiltonians.py
--rw-r--r--  2.0 unx    18981 b- defN 22-Nov-04 21:43 qat/fermion/matchgates.py
--rw-r--r--  2.0 unx     6962 b- defN 22-Nov-04 21:43 qat/fermion/observable_generator.py
--rw-r--r--  2.0 unx    15217 b- defN 22-Nov-04 21:43 qat/fermion/phase_estimation.py
--rw-r--r--  2.0 unx    11122 b- defN 22-Nov-04 21:43 qat/fermion/transforms.py
--rw-r--r--  2.0 unx    22685 b- defN 22-Nov-04 21:43 qat/fermion/trotterisation.py
--rw-r--r--  2.0 unx     8919 b- defN 22-Nov-04 21:43 qat/fermion/util.py
--rw-r--r--  2.0 unx     2510 b- defN 22-Nov-04 21:43 qat/fermion/vqe.py
--rw-r--r--  2.0 unx      425 b- defN 22-Nov-04 21:43 qat/fermion/chemistry/__init__.py
--rw-r--r--  2.0 unx     5099 b- defN 22-Nov-04 21:43 qat/fermion/chemistry/pyscf_tools.py
--rw-r--r--  2.0 unx     8678 b- defN 22-Nov-04 21:43 qat/fermion/chemistry/qse.py
--rw-r--r--  2.0 unx    30748 b- defN 22-Nov-04 21:43 qat/fermion/chemistry/ucc.py
--rw-r--r--  2.0 unx    27365 b- defN 22-Nov-04 21:43 qat/fermion/chemistry/ucc_deprecated.py
--rw-r--r--  2.0 unx    15863 b- defN 22-Nov-04 21:43 qat/fermion/chemistry/wrapper.py
--rw-r--r--  2.0 unx        0 b- defN 22-Nov-04 21:43 qat/fermion/naturalgradient/__init__.py
--rw-r--r--  2.0 unx    23172 b- defN 22-Nov-04 21:43 qat/fermion/naturalgradient/auto_derivatives.py
--rw-r--r--  2.0 unx     2408 b- defN 22-Nov-04 21:43 qat/fermion/naturalgradient/custom_gate_set.py
--rw-r--r--  2.0 unx      975 b- defN 22-Nov-04 21:43 qat/fermion/naturalgradient/expressions.py
--rw-r--r--  2.0 unx     9758 b- defN 22-Nov-04 21:43 qat/fermion/naturalgradient/qfim_plugin.py
--rw-r--r--  2.0 unx      254 b- defN 22-Nov-04 21:43 qat/generators/hook_vqe.py
--rw-r--r--  2.0 unx     7034 b- defN 22-Nov-04 21:43 qat/plugins/adapt_vqe.py
--rw-r--r--  2.0 unx      172 b- defN 22-Nov-04 21:43 qat/plugins/hook_natgrad_plugin.py
--rw-r--r--  2.0 unx     3104 b- defN 22-Nov-04 21:43 qat/plugins/multiple_launches_analyzer.py
--rw-r--r--  2.0 unx     4993 b- defN 22-Nov-04 21:43 qat/plugins/sequential_optimization.py
--rw-r--r--  2.0 unx     1999 b- defN 22-Nov-04 21:43 qat/plugins/transform_observable.py
--rw-r--r--  2.0 unx    10090 b- defN 22-Nov-04 21:43 qat/plugins/zero_noise_extrapolator.py
--rw-r--r--  2.0 unx    11340 b- defN 22-Nov-04 21:45 myqlm_fermion-1.0.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     1881 b- defN 22-Nov-04 21:45 myqlm_fermion-1.0.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Nov-04 21:45 myqlm_fermion-1.0.0.dist-info/WHEEL
--rw-r--r--  2.0 unx        4 b- defN 22-Nov-04 21:45 myqlm_fermion-1.0.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3179 b- defN 22-Nov-04 21:45 myqlm_fermion-1.0.0.dist-info/RECORD
-36 files, 312298 bytes uncompressed, 84905 bytes compressed:  72.8%
+Zip file size: 90478 bytes, number of entries: 36
+-rw-r--r--  2.0 unx      357 b- defN 23-Jul-31 22:54 qat/fermion/__init__.py
+-rw-r--r--  2.0 unx     5781 b- defN 23-Jul-31 22:54 qat/fermion/ansatz_generator.py
+-rw-r--r--  2.0 unx    11031 b- defN 23-Jul-31 22:54 qat/fermion/circuits.py
+-rw-r--r--  2.0 unx     7092 b- defN 23-Jul-31 22:54 qat/fermion/fermion_algebra.py
+-rw-r--r--  2.0 unx      623 b- defN 23-Jul-31 22:54 qat/fermion/generator_tools.py
+-rw-r--r--  2.0 unx    31710 b- defN 23-Jul-31 22:54 qat/fermion/hamiltonians.py
+-rw-r--r--  2.0 unx    18981 b- defN 23-Jul-31 22:54 qat/fermion/matchgates.py
+-rw-r--r--  2.0 unx     6962 b- defN 23-Jul-31 22:54 qat/fermion/observable_generator.py
+-rw-r--r--  2.0 unx    15216 b- defN 23-Jul-31 22:54 qat/fermion/phase_estimation.py
+-rw-r--r--  2.0 unx    10916 b- defN 23-Jul-31 22:54 qat/fermion/transforms.py
+-rw-r--r--  2.0 unx    22685 b- defN 23-Jul-31 22:54 qat/fermion/trotterisation.py
+-rw-r--r--  2.0 unx     8919 b- defN 23-Jul-31 22:54 qat/fermion/util.py
+-rw-r--r--  2.0 unx     2510 b- defN 23-Jul-31 22:54 qat/fermion/vqe.py
+-rw-r--r--  2.0 unx      425 b- defN 23-Jul-31 22:54 qat/fermion/chemistry/__init__.py
+-rw-r--r--  2.0 unx     5099 b- defN 23-Jul-31 22:54 qat/fermion/chemistry/pyscf_tools.py
+-rw-r--r--  2.0 unx     8678 b- defN 23-Jul-31 22:54 qat/fermion/chemistry/qse.py
+-rw-r--r--  2.0 unx    30800 b- defN 23-Jul-31 22:54 qat/fermion/chemistry/ucc.py
+-rw-r--r--  2.0 unx    27361 b- defN 23-Jul-31 22:54 qat/fermion/chemistry/ucc_deprecated.py
+-rw-r--r--  2.0 unx    15832 b- defN 23-Jul-31 22:54 qat/fermion/chemistry/wrapper.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-31 22:54 qat/fermion/naturalgradient/__init__.py
+-rw-r--r--  2.0 unx    23172 b- defN 23-Jul-31 22:54 qat/fermion/naturalgradient/auto_derivatives.py
+-rw-r--r--  2.0 unx     2408 b- defN 23-Jul-31 22:54 qat/fermion/naturalgradient/custom_gate_set.py
+-rw-r--r--  2.0 unx      975 b- defN 23-Jul-31 22:54 qat/fermion/naturalgradient/expressions.py
+-rw-r--r--  2.0 unx     9713 b- defN 23-Jul-31 22:54 qat/fermion/naturalgradient/qfim_plugin.py
+-rw-r--r--  2.0 unx      254 b- defN 23-Jul-31 22:54 qat/generators/hook_vqe.py
+-rw-r--r--  2.0 unx     8955 b- defN 23-Jul-31 22:54 qat/plugins/adapt_vqe.py
+-rw-r--r--  2.0 unx      172 b- defN 23-Jul-31 22:54 qat/plugins/hook_natgrad_plugin.py
+-rw-r--r--  2.0 unx     3104 b- defN 23-Jul-31 22:54 qat/plugins/multiple_launches_analyzer.py
+-rw-r--r--  2.0 unx     4993 b- defN 23-Jul-31 22:54 qat/plugins/sequential_optimization.py
+-rw-r--r--  2.0 unx     2024 b- defN 23-Jul-31 22:54 qat/plugins/transform_observable.py
+-rw-r--r--  2.0 unx    10090 b- defN 23-Jul-31 22:54 qat/plugins/zero_noise_extrapolator.py
+-rw-r--r--  2.0 unx    11340 b- defN 23-Jul-31 22:56 myqlm_fermion-1.1.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1859 b- defN 23-Jul-31 22:56 myqlm_fermion-1.1.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-31 22:56 myqlm_fermion-1.1.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        4 b- defN 23-Jul-31 22:56 myqlm_fermion-1.1.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3179 b- defN 23-Jul-31 22:56 myqlm_fermion-1.1.0.dist-info/RECORD
+36 files, 313312 bytes uncompressed, 85354 bytes compressed:  72.8%
```

## zipnote {}

```diff
@@ -87,23 +87,23 @@
 
 Filename: qat/plugins/transform_observable.py
 Comment: 
 
 Filename: qat/plugins/zero_noise_extrapolator.py
 Comment: 
 
-Filename: myqlm_fermion-1.0.0.dist-info/LICENSE
+Filename: myqlm_fermion-1.1.0.dist-info/LICENSE
 Comment: 
 
-Filename: myqlm_fermion-1.0.0.dist-info/METADATA
+Filename: myqlm_fermion-1.1.0.dist-info/METADATA
 Comment: 
 
-Filename: myqlm_fermion-1.0.0.dist-info/WHEEL
+Filename: myqlm_fermion-1.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: myqlm_fermion-1.0.0.dist-info/top_level.txt
+Filename: myqlm_fermion-1.1.0.dist-info/top_level.txt
 Comment: 
 
-Filename: myqlm_fermion-1.0.0.dist-info/RECORD
+Filename: myqlm_fermion-1.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## qat/fermion/hamiltonians.py

```diff
@@ -21,14 +21,49 @@
     "X": [[0, 1], [1, 0]],
     "I": [[1, 0], [0, 1]],
     "Y": [[0, -1j], [1j, 0]],
     "Z": [[1, 0], [0, -1]],
 }
 
 
+def _transform_to_normal_order(terms, nbqbits):
+    """
+    Transform fermionic terms of a FermionHamiltonian to normally ordered fermionic terms.
+    """
+
+    # Initialize empty hamiltonian
+    ordered_hamiltonian = FermionHamiltonian(nbqbits, terms=[])
+
+    # Add ordered terms to Hamiltonian
+    for term in terms:
+        new_term = normal_order_fermionic_term(term)
+
+        for element in new_term:
+
+            if new_term:
+                ordered_hamiltonian += FermionHamiltonian(nbqbits, terms=[element], normal_order=False)
+
+    return ordered_hamiltonian.terms
+
+
+def _preprocess_terms(terms, nbqbits, normal_order):
+    """Preprocess input terms into FermionicTerms with or without normal ordering.
+
+    Args:
+        terms (List[Term]): List of fermionic terms.
+        nbqbits (int): Number of qbits of the hamiltonian which terms are being processed
+        normal_order (bool): If the FermionicTerms sould be normally ordered.
+    """
+    # Converts to FermionicTerm if needed
+    terms = terms if isinstance(terms[0], FermionicTerm) else [FermionicTerm.from_term(term) for term in terms]
+
+    # Ensure normal ordering of the fermionic terms
+    return _transform_to_normal_order(terms, nbqbits) if normal_order else terms
+
+
 class SpinHamiltonian(Observable):
     r"""
     Implementation of a spin Hamiltonian.
 
     Args:
         nqbits (int): the total number of qubits
         terms (List[Term]): the list of terms
@@ -55,53 +90,50 @@
     """
 
     def __init__(
         self,
         nqbits: int,
         terms: List[Term],
         constant_coeff: float = 0.0,
-        do_clean_up: bool = True,
     ):
 
         self.matrix = None
-        self.do_clean_up = do_clean_up
 
         super(SpinHamiltonian, self).__init__(
             nqbits,
             pauli_terms=terms,
             constant_coeff=constant_coeff,
-            do_clean_up=do_clean_up,
         )
 
         # Fast consistency check on the first term inputted.
         self._fast_consistency_check()
 
     def __add__(self, other):
         res = super().__add__(other)
-        return SpinHamiltonian(res.nbqbits, res.terms, res.constant_coeff, do_clean_up=self.do_clean_up)
+        return SpinHamiltonian(res.nbqbits, res.terms, res.constant_coeff)
 
     def __radd__(self, other):
         res = super().__radd__(other)
-        return SpinHamiltonian(res.nbqbits, res.terms, res.constant_coeff, do_clean_up=self.do_clean_up)
+        return SpinHamiltonian(res.nbqbits, res.terms, res.constant_coeff)
 
     def __sub__(self, other):
         res = super().__sub__(other)
-        return SpinHamiltonian(res.nbqbits, res.terms, res.constant_coeff, do_clean_up=self.do_clean_up)
+        return SpinHamiltonian(res.nbqbits, res.terms, res.constant_coeff)
 
     def __rsub__(self, other):
         res = super().__rsub__(other)
-        return SpinHamiltonian(res.nbqbits, res.terms, res.constant_coeff, do_clean_up=self.do_clean_up)
+        return SpinHamiltonian(res.nbqbits, res.terms, res.constant_coeff)
 
     def __mul__(self, other):
         res = super().__mul__(other)
-        return SpinHamiltonian(res.nbqbits, res.terms, res.constant_coeff, do_clean_up=self.do_clean_up)
+        return SpinHamiltonian(res.nbqbits, res.terms, res.constant_coeff)
 
     def __rmul__(self, other):
         res = super().__rmul__(other)
-        return SpinHamiltonian(res.nbqbits, res.terms, res.constant_coeff, do_clean_up=self.do_clean_up)
+        return SpinHamiltonian(res.nbqbits, res.terms, res.constant_coeff)
 
     def __or__(self, other):
         return self * other - other * self
 
     def _fast_consistency_check(self):
         """
         Assert that the first term inputted does not contain fermionic operators.
@@ -122,15 +154,14 @@
 
         """
 
         return SpinHamiltonian(
             self.nbqbits,
             [Term(np.conj(term.coeff), term.op, term.qbits) for term in self.terms],
             np.conj(self.constant_coeff),
-            do_clean_up=self.do_clean_up,
         )
 
     def get_matrix(self, sparse: bool = False) -> np.ndarray:
         r"""
         This function returns the matrix corresponding to :math:`H` in the computational basis.
 
         Args:
@@ -176,25 +207,25 @@
 
         final_matrix += self.constant_coeff * id_type(2**self.nbqbits)
         self.matrix = final_matrix
 
         return final_matrix
 
     @staticmethod
-    def _make_spin_op(op: str, qb: int, nqbits: int, sparse: bool) -> Union[np.ndarray, sp.bsr.bsr_matrix]:
+    def _make_spin_op(op: str, qb: int, nqbits: int, sparse: bool) -> Union[np.ndarray, sp.bsr_matrix]:
         """Build spin operator.
 
         Args:
             op (str): Pauli string.
             qb (int): Target qubit.
             nqbits (int): Number of qubits.
             sparse (bool): If a sparse matrix should be returned.
 
         Returns:
-            Union[np.ndarray, sp.bsr.bsr_matrix]: Matrix of the spin operator.
+            Union[np.ndarray, sp.bsr_matrix]: Matrix of the spin operator.
         """
 
         id_type = sp.identity if sparse else np.identity
         m_type = sp.csr_matrix if sparse else np.array
         kron_op = sp.kron if sparse else np.kron
 
         if qb == 0:
@@ -231,24 +262,23 @@
     r"""
     Implementation of a fermionic Hamiltonian.
 
     Args:
         nqbits (int): The total number of qubits
         terms (List[Term]): The list of terms
         constant_coeff (float): Constant term
-        do_clean_up (bool, optional): If the terms should be simplified. Default to True.
         normal_order (bool, optional): If the fermionic terms should be normal (or Wick) ordered. Default to True. True is
             recommended always.
 
     Attributes:
         nbqbits (int): The total number of qubits
         terms (List[Term]): The list of terms
         constant_coeff (float): Constant term.
         matrix (np.ndarray): The corresponding matrix (None by default, can be set by calling get_matrix method).
-        normal_order (bool): If the fermionic terms should be normal (or Wick) ordered. 
+        normal_order (bool): If the fermionic terms should be normal (or Wick) ordered.
 
     Note:
         Fermionic Hamiltonians are by default automatically normally ordered.
 
     Example:
 
         .. run-block:: python
@@ -263,110 +293,76 @@
     """
 
     def __init__(
         self,
         nqbits: int,
         terms: List[Term],
         constant_coeff: float = 0.0,
-        do_clean_up: bool = True,
         normal_order: bool = True,
     ):
 
         self.matrix = None
-        self.do_clean_up = do_clean_up
-        self.terms = terms or []
+
+        if terms:
+            terms = _preprocess_terms(terms, nqbits, normal_order)
 
         super().__init__(
             nqbits,
             pauli_terms=terms,
             constant_coeff=constant_coeff,
-            do_clean_up=do_clean_up,
         )
 
-        if self.terms:
-            self._preprocess_terms(terms, normal_order)
-
     def copy(self):
         """Deepcopy the current class.
 
         Returns:
             :class:`~qat.fermion.hamiltonians.FermionHamiltonian`: Copy of the FermionHamiltonian.
         """
         return deepcopy(self)
 
-    def transform_to_normal_order(self):
-        """
-        Transform fermionic terms of a FermionHamiltonian to normally ordered fermionic terms.
-        """
-
-        # Initialize empty hamiltonian
-        ordered_hamiltonian = FermionHamiltonian(self.nbqbits, terms=[])
-
-        # Add ordered terms to Hamiltonian
-        for term in self.terms:
-            new_term = normal_order_fermionic_term(term)
-
-            for element in new_term:
-
-                if new_term:
-                    ordered_hamiltonian += FermionHamiltonian(self.nbqbits, terms=[element], normal_order=False)
-
-        self.terms = ordered_hamiltonian.terms
-
-    def _preprocess_terms(self, terms, normal_order):
-        """Preprocess input terms into FermionicTerms with or without normal ordering.
-
-        Args:
-            terms (List[Term]): List of fermionic terms.
-            normal_order (bool): If the FermionicTerms sould be normally ordered.
-        """
-        # Converts to FermionicTerm if needed
-        self.terms = terms if isinstance(terms[0], FermionicTerm) else [FermionicTerm.from_term(term) for term in terms]
-
-        # Ensure normal ordering of the fermionic terms
-        if normal_order:
-            self.transform_to_normal_order()
-
     def __add__(self, other):
         res = super().__add__(other)
-        return FermionHamiltonian(res.nbqbits, res.terms, res.constant_coeff, do_clean_up=self.do_clean_up)
+        return FermionHamiltonian(res.nbqbits, res.terms, res.constant_coeff)
 
     def __radd__(self, other):
         res = super().__radd__(other)
-        return FermionHamiltonian(res.nbqbits, res.terms, res.constant_coeff, do_clean_up=self.do_clean_up)
+        return FermionHamiltonian(res.nbqbits, res.terms, res.constant_coeff)
 
     def __sub__(self, other):
         res = super().__sub__(other)
-        return FermionHamiltonian(res.nbqbits, res.terms, res.constant_coeff, do_clean_up=self.do_clean_up)
+        return FermionHamiltonian(res.nbqbits, res.terms, res.constant_coeff)
 
     def __rsub__(self, other):
         res = super().__rsub__(other)
-        return FermionHamiltonian(res.nbqbits, res.terms, res.constant_coeff, do_clean_up=self.do_clean_up)
+        return FermionHamiltonian(res.nbqbits, res.terms, res.constant_coeff)
 
     def __mul__(self, other):
         if isinstance(other, (Number, BaseArithmetic)):
+            # double deepcopy of the terms, could be reduced to one by creating a new observable instead
+            # of copying the existing one
             new_ham = self.copy()
-            for i, _ in enumerate(new_ham.terms):
-                new_ham.terms[i].coeff *= other
+            terms = [*map(deepcopy, self.terms)]
+            for term in terms:
+                term.coeff *= other
+            new_ham.set_terms(terms)
             new_ham.constant_coeff *= other
             return new_ham
 
         term_list = []
         for term in self.terms:
             term_list.append(FermionicTerm(term.coeff * other.constant_coeff, term.op, term.qbits))
 
         for term in other.terms:
             # pylint: disable=E1101
             term_list.append(FermionicTerm(self.constant_coeff * term.coeff, term.op, term.qbits))
 
         for term1, term2 in itertools.product(self.terms, other.terms):
-            term_list.append(term1 * term2)
+            term_list.append(term1._term * term2._term)
 
-        fermionic_hamiltonian = FermionHamiltonian(self.nbqbits, terms=term_list, do_clean_up=self.do_clean_up, normal_order=True)
-        fermionic_hamiltonian.clean_up()
+        fermionic_hamiltonian = FermionHamiltonian(self.nbqbits, terms=term_list, normal_order=True)
 
         return fermionic_hamiltonian
 
     def __or__(self, other):
         return self * other - other * self
 
     def __rmul__(self, other):
@@ -496,15 +492,15 @@
                 for no_term in no_terms:
                     _fill_tensors(no_term)
 
             else:
                 term = order_qubits(term)
                 _fill_tensors(term)
 
-        return ElectronicStructureHamiltonian(hpq, hpqrs, do_clean_up=self.do_clean_up)
+        return ElectronicStructureHamiltonian(hpq, hpqrs)
 
 
 class ElectronicStructureHamiltonian(FermionHamiltonian):
     r"""
     A container for the electronic-structure Hamiltonian, defined as
 
     .. math::
@@ -545,27 +541,25 @@
     TOL = 1e-12
 
     def __init__(
         self,
         hpq: np.ndarray,
         hpqrs: np.ndarray = None,
         constant_coeff: float = 0.0,
-        do_clean_up: bool = True,
     ):
 
         if hpqrs is None:
             hpqrs = np.zeros((hpq.shape[0], hpq.shape[0], hpq.shape[0], hpq.shape[0]))
 
         self._hpq = hpq
         self._hpqrs = hpqrs
-        self.do_clean_up = do_clean_up
 
         terms = self._get_fermionic_terms()
 
-        super(ElectronicStructureHamiltonian, self).__init__(self._hpq.shape[0], terms, constant_coeff, do_clean_up=do_clean_up)
+        super(ElectronicStructureHamiltonian, self).__init__(self._hpq.shape[0], terms, constant_coeff)
         
     @property
     def hpq(self):
         """hpq getter.
 
         Returns:
             np.ndarray: hpq matrix
@@ -576,15 +570,15 @@
     def hpq(self, value):
         """
         hpq setter.
         """
         self._hpq = value
         terms = self._get_fermionic_terms()
         # pylint: disable=E1101
-        super(ElectronicStructureHamiltonian, self).__init__(self._hpq.shape[0], terms, self.constant_coeff, do_clean_up=self.do_clean_up)
+        super(ElectronicStructureHamiltonian, self).__init__(self._hpq.shape[0], terms, self.constant_coeff)
 
     @property
     def hpqrs(self):
         """hpqs getter.
 
         Returns:
             np.ndarray: hpqrs matrix
@@ -595,15 +589,15 @@
     def hpqrs(self, value):
         """
         hpqrs getter.
         """
         self._hpqrs = value
         terms = self._get_fermionic_terms()
         # pylint: disable=E1101
-        super(ElectronicStructureHamiltonian, self).__init__(self._hpq.shape[0], terms, self.constant_coeff, do_clean_up=self.do_clean_up)
+        super(ElectronicStructureHamiltonian, self).__init__(self._hpq.shape[0], terms, self.constant_coeff)
 
     def dag(self) -> "ElectronicStructureHamiltonian":
         """Compute the conjugate transpose of the Hamiltonian.
 
         Returns:
             ElectronicStructureHamiltonian: Conjugate transpose of the Hamiltonian.
 
@@ -622,15 +616,14 @@
     def __add__(self, other):
 
         # pylint: disable=E1101
         return ElectronicStructureHamiltonian(
             self.hpq + other.hpq,
             self.hpqrs + other.hpqrs,
             self.constant_coeff + other.constant_coeff,
-            do_clean_up=self.do_clean_up,
         )
 
     def _get_fermionic_terms(self) -> List[Term]:
         """Get the FermionicHamiltonian terms from current ElectronicStructureHamiltonian.
 
         Returns:
             terms (List[Term]): Fermionic terms of the ElectronicStructureHamiltonian
@@ -660,15 +653,15 @@
         Returns:
             FermionHamiltonian: Fermionic Hamiltonian.
         """
 
         terms = self._get_fermionic_terms()
 
         # pylint: disable=E1101
-        return FermionHamiltonian(self.hpq.shape[0], terms, self.constant_coeff, do_clean_up=self.do_clean_up)
+        return FermionHamiltonian(self.hpq.shape[0], terms, self.constant_coeff)
 
 
 def make_anderson_model(u: float, mu: float, v: np.ndarray, epsilon: np.ndarray) -> ElectronicStructureHamiltonian:
     r"""
     Returns the canonical second quantized form
 
     .. math::
@@ -878,20 +871,21 @@
     return idx_spins_ord
 
 
 def make_hubbard_model(t_mat: np.ndarray, U: float, mu: float) -> ElectronicStructureHamiltonian:
     r"""Constructs Hubbard model
 
     .. math::
-        H = \sum_{ij,\sigma} t_{ij} c^\dagger_i c_j + U \sum_i n_{i\uparrow} n_{i \downarrow} - \mu \sum_i n_i
+        H = \sum_{ij,\sigma} (t_{ij} -  mu \delta_{ij}) c^\dagger_i c_j + U \sum_i n_{i\uparrow} n_{i \downarrow} 
 
     Args:
-        t_mat (np.ndarray): Hopping matrix (n_sites x n_sites).
+        t_mat (np.ndarray): Hopping matrix (n_sites x n_sites). t_mat may have diagonal terms contributing 
+                            to the chemical potential on each site.
         U (float): Hubbard U.
-        mu (float): Chemical potential.
+        mu (float): Reference chemical potential.
 
     Returns:
         ElectronicStructureHamiltonian: The Hubbard Hamiltonian.
 
     Notes:
         Spin-orbital labeling convention: :math:`i \equiv (k, \sigma) = 2 k + \sigma`
         with :math:`i`: site index and :math:`\sigma`: spin index.
@@ -905,15 +899,15 @@
 
         for sig in [0, 1]:
             hpq[2 * i + sig, 2 * j + sig] = t_mat[i, j]
 
     for i in range(t_mat.shape[0]):
 
         for sig in [0, 1]:
-            hpq[2 * i + sig, 2 * i + sig] = -mu
+            hpq[2 * i + sig, 2 * i + sig] += -mu
 
     hpqrs = np.zeros((nqbit, nqbit, nqbit, nqbit))
 
     for i in range(t_mat.shape[0]):
 
         for sig in [0, 1]:
```

## qat/fermion/phase_estimation.py

```diff
@@ -89,15 +89,15 @@
             - Energy found,
             - associated probability.
 
     Note:
         Usually, energies lie outside the range :math:`(-\frac{2\pi}{t}, 0)`. However, this range can be adjusted
         by specifying the arguments `E_target` and `size_interval` thus searching inside the window
         :math:`(E_{t} - \frac{\Delta}{2}, E_{target} + \frac{size\_interval}{2})`,
-        where :math:`E_{t}` and :math:`\Delta` stand for . We suggest to always start from a large size interval
+        where :math:`E_{t}` and :math:`\Delta` stand for. We suggest to always start from a large size interval
         and unbiased target energy like 0 thus enclosing many of the eigenenergies including the desired one.
         One can then narrow the window around an already found eigenenergy for a better precision.
         Experience shows that working with a window not enclosing an eigenenergy makes the QPE still output a result,
         but it is misleading.
 
     """
```

## qat/fermion/transforms.py

```diff
@@ -103,15 +103,15 @@
 
         print(f"H = {hamiltonian} \n")
         print(f"H(spin) = {spin_hamiltonian}")
 
     """
 
     nqbits = fermion_hamiltonian.nbqbits
-    spin_hamiltonian = SpinHamiltonian(nqbits, [], constant_coeff=fermion_hamiltonian.constant_coeff, do_clean_up=False)
+    spin_hamiltonian = SpinHamiltonian(nqbits, [], constant_coeff=fermion_hamiltonian.constant_coeff)
 
     for term in fermion_hamiltonian.terms:
 
         cur_ham = SpinHamiltonian(nqbits, [], constant_coeff=term.coeff)
 
         for op, qb in zip(term.op, term.qbits):
 
@@ -125,16 +125,14 @@
             sign = -1 if op == "C" else 1
             mini_ham.add_term(Term(1j * sign * 0.5, st, qbits))
 
             cur_ham = cur_ham * mini_ham
 
         spin_hamiltonian += cur_ham
 
-    spin_hamiltonian.clean_up()
-
     return spin_hamiltonian
 
 
 def transform_to_parity_basis(fermion_hamiltonian: Union[FermionHamiltonian, ElectronicStructureHamiltonian]) -> SpinHamiltonian:
     r"""Transform to parity basis.
 
     Args:
@@ -158,15 +156,15 @@
 
         print(f"H = {hamiltonian} \n")
         print(f"H(spin) = {spin_hamiltonian}")
 
     """
 
     nqbits = fermion_hamiltonian.nbqbits
-    spin_hamiltonian = SpinHamiltonian(nqbits, [], constant_coeff=fermion_hamiltonian.constant_coeff, do_clean_up=False)
+    spin_hamiltonian = SpinHamiltonian(nqbits, [], constant_coeff=fermion_hamiltonian.constant_coeff)
 
     for term in fermion_hamiltonian.terms:
 
         cur_ham = SpinHamiltonian(nqbits, [Term(term.coeff, "I" * nqbits, list(range(nqbits)))])
 
         for op, qb in zip(term.op, term.qbits):
 
@@ -180,16 +178,14 @@
             st = "Y" + "X" * (nqbits - qb - 1)
             mini_ham.add_term(Term(1j * sign * 0.5, st, qbits))
 
             cur_ham = cur_ham * mini_ham
 
         spin_hamiltonian += cur_ham
 
-    spin_hamiltonian.clean_up()
-
     return spin_hamiltonian
 
 
 def transform_to_bk_basis(fermion_hamiltonian: Union[FermionHamiltonian, ElectronicStructureHamiltonian]) -> SpinHamiltonian:
     r"""Transform to Bravyi-Kitaev (BK) basis.
 
     Args:
@@ -215,28 +211,27 @@
         print(f"H(spin) = {spin_hamiltonian}")
 
     """
 
     nqbits = fermion_hamiltonian.nbqbits
     pcu_sets = make_PCU_sets(nqbits)
 
-    spin_hamiltonian = SpinHamiltonian(nqbits, [], constant_coeff=fermion_hamiltonian.constant_coeff, do_clean_up=False)
+    spin_hamiltonian = SpinHamiltonian(nqbits, [], constant_coeff=fermion_hamiltonian.constant_coeff)
 
     for term in fermion_hamiltonian.terms:
 
         cur_ham = SpinHamiltonian(
             nqbits,
             [Term(term.coeff, "I" * nqbits, list(range(nqbits)))],
-            do_clean_up=False,
         )
 
         for op, qb in zip(term.op, term.qbits):
 
             sign = -1 if op == "C" else 1
-            mini_ham = SpinHamiltonian(nqbits, [], do_clean_up=False)
+            mini_ham = SpinHamiltonian(nqbits, [])
             p_set, c_set, u_set = pcu_sets[qb]
 
             qbits = []
 
             st = "Z" * len(p_set)
             qbits.extend([ind for ind in p_set])
             st += "X"
@@ -255,16 +250,14 @@
             qbits.extend([ind for ind in u_set])
             mini_ham.add_term(Term(1j * sign * 0.5, st, qbits))
 
             cur_ham = cur_ham * mini_ham
 
         spin_hamiltonian += cur_ham
 
-    spin_hamiltonian.clean_up()
-
     return spin_hamiltonian
 
 
 def get_jw_code(nbits: int) -> np.ndarray:
     r"""Construct Jordan-Wigner code matrix :math:`C`.
 
     i.e matrix :math:`C` to get new bit value :math:`p_i` from bit values :math:`f_j`
```

## qat/fermion/chemistry/ucc.py

```diff
@@ -227,34 +227,31 @@
     two_body_coefficients = _two_body_integrals_to_h(two_body_integrals)
 
     return one_body_coefficients, two_body_coefficients
 
 
 def _build_cluster_operator(l_ex_op: List[Tuple[int]], nqbits: int) -> List[FermionHamiltonian]:
     r"""
-    Builds the cluster operator and reduces the trial
-    parametrization to match the selected excitation operators.
+    Builds the cluster operator with selected excitation operators.
 
     The UCCSD cluster operator :math:`T` is defined (in normal-ordered form) as:
 
     .. math::
 
         T(\theta) = \sum_{a, i} \theta_a^i (a^\dagger_a a_i -
         a^\dagger_i a_a) + \sum_{a > b, i > j} \theta_{a, b}^{i, j}
         (a^\dagger_a a^\dagger_b a_i a_j - a^\dagger_i a^\dagger_j a_a
         a_b)
 
     where :math:`i, j` (resp. :math:`a, b`) indices occupied (resp.
     inoccupied) spin-orbitals. It is antihermitian.
 
-    The function returns :math:`iT`.
-
-    Finally, the trial MP2 parametrization is reduced to only store the
-    non-zero parameters corresponding to the selected excitation
-    parameters.
+    The function returns a list of the operators :math:`i (a^\dagger_a a_i -
+        a^\dagger_i a_a)` and :math:`i (a^\dagger_a a^\dagger_b a_i a_j - a^\dagger_i a^\dagger_j a_a
+        a_b)`.
 
     Args:
         l_ex_op (List[Tuple[int]]): The list of of (a, b, i, j) and (a, i) tuples describing the
             excitation operators (without Hermitian conjugate, i.e. only excitation from unoccupied
             to  occupied orbitals) to consider among the set associated to the active orbitals.
         nqbits (int): The total number of qubits.
 
@@ -811,19 +808,19 @@
         nqbits (Optional[int]): The number of qubits.
         noons (Optional[List[float]]): The natural-orbital occupation numbers
             :math:`n_i`, sorted in descending order (from high occupations
             to low occupations) (doubled due to spin degeneracy).
 
     Returns:
         List[FermionHamiltonian]:
-            The list of cluster operators :math:`\{T_{a}^{i}, a \in \mathcal{I}', i \in \mathcal{O}' \} \cup \{T_{ab}^{ij}, a>b, i>j, a,b \in \mathcal{I}', i,j \in \mathcal{O}'\}`
+            The list of cluster operators :math:`\{i T_{a}^{i}, a \in \mathcal{I}', i \in \mathcal{O}' \} \cup \{iT_{ab}^{ij}, a>b, i>j, a,b \in \mathcal{I}', i,j \in \mathcal{O}'\}`, with :math:`\mathcal{I}` (resp. :math:`\mathcal{O}`) the inoccupied (resp. occupied) orbitals.
 
     Note:
         This function accepts as input the number of qubits or the noons. One of them is needed for the computation of the
-        cluster operators. :code:`n_electrons` and :code:`n_qbits` must be pair.
+        cluster operators. :code:`n_electrons` and :code:`n_qbits` must be even.
 
     """
 
     if noons is None and nqbits is None:
         raise TypeError("Missing input nqbits/noons. One is needed to compute the cluster operators.")
 
     if noons is not None:
@@ -831,21 +828,21 @@
         noons = _extend_list(noons)
         qbit_range = list(range(len(noons)))
 
     else:
 
         # Sanity check for nqbits
         if nqbits % 2 != 0:
-            raise ValueError(f"Only pair values of nqbits are allowed.")
+            raise ValueError(f"Only even values of nqbits are allowed.")
 
         qbit_range = list(range(nqbits))
 
     # Sanity check for n_electrons
     if n_electrons % 2 != 0:
-        raise ValueError(f"Only pair values of n_electrons are allowed.")
+        raise ValueError(f"Only even values of n_electrons are allowed.")
 
     (
         occupied_orbitals,
         unoccupied_orbitals,
     ) = _construct_active_orbitals(n_electrons, qbit_range)
 
     exc_op_list = select_excitation_operators(occupied_orbitals, unoccupied_orbitals, noons)
```

## qat/fermion/chemistry/ucc_deprecated.py

```diff
@@ -202,17 +202,18 @@
 
             for angle, cluster_op in zip(theta, cluster_ops):
                 # op_index = (i, a) or (i, j, a, b)
 
                 for term in cluster_op.terms:
                     assert isinstance(term.coeff, (float, complex))
 
+                    coeff = term.coeff
                     if isinstance(term.coeff, complex):
                         assert term.coeff.imag < 1e-13
-                        term.coeff = term.coeff.real
+                        coeff = term.coeff.real
 
                     coeff = angle * term.coeff
                     terms.append(Term(coeff, term.op, term.qbits))
 
             # QRoutine implementation
             cluster_op_obs = SpinHamiltonian(nqbits, terms)
             qrout_expt = make_spin_hamiltonian_trotter_slice(cluster_op_obs)
@@ -609,15 +610,15 @@
 
 #     core_constant, one_body_as, two_body_as = compute_active_space_integrals(
 #         one_body_integrals, two_body_integrals, active_indices, occupied_indices
 #     )
 
 #     hpq, hpqrs = convert_to_h_integrals(one_body_as, two_body_as)
 
-#     H_active = ElectronicStructureHamiltonian(hpq, hpqrs, constant_coeff=nuclear_repulsion + core_constant, do_clean_up=False)
+#     H_active = ElectronicStructureHamiltonian(hpq, hpqrs, constant_coeff=nuclear_repulsion + core_constant)
 
 #     return H_active, active_indices, occupied_indices
 
 
 def get_active_space_hamiltonian(
     one_body_integrals, two_body_integrals, noons, nels, nuclear_repulsion, threshold_1=0.02, threshold_2=1e-3
 ):
@@ -707,10 +708,10 @@
 
     core_constant, one_body_as, two_body_as = compute_active_space_integrals(
         one_body_integrals, two_body_integrals, active_indices, occupied_indices
     )
 
     hpq, hpqrs = convert_to_h_integrals(one_body_as, two_body_as)
 
-    H_active = ElectronicStructureHamiltonian(hpq, hpqrs, constant_coeff=nuclear_repulsion + core_constant, do_clean_up=False)
+    H_active = ElectronicStructureHamiltonian(hpq, hpqrs, constant_coeff=nuclear_repulsion + core_constant)
 
     return H_active, active_indices, occupied_indices
```

## qat/fermion/chemistry/wrapper.py

```diff
@@ -270,15 +270,14 @@
 
         hpq, hpqrs = convert_to_h_integrals(self.one_body_integrals, self.two_body_integrals)
 
         h_electronic = ElectronicStructureHamiltonian(
             hpq,
             hpqrs,
             constant_coeff=self.constant_coeff + self.core_constant,
-            do_clean_up=False,
         )
 
         return h_electronic
 
 
 class MoleculeInfo(object):
     r"""MoleculeInfo helper class. This class is a even higher level version of the
```

## qat/fermion/naturalgradient/qfim_plugin.py

```diff
@@ -48,15 +48,15 @@
         lambda_step (float, optional): Gradient descent step size :math:`\lambda`.
             Defaults to 0.2.
         stop_crit (string, optional): Stopping criterion, among {"grad_norm"|"energy_dist"}.
             Defaults to grad_norm.
         tol (float, optional): Tolerance for stopping criterion.
             Defaults to 1e-10.
         x0 (list, optional): Initial value of the parameters. The indexing must be the same as for the variables obtained via the
-            `.get_variables()`method. If None, the initial parameters will be randomly chosen. Defaults to None.
+            `.get_variables()` method. If None, the initial parameters will be randomly chosen. Defaults to None.
 
     """
 
     def __init__(
         self,
         maxiter: int = 200,
         lambda_step: float = 0.2,
@@ -244,12 +244,8 @@
                     stopping_criterion = True
 
             self.iterations += 1
 
         # Generate (angle, energy) tuple for optimizer trace metadata
         angle_energy = [(angles[idx], self.trace[idx]) for idx in range(len(self.trace))]
 
-        return (
-            self.trace[-1],
-            self.parameters_dict.values(),
-            {"iterations": self.iterations, "energies": angle_energy}
-        )
+        return (self.trace[-1], self.parameters_dict.values(), {"iterations": self.iterations, "energies": angle_energy})
```

## qat/plugins/adapt_vqe.py

```diff
@@ -2,60 +2,68 @@
 """
 ADAPT-VQE Plugin
 """
 
 import warnings
 from typing import List
 from tqdm.auto import tqdm
+import copy
 import numpy as np
 
 from qat.core.junction import Junction
 from qat.core import Result, Observable, Job
 from qat.lang.AQASM import Program, RX, RY, RZ, H, CNOT
 
 
 class AdaptVQEPlugin(Junction):
     r"""
-    Plugin implementation of the ADAPT-VQE algorithm, which builds ansatze by selecting operators from a given pool of operators.
-    The method is based on `Grimsley et al. article <https://www.nature.com/articles/s41467-019-10988-2.pdf>`_.
+    Plugin implementation of the ADAPT-VQE algorithm, which builds ansatze by selecting operators :math:`\tau_k` from a user-defined pool of operators.
+    Once an operator is chosen, a parameterized gate :math:`\exp(\theta_k \tau_k)` is added to the circuit.
+    The method is based on the `Grimsley et al. <https://www.nature.com/articles/s41467-019-10988-2.pdf>`_ publication.
 
-    Args:
-        operator_pool (List[Observable]): List of operators to choose from.
-            The pool of commutators is internally constructed from this list.
-        n_iterations (int, optional): Maximum number of iteration to perform. Defaults to 300.
-        commutators (List[Union[Observable, SpinHamiltonian]): List of commutators to use when computing the energy gradients.
-        early_stopper (float, optional): Loss value for which the run is stopped. Defaults to 1e-6.
 
+    Args:
+        operator_pool (List[Observable]): List of operators :math:`\tau_k` to choose from (they should be antihermitian).
+            The pool of commutators is either given by the user or internally constructed from this list.
+        n_iterations (int, optional): Maximum number of iterations to perform. Defaults to 300.
+        tol_vanishing_grad (float, optional): threshold value of the norm-2 of the gradient vector under which 
+            to stop the computation. Defaults to 1e-3.
+        commutators (List[Observable], optional): List of commutators between the observable and an operator from 
+            the pool, whose expectation values yield the gradient. Defaults to None, in which case it is constructed
+            when the plugin is run.
     """
 
     def __init__(
         self,
         operator_pool: List[Observable],
         n_iterations: int = 300,
-        early_stopper: float = 1e-6,
+        tol_vanishing_grad : float = 1e-3,
+        commutators = None
     ):
 
         self.pool = operator_pool
         self.n_iterations = n_iterations
-        self.early_stopper = early_stopper
-        self.commutators = None
+        self.tol_vanishing_grad = tol_vanishing_grad
+        self.commutators = commutators
 
         super().__init__(collective=False)
 
-    def _compute_commutators(self, observable: Observable):
+    @staticmethod
+    def _compute_commutators(observable: Observable, pool:List[Observable]):
         """Compute commutators between pool operators and the observable.
 
         Args:
-            job (Job): Job.
-
+            observable (Observable): The Observable whose expectation value is to be minimized.
+            pool (List[Observable]): the pool of operators to compute the commutator with
+            
         Returns:
             list: List of Observable
         """
 
-        return [observable | op for op in tqdm(self.pool, desc="Computing commutators...")]
+        return [observable | op for op in tqdm(pool, desc="Computing commutators...")]
 
     @staticmethod
     def _grow_ansatz(operator: Observable, iter_num: int) -> Program:
         r"""
         Make a parameterized Trotter slice corresponding to \exp(-i \theta_i O)
 
         Args:
@@ -141,73 +149,91 @@
         Returns:
             Result: Result
         """
 
         # Get circuit
         circuit = job.circuit
 
+        # Initialize bound circuit for gradient evaluation
+        bound_circuit = copy.copy(circuit)
+
         # Initialize Result container
         result = Result()
 
         # Initialize registers
-        energy_trace = []
+        energy_trace = [] # final energies of each optimization
         operator_idx = []
-
+        optimization_trace = [] # full ansatz optimization traces for each adapt step
+        n_iters_optim = [] # number of optimization steps for each current circuit
+        
         # Compute commutators
-        commutators = self._compute_commutators(job.observable)
-
+        if self.commutators is None:
+            self.commutators = self._compute_commutators(job.observable, self.pool)
+            
         pbar = tqdm(range(self.n_iterations))
         # Iterate over number of input number of iterations
-        for _ in pbar:
+        for iter_num in pbar:
 
             # Step energy register
             energy_gradients = []
 
             # Loop over operator pool and find the one with biggest energy gradient
             pbar.set_description("Computing energy gradients...")
-            for commutator in commutators:
-
-                val = self.execute(circuit.to_job(observable=commutator)).value
+            for commutator in self.commutators:
+                val = -1j*self.execute(bound_circuit.to_job(observable=commutator)).value
                 energy_gradients.append(val)
-
-            # If all energy gradients are equal, pick randomly from the pool one of the operators
-            energies_are_equal = all(item == energy_gradients[0] for item in energy_gradients)
-
-            if energies_are_equal:
-
-                # # If we have converged, energy gradient will remain at zero for all values
-                if energy_gradients[0] == 0:
-                    warnings.warn(
-                        "All energy gradients are equal to zero for given operator pool. Ending calculation.", stacklevel=2
+            
+            grad_vec_norm = np.linalg.norm(energy_gradients) 
+            
+            if grad_vec_norm < self.tol_vanishing_grad:
+                warnings.warn(
+                        "Norm of the energy gradient is below the set threshold. Ending calculation.", stacklevel=2
                     )
-                    break
-
-                # If energy gradients are equal, pick randomly one of them
-                op_ind = np.random.choice(np.arange(0, len(commutators) - 1))
+                op_ind = None
 
             # Else pick the one which changes energy the most (if 2 or more are equal, pick the first one)
             else:
                 op_ind = np.argmax(np.abs(energy_gradients))
 
-            operator_idx.append(op_ind)
-
-            # Grow ansatz
-            pbar.set_description("Growing ansatz...")
-
-            current_ansatz = self._grow_ansatz(self.pool[op_ind], 1)
-            circuit += current_ansatz.to_circ()
-
-            # Define the variational Job to optimize
-            job = circuit.to_job(observable=job.observable)
-
-            # Optimize the parameters
-            result = self.execute(circuit.to_job(observable=job.observable))
-
-            # Store current energy
+            if op_ind is not None:
+                operator_idx.append(op_ind)
+                # Grow ansatz
+                pbar.set_description("Growing ansatz...")
+
+                current_ansatz = self._grow_ansatz(self.pool[op_ind], iter_num)
+                circuit += current_ansatz.to_circ()
+
+                # Optimize the parameters (the job's circuit was updated)
+                result = self.execute(job)
+
+                # Update bound circuit
+                bound_circuit = circuit(**result.parameter_map)
+
+                # Store optimization results
+                energy_trace.append(result.value) # the optimal energy
+                n_iters_optim.append(len(eval(result.meta_data["optimization_trace"])))
+                optimization_trace += eval(result.meta_data["optimization_trace"]) # the whole trace
+                
             # pylint: disable=eval-used
-            energy_trace += eval(result.meta_data["optimization_trace"])
+            if not len(operator_idx): # empty list, meaning the circuit was never grown
+                warnings.warn(
+                        "Optimizing the initial circuit.", stacklevel=2
+                    )
+                # Optimize the parameters of the untouched circuit
+                result = self.execute(job)
+                # Store optimization results
+                energy_trace.append(result.value) # the optimal energy
+                if len(job.circuit.var_dic): # initial circuit is indeed variational
+                    n_iters_optim.append(len(eval(result.meta_data["optimization_trace"])))
+                    optimization_trace += eval(result.meta_data["optimization_trace"]) # the whole trace
+                break
+               
+            if op_ind is None:
+                break
 
         result.meta_data = {}
         result.meta_data["operator_order"] = str(operator_idx)
-        result.meta_data["optimization_trace"] = str(energy_trace)
-
+        result.meta_data["energy_trace"] = str(energy_trace)
+        result.meta_data["optimization_trace"] = str(optimization_trace)
+        result.meta_data["n_iters_optim"] = str(n_iters_optim)
+        
         return result
```

## qat/plugins/transform_observable.py

```diff
@@ -10,16 +10,16 @@
 class TransformObservable(AbstractPlugin):
     """
     Plugin performing a transformation on the Observable, to cast
     a :class:`qat.fermion.hamiltonians.FermionHamiltonian` or a :class:`qat.fermion.hamiltonians.ElectronicStructureHamiltonian`
     into a :class:`qat.fermion.hamiltonians.SpinHamiltonian`. The transformation is defined
     by a identifier (i.e. string)
 
-     - **jordan-wigner**: Jordan-Wigned transformation
-       (cf. :func:`~qat.fermion.transforms.transfrom_to_jw_basis`**)
+     - **jordan-wigner**: Jordan-Wigner transformation
+       (cf. :func:`~qat.fermion.transforms.transform_to_jw_basis`)
      - **bravyi-kitaev**: Bravyi-Kitaev transformation
        (cf. :func:`~qat.fermion.transforms.transform_to_bk_basis`)
      - **parity-basis**: Parity basis transformation
        (cf. :func:`~qat.fermion.transforms.transform_to_parity_basis`)
 
     Args:
         name (str): Transformation
@@ -34,14 +34,15 @@
 
     def __init__(self, name: str):
         try:
             self.transform = TransformObservable.transforms[name]
 
         except KeyError as excpt:
             raise ValueError(f"Unknown transformation {name!r}") from excpt
+        super().__init__()
 
     def compile(self, batch, specs):
         """
         Compile method. Transform every job composing a batch
 
         Args:
             batch (:class:`~qat.core.Batch`): batch to compile
```

## Comparing `myqlm_fermion-1.0.0.dist-info/LICENSE` & `myqlm_fermion-1.1.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `myqlm_fermion-1.0.0.dist-info/METADATA` & `myqlm_fermion-1.1.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: myqlm-fermion
-Version: 1.0.0
+Version: 1.1.0
 Summary: myQLM-fermion package
 Home-page: https://atos.net/en/lp/myqlm
 Author: Atos Quantum Lab
 License: Atos myQLM EULA
 Project-URL: Documentation, https://myqlm.github.io
 Project-URL: Bug Tracker, https://github.com/myQLM/myqlm-issues/issues
 Project-URL: Community, https://myqlmworkspace.slack.com
@@ -13,15 +13,14 @@
 License-File: LICENSE
 Requires-Dist: qat-core
 Requires-Dist: qat-lang
 Requires-Dist: myqlm
 Requires-Dist: anytree
 Requires-Dist: bitstring
 Requires-Dist: numpy
-Requires-Dist: pytest
 Requires-Dist: scipy
 Requires-Dist: tqdm
 
 MyQLM fermion module
 =============================
 
 `MyQLM-fermion` is the new open-source module in `MyQLM`.
```

## Comparing `myqlm_fermion-1.0.0.dist-info/RECORD` & `myqlm_fermion-1.1.0.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,36 +1,36 @@
 qat/fermion/__init__.py,sha256=KSUSVAtX_BtxX-ELLXFEZ17uOjnnb1Fpcp1Wp-_G2vg,357
 qat/fermion/ansatz_generator.py,sha256=FG50Z9u6ZRfmMjQHL6yHJREnzOiZDkMPyJ7elPxT4JQ,5781
 qat/fermion/circuits.py,sha256=CVUsLxJtpSGCoF26Sgdic0eif3IPkc4sMei2vYbE4XI,11031
 qat/fermion/fermion_algebra.py,sha256=t1qCywb15oGBYmUeqPXW_RaXRbQcwGeTNrzPbPdL-ks,7092
 qat/fermion/generator_tools.py,sha256=kIFY0kDx-4jl8Xu96AAkSmMDekvUp-5byI0AB7W9X0M,623
-qat/fermion/hamiltonians.py,sha256=XdHj8aSaTCIRbV_UNusARy5W4ybdG9LbY4fdyAMQ6Kg,32385
+qat/fermion/hamiltonians.py,sha256=rBjLthc5ywpPPuV-l9atnx-wOPmUV8p9VJmcfWIMCnU,31710
 qat/fermion/matchgates.py,sha256=2XAuYK0GKDOdg-VfdeINGjSMvykS6eYdJZpIvoQRIs4,18981
 qat/fermion/observable_generator.py,sha256=tmDV61NB1uEWAaqJJJ3A64Q408jXuXkGvdIcU6QT3uA,6962
-qat/fermion/phase_estimation.py,sha256=lChpdu67GrjAwBgGdTETcKhZDf2skBhYMPwGr3clqtI,15217
-qat/fermion/transforms.py,sha256=0bqmfHC-Xyvn6Ud-Ry4fw1fNHP0MFz44O3wEPS8IEUI,11122
+qat/fermion/phase_estimation.py,sha256=9f--mNUnikkoJ6sc6Fm3XCfhufqni_pCuhpUwUfIb2I,15216
+qat/fermion/transforms.py,sha256=flEU0jTHpq347pEMT2y8JflawVDnLPlu46dvLCu_DFE,10916
 qat/fermion/trotterisation.py,sha256=4q3Vz9AFmFz1EQT-VLGyed99fYylNO2nt35nP2q0A04,22685
 qat/fermion/util.py,sha256=sR9cczHBp99urNF4T-6hhztkgBZwBvME-ooAIpeUuuQ,8919
 qat/fermion/vqe.py,sha256=fxt7PuiRdltUdrLQGK_9DhyvuR2qTzaHtb1pE0A2auQ,2510
 qat/fermion/chemistry/__init__.py,sha256=cSybek8J8xAYyNi5eGJAzguBBx29cJZ9_ECEblvZHYg,425
 qat/fermion/chemistry/pyscf_tools.py,sha256=cdfIUdUJIuMFpWs_Q-agHLvyksy1yTW2Xtsimy8fzU4,5099
 qat/fermion/chemistry/qse.py,sha256=xxPDbI0vVzM2yrILe_SI0LCtXaHeJsK-VwOwVtyN6js,8678
-qat/fermion/chemistry/ucc.py,sha256=pcCUWy6rZA2hhWw8yCcwUUlxWnA-b1NRF1qFqIiUjk4,30748
-qat/fermion/chemistry/ucc_deprecated.py,sha256=MXIya2h6Zoz8ojYfjL7m6Ymqh8ax8mWmaG6sOXv0vhc,27365
-qat/fermion/chemistry/wrapper.py,sha256=QiwFr6rK03Kojkhye_hXHdbZVXJo4FG8VPG0KAgbRZs,15863
+qat/fermion/chemistry/ucc.py,sha256=xpkdDJc_NThA2xuzaIzp5vQpcB8RZV8vnM0Mszg_gXI,30800
+qat/fermion/chemistry/ucc_deprecated.py,sha256=k3UhtmKu_1hsQ1NVl4GeMwHyTPNjWdEg3P6-rs4hSVQ,27361
+qat/fermion/chemistry/wrapper.py,sha256=jz9rhS50Zt8K_JyVPbw41PiCrQN3KMNvvzfMMyX9dEw,15832
 qat/fermion/naturalgradient/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 qat/fermion/naturalgradient/auto_derivatives.py,sha256=iaDgE1IItjYlt1WCSFUrtCQBZqbmyDWg3i6kukawqAE,23172
 qat/fermion/naturalgradient/custom_gate_set.py,sha256=T8n7HrGZVS7BRw5zNjmMG-CT1nH2zpe7Zngct_UBRNU,2408
 qat/fermion/naturalgradient/expressions.py,sha256=0VZaokaWxPaOdGZNMMcNOeIa8pSoPpROTUCZzcQoOrc,975
-qat/fermion/naturalgradient/qfim_plugin.py,sha256=Tdfi9J3xJP4oXw7DUowOTRpGvRw_RPkAS4Fxvk37GeU,9758
+qat/fermion/naturalgradient/qfim_plugin.py,sha256=ow-OiUpLveGI7COAqxVM630b_dBQmP-nyzf0SC-qmd0,9713
 qat/generators/hook_vqe.py,sha256=yU3M76IPHtGF315ow5YdM-CBz3XjTt35jnTz_UQHEz4,254
-qat/plugins/adapt_vqe.py,sha256=z6Y4VQH7xjO8w9I3uIKseDLZsWy4Jy-djp6tqGotPs8,7034
+qat/plugins/adapt_vqe.py,sha256=8_iUoSApPfSjjayF9zPMA7bod6wMqpPiMwa5WgGUFMI,8955
 qat/plugins/hook_natgrad_plugin.py,sha256=Im87vBS96TIq8NWM9y4wzb-Io0JNS6ChP5CMMK7kptU,172
 qat/plugins/multiple_launches_analyzer.py,sha256=UamQGX8PylpI7VsjU9K4NQa0aLod_R-6zk_CW2D4OFM,3104
 qat/plugins/sequential_optimization.py,sha256=um3ylziLXK6CCJUqVcMURWdscZWe890axx_9lOAMAT8,4993
-qat/plugins/transform_observable.py,sha256=IpTZgmd-5np1mU84m8KWcVapMmJ3wt5v1JmUXJb28o4,1999
+qat/plugins/transform_observable.py,sha256=KzAvpqXPVe2j_EyZ3vlyHKVTp_A8Ea4sGcuDVgCrzpQ,2024
 qat/plugins/zero_noise_extrapolator.py,sha256=qx3AGgabux2kxGuI3nqmFBiFiRioIPmRb0_kT60LJgg,10090
-myqlm_fermion-1.0.0.dist-info/LICENSE,sha256=V0jud3X0yASwWe9bl9ASbBx2hNtJg2sK9i1FBZOmp7Y,11340
-myqlm_fermion-1.0.0.dist-info/METADATA,sha256=cdwjj8cGPWwoAqZ7VezbX3-jrKncXHoU8EbuqyvPWSM,1881
-myqlm_fermion-1.0.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-myqlm_fermion-1.0.0.dist-info/top_level.txt,sha256=EtiE-lzXpV6tDPK3leIRADd9p6cOal7g6fxvqQ-u_yc,4
-myqlm_fermion-1.0.0.dist-info/RECORD,,
+myqlm_fermion-1.1.0.dist-info/LICENSE,sha256=V0jud3X0yASwWe9bl9ASbBx2hNtJg2sK9i1FBZOmp7Y,11340
+myqlm_fermion-1.1.0.dist-info/METADATA,sha256=1zHlPKTnJiodrjtFITKysCLcuedzabJ9tBHn1s66kLw,1859
+myqlm_fermion-1.1.0.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
+myqlm_fermion-1.1.0.dist-info/top_level.txt,sha256=EtiE-lzXpV6tDPK3leIRADd9p6cOal7g6fxvqQ-u_yc,4
+myqlm_fermion-1.1.0.dist-info/RECORD,,
```

