# Comparing `tmp/awsimple-2.4.5-py3-none-any.whl.zip` & `tmp/awsimple-2.5.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,20 +1,20 @@
-Zip file size: 32817 bytes, number of entries: 18
+Zip file size: 32866 bytes, number of entries: 18
 -rw-rw-rw-  2.0 fat      871 b- defN 23-Apr-12 19:14 awsimple/__init__.py
--rw-rw-rw-  2.0 fat      323 b- defN 23-May-05 15:59 awsimple/__version__.py
--rw-rw-rw-  2.0 fat     6952 b- defN 23-Apr-12 23:17 awsimple/aws.py
--rw-rw-rw-  2.0 fat     7137 b- defN 23-Mar-14 23:35 awsimple/cache.py
--rw-rw-rw-  2.0 fat    35834 b- defN 23-May-05 02:27 awsimple/dynamodb.py
--rw-rw-rw-  2.0 fat     4619 b- defN 23-Mar-14 23:35 awsimple/dynamodb_miv.py
+-rw-rw-rw-  2.0 fat      323 b- defN 23-Aug-01 21:35 awsimple/__version__.py
+-rw-rw-rw-  2.0 fat     7063 b- defN 23-Aug-01 21:29 awsimple/aws.py
+-rw-rw-rw-  2.0 fat     7163 b- defN 23-Aug-01 21:29 awsimple/cache.py
+-rw-rw-rw-  2.0 fat    36078 b- defN 23-Aug-01 21:34 awsimple/dynamodb.py
+-rw-rw-rw-  2.0 fat     4645 b- defN 23-Aug-01 21:23 awsimple/dynamodb_miv.py
 -rw-rw-rw-  2.0 fat     4278 b- defN 23-Mar-14 23:10 awsimple/logs.py
 -rw-rw-rw-  2.0 fat      199 b- defN 23-Mar-14 23:10 awsimple/mock.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Mar-14 23:10 awsimple/py.typed
--rw-rw-rw-  2.0 fat    23243 b- defN 23-Mar-14 23:35 awsimple/s3.py
--rw-rw-rw-  2.0 fat     3266 b- defN 23-Mar-14 23:10 awsimple/sns.py
--rw-rw-rw-  2.0 fat    15040 b- defN 23-May-05 16:42 awsimple/sqs.py
--rw-rw-rw-  2.0 fat     1093 b- defN 23-May-05 16:56 awsimple-2.4.5.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1093 b- defN 23-May-05 16:56 awsimple-2.4.5.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat     4815 b- defN 23-May-05 16:56 awsimple-2.4.5.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-05 16:56 awsimple-2.4.5.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        9 b- defN 23-May-05 16:56 awsimple-2.4.5.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1376 b- defN 23-May-05 16:56 awsimple-2.4.5.dist-info/RECORD
-18 files, 110240 bytes uncompressed, 30603 bytes compressed:  72.2%
+-rw-rw-rw-  2.0 fat    23256 b- defN 23-Aug-01 21:23 awsimple/s3.py
+-rw-rw-rw-  2.0 fat     3292 b- defN 23-Aug-01 21:21 awsimple/sns.py
+-rw-rw-rw-  2.0 fat    15079 b- defN 23-Aug-01 21:25 awsimple/sqs.py
+-rw-rw-rw-  2.0 fat     1093 b- defN 23-Aug-01 21:37 awsimple-2.5.1.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1093 b- defN 23-Aug-01 21:37 awsimple-2.5.1.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat     4815 b- defN 23-Aug-01 21:37 awsimple-2.5.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Aug-01 21:37 awsimple-2.5.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        9 b- defN 23-Aug-01 21:37 awsimple-2.5.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1376 b- defN 23-Aug-01 21:37 awsimple-2.5.1.dist-info/RECORD
+18 files, 110725 bytes uncompressed, 30652 bytes compressed:  72.3%
```

## zipnote {}

```diff
@@ -30,26 +30,26 @@
 
 Filename: awsimple/sns.py
 Comment: 
 
 Filename: awsimple/sqs.py
 Comment: 
 
-Filename: awsimple-2.4.5.dist-info/LICENSE
+Filename: awsimple-2.5.1.dist-info/LICENSE
 Comment: 
 
-Filename: awsimple-2.4.5.dist-info/LICENSE.txt
+Filename: awsimple-2.5.1.dist-info/LICENSE.txt
 Comment: 
 
-Filename: awsimple-2.4.5.dist-info/METADATA
+Filename: awsimple-2.5.1.dist-info/METADATA
 Comment: 
 
-Filename: awsimple-2.4.5.dist-info/WHEEL
+Filename: awsimple-2.5.1.dist-info/WHEEL
 Comment: 
 
-Filename: awsimple-2.4.5.dist-info/top_level.txt
+Filename: awsimple-2.5.1.dist-info/top_level.txt
 Comment: 
 
-Filename: awsimple-2.4.5.dist-info/RECORD
+Filename: awsimple-2.5.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## awsimple/__version__.py

```diff
@@ -1,8 +1,8 @@
 __application_name__ = "awsimple"
 __title__ = __application_name__
 __author__ = "abel"
-__version__ = "2.4.5"
+__version__ = "2.5.1"
 __author_email__ = "j@abel.co"
 __url__ = "https://github.com/jamesabel/awsimple"
 __download_url__ = "https://github.com/jamesabel/awsimple"
 __description__ = "Simple AWS API for S3, DynamoDB, SNS, and SQS"
```

## awsimple/aws.py

```diff
@@ -1,9 +1,9 @@
 import os
-from typing import Union
+from typing import Union, Any
 from logging import getLogger
 
 from typeguard import typechecked
 
 from awsimple import __application_name__, is_mock
 
 log = getLogger(__application_name__)
@@ -24,19 +24,19 @@
     return most_recent_error
 
 
 class AWSAccess:
     @typechecked()
     def __init__(
         self,
-        resource_name: str = None,
-        profile_name: str = None,
-        aws_access_key_id: str = None,
-        aws_secret_access_key: str = None,
-        region_name: str = None,
+        resource_name: Union[str, None] = None,
+        profile_name: Union[str, None] = None,
+        aws_access_key_id: Union[str, None] = None,
+        aws_secret_access_key: Union[str, None] = None,
+        region_name: Union[str, None] = None,
     ):
         """
         AWSAccess - takes care of basic AWS access (e.g. session, client, resource), getting some basic AWS information, and mock support for testing.
 
         :param resource_name: AWS resource name (e.g. s3, dynamodb, sqs, sns, etc.). Can be None if just testing the connection.
 
         # Provide either: profile name or access key ID/secret access key pair
@@ -65,14 +65,15 @@
         # https://docs.aws.amazon.com/cli/latest/userguide/cli-config-files.html
         kwargs = {}
         for k in ["profile_name", "aws_access_key_id", "aws_secret_access_key", "region_name"]:
             if getattr(self, k) is not None:
                 kwargs[k] = getattr(self, k)
         self.session = boto3.session.Session(**kwargs)
 
+        self.client = None  # type: Any
         if is_mock():
             # moto mock AWS
             for aws_key in ["AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY", "AWS_SECURITY_TOKEN", "AWS_SESSION_TOKEN"]:
                 self._aws_keys_save[aws_key] = os.environ.get(aws_key)  # will be None if not set
                 os.environ[aws_key] = "testing"
 
             if self.resource_name == "s3":
```

## awsimple/cache.py

```diff
@@ -30,15 +30,15 @@
             size += os.path.getsize(p)
         elif p.is_dir():
             size += get_directory_size(p)
     return size
 
 
 @typechecked()
-def lru_cache_write(new_data: Union[Path, bytes], cache_dir: Path, cache_file_name: str, max_absolute_cache_size: int = None, max_free_portion: float = None) -> bool:
+def lru_cache_write(new_data: Union[Path, bytes], cache_dir: Path, cache_file_name: str, max_absolute_cache_size: Union[int, None] = None, max_free_portion: Union[float, None] = None) -> bool:
     """
     free up space in the LRU cache to make room for the new file
     :param new_data: path to new file or a bytes object we want to put in the cache
     :param cache_dir: cache directory
     :param cache_file_name: file name to write in cache
     :param max_absolute_cache_size: max absolute cache size (or None if not specified)
     :param max_free_portion: max portion of disk free space the cache is allowed to consume (e.g. 0.1 to take up to 10% of free disk space)
```

## awsimple/dynamodb.py

```diff
@@ -88,15 +88,15 @@
 
         if is_int:
             # if representable with an integer, use an integer
             serializable_representation = int(o)
         else:
             # not representable with an integer so use a float
             serializable_representation = float(o)
-    elif isinstance(o, bytes) or isinstance(o, bytearray):
+    elif isinstance(o, bytes) or isinstance(o, bytearray) or isinstance(o, Path):
         serializable_representation = str(o)
     elif hasattr(o, "value"):
         # e.g. PIL images
         serializable_representation = str(o.value)
     else:
         raise NotImplementedError(f"can not serialize {o} since type={type(o)}")
     return serializable_representation
@@ -210,15 +210,15 @@
     if is_valid and cache_life is not None:
         is_valid = time.time() <= getmtime(str(file_path)) + cache_life
     return is_valid
 
 
 class DynamoDBAccess(CacheAccess):
     @typechecked()
-    def __init__(self, table_name: str = None, reload_comparison: Callable[[int, int], bool] = operator.gt, **kwargs):
+    def __init__(self, table_name: Union[str, None] = None, reload_comparison: Callable[[int, int], bool] = operator.gt, **kwargs):
         """
         AWS DynamoDB access
 
         :param table_name: DynamoDB table name
         :param reload_comparison: table size comparison to use to determine if we need to reload from cloud. Use operator.eq if table is not monotonically increasing and won't be used within
                                   6 hours after modification.
         :param kwargs: kwargs
@@ -413,16 +413,16 @@
         """
         return self.rows_to_dict(self.scan_table_cached(invalidate_cache), sort_key)
 
     @typechecked()
     def create_table(
         self,
         partition_key: str,
-        sort_key: str = None,
-        secondary_index: str = None,
+        sort_key: Union[str, None] = None,
+        secondary_index: Union[str, None] = None,
         partition_key_type: Union[Type[str], Type[int], Type[bool]] = str,
         sort_key_type: Union[Type[str], Type[int], Type[bool]] = str,
         secondary_key_type: Union[Type[str], Type[int], Type[bool]] = str,
     ) -> bool:
         """
         Create a DynamoDB table.
 
@@ -532,15 +532,15 @@
         """
 
         assert self.resource is not None
         try:
             table = self.resource.Table(self.table_name)
             key_schema = table.key_schema
         except self.client.exceptions.ResourceNotFoundException:
-            raise DynamoDBTableNotFound(self.table_name)
+            raise DynamoDBTableNotFound(str(self.table_name))
         keys = self._get_keys_from_schema(key_schema)
         return keys
 
     @lru_cache()
     def get_primary_partition_key(self) -> str:
         primary_keys = self.get_primary_keys_dict()
         return primary_keys[KeyType.partition]
@@ -641,15 +641,17 @@
         :param args: key, value pairs or keyword args
         :return: a list of DB rows matching the query
         """
         args = self._args_kwargs(args, kwargs)
         return self._query("begins_with", *args)
 
     @typechecked()
-    def query_one(self, partition_key: str = None, partition_value=None, direction: QuerySelection = QuerySelection.highest, secondary_index_name: str = None) -> Union[dict, None]:
+    def query_one(
+        self, partition_key: Union[str, None] = None, partition_value=None, direction: QuerySelection = QuerySelection.highest, secondary_index_name: Union[str, None] = None
+    ) -> Union[dict, None]:
         """
         Query and return one or none items, optionally using the sort key to provide either the start or end of the ordered (sorted) set of items.
 
         This is particularly useful when the table uses a sort key that orders the items, and you want one value that is at one of the
         ends of that sort. For example, if the sort key is an epoch timestamp (number) and direction is QueryDirection.highest, the most recent item is returned.
 
         :param partition_key: partition key (optional - if not given AWSimple will use the primary partition key)
@@ -730,18 +732,20 @@
         :param item: item
         """
         assert self.resource is not None
         try:
             table = self.resource.Table(self.table_name)
             table.put_item(Item=item)
         except self.client.exceptions.ResourceNotFoundException:
-            raise DynamoDBTableNotFound(self.table_name)
+            raise DynamoDBTableNotFound(str(self.table_name))
 
     # cant' do a @typechecked() since optional item requires a single type
-    def get_item(self, partition_key: str = None, partition_value: Union[str, int] = None, sort_key: Union[str, None] = None, sort_value: Union[str, int] = None) -> dict:
+    def get_item(
+        self, partition_key: Union[str, None] = None, partition_value: Union[str, int, None] = None, sort_key: Union[str, None] = None, sort_value: Union[str, int, None] = None
+    ) -> dict:
         """
         Get a DB item using the primary keys. Raise DBItemNotFound if item does not exist.
 
         :param partition_key: partition key (optional - if not given or None AWSimple will provide it)
         :param partition_value: partition value (str or int)
         :param sort_key: sort key (optional in case sort not used, but if sort used and not given or None AWSimple will provide it)
         :param sort_value: sort value (optional str or int)
@@ -757,21 +761,21 @@
         try:
             table = self.resource.Table(self.table_name)
             key = {partition_key: partition_value}  # type: Dict[str, Any]
             if sort_key is not None:
                 key[sort_key] = sort_value
             response = table.get_item(Key=key)
         except self.client.exceptions.ResourceNotFoundException:
-            raise DynamoDBTableNotFound(self.table_name)
+            raise DynamoDBTableNotFound(str(self.table_name))
         if (item := response.get("Item")) is None:
             raise DBItemNotFound(key)
         return item
 
     # cant' do a @typechecked() since optional item requires a single type
-    def delete_item(self, partition_key: str = None, partition_value: Union[str, int] = None, sort_key: Union[str, None] = None, sort_value: Union[str, int, None] = None):
+    def delete_item(self, partition_key: Union[str, None] = None, partition_value: Union[str, int, None] = None, sort_key: Union[str, None] = None, sort_value: Union[str, int, None] = None):
         """
         Delete table item
 
         :param partition_key: item partition (aka hash) key
         :param partition_value: item partition (aka hash) value
         :param sort_key: item sort key (if exists)
         :param sort_value: item sort value (if sort key exists)
@@ -787,15 +791,20 @@
         key = {partition_key: partition_value}  # type: dict[str, Any]
         if sort_key is not None:
             key[sort_key] = sort_value
         table.delete_item(Key=key)
 
     # cant' do a @typechecked() since optional item requires a single type
     def upsert_item(
-        self, partition_key: str = None, partition_value: Union[str, int] = None, sort_key: Union[str, None] = None, sort_value: Union[str, int, None] = None, item: Union[dict, None] = None
+        self,
+        partition_key: Union[str, None] = None,
+        partition_value: Union[str, int, None] = None,
+        sort_key: Union[str, None] = None,
+        sort_value: Union[str, int, None] = None,
+        item: Union[dict, None] = None,
     ):
         """
         Upsert (update or insert) table item
 
         :param partition_key: item partition (aka hash) key
         :param partition_value: item partition (aka hash) value
         :param sort_key: item sort key (if exists)
```

## awsimple/dynamodb_miv.py

```diff
@@ -43,22 +43,22 @@
     some cases may be even more useful.
     """
 
     @typechecked()
     def create_table(  # type: ignore
         self,
         partition_key: str,
-        secondary_index: str = None,
+        secondary_index: Union[str, None] = None,
         partition_key_type: Union[Type[str], Type[int], Type[bool]] = str,
         secondary_key_type: Union[Type[str], Type[int], Type[bool]] = str,
     ) -> bool:
         return super().create_table(partition_key, miv_string, secondary_index, partition_key_type, int, secondary_key_type)
 
     @typechecked()
-    def put_item(self, item: dict, time_us: int = None):
+    def put_item(self, item: dict, time_us: Union[int, None] = None):
         """
         Put (write) a DynamoDB table item with the miv automatically filled in.
 
         :param item: item
         :param time_us: optional time in uS to use (otherwise current time is used)
         """
         assert self.resource is not None
```

## awsimple/s3.py

```diff
@@ -90,15 +90,15 @@
     if not s3_key.endswith(json_extension):
         s3_key = f"{s3_key}{json_extension}"
     return s3_key
 
 
 class S3Access(CacheAccess):
     @typechecked()
-    def __init__(self, bucket_name: str = None, **kwargs):
+    def __init__(self, bucket_name: Union[str, None] = None, **kwargs):
         """
         S3 Access
 
         :param bucket_name: S3 bucket name
         :param kwargs: kwargs
         """
         self.bucket_name = bucket_name
```

## awsimple/sns.py

```diff
@@ -82,15 +82,15 @@
             protocol = "sqs"
         else:
             raise ValueError(f"{subscriber=}")
         response = self.client.subscribe(TopicArn=self.get_arn(), Protocol=protocol, Endpoint=endpoint, ReturnSubscriptionArn=True)
         return response["SubscriptionArn"]
 
     @typechecked()
-    def publish(self, message: str, subject: str = None, attributes: dict = None) -> str:
+    def publish(self, message: str, subject: Union[str, None] = None, attributes: Union[dict, None] = None) -> str:
         """
         publish to an existing SNS topic
 
         :param message: message string
         :param subject: subject string
         :param attributes: message attributes (see AWS SNS documentation on SNS MessageAttributes)
         :return: message ID
```

## awsimple/sqs.py

```diff
@@ -45,15 +45,15 @@
 # AWS defaults
 aws_sqs_long_poll_max_wait_time = 20  # seconds
 aws_sqs_max_messages = 10
 
 
 class SQSAccess(AWSAccess):
     @typechecked()
-    def __init__(self, queue_name: str, immediate_delete: bool = True, visibility_timeout: int = None, minimum_visibility_timeout: int = 0, **kwargs):
+    def __init__(self, queue_name: str, immediate_delete: bool = True, visibility_timeout: Union[int, None] = None, minimum_visibility_timeout: int = 0, **kwargs):
         """
         SQS access
 
         :param queue_name: queue name
         :param immediate_delete: True to immediately delete read message(s) upon receipt, False to require the user to call delete_message()
         :param visibility_timeout: visibility timeout (if explicitly given) - set to None to automatically attempt to determine the timeout
         :param minimum_visibility_timeout: visibility timeout will be at least this long (do not set if visibility_timeout set)
@@ -170,15 +170,15 @@
                 raise ValueError(f"do not specify both timeout ({self.user_provided_timeout}) and minimum_timeout {self.user_provided_minimum_timeout}")
             else:
                 visibility_timeout = self.user_provided_timeout  # timeout explicitly given by the user
 
         return visibility_timeout
 
     @typechecked()
-    def _receive(self, max_number_of_messages_parameter: int = None) -> List[SQSMessage]:
+    def _receive(self, max_number_of_messages_parameter: Union[int, None] = None) -> List[SQSMessage]:
         if self.user_provided_timeout is None and not self.immediate_delete:
             # read in response history (and initialize it if it doesn't exist)
             try:
                 with open(self._get_response_history_file_path()) as f:
                     self.response_history = json.load(f)
             except FileNotFoundError:
                 pass
@@ -254,15 +254,15 @@
         elif message_count == 1:
             message = messages[0]
         else:
             raise RuntimeError(f"{message_count=}")
         return message
 
     @typechecked()
-    def receive_messages(self, max_messages: int = None) -> List[SQSMessage]:
+    def receive_messages(self, max_messages: Union[int, None] = None) -> List[SQSMessage]:
         """
         receive a (possibly empty) list of SQS messages from this queue
 
         :param max_messages: maximum number of messages to receive (None for all available messages)
         :return: list of messages
         """
         return self._receive(max_messages)
```

## Comparing `awsimple-2.4.5.dist-info/LICENSE` & `awsimple-2.5.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `awsimple-2.4.5.dist-info/LICENSE.txt` & `awsimple-2.5.1.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `awsimple-2.4.5.dist-info/METADATA` & `awsimple-2.5.1.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: awsimple
-Version: 2.4.5
+Version: 2.5.1
 Summary: Simple AWS API for S3, DynamoDB, SNS, and SQS
 Home-page: https://github.com/jamesabel/awsimple
 Download-URL: https://github.com/jamesabel/awsimple
 Author: abel
 Author-email: j@abel.co
 License: MIT License
 Project-URL: Documentation, https://awsimple.readthedocs.io/
```

### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: awsimple Version: 2.4.5 Summary: Simple AWS API for
+Metadata-Version: 2.1 Name: awsimple Version: 2.5.1 Summary: Simple AWS API for
 S3, DynamoDB, SNS, and SQS Home-page: https://github.com/jamesabel/awsimple
 Download-URL: https://github.com/jamesabel/awsimple Author: abel Author-email:
 j@abel.co License: MIT License Project-URL: Documentation, https://
 awsimple.readthedocs.io/ Keywords: aws,cloud,storage,database,dynamodb,s3
 Description-Content-Type: text/markdown License-File: LICENSE License-File:
 LICENSE.txt Requires-Dist: boto3 Requires-Dist: typeguard (<3) Requires-Dist:
 hashy (>=0.1.1) Requires-Dist: dictim Requires-Dist: appdirs Requires-Dist:
```

## Comparing `awsimple-2.4.5.dist-info/RECORD` & `awsimple-2.5.1.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 awsimple/__init__.py,sha256=HIEMxWrkMoIAC6m_PGv0_OgyJ5vfOhuAVJgRmRbT0eg,871
-awsimple/__version__.py,sha256=8SGXrMStlNQAdTn0phWqAWb9Q2Hx02Ai1zwTpVicVNk,323
-awsimple/aws.py,sha256=4RYd-BmzFx02wCNTb4md9Z59M6okhFK5zIP9NpoqXoU,6952
-awsimple/cache.py,sha256=5dYf7bh1Dr_pFbkHck4Ym8zrffctv0ERhGJwieRHQH8,7137
-awsimple/dynamodb.py,sha256=giwvkmxJidMEOYSTaAj2BFERzfPm92vg2lmaOQoDbzo,35834
-awsimple/dynamodb_miv.py,sha256=FcbEn2VbrYxQcgQKqFoWFqVwAkoqJpwZ4Nr5guXgGXM,4619
+awsimple/__version__.py,sha256=z5wxp3RtCKQZoksqmR7Adjv7f1ltIqhhudN4ofocyGo,323
+awsimple/aws.py,sha256=pPYVHKysUbKPLqgco6xf-neZAdHtZMXHjpwHAb-5z6s,7063
+awsimple/cache.py,sha256=tdLeMw2IYW9Y4lGT2SAGUI7u_aTX_TFQs2udXcqW6fI,7163
+awsimple/dynamodb.py,sha256=PEQ1ypj0YW4Pk5UFsosTvudJldGe-BTDOxDG0s5LY7c,36078
+awsimple/dynamodb_miv.py,sha256=4xPxQDYkIM-BVDGyAre6uqwJHsxguEbHbof8ztt-V7g,4645
 awsimple/logs.py,sha256=A2RmTT90pfFTthfENd7GSsEHSIBJXO8ICHPdA7sEsHY,4278
 awsimple/mock.py,sha256=32CNU656uC3PBhjCJ4R-WBTtHbSl6VNVkpN8G8XDvsQ,199
 awsimple/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-awsimple/s3.py,sha256=uMEz6NN9hXOfsQNUNJ2YOuKGKlT2xqZ5btJ9zsCHBrY,23243
-awsimple/sns.py,sha256=LjKj-UxPdfRDQfN10jU_ULjnlEqLmHcuqfRIKX9lkZo,3266
-awsimple/sqs.py,sha256=d2228qH_jwNRo8XXXL8Pmng47yx5IwzwRNA-k_jWe-g,15040
-awsimple-2.4.5.dist-info/LICENSE,sha256=d956YAgtDaxgxQmccyUk__EfhORZyBjvmJ8pq6zYTxk,1093
-awsimple-2.4.5.dist-info/LICENSE.txt,sha256=d956YAgtDaxgxQmccyUk__EfhORZyBjvmJ8pq6zYTxk,1093
-awsimple-2.4.5.dist-info/METADATA,sha256=0dK-Mt0OUkDT8TjKn1slO-Rgt-rByUhtulhAtKYQXfw,4815
-awsimple-2.4.5.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-awsimple-2.4.5.dist-info/top_level.txt,sha256=mwqCoH_8vAaK6iYioiRbasXmVCQM7AK3grNWOKp2VHE,9
-awsimple-2.4.5.dist-info/RECORD,,
+awsimple/s3.py,sha256=_HoUhpmh3M4SfY_677kGjjo6CGjnY80-PwCzTrHImAw,23256
+awsimple/sns.py,sha256=dOx3VUS04xxeG1krGudN4A5fqoIpXeHqXNkBvfbr_6Q,3292
+awsimple/sqs.py,sha256=l1ufVbWw7HzJMpJLWGjy5aCKbOMKgwoHjaIDHga24kQ,15079
+awsimple-2.5.1.dist-info/LICENSE,sha256=d956YAgtDaxgxQmccyUk__EfhORZyBjvmJ8pq6zYTxk,1093
+awsimple-2.5.1.dist-info/LICENSE.txt,sha256=d956YAgtDaxgxQmccyUk__EfhORZyBjvmJ8pq6zYTxk,1093
+awsimple-2.5.1.dist-info/METADATA,sha256=KbE7RN21_SDKmBp7zgGx5uI-5mYYpLb3dMWAS1N3Wd4,4815
+awsimple-2.5.1.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
+awsimple-2.5.1.dist-info/top_level.txt,sha256=mwqCoH_8vAaK6iYioiRbasXmVCQM7AK3grNWOKp2VHE,9
+awsimple-2.5.1.dist-info/RECORD,,
```

